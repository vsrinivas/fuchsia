# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/package_list.gni")
import("//build/images/args.gni")
import("//build/packages/package_metadata.gni")
import("//build/product.gni")
import("//build/security.gni")
import("//src/sys/pkg/bin/package-tool/package-tool.gni")
import("//src/sys/pkg/bin/pm/pm.gni")
import("//src/sys/pkg/bin/system-updater/epoch/generate_epoch.gni")
import("//src/sys/pkg/repositories/devhost/devhost.gni")

assert(current_toolchain == default_toolchain,
       "//build/images/* are only valid in the Fuchsia toolchain")

if (use_bringup_assembly) {
  # These don't have any meaning in a bringup assembly, so leave them as empty
  # placeholder targets.
  group("updates") {
  }
  group("packages") {
  }
  group("publish") {
  }

  # This file doesn't exist for bringup, as bringup does not have packages to
  # upload blobs for.
  group("all_package_manifests.list") {
  }
} else {
  group("updates") {
    testonly = true
    deps = [
      ":package_lists",
      ":publish",
    ]
  }

  # Use the common `labels` and `files` vars
  import("//build/images/paths.gni")

  #####
  # These are the package groups that are used to build the system

  group("universe_packages") {
    testonly = fuchsia_zbi_testonly
    visibility = [ ":*" ]
    public_deps = [
      "//:developer_universe_packages",
      "//:legacy_universe_packages",
    ]
  }

  group("packages") {
    testonly = true
    public_deps = [ ":universe_packages" ]
  }

  #####
  # These are lists of the packages in the above groups

  package_list_from_assembly("base_packages.list") {
    testonly = true
    system_label = labels.images
    package_set = "base"
    contents = "name"
    outputs = [ files.base_package_names ]
  }

  package_list_from_assembly("cache_packages.list") {
    testonly = true
    system_label = labels.images
    package_set = "cache"
    contents = "name"
    outputs = [ files.cache_package_names ]
  }

  generate_package_metadata("universe_packages.list") {
    testonly = true
    visibility = [ ":*" ]
    data_keys = [ "package_names" ]
    outputs = [ files.universe_package_names ]
    deps = [ ":universe_packages" ]
  }

  group("package_lists") {
    testonly = true
    visibility = [ ":*" ]

    deps = [
      ":all_package_manifests.list",
      ":base_packages.list",
      ":cache_packages.list",
      ":universe_packages.list",
    ]
  }

  ###
  ### Amber updates.
  ###

  recovery_images_list = root_build_dir + "/recovery_images_list"
  generated_file("recovery_images_list") {
    testonly = true
    outputs = [ recovery_images_list ]
    output_conversion = "list lines"
    data_keys = [ "update_target" ]
    deps = [ recovery_label ]
  }

  generate_epoch("epoch.json") {
    output_file = "${target_out_dir}/${target_name}"
  }

  # This output is a manifest of manifests that is usable as an input to `pm
  # publish -lp`, a tool for publishing a set of packages from a build produced
  # list of package manifests.
  all_package_manifests_list = root_build_dir + "/all_package_manifests.list"
  generate_package_metadata("package_manifests_from_metadata.list") {
    testonly = true
    outputs = [ files.manifests_from_metadata ]
    data_keys = [ "package_output_manifests" ]
    rebase = root_build_dir
    deps = [
      ":packages",

      # The update packages for the main image
      labels.images,

      # The base and update packages for the prime package (for N+1 ota tests)
      labels.images_prime,
    ]
  }

  package_list_from_assembly("base_package_manifests.list") {
    testonly = true
    system_label = labels.images
    package_set = "base"
    contents = "manifest"
    outputs = [ files.base_package_manifests ]
  }

  package_list_from_assembly("cache_package_manifests.list") {
    testonly = true
    system_label = labels.images
    package_set = "cache"
    contents = "manifest"
    outputs = [ files.cache_package_manifests ]
  }

  action("all_package_manifests.list") {
    testonly = true
    script = "//build/cat.sh"
    outputs = [ all_package_manifests_list ]
    deps = [
      ":base_package_manifests.list",
      ":cache_package_manifests.list",
      ":package_manifests_from_metadata.list",
    ]
    args = rebase_path(outputs, root_build_dir)
    sources = []
    foreach(_dep, deps) {
      _dep_outputs = []  # tell gn its ok to rewrite each iteration
      _dep_outputs = get_target_outputs(_dep)
      args += [ rebase_path(_dep_outputs[0], root_build_dir) ]
      sources += [ _dep_outputs[0] ]
    }
  }

  _output_repository_dir = "${root_build_dir}/amber-files"

  # Publish all packages to the package repository.
  devhost_repository_publish("publish") {
    testonly = true

    output_repository_dir = _output_repository_dir

    deps = [ ":all_package_manifests.list" ]
    package_list_manifests = [ all_package_manifests_list ]

    metadata = {
      package_repository = [
        {
          path = rebase_path("${_output_repository_dir}/repository",
                             root_build_dir)
          targets =
              rebase_path("${_output_repository_dir}/repository/targets.json",
                          root_build_dir)
          blobs = rebase_path("${_output_repository_dir}/repository/blobs",
                              root_build_dir)
        },
      ]
    }
  }

  # Allow the incremental publisher to stage the repository keys and root metadata so it can publish
  # without needing to do a full build.
  group("prepare_publish") {
    testonly = true
    deps = [
      ":publish_prepare_repository_keys",
      ":publish_prepare_repository_root_metadata",
    ]
  }
}

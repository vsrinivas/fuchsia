# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/board.gni")
import("//build/compiled_action.gni")
import("//build/component/component_id_index.gni")
import("//build/config.gni")
import("//build/config/clang/clang.gni")
import("//build/config/fuchsia/zircon.gni")
import("//build/config/fuchsia/zircon_legacy_vars.gni")
import("//build/images/args.gni")
import("//build/images/boot.gni")
import("//build/images/collect_blob_manifest.gni")
import("//build/images/custom_signing.gni")
import("//build/images/filesystem_limits.gni")
import("//build/images/fvm.gni")
import("//build/images/manifest.gni")
import("//build/images/max_fvm_size.gni")
import("//build/images/pkgfs.gni")
import("//build/images/shell_commands.gni")
import("//build/images/ta.gni")
import("//build/images/vbmeta.gni")
import("//build/images/zxcrypt.gni")
import("//build/info/info.gni")
import("//build/package_metadata.gni")
import("//build/product.gni")
import("//build/unification/future/images/devmgr_config.gni")
import("//build/unification/images/common_image_contents.gni")
import("//build/unification/zbi/migrated_zbi.gni")
import("//build/unification/zbi/zbi_input.gni")
import("//src/sys/component_index/component_index.gni")
import("//src/sys/pkg/bin/pm/pm.gni")

# update_manifest is for the "update.manifest" target below.
update_manifest = []

# Dependencies for all image targets referenced by paver_targets, i.e., the
# images needed by the generated pave scripts.
default_image_deps = []

board_name_file = "$root_build_dir/board_name"
write_file(board_name_file, "${board_name}")

group("meta_packages") {
  testonly = true
  visibility = [ ":*" ]
  public_deps = meta_package_labels
}

group("base_packages") {
  testonly = true
  visibility = [ ":*" ]
  public_deps = [ "//:additional_base_packages" ]
  if (check_production_eligibility) {
    assert_no_deps = [ "//build/validate:non_production_tag" ]
  }
}

group("cache_packages") {
  testonly = true
  visibility = [ ":*" ]
  public_deps = [ "//:additional_cache_packages" ]
  if (check_production_eligibility) {
    assert_no_deps = [ "//build/validate:non_production_tag" ]
  }
}

group("universe_packages") {
  testonly = true
  visibility = [ ":*" ]
  public_deps = [
    ":base_packages",
    ":cache_packages",
    "//:additional_universe_packages",
  ]
}

group("packages") {
  testonly = true
  public_deps = [
    ":meta_packages",
    ":universe_packages",
  ]
}

template("package_list") {
  generate_package_metadata(target_name) {
    testonly = true
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "visibility",
                           ])

    data_keys = [ "package_names" ]
    outputs = [ "$root_out_dir/$target_name" ]
  }
}

package_list("base_packages.list") {
  visibility = [ ":*" ]
  deps = [
    ":base_packages",
    ":meta_packages",
  ]
}

package_list("cache_packages.list") {
  visibility = [ ":*" ]
  deps = [ ":cache_packages" ]
}

package_list("universe_packages.list") {
  visibility = [ ":*" ]
  deps = [ ":universe_packages" ]
}

group("package_lists") {
  testonly = true
  visibility = [ ":*" ]

  deps = [
    ":all_package_manifests.list",
    ":base_packages.list",
    ":cache_packages.list",
    ":universe_packages.list",
  ]
}

config_package("config-data") {
  testonly = true
  visibility = [ ":*" ]
  deps = [
    ":component_id_index_config_data",
    ":universe_packages",
  ]
}

shell_commands("shell-commands") {
  testonly = true
  visibility = [ ":*" ]
  deps = [ ":universe_packages" ]
}

###
### Fuchsia system image.  This aggregates contributions from all the
### package() targets enabled in the build.
###

monolith_meta_far_merkle_index =
    "$target_out_dir/monolith_meta_far_merkle_index"
generate_package_metadata("monolith_meta_far_merkle_index") {
  testonly = true
  outputs = [ monolith_meta_far_merkle_index ]
  data_keys = [ "meta_far_merkle_index_entries" ]
  deps = [
    ":base_packages",
    ":meta_packages",
  ]
}

# The pkgsvr index is a manifest mapping `package_name/package_version` to
# the merkleroot of the package's meta.far file.
pkgsvr_index = "$target_out_dir/pkgsvr_index"

action("pkgsvr_index") {
  visibility = [
    ":system_image.manifest",
    ":system_image_prime.manifest",
    ":update_packages.manifest",
  ]
  testonly = true
  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":monolith_meta_far_merkle_index" ]
  inputs = [ monolith_meta_far_merkle_index ]

  script = "//build/images/manifest_content_expand.sh"
  args = [
    rebase_path(monolith_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

preinstall_meta_far_merkle_index =
    "$target_out_dir/preinstall_meta_far_merkle_index"
generate_package_metadata("preinstall_meta_far_merkle_index") {
  testonly = true
  outputs = [ preinstall_meta_far_merkle_index ]
  data_keys = [ "meta_far_merkle_index_entries" ]
  deps = [ ":cache_packages" ]
}

#
# The cache index is another manifest mapping `package_name/package_version` to
# the merkleroot of the package's meta.far file, only for cache packages
cache_index = "$target_out_dir/cache_index"

action("cache_index") {
  visibility = [ ":system_image.manifest" ]
  testonly = true
  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":preinstall_meta_far_merkle_index" ]
  inputs = [ preinstall_meta_far_merkle_index ]

  script = "//build/images/manifest_content_expand.sh"
  args = [
    rebase_path(preinstall_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

# The /boot and /system manifests have to be generated in concert.  Things
# like drivers going into /system can affect what needs to go into /boot.
boot_manifest = "$target_out_dir/boot.manifest"

system_image_manifest_args = "system_image.manifest_args"
system_image_manifest_args_path = target_gen_dir + "/system_image.manifest_args"

generated_file(system_image_manifest_args) {
  testonly = true
  outputs = [ system_image_manifest_args_path ]
  data_keys = [ "system_image_rsps" ]
  walk_keys = [ "system_image_barrier" ]
  deps = [
    ":base_packages",
    ":meta_packages",
  ]
}

# The system_image "package" manifest is everything that appears in /system.
generate_manifest("system_image.manifest") {
  visibility = [ ":*" ]
  testonly = true

  # Create the /boot manifest that gets packed into BOOTFS in the ZBI.
  # /system manifest files can assume that the /boot files are visible at
  # runtime, so dependencies already in /boot won't be copied into /system.
  bootfs_manifest = boot_manifest
  bootfs_zircon_groups = "all"

  # Collect whatever we want from Zircon that didn't go into /boot.
  zircon_groups = ""

  # Now each package() target in the build contributes manifest entries.
  # For system_image packages, these contain binaries that need their
  # references resolved from the auxiliary manifests or /boot (above).
  deps = [ ":" + system_image_manifest_args ]
  sources = [ system_image_manifest_args_path ]
  args = [ "@" + rebase_path(system_image_manifest_args_path, root_build_dir) ]

  args += [ "--entry-manifest=" +
            get_label_info(":$target_name", "label_no_toolchain") ]

  # Add the meta/package JSON file that makes this the "system_image" package.
  json = "system_meta_package.json"
  sources += [ json ]
  args += [ "--entry=meta/package=" + rebase_path(json, root_build_dir) ]

  # Add the static packages (pkgsvr) index.
  deps += [ ":pkgsvr_index" ]
  sources += [ pkgsvr_index ]
  args += [ "--entry=data/static_packages=" +
            rebase_path(pkgsvr_index, root_build_dir) ]

  # Add the cache packages index.
  deps += [ ":cache_index" ]
  sources += [ cache_index ]
  args += [ "--entry=data/cache_packages=" +
            rebase_path(cache_index, root_build_dir) ]

  # Add the allowlist for which non-static packages pkgfs will return.
  sources += [ pkgfs_packages_allowlist ]
  args += [ "--entry=data/pkgfs_packages_non_static_packages_allowlist.txt=" +
            rebase_path(pkgfs_packages_allowlist, root_build_dir) ]
}
system_manifest_outputs = get_target_outputs(":system_image.manifest")
assert(boot_manifest == system_manifest_outputs[1])

# The prime version of the system_image has an extra "dummy" file.
# The prime images are used to have an alternate known-compatible OTA
# target for integration testing.
action("system_image_prime.manifest") {
  visibility = [ ":*" ]
  testonly = true
  script = "manifest.py"
  outputs = [ "$target_out_dir/$target_name" ]

  deps = [ ":system_image.manifest" ]
  sources = system_manifest_outputs + [
              "system_image_prime_meta_package.json",
              "dummy/example.txt",
            ]
  args = [
    "--output",
    rebase_path(outputs[0], root_build_dir),
    "--rewrite",
    "meta/package={target}=" +
        rebase_path("system_image_prime_meta_package.json", root_build_dir),
    "--manifest",
    rebase_path(system_manifest_outputs[0], root_build_dir),
    "--reset-rewrite",
    "--entry",
    "data/dummy/example.txt=" +
        rebase_path("dummy/example.txt", root_build_dir),
  ]
}

# Generate, sign, and seal the system_image package file.
pm_build("system_image.meta") {
  package_name = "system_image"
  visibility = [ ":*" ]
  testonly = true
  manifest = ":system_image.manifest"
}

# Now generate the blob manifest.  This lists all the source files
# that need to go into the blobfs image.  That is everything from the
# system_image manifest, everything from each package manifest, and
# all the synthesized meta.far files.
blob_manifest = "$target_out_dir/blob.manifest"

collect_blob_manifest("blob.manifest") {
  testonly = true
  visibility = [ ":*" ]
  outputs = [ blob_manifest ]
  deps = [
    ":base_packages",
    ":cache_packages",
    ":meta_packages",
    ":system_image.meta",
    ":update.meta",
    pkgfs_package_label,
  ]
}

blob_image_path = "$target_out_dir/blob.blk"
rebased_blob_image_path = rebase_path(blob_image_path, root_build_dir)
blob_size_list = "$root_build_dir/blobs.json"

# Pack up all the blobs!
compiled_action("blob.blk") {
  visibility = [ ":*" ]
  testonly = true
  deps = [ ":blob.manifest" ]
  outputs = [
    blob_image_path,
    blob_size_list,
  ]
  depfile = blob_image_path + ".d"
  inputs = [ blob_manifest ]
  tool = "//zircon/tools/blobfs"
  args = [
    "--depfile",
    "--json-output",
    rebase_path(blob_size_list, root_build_dir),
  ]
  if (compress_blobs) {
    args += [ "--compress" ]
  }
  args += [
    rebase_path(blob_image_path, root_build_dir),
    "create",
    "--manifest",
    rebase_path(blob_manifest, root_build_dir),
  ]

  metadata = {
    images = [
      {
        name = "blob"
        path = rebased_blob_image_path
        type = "blk"
      },
    ]
    image_paths = [ "IMAGE_BLOB_RAW=$rebased_blob_image_path" ]
  }
}
default_image_deps += [ ":blob.blk" ]

# The prime images are used to have an alternate known-compatible OTA
# target for integration testing.
pm_build("system_image_prime.meta") {
  package_name = "system_image_prime"
  visibility = [ ":*" ]
  testonly = true
  manifest = ":system_image_prime.manifest"
}

###
### Zircon Boot Images
###

# Copy the QEMU kernel from the Zircon build directory to keep invariant that
# all image paths are relative to the Fuchsia root_build_dir without the
# leading "../".
copy("qemu-kernel") {
  sources = []
  outputs = []
  image_metadata = []
  image_path_metadata = []

  # GN's copy() itself will enforce that there is only one QEMU kernel
  # found, as else length(outputs) != 1 which is illegal.
  foreach(image, zircon_images) {
    if (image.name == "qemu-kernel" && image.cpu == target_cpu) {
      sources += [ "$zircon_root_build_dir/${image.path}" ]
      outputs += [ "$root_build_dir/${image.path}" ]
      image_metadata += [
        {
          archive = add_qemu_to_build_archives
          name = "qemu-kernel"
          path = image.path
          type = "kernel"
        },
      ]
      image_path_metadata += [ "IMAGE_QEMU_KERNEL_RAW=${image.path}" ]
    }
  }
  metadata = {
    images = image_metadata
    image_paths = image_path_metadata
  }
}
default_image_deps += [ ":qemu-kernel" ]

# Generate the /boot/config/devmgr file.  This looks like a kernel command
# line file, but is read by devmgr (in addition to kernel command line
# arguments), not by the kernel or boot loader.
action("devmgr_config.txt") {
  visibility = [
    ":fuchsia",
    ":fuchsia.vbmeta",
    ":fuchsia.vbmeta__zbi_props",
    ":fuchsia.vbmeta__vb_desc",
    ":devmgr_config",
    ":devmgr_config_prime.txt",
  ]
  testonly = true

  script = "manifest.py"
  outputs = [ "$target_out_dir/devmgr_config.txt" ]
  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]
  sources = []
  deps = [ ":system_image.manifest" ]

  pkgfs = "bin/" + pkgfs_binary_name
  pkgfs_label = pkgfs_package_label
  pkgfs_pkg_out_dir = get_label_info(pkgfs_label, "target_out_dir") + "/" +
                      get_label_info(pkgfs_label, "name")
  pkgfs_blob_manifest = "$pkgfs_pkg_out_dir/meta/contents"
  system_image_merkleroot = "$target_out_dir/system_image.meta/meta.far.merkle"

  deps += [
    ":system_image.meta",
    "//build/info:latest-commit-date",
    pkgfs_label,
  ]
  sources += [
    pkgfs_blob_manifest,
    system_image_merkleroot,
  ]

  args += [ "--entry=devmgr.require-system=true" ]

  # Add the pkgfs command line, embedding the merkleroot of the system image.
  args += [
    "--contents",
    "--rewrite=*=zircon.system.pkgfs.cmd={target}+{source}",
    "--entry=${pkgfs}=" + rebase_path(system_image_merkleroot, root_build_dir),
    "--no-contents",
    "--reset-rewrite",
  ]

  # Embed the pkgfs blob manifest with the "zircon.system.pkgfs.file."
  # prefix on target file names.
  args += [
    "--rewrite=*=zircon.system.pkgfs.file.{target}={source}",
    "--manifest=" + rebase_path(pkgfs_blob_manifest, root_build_dir),
    "--reset-rewrite",
  ]

  # Add the backstop UTC value from the integration repo latest commit
  args += [
    "--contents",
    "--entry=clock.backstop=" +
        rebase_path(build_info_files.minimum_utc_stamp, root_build_dir),
    "--no-contents",
    "--reset-rewrite",
  ]

  foreach(entry, devmgr_config) {
    args += [ "--entry=$entry" ]
  }

  # If there were any ASan drivers in the build, bin/devhost.asan
  # should have been brought into the boot manifest.  devmgr needs to
  # be told to use it in case there are ASan drivers in /system but
  # none in /boot.  If there were any non-ASan drivers in the build,
  # bin/devhost.asan will load them and needs to know to moderate the
  # checking for interacting with uninstrumented code.
  sources += [ boot_manifest ]
  args += [
    "--include=bin/devhost",
    "--manifest=" + rebase_path(boot_manifest, root_build_dir),
  ]
}

devmgr_config("devmgr_config") {
  label = ":devmgr_config.txt"
  testonly = true
}

# Generate the prime /boot/config/devmgr file. Points to system_image_prime
# instead of system_image
# The prime images are used to have an alternate known-compatible OTA
# target for integration testing.
action("devmgr_config_prime.txt") {
  visibility = [
    ":fuchsia_prime",
    ":fuchsia_prime.vbmeta",
    ":fuchsia_prime.vbmeta__zbi_props",
    ":fuchsia_prime.vbmeta__vb_desc",
    ":devmgr_config_prime",
  ]
  testonly = true

  script = "manifest.py"
  outputs = [ "$target_out_dir/devmgr_config_prime.txt" ]
  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]
  deps = [ ":devmgr_config.txt" ]
  devmgr_config_outputs = get_target_outputs(":devmgr_config.txt")
  sources = devmgr_config_outputs
  args += [
    "--exclude",
    "zircon.system.pkgfs.cmd",
    "--manifest",
    rebase_path(devmgr_config_outputs[0], root_build_dir),
    "--reset-exclude",
  ]

  pkgfs = "bin/" + pkgfs_binary_name
  system_image_merkleroot =
      "$target_out_dir/system_image_prime.meta/meta.far.merkle"

  deps += [ ":system_image_prime.meta" ]
  sources += [ system_image_merkleroot ]

  # Add the pkgfs command line, embedding the merkleroot of the system image.
  args += [
    "--contents",
    "--rewrite=*=zircon.system.pkgfs.cmd={target}+{source}",
    "--entry=${pkgfs}=" + rebase_path(system_image_merkleroot, root_build_dir),
    "--no-contents",
    "--reset-rewrite",
  ]
}

devmgr_config("devmgr_config_prime") {
  label = ":devmgr_config_prime.txt"
  testonly = true
}

generated_file("zxcrypt_config.txt") {
  outputs = [ "$target_out_dir/$target_name" ]
  contents = zxcrypt_key_source
}

group("fuchsia_contents") {
  deps = [
    "//build/unification/future/images:fuchsia_kernel_cmdline",
    "//build/unification/future/images:ta",
    "//build/unification/future/images:zxcrypt",
    "//build/unification/zbi:kernel",
  ]
  deps += product_bootfs_labels + board_bootfs_labels
  deps += common_image_contents
}

# The main bootable image, which requires `blob.blk` to appear on some
# attached storage device at runtime.
migrated_zbi("fuchsia") {
  testonly = true

  output_dir = root_out_dir

  deps = [ ":fuchsia_contents" ]

  if (!include_devmgr_config_in_vbmeta) {
    deps += [ ":devmgr_config" ]
  }

  metadata = {
    images = [
      {
        name = "zircon-a"
        path = "fuchsia.zbi"
        type = "zbi"

        archive = true
        bootserver_pave = []

        # TODO(ZX-2069): we want to reduce the usage of mexec, but currently we
        # do not have sufficient boot control on x64.
        if (target_cpu == "x64") {
          bootserver_pave += [ "--boot" ]
        }
        if (custom_signing_script == "" && !use_vboot) {
          bootserver_pave += [
            "--zircona",
            # TODO(ZX-2625): `dm reboot-recovery` boots from zircon-b instead of
            # zircon-r, so for now zedboot is being paved to this slot.
            # "--zirconb",
          ]
        }
      },
    ]

    image_paths = [
      "IMAGE_ZIRCONA_ZBI=fuchsia.zbi",

      # TODO(mcgrathr): The complete ZBI can be used with a separate
      # kernel too, the kernel image in it will just be ignored.  So
      # just use the primary ZBI for this until all uses are
      # converted to using the ZBI alone.  Then remove this as
      # IMAGE_BOOT_RAM variable should no longer be in use.
      "IMAGE_BOOT_RAM=fuchsia.zbi",
    ]
  }
}
default_image_deps += [ ":fuchsia" ]

if (!use_vboot && custom_signing_script == "") {
  update_manifest += [
    {
      target = "zbi"
      deps = [ ":fuchsia" ]
    },
  ]
}

# ZBI tool JSON output doesn't record paths of input files so there's no easy
# way to find out where each of the binaries in bootfs entry came from. Rather,
# we extract the ZBI and then pass this directory as an input to the elfinfo.py
# script which computes the ELF sizes.
#
# TODO(phosek): Try to come up with a more efficient solution that does not
# require extract the ZBI.

fuchsia_zbi_json = "$target_out_dir/fuchsia.zbi.json"
fuchsia_zbi_bootfs_dir = "$target_out_dir/fuchsia.zbi/bootfs"

zircon_tool_action("extract_bootfs") {
  visibility = [ ":elf_sizes.json" ]
  testonly = true
  tool = "zbi"
  inputs = [ "$root_out_dir/fuchsia.zbi" ]
  outputs = [ fuchsia_zbi_json ]
  deps = [ ":fuchsia" ]
  args = [
    "--extract",
    "--output-dir=" + rebase_path(fuchsia_zbi_bootfs_dir, root_build_dir),
    "--json-output=" + rebase_path(fuchsia_zbi_json, root_build_dir),
    rebase_path(inputs[0], root_out_dir),
  ]
}

action("elf_sizes.json") {
  testonly = true
  script = "elfinfo.py"
  deps = [
    ":blob.blk",
    ":extract_bootfs",
  ]
  sources = [
    blob_size_list,
    fuchsia_zbi_json,
  ]
  outputs = [ "$root_build_dir/$target_name" ]
  args = [
    "--sizes",
    rebase_path(outputs[0], root_build_dir),
    "--blobs",
    rebase_path(blob_size_list, root_build_dir),
    "--zbi",
    rebase_path(fuchsia_zbi_json, root_build_dir),
    "--bootfs-dir",
    rebase_path(fuchsia_zbi_bootfs_dir, root_build_dir),
  ]
}

# Generate the prime fuchsia.zbi.
# The prime images are used to have an alternate known-compatible OTA
# target for integration testing.
migrated_zbi("fuchsia_prime") {
  testonly = true

  output_dir = root_out_dir

  deps = [ ":fuchsia_contents" ]

  if (!include_devmgr_config_in_vbmeta) {
    deps += [ ":devmgr_config_prime" ]
  }
}

unsigned_zbi_prime = {
  dep = ":fuchsia_prime"
  updater = "zbi"
}

unsigned_zbi_to_zedboot = {
  dep = "zedboot:zbi"
  updater = "zbi"
  target = "zedboot.zbi"
}

if (custom_signing_script != "") {
  custom_signed_zbi("signed") {
    output_name = "fuchsia.zbi"
    testonly = true
    deps = [ ":fuchsia" ]
    zbi_outputs = get_target_outputs(":fuchsia")
    zbi = [ zbi_outputs[0] ]
    metadata = {
      images = [
        {
          archive = true
          bootserver_pave = [ "--zircona" ]
          name = "zircon-a.signed"
          path = "$output_name.signed"
          type = "zbi.signed"
        },
      ]
      image_paths = [ "IMAGE_ZIRCONA_SIGNEDZBI=$output_name.signed" ]
    }
  }
} else if (use_vboot) {
  # ChromeOS vboot images.
  vboot("signed") {
    testonly = true
    output_name = "fuchsia.zbi"
    deps = [ ":fuchsia" ]

    metadata = {
      images = [
        {
          archive = true
          bootserver_pave = [ "--zircona" ]
          name = "zircon-a.signed"
          path = "$output_name.vboot"
          type = "zbi.signed"
        },
      ]
      image_paths = [ "IMAGE_ZIRCONA_SIGNEDZBI=$output_name.signed" ]
    }
  }
}

if (custom_signing_script != "" || use_vboot) {
  default_image_deps += [ ":signed" ]
  update_manifest += [
    {
      target = "zbi.signed"
      deps = [ ":signed" ]
    },
  ]
}

# Sign fuchsia_prime.zbi, if neccessary.
# The *_prime and *_to_zedboot images are used to have an alternate
# known-compatible OTA target for integration testing.
if (custom_signing_script != "") {
  custom_signed_zbi("fuchsia_prime_signed") {
    output_name = "fuchsia_prime.zbi"
    testonly = true
    deps = [ ":fuchsia_prime" ]
    zbi_outputs = get_target_outputs(":fuchsia_prime")
    zbi = [ zbi_outputs[0] ]
  }
  zbi_prime = {
    dep = ":fuchsia_prime_signed"
    updater = "zbi.signed"
  }
  zbi_to_zedboot = {
    dep = "//build/images/zedboot:signed"
    updater = "zbi.signed"
    target = "zedboot.zbi.signed"
  }
  not_needed([
               "unsigned_zbi_prime",
               "unsigned_zbi_to_zedboot",
             ])
} else if (use_vboot) {
  # ChromeOS vboot images.
  vboot("fuchsia_prime_signed") {
    testonly = true
    output_name = "fuchsia_prime.zbi"
    deps = [ ":fuchsia_prime" ]
  }

  zbi_prime = {
    dep = ":fuchsia_prime_signed"
    updater = "zbi.signed"
  }
  zbi_to_zedboot = {
    dep = "//build/images/zedboot:signed"
    updater = "zbi.signed"
    target = "zedboot.vboot"
  }
  not_needed([
               "unsigned_zbi_prime",
               "unsigned_zbi_to_zedboot",
             ])
} else {
  zbi_prime = unsigned_zbi_prime
  zbi_to_zedboot = unsigned_zbi_to_zedboot
}

if (use_vbmeta) {
  vbmeta("fuchsia.vbmeta") {
    output_name = "fuchsia"
    testonly = true
    if (custom_signing_script != "") {
      deps = [ ":signed" ]
      zbi_outputs = get_target_outputs(":signed")
      zbi = [ zbi_outputs[0] ]
    } else {
      deps = [ ":fuchsia" ]
      zbi_outputs = get_target_outputs(":fuchsia")
      zbi = [ zbi_outputs[0] ]
    }
    if (include_devmgr_config_in_vbmeta) {
      deps += [ ":devmgr_config.txt" ]

      boot_args_file = get_target_outputs(":devmgr_config.txt")

      # expecting a single file
      assert([ boot_args_file[0] ] == boot_args_file,
             "expect a single output file form 'devmgr_config.txt' target")

      prop_from_file = [
        {
          # zbi item type w/o ZBI_TYPE_ prefix
          type = "IMAGE_ARGS"
          file = boot_args_file[0]
        },
      ]
    }

    metadata = {
      images = [
        {
          archive = true
          name = "zircon-a"
          path = "fuchsia.vbmeta"
          type = "vbmeta"

          bootserver_pave = [ "--vbmetaa" ]
        },
      ]
      image_paths = [ "IMAGE_VBMETAA_RAW=fuchsia.vbmeta" ]
    }
  }

  vbmeta("fuchsia_prime.vbmeta") {
    output_name = "fuchsia_prime"
    testonly = true
    if (custom_signing_script != "") {
      deps = [ ":fuchsia_prime_signed" ]
      zbi_outputs = get_target_outputs(":fuchsia_prime_signed")
      zbi = [ zbi_outputs[0] ]
    } else {
      deps = [ ":fuchsia_prime" ]
      zbi_outputs = get_target_outputs(":fuchsia_prime")
      zbi = [ zbi_outputs[0] ]
    }
    if (include_devmgr_config_in_vbmeta) {
      deps += [ ":devmgr_config_prime.txt" ]

      boot_args_file = get_target_outputs(":devmgr_config_prime.txt")

      # expecting a single file
      assert(
          [ boot_args_file[0] ] == boot_args_file,
          "expect a single output file form 'devmgr_config_prime.txt' target")

      prop_from_file = [
        {
          # zbi item type w/o ZBI_TYPE_ prefix
          type = "IMAGE_ARGS"
          file = boot_args_file[0]
        },
      ]
    }
  }

  default_image_deps += [ ":fuchsia.vbmeta" ]

  update_manifest += [
    {
      target = "fuchsia.vbmeta"
      sources = [ "$root_build_dir/fuchsia.vbmeta" ]
      deps = [ ":fuchsia.vbmeta" ]
    },
  ]
}

# The updater also wants the zedboot zbi as recovery.
if (custom_signing_script != "") {
  update_manifest += [
    {
      deps = [ "zedboot:signed" ]
      sources = [ "$root_out_dir/zedboot.zbi.signed" ]
      target = "zedboot.signed"
    },
  ]
} else if (use_vboot) {
  update_manifest += [
    {
      deps = [ "zedboot:signed" ]
      sources = [ "$root_out_dir/zedboot.vboot" ]

      target = "zedboot.signed"
    },
  ]
} else {
  update_manifest += [
    {
      deps = [ "zedboot:zbi" ]
      sources = [ "$root_out_dir/zedboot.zbi" ]
      target = "zedboot"
    },
  ]
}
if (use_vbmeta) {
  update_manifest += [
    {
      deps = [ "zedboot:zedboot.vbmeta" ]
      sources = [ "$root_out_dir/zedboot.vbmeta" ]
      target = "recovery.vbmeta"
    },
  ]
}

###
### Complete images for booting and installing the whole system.
###

# deps, inputs and args for the filesystem_sizes.json action.
filesystem_sizes_deps = []
filesystem_sizes_inputs = []
filesystem_sizes_args = []

data_image_path = "$target_out_dir/data.blk"

# data.blk creates minfs data partition. The partition is included in fvm.blk
# and fvm.sparse.blk. To increase the size of the data partition, increase
# the total size of the fvm images using |fvm_image_size|.
compiled_action("data.blk") {
  testonly = true

  rebased_data_image_path = rebase_path(data_image_path, root_build_dir)

  tool = "//zircon/tools/minfs"
  outputs = [ data_image_path ]
  depfile = data_image_path + ".d"
  args = [
    "--depfile",
    rebase_path(data_image_path, root_build_dir),
    "create",
  ]
  if (data_partition_manifest != "") {
    args += [
      "--manifest",
      rebase_path(data_partition_manifest),
    ]
  }

  metadata = {
    images = [
      {
        name = "data"
        path = rebased_data_image_path
        type = "blk"
      },
    ]
    image_paths = [ "IMAGE_DATA_RAW=$rebased_data_image_path" ]
  }
}

default_image_deps += [ ":data.blk" ]

# Record the maximum allowable FVM size in the build directory for later steps
# to check against.
max_fvm_size_file = "$root_build_dir/max_fvm_size.txt"
write_file(max_fvm_size_file, max_fvm_size)

fvm_blob_partition = {
  type = "blob"
  dep = ":blob.blk"
  minimum_inodes = blobfs_minimum_inodes
  minimum_data_bytes = blobfs_minimum_data_bytes
  maximum_bytes = blobfs_maximum_bytes
}

fvm_data_partition = {
  type = "data"
  dep = ":data.blk"
  minimum_inodes = minfs_minimum_inodes
  minimum_data_bytes = minfs_minimum_data_bytes
  maximum_bytes = minfs_maximum_bytes
}

# fvm.blk creates an FVM partition image containing the blob partition produced
# by blob.blk and the data partition produced by data.blk. fvm.blk is primarily
# invoked and used by the qemu run, via `fx emu` / `fx qemu`.
generate_fvm("fvm.blk") {
  testonly = true

  output_name = "$target_out_dir/fvm.blk"
  rebased_output_name = rebase_path(output_name, root_build_dir)

  args = fvm_create_args
  if (fvm_image_size != "") {
    args += [
      "--length",
      fvm_image_size,
      "--resize-image-file-to-fit",
    ]
  }
  partitions = [
    fvm_blob_partition,
    fvm_data_partition,
  ]
  metadata = {
    images = [
      {
        archive = add_qemu_to_build_archives
        name = "storage-full"
        path = rebased_output_name
        type = "blk"
      },
    ]
    image_paths = [ "IMAGE_FVM_RAW=$rebased_output_name" ]
  }
}
default_image_deps += [ ":fvm.blk" ]

fvm_sparse_blk_path = "$target_out_dir/fvm.sparse.blk"

# fvm.sparse.blk creates a sparse FVM partition image containing the blob
# partition produced by blob.blk and the data partition produced by data.blk.
# fvm.sparse.blk is primarily invoked and used by the paver boot, via `fx
# pave`.
generate_fvm("fvm.sparse.blk") {
  testonly = true

  output_name = fvm_sparse_blk_path
  rebased_output_name = rebase_path(output_name, root_build_dir)

  deps = [
    ":blob.blk",
    ":data.blk",
  ]
  args = fvm_sparse_args
  partitions = [
    fvm_blob_partition,
    fvm_data_partition,
  ]

  metadata = {
    images = [
      {
        archive = true
        bootserver_pave = [ "--fvm" ]
        name = "storage-sparse"
        path = rebased_output_name
        type = "blk"
      },
    ]
    image_paths = [ "IMAGE_FVM_SPARSE=$rebased_output_name" ]
  }
}
default_image_deps += [ ":fvm.sparse.blk" ]

filesystem_sizes_deps += [
  ":blob.blk",
  ":data.blk",
  ":fvm.sparse.blk",
  "//zircon/tools/blobfs($host_toolchain)",
  "//zircon/tools/fvm($host_toolchain)",
  "//zircon/tools/minfs($host_toolchain)",
]
filesystem_sizes_inputs += [
  blob_image_path,
  data_image_path,
  fvm_sparse_blk_path,
]
filesystem_sizes_args += [
  "--fvm-blk",
  rebase_path(fvm_sparse_blk_path),
  "--blob-blk",
  rebase_path(blob_image_path),
  "--data-blk",
  rebase_path(data_image_path),
  "--fvm-tool",
  rebase_path("$zircon_tools_dir/fvm"),
  "--blobfs-tool",
  rebase_path("$zircon_tools_dir/blobfs"),
  "--minfs-tool",
  rebase_path("$zircon_tools_dir/minfs"),
  "--max-fvm-contents-size",
  max_fvm_size,
  "--max-blob-contents-size",
  max_blob_contents_size,
  "--max-blob-image-size",
  max_blob_image_size,
  "--max-data-contents-size",
  max_data_contents_size,
  "--max-data-image-size",
  max_data_image_size,
]

# fvm.blob.sparse.blk creates a sparse FVM partition image containing the blob
# partition produced by blob.blk and an empty data partition that will be
# formatted on first boot.
fvm_blob_sparse_blk_path = "$target_out_dir/fvm.blob.sparse.blk"
rebased_fvm_blob_sparse_blk_path =
    rebase_path(fvm_blob_sparse_blk_path, root_build_dir)
generate_fvm("fvm.blob.sparse.blk") {
  testonly = true
  output_name = fvm_blob_sparse_blk_path
  deps = [ ":blob.blk" ]
  args = fvm_sparse_args
  with_empty_minfs = true
  partitions = [
    {
      type = "blob"
      dep = ":blob.blk"
      minimum_inodes = blob_blobfs_minimum_inodes
      minimum_data_bytes = blob_blobfs_minimum_data_bytes
      maximum_bytes = blob_blobfs_maximum_bytes
    },
  ]

  metadata = {
    image_paths = [ "IMAGE_FVM_BLOB_SPARSE=$rebased_fvm_blob_sparse_blk_path" ]

    if (include_fvm_blob_sparse) {
      images = [
        {
          # Hack: Infra expects bootserver_pave to be present
          # in the GN graph for this image to be built.
          bootserver_pave = []
          name = "fvm.blob.sparse"
          path = rebased_fvm_blob_sparse_blk_path
          type = "blk"
        },
      ]
    }
  }
}
default_image_deps += [ ":fvm.blob.sparse.blk" ]

zbi_input("fvm.blk_ramdisk") {
  testonly = true

  type = "ramdisk"

  # Use data_deps and not deps so that the contents of the fvm don't get
  # included in the dependent zbi.
  data_deps = [ ":fvm.blk" ]

  sources = [ "$target_out_dir/fvm.blk" ]
}

# This rolls the primary ZBI together with a compressed RAMDISK image of
# fvm.blk into a fat ZBI that boots the full system without using any real
# storage.  The system decompresses the fvm.blk image into memory and then
# sees that RAM disk just as if it were a real disk on the device.
migrated_zbi("netboot") {
  testonly = true

  output_dir = root_out_dir

  deps = [
    ":fuchsia",
    ":fvm.blk_ramdisk",
  ]

  metadata = {
    images = [
      {
        archive = enable_netboot
        bootserver_netboot = [ "--boot" ]
        name = "netboot"
        path = "netboot.zbi"
        type = "zbi"
      },
    ]
    image_paths = [
      "IMAGE_NETBOOT_ZBI=netboot.zbi",

      # TODO(mcgrathr): The complete ZBI can be used with a separate kernel
      # too, the kernel image in it will just be ignored.  So just use the
      # primary ZBI for this until all uses are converted to using the ZBI
      # alone.  Then remove this as IMAGE_BOOT_RAM variable should no
      # longer be in use.
      "IMAGE_NETBOOT_RAM=netboot.zbi",
    ]
  }
}

if (target_cpu != "arm64" && !use_vboot) {
  # TODO(surajmalhotra): Remove this target once SDK no longer depends on it.
  vboot("vboot") {
    testonly = true
    output_name = "fuchsia"
    deps = [ ":fuchsia" ]

    metadata = {
      images = [
        {
          name = "zircon-vboot"
          path = "fuchsia.vboot"
          type = "vboot"
        },
      ]
    }
  }
  default_image_deps += [ ":vboot" ]

  # EFI ESP images.
  esp("esp") {
    output_name = "fuchsia"
    testonly = true
    if (always_zedboot) {
      cmdline = "zedboot/efi_cmdline.txt"
    } else {
      cmdline = "efi_local_cmdline.txt"
    }
    metadata = {
      images = [
        {
          archive = true
          bootserver_pave = [ "--bootloader" ]
          bootserver_pave_zedboot = [ "--bootloader" ]
          name = "efi"
          path = "fuchsia.esp.blk"
          type = "blk"
        },
      ]
      image_paths = [ "IMAGE_ESP_RAW=fuchsia.esp.blk" ]
    }
  }
  default_image_deps += [ ":esp" ]

  if (!use_vboot && custom_signing_script == "") {
    update_manifest += [
      {
        deps = [ ":esp" ]
        target = "bootloader"
      },
    ]
  }
}

foreach(firmware, firmware_prebuilts) {
  if (firmware.type == "") {
    # Don't add a trailing delimiter if firmware.type is empty.
    name = "firmware"
    bootserver_arg = "--firmware"
  } else {
    name = "firmware_${firmware.type}"
    bootserver_arg = "--firmware-${firmware.type}"
  }

  # By convention image_paths shell variables are upper-case. There must
  # be a better way to do this but I'm not sure what it is.
  upper_name = name
  upper_name = string_replace(upper_name, "a", "A")
  upper_name = string_replace(upper_name, "b", "B")
  upper_name = string_replace(upper_name, "c", "C")
  upper_name = string_replace(upper_name, "d", "D")
  upper_name = string_replace(upper_name, "e", "E")
  upper_name = string_replace(upper_name, "f", "F")
  upper_name = string_replace(upper_name, "g", "G")
  upper_name = string_replace(upper_name, "h", "H")
  upper_name = string_replace(upper_name, "i", "I")
  upper_name = string_replace(upper_name, "j", "J")
  upper_name = string_replace(upper_name, "k", "K")
  upper_name = string_replace(upper_name, "l", "L")
  upper_name = string_replace(upper_name, "m", "M")
  upper_name = string_replace(upper_name, "n", "N")
  upper_name = string_replace(upper_name, "o", "O")
  upper_name = string_replace(upper_name, "p", "P")
  upper_name = string_replace(upper_name, "q", "Q")
  upper_name = string_replace(upper_name, "r", "R")
  upper_name = string_replace(upper_name, "s", "S")
  upper_name = string_replace(upper_name, "t", "T")
  upper_name = string_replace(upper_name, "u", "U")
  upper_name = string_replace(upper_name, "v", "V")
  upper_name = string_replace(upper_name, "w", "W")
  upper_name = string_replace(upper_name, "x", "X")
  upper_name = string_replace(upper_name, "y", "Y")
  upper_name = string_replace(upper_name, "z", "Z")

  copy(name) {
    testonly = true
    sources = [ rebase_path("${firmware.path}${firmware_prebuilts_path_suffix}",
                            root_build_dir) ]
    outputs = [ "$root_out_dir/$name.img" ]

    metadata = {
      images = [
        {
          archive = true
          bootserver_pave = [ bootserver_arg ]
          bootserver_pave_zedboot = [ bootserver_arg ]
          name = name
          path = "$name.img"
          type = "img"
        },
      ]
      image_paths = [ "IMAGE_${upper_name}=$name.img" ]
    }
  }

  default_image_deps += [ ":$name" ]

  update_manifest += [
    {
      target = name
      deps = [ ":$name" ]
      sources = [ "$root_out_dir/$name.img" ]
    },
  ]
}

# If a GPT image was specified, make it available as a build artifact.
if (gpt_image != "") {
  copy("gpt") {
    testonly = true
    sources = [ rebase_path(gpt_image, root_build_dir) ]
    outputs = [ "$root_out_dir/gpt.bin" ]

    metadata = {
      images = [
        {
          archive = true
          name = "gpt"
          path = "gpt.bin"
          type = "bin"
        },
      ]
      image_paths = [ "IMAGE_GPT=gpt.bin" ]
    }
  }

  default_image_deps += [ ":gpt" ]
}

# Copy any board-specific tools.
group("board_tools") {
  deps = []

  foreach(tool_path, board_tools) {
    basename = get_path_info(tool_path, "file")
    copy("board_tool_$basename") {
      sources = [ rebase_path(tool_path, root_build_dir) ]
      outputs = [ "$root_out_dir/board_tools/$basename" ]

      metadata = {
        images = [
          {
            archive = true
            name = "$basename"
            path = "board_tools/$basename"
            type = "script"
          },
        ]
      }
    }

    deps += [ ":board_tool_$basename" ]
  }
}

default_image_deps += [ ":board_tools" ]

action("filesystem_sizes.json") {
  testonly = true
  script = "format_filesystem_sizes.py"
  deps = filesystem_sizes_deps + [
           ":fuchsia",
           "zedboot:zbi",
         ]
  output_name = "$root_build_dir/filesystem_sizes.json"
  outputs = [ output_name ]
  fuchsia_target_outputs = get_target_outputs(":fuchsia")

  # Can't use get_target_outputs() because this defined in another file.
  zedboot_zbi_file = "$root_out_dir/zedboot.zbi"
  inputs =
      filesystem_sizes_inputs + fuchsia_target_outputs + [ zedboot_zbi_file ]
  args = filesystem_sizes_args + [
           "--fuchsia-zbi",
           rebase_path(fuchsia_target_outputs[0]),
           "--zedboot-zbi",
           rebase_path(zedboot_zbi_file),
           "--max-fuchsia-zbi-size",
           max_fuchsia_zbi_size,
           "--max-zedboot-zbi-size",
           max_zedboot_zbi_size,
           "--output",
           rebase_path(output_name),
         ]
}

# Pseudo-target to record information about the sizes of filesystems assembled
# during the build for later analysis.
group("record_filesystem_sizes") {
  testonly = true
  deps = [
    ":elf_sizes.json",
    ":filesystem_sizes.json",
  ]
}

###
### Paver and flash scripts, and archives using those images and zedboot's images.
###

action("flash_script") {
  script = "//build/images/generate_flash_script.sh"
  outputs = [ "$root_out_dir/flash.sh" ]
  image = "$root_out_dir/zedboot.zbi"
  args = [
    "--image=" + rebase_path(image, root_build_dir),
    "--output=" + rebase_path(outputs[0], root_build_dir),
    "--zircon-a=${zircon_a_partition}",
    "--zircon-b=${zircon_b_partition}",
    "--zircon-r=${zircon_r_partition}",
    "--vbmeta-a=${vbmeta_a_partition}",
    "--vbmeta-b=${vbmeta_b_partition}",
    "--vbmeta-r=${vbmeta_r_partition}",
    "--active=${active_partition}",
    "--signed=${signed_image}",
    "--product=${fastboot_product}",
    "--pre-erase-flash=${pre_erase_flash}",
  ]
  metadata = {
    images = [
      {
        name = "flash-script"
        path = "flash.sh"
        type = "script"
      },
    ]
    image_paths = [ "IMAGE_FLASH_SH=netboot.sh" ]
  }
}

if (override_recovery_label != "") {
  default_image_deps += [ override_recovery_label ]
}

paver_targets = [
  {
    name = "netboot-script"
    outputs = [ "$root_build_dir/netboot.sh" ]
    switch = "--netboot="
    extra_bootserver_arguments = ""

    deps = [ ":bootserver" ]

    # XXX(46415): The build graph for "bringup" (bootfs_only) MUST only
    # contain one zircon-a metadata target, which means that anything
    # reaching fuchsia.zbi must be excluded from the build graph.
    if (bootfs_only) {
      deps += [ "bringup" ]
    } else {
      deps += [ ":netboot" ]
    }
    metadata = {
      images = [
        {
          name = name
          path = "netboot.sh"
          type = "script"
        },
      ]
      image_paths = [ "IMAGE_NETBOOT_SH=netboot.sh" ]
    }
  },
  {
    name = "zedboot-script"
    outputs = [ "$root_build_dir/pave-zedboot.sh" ]
    deps = [ ":bootserver" ]
    if (bootfs_only) {
      deps += [ "bringup" ]
      switch = "--netboot="
    } else {
      deps += [ "zedboot" ]
      switch = "--pave_zedboot="
    }
    extra_bootserver_arguments = "--allow-zedboot-version-mismatch"
    metadata = {
      images = [
        {
          name = name
          path = "pave-zedboot.sh"
          type = "script"
        },
      ]
      image_paths = [ "IMAGE_PAVE_ZEDBOOT_SH=pave-zedboot.sh" ]
    }
  },
  {
    name = "paver-script"
    outputs = [ "$root_build_dir/pave.sh" ]
    deps = [ ":bootserver" ]
    if (bootfs_only) {
      deps += [ "bringup" ]
      switch = "--netboot="
    } else {
      deps += default_image_deps
      switch = "--pave="
    }
    extra_bootserver_arguments = ""
    metadata = {
      images = [
        {
          name = name
          path = "pave.sh"
          type = "script"
        },
      ]
      image_paths = [ "IMAGE_PAVE_SH=pave.sh" ]
    }
  },
]

# Name the entrypoint scripts in images.json as well, as that they are
# presently the stable API to perform a pave/netboot/etc. without botanist.

archive_formats = [
  "tar",
  "tgz",
]
foreach(format, archive_formats) {
  paver_targets += [
    {
      name = "archive-$format"
      outputs = [ "$root_build_dir/build-archive.$format" ]
      switch = "--archive="
      extra_bootserver_arguments = ""
      deps = [
        ":archive-extras",
        ":flash_script",
        ":paver-script",
        "zedboot",
      ]
      metadata = {
        archives = [
          {
            name = "archive"
            path = "build-archive.$format"
            type = "$format"
          },
        ]
      }
    },
  ]
}

archive_deps = []
foreach(target, paver_targets) {
  action(target.name) {
    deps = []
    if (defined(target.deps)) {
      deps += target.deps
    }
    testonly = true
    outputs = target.outputs
    depfile = "${outputs[0]}.d"
    script = "pack-images.py"
    args = [
      "--depfile=" + rebase_path(depfile, root_build_dir),
      target.switch + rebase_path(outputs[0], root_build_dir),
      "--board_name=${board_name}",
    ]

    if (additional_bootserver_arguments != "") {
      args += [
        "--additional_bootserver_arguments=${additional_bootserver_arguments}",
      ]
    }
    if (target.extra_bootserver_arguments != "") {
      args += [ "--additional_bootserver_arguments=${target.extra_bootserver_arguments}" ]
    }

    args += [
      "images.json",
      "checkout_artifacts.json",
    ]

    if (defined(target.metadata)) {
      metadata = target.metadata
    }
  }
  archive_deps += [ ":${target.name}" ]
}

group("archives") {
  testonly = true
  deps = archive_deps
}

###
### Amber updates.
###

# update_packages.manifest contains the same entries as the pkgsvr_index but
# additionally includes the system_image package.

update_meta_far_merkle_index = "$target_out_dir/update_meta_far_merkle_index"
generate_package_metadata("update_meta_far_merkle_index") {
  testonly = true
  outputs = [ update_meta_far_merkle_index ]
  data_keys = [ "meta_far_merkle_index_entries" ]
  deps = [
    ":base_packages",
    ":cache_packages",
    ":meta_packages",
    ":system_image.meta",
  ]
}

action("update_packages.manifest") {
  visibility = [ ":update.manifest" ]
  testonly = true

  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":update_meta_far_merkle_index" ]
  inputs = [ update_meta_far_merkle_index ]

  script = "manifest_content_expand.sh"
  args = [
    rebase_path(update_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

action("update_packages.manifest.json") {
  visibility = [ ":update.manifest" ]
  testonly = true

  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":update_meta_far_merkle_index" ]
  inputs = [ update_meta_far_merkle_index ]

  script = "generate_packages_json.py"
  args = [
    rebase_path(update_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

# The update package manifest contains the pkgsvr_index and the target
# system kernel images.
action("update.manifest") {
  visibility = [ ":*" ]
  testonly = true

  additional_update_manifest_entries = [
    {
      target = "packages"
      deps = [ ":update_packages.manifest" ]
    },
    {
      target = "packages.json"
      deps = [ ":update_packages.manifest.json" ]
    },

    # Add the meta/package JSON file that makes this the "update" package.
    {
      target = "meta/package"
      sources = [ "update_package.json" ]
    },
    {
      target = "version"
      sources = [ rebase_path(build_info_files.version, "", root_build_dir) ]
    },
    {
      target = "board"
      sources = [ board_name_file ]
    },
  ]

  script = "manifest.py"

  outputs = [ "$target_out_dir/$target_name" ]

  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]
  sources = []

  deps = [
    # This dep ensures the version file included below is always generated,
    # which is presently significant only really for bringup, as bringup still
    # attempts to build this target.
    "//build/info:build-info",
  ]

  # Each entry optionally specifies deps or sources that are added to that of
  # this action, as well as a `target` to be included in the generated
  # manifest.
  foreach(entry, update_manifest + additional_update_manifest_entries) {
    entry_source = ""
    if (defined(entry.deps)) {
      deps += entry.deps
    }

    if (defined(entry.sources)) {
      # TODO(BLD-354): We should only have single source
      sources = []
      sources += entry.sources
      entry_source = sources[0]
    } else if (defined(entry.deps)) {
      foreach(label, entry.deps) {
        # TODO(BLD-354): We should only have single output
        dep_outputs = []
        dep_outputs += get_target_outputs(label)
        entry_source = dep_outputs[0]
      }
    }
    entry_source = rebase_path(entry_source, root_build_dir)
    args += [ "--entry=${entry.target}=${entry_source}" ]
  }
}

pm_build("update.meta") {
  visibility = [ ":*" ]
  testonly = true
  manifest = ":update.manifest"
  package_name = "update"
}

###
### Generate an update package with system_image_prime and fuchsia_prime.
###

# The prime images are used to have an alternate known-compatible OTA
# target for integration testing.

update_prime_meta_far_merkle_index =
    "$target_out_dir/update_prime_meta_far_merkle_index"
generate_package_metadata("update_prime_meta_far_merkle_index") {
  testonly = true
  outputs = [ update_prime_meta_far_merkle_index ]
  data_keys = [ "meta_far_merkle_index_entries" ]
  deps = [
    ":base_packages",
    ":meta_packages",
    ":system_image_prime.meta",
  ]
}

action("update_prime_packages.manifest") {
  visibility = [ ":update_prime.manifest" ]
  testonly = true

  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":update_prime_meta_far_merkle_index" ]
  inputs = [ update_prime_meta_far_merkle_index ]

  script = "manifest_content_expand.sh"
  args = [
    rebase_path(update_prime_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

action("update_prime_packages.manifest.json") {
  visibility = [ ":update_prime.manifest" ]
  testonly = true

  outputs = [ "$target_out_dir/$target_name" ]
  deps = [ ":update_prime_meta_far_merkle_index" ]
  inputs = [ update_prime_meta_far_merkle_index ]

  script = "generate_packages_json.py"
  args = [
    rebase_path(update_prime_meta_far_merkle_index, root_build_dir),
    rebase_path(outputs[0], root_build_dir),
  ]
}

action("update_prime.manifest") {
  visibility = [ ":*" ]
  testonly = true

  script = "manifest.py"

  outputs = [ "$target_out_dir/$target_name" ]

  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]

  deps = [
    ":update.manifest",
    ":update_prime_packages.manifest",
    ":update_prime_packages.manifest.json",
    zbi_prime.dep,
  ]
  update_manifest_outputs = get_target_outputs(":update.manifest")
  update_prime_packages_manifest_outputs =
      get_target_outputs(":update_prime_packages.manifest")
  update_prime_packages_manifest_json_outputs =
      get_target_outputs(":update_prime_packages.manifest.json")
  zbi_outputs = get_target_outputs(zbi_prime.dep)

  sources = update_manifest_outputs
  args += [
    "--rewrite",
    "meta/package={target}=" +
        rebase_path("update_package.json", root_build_dir),
    "--rewrite",
    "packages={target}=" +
        rebase_path(update_prime_packages_manifest_outputs[0], root_build_dir),
    "--rewrite",
    "packages.json={target}=" +
        rebase_path(update_prime_packages_manifest_json_outputs[0],
                    root_build_dir),
    "--rewrite",
    zbi_prime.updater + "={target}=" +
        rebase_path(zbi_outputs[0], root_build_dir),
  ]

  if (use_vbmeta) {
    deps += [ ":fuchsia_prime.vbmeta" ]
    fuchsia_prime_vbmeta = get_target_outputs(":fuchsia_prime.vbmeta")
    args += [
      "--rewrite",
      "fuchsia.vbmeta={target}=" +
          rebase_path(fuchsia_prime_vbmeta[0], root_build_dir),
    ]
  }

  args += [
    "--manifest",
    rebase_path(update_manifest_outputs[0], root_build_dir),
  ]
}

pm_build("update_prime.meta") {
  visibility = [ ":*" ]
  testonly = true
  manifest = ":update_prime.manifest"
  package_name = "update_prime"
}

###
### Generate an update package with zedboot.
###

# The update-to-zedboot images are used to have an update package that OTAs to
# zedboot for integration testing.

# In order for the update-to-zedboot package to be compatible with the update
# package, it needs to contain a "packages" file. However, we don't actually
# need any packages to be installed since we're writing zedboot instead of
# Fuchsia. So we'll just generate an empty "packages" file.
generated_file("update-to-zedboot-packages.manifest") {
  outputs = [ "$target_out_dir/$target_name" ]
  contents = []
}

action("update-to-zedboot.manifest") {
  visibility = [ ":*" ]
  testonly = true

  script = "manifest.py"

  outputs = [ "$target_out_dir/$target_name" ]

  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]

  deps = [
    ":update-to-zedboot-packages.manifest",
    ":update.manifest",
    zbi_to_zedboot.dep,
  ]
  update_manifest_outputs = get_target_outputs(":update.manifest")
  update_to_zedboot_packages_manifest_outputs =
      get_target_outputs(":update-to-zedboot-packages.manifest")

  sources = update_manifest_outputs
  args += [
    "--rewrite",
    "meta/package={target}=" +
        rebase_path("update_package.json", root_build_dir),
    "--rewrite",
    "packages={target}=" +
        rebase_path(update_to_zedboot_packages_manifest_outputs[0],
                    root_build_dir),
    "--rewrite",
    zbi_to_zedboot.updater + "={target}=" + zbi_to_zedboot.target,
  ]
  if (use_vbmeta) {
    deps += [ "zedboot:zedboot.vbmeta" ]
    args += [
      "--rewrite",
      "fuchsia.vbmeta={target}=zedboot.vbmeta",
    ]
  }

  args += [
    "--manifest",
    rebase_path(update_manifest_outputs[0], root_build_dir),
  ]
}

pm_build("update-to-zedboot.meta") {
  visibility = [ ":*" ]
  testonly = true
  manifest = ":update-to-zedboot.manifest"
  package_name = "update-to-zedboot"
}

action("update.sources.manifest") {
  visibility = [ ":*" ]
  testonly = true
  script = "manifest.py"
  deps = [ ":update.manifest" ]
  outputs = [ "$target_out_dir/update.sources.manifest" ]
  update_manifests = get_target_outputs(deps[0])
  args = [
    "--sources",
    "--output=" + rebase_path(outputs[0], root_build_dir),
    "--manifest=" + rebase_path(update_manifests[0]),
  ]
}

# This output is a manifest of manifests that is usable as an input to `pm
# publish -lp`, a tool for publishing a set of packages from a build produced
# list of package manifests.
all_package_manifests_list = root_build_dir + "/all_package_manifests.list"
generate_package_metadata("all_package_manifests.list") {
  testonly = true
  outputs = [ all_package_manifests_list ]
  data_keys = [ "package_output_manifests" ]
  rebase = root_build_dir
  deps = [
    ":packages",
    ":system_image.meta",
    ":system_image_prime.meta",
    ":update-to-zedboot.meta",
    ":update.meta",
    ":update_prime.meta",
  ]
}

# A component ID index maps component instance IDs to component monikers.
# Indices are defined using the component_id_index() GN template. They are
# merged together into a single index and supplied to appmgr using the
# component_id_index_config_data() template, which produces a config_data().
#
# If a system assembly contains components which use isolated storage, then it
# needs include a component_id_index_config_data().
#
# For more details, see //docs/development/components/component_id_index.md#system-assembly
component_id_index_config_data("component_id_index_config_data") {
  testonly = true

  # crawl for component_id_index()s in the base set.
  deps = [ ":base_packages" ]
}

component_index_metadata = "$target_out_dir/component_index_metadata"
generate_component_index("component_index_metadata") {
  visibility = [
    "//build/images:*",
    "//src/sys/component_index:*",
  ]

  testonly = true

  outputs = [ component_index_metadata ]

  deps = [ ":universe_packages" ]
}

# We copy the metatdata to the root dir so that it can easily be used by host
# tools
copy("root_component_index_metadata") {
  testonly = true
  sources = [ component_index_metadata ]
  outputs = [ "$root_out_dir/component_index_metadata" ]
  deps = [ ":component_index_metadata" ]
}

# The system index is the index of all universe packages, naming each
# blobs.json file instead of its merkleroot, and including a tag of the package
# set the package is a part of (base/cache/universe). Additionally the
# system_index has the system package itself, and the system update package.
system_index = "$target_out_dir/system_index"

tagged_snapshot_manifests = [
  {
    tag = "monolith"
    deps = [
      ":base_packages",
      ":meta_packages",
      ":system_image.meta",
      ":update.meta",
    ]
  },
  {
    tag = "preinstall"
    deps = [ ":cache_packages" ]
  },
  {
    tag = "available"
    deps = [ ":universe_packages" ]
  },
]

all_snapshot_entries = []
foreach(manifest, tagged_snapshot_manifests) {
  untagged_entries = "${manifest.tag}.snapshot_entries.untagged"
  generate_package_metadata(untagged_entries) {
    testonly = true
    outputs = [ target_gen_dir + "/" + target_name ]
    deps = manifest.deps
    data_keys = [ "snapshot_entries" ]
  }

  tagged_entries = "${manifest.tag}.snapshot_entries"
  action(tagged_entries) {
    testonly = true
    deps = [ ":" + untagged_entries ]
    script = "add_tag_to_manifest.sh"
    inputs = [ target_gen_dir + "/" + untagged_entries ]
    outputs = [ root_build_dir + "/" + target_name ]
    args = [
      manifest.tag,
      rebase_path(inputs[0], root_build_dir),
      rebase_path(outputs[0], root_build_dir),
    ]
  }
  all_snapshot_entries += [ tagged_entries ]
}

action("system_index") {
  visibility = [ ":system_snapshot" ]
  testonly = true

  script = "//build/cat.sh"
  outputs = [ "$target_out_dir/$target_name" ]
  args = [ rebase_path(outputs[0], root_build_dir) ]
  deps = []
  foreach(entry, all_snapshot_entries) {
    args += [ entry ]
    deps += [ ":" + entry ]
  }
}

compiled_action("system_snapshot") {
  tool = "//src/sys/pkg/bin/pm:pm_bin"
  tool_output_name = "pm"

  visibility = [ ":updates" ]
  testonly = true

  deps = [ ":system_index" ]

  inputs = [ system_index ]

  outputs = [ "$target_out_dir/system.snapshot" ]

  args = [
    "snapshot",
    "--manifest",
    rebase_path(inputs[0], root_build_dir),
    "--output",
    rebase_path(outputs[0], root_build_dir),
  ]
}

# publish all packages to the package repository.
pm_publish("publish") {
  testonly = true
  deps = [ ":all_package_manifests.list" ]
  inputs = [ all_package_manifests_list ]
}

group("updates") {
  testonly = true
  deps = [
    ":package_lists",
    ":publish",
    ":root_component_index_metadata",
    ":system_snapshot",
  ]
}

group("bootserver") {
  deps = [ "//tools/bootserver_old:bootserver($host_toolchain)" ]

  host_out_dir = get_label_info(":bogus($host_toolchain)", "root_out_dir")

  metadata = {
    images = [
      {
        archive = true
        name = "bootserver"
        path = rebase_path("$host_out_dir/bootserver", root_build_dir)
        type = "exe.$host_platform"
      },
    ]
  }
}

group("archive-extras") {
  metadata = {
    # Not actually images, but historically required entries to be included in
    # the relevant build archives.
    images = [
      {
        archive = true
        name = "buildargs"
        type = "gn"
        path = "args.gn"
      },
    ]
  }
}

group("images") {
  testonly = true
  deps = [
    ":archive-extras",
    ":default-images",
  ]

  if (!bootfs_only) {
    deps += [ ":netboot" ]
  }
}

# The default-images target is a dependency of the top level default
# target when appropriate, and contains the minimum set of images that
# are typical given the requested build configuration.
group("default-images") {
  testonly = true

  deps = [
    ":bootserver",
    ":flash_script",
    ":paver-script",
    ":qemu-kernel",
    ":zedboot-script",
    "zedboot",
  ]

  if (enable_netboot) {
    deps += [ ":netboot-script" ]
  }

  # XXX(46415): The build graph for "bringup" (bootfs_only) MUST only
  # contain one zircon-a metadata target, which means that anything
  # reaching fuchsia.zbi must be excluded from the build graph.
  if (!bootfs_only) {
    deps += [
      ":record_filesystem_sizes",
      ":root_component_index_metadata",
      ":updates",
      "recovery",
    ]

    if (override_recovery_label != "") {
      deps += [ override_recovery_label ]
    }
  }
}

generated_file("image_paths") {
  testonly = true
  outputs = [ "$root_build_dir/image_paths.sh" ]
  output_conversion = "list lines"
  data_keys = [ "image_paths" ]
  deps = [ ":images" ]
}

# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/fuchsia/zircon.gni")
import("//build/config/fuchsia/zircon_images.gni")

# Merges manifests together to recreate an image manifest generated by the
# Zircon build.
#
# Parameters
#
#   deps (required)
#     List of targets generating a manifest.
#
#   reference (optional)
#     Path to the Zircon image manifest that this target is replicating.

template("aggregate_manifest") {
  assert(defined(invoker.deps), "Aggregate manifest needs dependencies.")

  manifest_target_name = "$target_name.manifest"

  final_manifest = "$target_out_dir/$target_name.unification.manifest"

  group_deps = []

  # Merges all the dependent manifests together.
  action(manifest_target_name) {
    script = "//build/images/manifest.py"

    inputs = []

    outputs = [
      final_manifest,
    ]

    response_file_contents = [
      "--output",
      rebase_path(outputs[0]),
      "--unique",
    ]

    foreach(dep, invoker.deps) {
      out_dir = get_label_info(dep, "target_out_dir")
      name = get_label_info(dep, "name")
      manifest = "$out_dir/$name.unification.manifest"
      inputs += [ manifest ]
      response_file_contents += [
        "--manifest",
        rebase_path(manifest),
      ]
    }

    args = [ "@{{response_file_name}}" ]

    deps = invoker.deps
  }
  group_deps += [ ":$manifest_target_name" ]

  if (defined(invoker.reference)) {
    # Look for the reference manifest in the list of Zircon-supplied images.
    reference = invoker.reference
    reference_manifest = false
    foreach(image, zircon_images) {
      if (image.type == "manifest") {
        if (image.name == reference) {
          assert(reference_manifest == false,
                 "Duplicate manifest for $reference")
          reference_manifest = "$zircon_root_build_dir/${image.path}"
        }
      }
    }
    assert(reference_manifest != false,
           "Could not find manifest for $reference")

    normalize_target_name = "$target_name.normalize"
    compare_target_name = "$target_name.compare"
    normalized_manifest = "$target_gen_dir/$target_name.normalized_ref.txt"

    # The first step is to "rebase" the reference manifest so that its paths
    # are also relative to the present build's root_build_dir.
    action(normalize_target_name) {
      script = "//build/images/manifest.py"

      inputs = [
        reference_manifest,
      ]

      outputs = [
        normalized_manifest,
      ]

      args = [
        "--output",
        rebase_path(outputs[0]),
        "--unique",
        "--cwd",
        rebase_path(zircon_root_build_dir, root_out_dir),
        "--manifest",
        rebase_path(inputs[0]),
      ]
    }

    # Verify that the generated and reference manifest are identical.
    action(compare_target_name) {
      script = "compare_manifests.py"

      inputs = [
        final_manifest,
        normalized_manifest,
      ]

      outputs = [
        "$target_out_dir/$target_name.success.stamp",
      ]

      args = [
        "--generated",
        rebase_path(final_manifest),
        "--reference",
        rebase_path(normalized_manifest),
        "--stamp",
        rebase_path(outputs[0]),
      ]

      deps = [
        ":$manifest_target_name",
        ":$normalize_target_name",
      ]
    }

    group_deps += [ ":$compare_target_name" ]
  }

  group(target_name) {
    public_deps = group_deps
  }
}

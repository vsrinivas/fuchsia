# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/fuchsia/zircon.gni")
import("//build/python/python.gni")
import("aggregate_manifest.gni")

# A binary object (app, driver, test) generated by the Zircon build.
#
# The purpose of this type is to exposes a binary built by the ZN build.
# Traditionally, these are shipped to the GN build in aggregate form, i.e. as
# part of a much larger .zbi or .manifest file.
#
# The binary is represented by a manifest using the BOOTFS format. This allows
# the GN build to include granular listings of what goes into the various images
# it produces instead of sharing the work with the ZN build.
#
# Once the contents of images are encoded in the GN build, moving a given binary
# from ZN to GN becomes a matter of moving source code around and verifying that
# the resulting binary is well-formed.
#
# Parameters
#
#   contents (required)
#     A list of strings representing the manifest contents.

template("zircon_artifact") {
  assert(defined(invoker.contents), "Manifest contents are missing.")

  manifest = "$target_out_dir/$target_name.original.manifest"
  write_file(manifest, invoker.contents)

  main_target_name = target_name
  rebase_target_name = "$target_name.rebase"

  action(rebase_target_name) {
    script = python_exe_src

    inputs = [ manifest ]

    outputs = [ "$target_out_dir/$target_name.unification.manifest" ]

    args = [
      rebase_path("//build/images/manifest.py", root_build_dir),
      "--output",
      rebase_path(outputs[0], root_build_dir),
      "--unique",
      "--cwd",
      rebase_path(zircon_root_build_dir, root_build_dir),
      "--manifest",
      rebase_path(inputs[0]),
    ]
  }

  aggregate_manifest(main_target_name) {
    deps = [ ":$rebase_target_name" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }
}

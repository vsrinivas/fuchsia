# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/rust/rustc_artifact.gni")
import("//build/testing/host_test.gni")
import("//build/toolchain/concurrent_jobs.gni")
import("//build/toolchain/rbe.gni")

# Internal template supporting rustc_test.
#
# This templates support rustc_test and the equivalent targets generated by other rustc_*** rules
# when `with_unit_tests=true`. A different rule name than `rustc_test` is necessary so that cascaded
# rules can inherit `configs` while we can maintain sensible defaults (through `set_defaults`) for
# `rustc_test` callers. See `BUILDCONFIG.gn` for example `set_defaults` usage with rustc_*** rules.
#
# If in doubt, use rustc_test instead.
template("rustc_test_internal") {
  not_needed(invoker,
             [
               "version",
               "testonly",
             ])

  # default location for rust libraries
  source_root = "src/lib.rs"
  if (defined(invoker.source_root)) {
    source_root = invoker.source_root
  }

  if (defined(invoker.original_target_name)) {
    _original_target_name = invoker.original_target_name
  } else {
    _original_target_name = target_name
  }

  # use the target name unless another name is specified
  assert(!(defined(invoker.output_name) && defined(invoker.name)),
         "Only one of output_name and name may be specified.")
  package_name = target_name
  if (defined(invoker.output_name)) {
    package_name = invoker.output_name
  } else if (defined(invoker.name)) {
    package_name = invoker.name
  }

  # built-in gn rules do not support dashes
  crate_name = string_replace(package_name, "-", "_")

  exe_target_name = target_name

  if (is_host) {
    exe_target_name = "${target_name}_executable"
    all_deps = [ ":${exe_target_name}" ]
    if (defined(invoker.deps)) {
      all_deps += invoker.deps
    }
    if (defined(invoker.non_rust_deps)) {
      all_deps += invoker.non_rust_deps
    }

    host_test(target_name) {
      binary_path = "${root_out_dir}/${crate_name}"
      deps = all_deps
      if (defined(invoker.test_environments)) {
        environments = invoker.test_environments
      }
      forward_variables_from(invoker,
                             [
                               "args",
                               "visibility",
                             ])
    }
  } else {
    # if not a host-side target, we don't need this since it doesn't
    # propogate to package.gni
    not_needed(invoker, [ "test_environments" ])
  }

  rustflags = []
  if (defined(invoker.rustflags)) {
    rustflags = invoker.rustflags
  }

  rustc_artifact(exe_target_name) {
    target_type = "executable"

    configs = []
    configs = invoker.configs

    # Add test-only configs
    if (defined(invoker.test_configs)) {
      configs += invoker.test_configs
    }

    crate_root = source_root
    clippy_crate_type = "bin"
    pass_through = {
      forward_variables_from(invoker, [ "output_dir" ])
      output_name = crate_name
    }
    crate_name = crate_name

    original_target_name = _original_target_name

    # tell rustc to compile in the test harness
    rustflags += [ "--test" ]

    # anything defined with rustc_test MUST be a test target
    testonly = true

    forward_variables_from(invoker,
                           [
                             "disable_clippy",
                             "enforce_source_listing",
                             "features",
                             "edition",
                             "inputs",
                             "sources",
                             "rustenv",
                             "visibility",
                           ])

    _use_rbe = rust_rbe_enable
    if (defined(invoker.disable_rbe)) {
      _use_rbe = !invoker.disable_rbe
    }

    _concurrency = concurrent_jobs.remote
    if (!_use_rbe) {
      _any_lto = toolchain_variant.tags + [
                   "lto",
                   "thinlto",
                 ] -
                 [
                   "lto",
                   "thinlto",
                 ] != toolchain_variant.tags

      if (_any_lto) {
        # LTO on tests can be memory-intensive, especially for Rust,
        # so reduce concurrency when running locally.
        # See http://fxbug.dev/111904 for more context.
        _concurrency = concurrent_jobs.local
      }
    }
    forward_variables_from(_concurrency, "*")  # sets a pool

    # Allow target to override pool, e.g. "highmem" for exceptionally
    # large jobs that should run with even less concurrency.
    if (defined(invoker.pool)) {
      pool = invoker.pool
    }

    deps = []
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.non_rust_deps)) {
      deps += invoker.non_rust_deps
    }

    # test_deps specified in the parent template (if not used directly)
    # should also be treated as normal dependencies
    if (defined(invoker.test_deps)) {
      deps += invoker.test_deps
    }

    _data_deps = []
    if (defined(invoker.data_deps)) {
      _data_deps = invoker.data_deps
    }
    if (is_fuchsia) {
      # Dynamic linking applies to not only to libstd but to libtest as well,
      # which means we must depend on it as a data_dep to get it in our
      # package.
      _dynamic_rust_config =
          [ "//build/config/fuchsia:dynamic_rust_standard_library" ]
      if (configs + _dynamic_rust_config - _dynamic_rust_config != configs) {
        _data_deps += [ "//build/toolchain/runtime:shared-rust-libtest-deps" ]
      } else {
        _data_deps += [ "//build/toolchain/runtime:static-rust-libtest-deps" ]
      }

      deps += [ "//build/rust:rust_test_metadata" ]
      metadata = {
        cmx_patches_walk = [ "//build/rust:rust_test_metadata" ]

        # Used by the fuchsia_test_component_manifest() template.
        test_component_manifest_cml = [
          {
            include = [ "//src/sys/test_runners/rust/default.shard.cml" ]
          },
        ]
      }
    }
    pass_through.data_deps = _data_deps
  }
}

# Defines a Rust unit test, without also compiling a separate binary or library
# target.
#
# Parameters
#
#   output_name (optional)
#   name (optional, deprecated)
#     Name of the test binary, also used as the crate name as defined in its
#     manifest file. If not specified, it is assumed to be the same as the
#     target name.
#
#   version
#     Semver version of the crate as seen on crates.io.
#
#   edition
#     Edition of the Rust language to be used. See
#     https://doc.rust-lang.org/edition-guide/editions/index.html for more info on rust editions.
#
#   configs (optional)
#     A list of config labels applying to this target.
#
#   enforce_source_listing (optional)
#     When true, enforces that any source files used by the Rust compiler are
#     listed in `sources`. Defaults to true.
#
#   sources (optional)
#     List of source files which this crate is allowed to compile. Only
#     allowed when `enforce_source_listing = true`.
#     The Rust compiler discovers source files by following `mod` declarations
#     starting at the `source_root`. The discovered source files must match this
#     list.
#
#   inputs (optional)
#     List of additional non-source files read by the compiler. These are typically
#     configuration or test-data files included in the build with the `include_str!`
#     macro. Only allowed when `enforce_source_listing = true`.
#
#   deps (optional)
#     List of rust_library GN targets on which this crate depends.
#     Third party crates can be included through paths like
#     "//third_party/rust_crates:<cratename>",
#
#   non_rust_deps (optional)
#     List of non-rust_library GN targets on which this crate depends.
#     Obsolete. Please use deps instead.
#
#   data_deps (optional)
#     List of GN targets that are only needed at runtime.
#
#   test_environments (optional)
#     What environments the unit test should target. Only used here
#     for linux and mac tests, with a default value of a general linux/mac
#     environment (as a function of $current_os).
#     See environments parameter on //build/testing/test_spec.gni for more
#     details.
#
#   args (optional)
#     List of flags to pass directly to the test binary, e.g.
#     ["--nocapture"].
#
#   source_root (optional)
#     Location of the crate root (e.g. `src/main.rs` or `src/lib.rs`).
#     This should usually be 'src/lib.rs/ for libraries (the default)
#     and `src/main.rs` for binaries.
#
#   features (optional)
#     A list of conditional compilation flags to enable. This can be used to set features for crates
#     built in-tree which are also published to crates.io. This would be passed to rustc as
#     '--cfg feature="XXX"'
#
#   rustenv (optional)
#     A list of environment variables that will be set when running the rust
#     compiler. These can be accessed at compile time with
#     [`std::env!`](https://doc.rust-lang.org/stable/std/macro.env.html)
#
#   output_dir (optional)
#     Directory that the resulting test should be placed in.
#     See: `gn help output_dir`
#
#   pool (optional)
#     Override the default concurrency pool when building the Rust test binary.
#     e.g. extremely high memory jobs run locally could use
#     "//build/config:highmem".
#
#   disable_rbe (optional)
#     Set to true to force this target to build locally, overriding the global
#     `rust_rbe_enable`.
#
#   disable_clippy (optional)
#     Don't run clippy on this target.
#
#   original_target_name (optional)
#     The name of the target as it appears in the BUILD file. Enables tooling
#     to find the template invocation in a BUILD file where this target was defined.
#
# Example of usage:
#
#   rustc_test("foo_test") {
#     source_root = "src/foo_test.rs",
#     deps = [
#       "//garnet/public/rust/bar",
#       "//third_party/rust_crates:clap",
#       "//third_party/rust_crates:serde",
#       "//third_party/rust_crates:slab",
#     ]
#     sources = [ "src/lib.rs" ]
#   }
template("rustc_test") {
  rustc_test_internal(target_name) {
    forward_variables_from(invoker, "*")
  }
}

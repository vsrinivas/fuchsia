# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/json/validate_json.gni")

# Defines an SDK element.
#
# Direct instantiation of `sdk_element` is not supported. Element authors should
# use specialized templates, e.g. `host_tool_sdk_element`, instead.
#
# Outputs
#
#   $target_gen_dir/${target_name}_packaging_manifest.json
#     A manifest describing which files are included in the element.
#
#   $target_gen_dir/${target_name}_sdk_metadata.json
#     A metadata file describing the element.
#     * This file is included in the final SDK and may be used by tools that
#       interact with the SDK.
#
# Parameters
#
#   schema (required)
#     JSON schema file for this element type.
#     * Metadata schema files are hosted under //build/sdk/meta and have
#       filenames of the form "{type}-{version}.json".
#
#   schema_refs (optional)
#     List of JSON schemas referenced by the schema file.
#     * Defaults to [ "//build/sdk/meta/common.json" ]
#
#   meta (required if `meta_src` is not set)
#     Scope describing the element's metadata file.
#     * This parameter's contents are determined by the schema defined by `type`
#       and `schema_version`.
#
#  meta_src (required if `meta` is not set)
#     Path to the element's metadata file.
#     * This parameter's contents are determined by the schema defined by `type`
#       and `schema_version`.
#
#  meta_dst (optional)
#    Destination path of the metadata file in the SDK element, relative to the
#    element root.
#    * By default, this is "${target_name}_sdk_metadata.json"
#
#   files (optional)
#     List of scopes describing the contents of this element.
#     * A file scope has the following attributes:
#       src (required)
#         Path to the original file.
#         Must be the absolute GN path, beginning with "//".
#       dst (required)
#         Destination path of the file relative to the element root.
#
#   api (optional) [TODO(b/204903307): implement the api parameter]
#     Path to the file representing the API canonically exposed by this element.
#     * If this attribute is set, "files" or "api_contents" must be set as well.
#     * An API file is a JSON file containing a map of file paths to canonical
#       MD5 hashes. The file paths correspond to the `dst` field of a file scope
#       (see "files" above).
#     * This file is used to ensure modifications to the API are explicitly
#       acknowledged.
#     * Changes to the API contents are approximated by comparing the MD5 hashes
#       of the API contents to the ones listed in the API file.
#
#   api_contents (optional)
#     List of scopes representing the files making up the element's API.
#     * Ignored if `api` is not set.
#     * By default, this parameter will be equal to the `files` parameter.
#     * Set `api_contents` explicitly if the element's API surface is describe
#       by only a subset of its files. For example, a C++ library may contain
#       header and source files, but its API consists of header files only.
#     * See the "files" section above for the definition of a file scope.
#
#   sdk_deps (optional)
#     List of GN labels for other SDK elements this element depends on at build
#     time.
#
#   sdk_soft_deps (optional)
#     List of GN labels for other SDK elements this element may depend on to be
#     useful to SDK users, but that are not build dependencies. For example, a
#     FIDL library may have a soft dependency on fidlc.
#
#   non_sdk_deps (optional)
#     List of GN labels which this target needs built, but are not SDK elements.
template("sdk_element") {
  if (defined(invoker.files)) {
    files = invoker.files
  } else {
    files = []
  }
  foreach(file, files) {
    assert(defined(file.src), "File $file does not specify a source.")
    assert(defined(file.dst), "File $file does not specify a destination.")
  }

  assert(defined(invoker.schema), "Must define element metadata schema")
  schema = invoker.schema

  if (defined(invoker.schema_refs)) {
    schema_refs = invoker.schema_refs
  } else {
    schema_refs = [ "//build/sdk/meta/common.json" ]
  }

  assert(defined(invoker.meta) || defined(invoker.meta_src),
         "Must define meta or meta_src")
  assert(!(defined(invoker.meta) && defined(invoker.meta_src)),
         "meta and meta_src are mutually exclusive")

  gn_deps = []
  if (defined(invoker.non_sdk_deps)) {
    gn_deps += invoker.non_sdk_deps
  }
  if (defined(invoker.sdk_deps)) {
    gn_deps += invoker.sdk_deps
  }
  if (defined(invoker.sdk_soft_deps)) {
    gn_deps += invoker.sdk_soft_deps
  }

  # The meta file contains the metadata describing the element, according to the
  # type-specific schema (see //build/sdk/meta).
  meta_target_name = "${target_name}_sdk_metadata"
  meta_file = "${target_gen_dir}/${meta_target_name}.json"
  meta_dst = "${meta_target_name}.json"
  if (defined(invoker.meta_dst)) {
    meta_dst = invoker.meta_dst
  }
  if (defined(invoker.meta_src)) {
    copy(meta_target_name) {
      forward_variables_from(invoker, [ "testonly" ])
      sources = [ invoker.meta_src ]
      outputs = [ meta_file ]
    }
  } else {
    meta_content = invoker.meta
    generated_file(meta_target_name) {
      forward_variables_from(invoker, [ "testonly" ])
      visibility = [ ":*" ]
      outputs = [ meta_file ]
      contents = meta_content
      output_conversion = "json"
    }
  }

  validate_target_name = "validate_${meta_target_name}"
  validate_json(validate_target_name) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":*" ]
    use_valico = true
    data = meta_file
    schema = schema
    sources = schema_refs
    public_deps = [ ":${meta_target_name}" ]
  }

  files += [
    {
      src = rebase_path(meta_file, root_out_dir)
      dst = meta_dst
    },
  ]

  # The manifest file contains the file mappings needed to package the element.
  manifest_target_name = "${target_name}_packaging_manifest"
  manifest_file = "${target_gen_dir}/${manifest_target_name}.json"
  generated_file(manifest_target_name) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":*" ]
    outputs = [ manifest_file ]
    contents = files
    output_conversion = "json"
  }

  # TODO(b/204903307): .api generation/validation

  group(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    public_deps = [
                    ":${manifest_target_name}",
                    ":${validate_target_name}",
                  ] + gn_deps
  }
}

# Produces sdk_molecule-compatible metadata from an sdk_element.
#
# This template converts SDK element metadata into SDK atom metadata, to allow
# SDK atoms to be gradually migrated to sdk_element without breaking the
# monolithic SDK build.
#
# Outputs
#
#   $target_gen_dir/${target_name}.sdk
#     A manifest describing which files are included in the element.
#
#   $target_gen_dir/${target_name}_adapter.meta.json
#     A metadata file describing the element.
#
# Parameters
#
#   sdk_element (required)
#     Label of the SDK element to adapt.
template("sdk_element_adapter") {
  assert(defined(invoker.sdk_element), "Must define sdk_element")
  element_label = get_label_info(invoker.sdk_element, "label_no_toolchain")
  element_name = get_label_info(invoker.sdk_element, "name")
  gen_dir = get_label_info(invoker.sdk_element, "target_gen_dir")

  # .sdk manifest file based on _packaging_manifest.json
  manifest_in = "${gen_dir}/${element_name}_packaging_manifest.json"
  manifest_out = "${target_gen_dir}/${target_name}.sdk"

  # .meta.json file based on _sdk_metadata.json
  meta_in = "${gen_dir}/${element_name}_sdk_metadata.json"
  meta_out = "${target_gen_dir}/${target_name}_adapter.meta.json"

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    public_deps = [ element_label ]
    outputs = [
      manifest_out,
      meta_out,
    ]
    script = "//build/sdk/sdk_element_adapter.py"
    sources = [
      manifest_in,
      meta_in,
    ]
    args = [
      "--manifest-in",
      rebase_path(manifest_in, root_build_dir),
      "--meta-in",
      rebase_path(meta_in, root_build_dir),
      "--manifest-out",
      rebase_path(manifest_out, root_build_dir),
      "--meta-out",
      rebase_path(meta_out, root_build_dir),
      "--gn-label",
      get_label_info(":${target_name}", "label_with_toolchain"),
    ]
  }
}

# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/package.gni")

# Helper template to create test component which runtests can execute.
#
# This template assumes that for all the test binaries in |tests| there would
# be a corresponding component manifest file in meta/ folder with same name.
# If there is none this template will fail with an error.
#
# Parameters
#
#   meta (optional)
#     [list of scopes] Defines the metadata entries in the package. A metadata
#     entry is typically a source file and is placed in the `meta/` directory of
#     the assembled package.
#
#     Entries in a scope in the meta list:
#
#       path (required)
#         [path] Location of entry in source or build directory. If the
#         resource is checked in, this will typically be specified as a
#         path relative to the BUILD.gn file containing the `package()`
#         target. If the resource is generated, this will typically be
#         specified relative to `$target_gen_dir`.
#
#       dest (required)
#         [path] Location the resource will be placed within `meta/`.
#
#   binaries (optional)
#     [list of scopes] Defines the binaries in the package. A binary is
#     typically produced by the build system and is placed in the `bin/`
#     directory of the assembled package.
#
#     Entries in a scope in the binaries list:
#
#       name (required)
#         [string] Name of the binary.
#
#       source (optional)
#         [path] Location of the binary in the build directory if it is not
#         at `$root_out_dir/$name`.
#
#       dest (optional)
#         [path] Location the binary will be placed within `bin/`.
#
#   tests (optional)
#     [list of scopes] Defines the test binaries in the package for v1 component
#     tests. A test is typically produced by the build system and is placed in
#     the `test/` directory of the assembled package.
#
#     Entries in a scope in the tests list:
#
#       name (required)
#         [string] Name of the test.
#
#       dest (optional)
#         [path] Location the binary will be placed within `test/`.
#
#       manifest (optional)
#         [path] Location of the component manifest file (`.cmx` file).
#
#       disabled (optional)
#         [bool] Whether to disable the test on continuous integration
#         jobs. This can be used when a test is temporarily broken, or if
#         it is too flaky or slow for CI. The test will also be skipped by
#         the `runtests` command.
#
#     For each tests entry this expects a corresponding cmx file in meta
#     directory.
#
#   v2_tests (optional)
#     [list of scopes] Defines the test binaries in the package for v2 component
#     tests. A test is typically produced by the build system and is placed in
#     the `test/` directory of the assembled package.
#
#     Entries in a scope in the tests list:
#
#       name (required)
#         [string] Name of the test.
#
#       dest (optional)
#         [path] Location the binary will be placed within `test/`.
#
#       manifest (optional)
#         [path] Location of the component manifest file (`.cml` file).
#
#       disabled (optional)
#         [bool] Whether to disable the test on continuous integration
#         jobs. This can be used when a test is temporarily broken, or if
#         it is too flaky or slow for CI. The test will also be skipped by
#         the `runtests` command.
#
#     For each v2_tests entry this expects a corresponding cml file in meta
#     directory.
#
#   resources (optional)
#     [list of scopes] Defines the resources in the package. A resource is a
#     data file that may be produced by the build system, checked in to a
#     source repository, or produced by another system that runs before the
#     build. Resources are placed in the `data/` directory of the assembled
#     package.
#
#     Entries in a scope in the resources list:
#
#       path (required)
#         [path] Location of resource in source or build directory. If the
#         resource is checked in, this will typically be specified as a
#         path relative to the BUILD.gn file containing the `package()`
#         target. If the resource is generated, this will typically be
#         specified relative to `$target_gen_dir`.
#
#       dest (required)
#         [path] Location the resource will be placed within `data/`.
#
#   extra (optional)
#     [list of paths] Manifest files containing extra entries, which
#     might be generated by the build.
#
#   deps (optional)
#   public_deps (optional)
#   data_deps (optional)
#     Usual GN meanings.
#
template("test_package") {
  forward_variables_from(invoker,
                         [
                           "tests",
                           "v2_tests",
                           "meta",
                         ])
  if (!defined(meta)) {
    meta = []
  }
  if (!defined(tests)) {
    tests = []
  }
  if (!defined(v2_tests)) {
    v2_tests = []
  }
  foreach(test, tests) {
    test_dest = test.name
    if (defined(test.dest)) {
      test_dest = test.dest
    }
    if (defined(test.manifest)) {
      test_manifest = test.manifest
    } else {
      test_manifest = "meta/${test_dest}.cmx"
    }

    meta += [
      {
        path = test_manifest
        dest = "${test_dest}.cmx"
      },
    ]
  }

  foreach(test, v2_tests) {
    test_dest = test.name
    if (defined(test.dest)) {
      test_dest = test.dest
    }
    if (defined(test.manifest)) {
      test_manifest = test.manifest
    } else {
      test_manifest = "meta/${test_dest}.cml"
    }

    meta += [
      {
        path = test_manifest
        dest = "${test_dest}.cm"
      },
    ]
  }

  tests += v2_tests

  package(target_name) {
    testonly = true
    forward_variables_from(invoker,
                           [
                             "binaries",
                             "data_deps",
                             "deprecated_shell",
                             "deps",
                             "drivers",
                             "extra",
                             "loadable_modules",
                             "package_name",
                             "public_deps",
                             "resources",
                             "rootjob_svc",
                             "rootresource_svc",
                             "visibility",
                           ])
  }
}

# Helper template to create unit test component which runtests can execute.
#
# This template assumes that all the test binaries in |tests| do not depend on
# any component manifest facets, features, services and etc. If you wish to use
# any of these features in your manifest, you must use `package` or
# `test_package`.
#
# Parameters
#
#   meta (optional)
#     [list of scopes] Defines the metadata entries in the package. A metadata
#     entry is typically a source file and is placed in the `meta/` directory of
#     the assembled package.
#
#     Entries in a scope in the meta list:
#
#       path (required)
#         [path] Location of entry in source or build directory. If the
#         resource is checked in, this will typically be specified as a
#         path relative to the BUILD.gn file containing the `package()`
#         target. If the resource is generated, this will typically be
#         specified relative to `$target_gen_dir`.
#
#       dest (required)
#         [path] Location the resource will be placed within `meta/`.
#
#   binaries (optional)
#     [list of scopes] Defines the binaries in the package. A binary is
#     typically produced by the build system and is placed in the `bin/`
#     directory of the assembled package.
#
#     Entries in a scope in the binaries list:
#
#       name (required)
#         [string] Name of the binary.
#
#       source (optional)
#         [path] Location of the binary in the build directory if it is not
#         at `$root_out_dir/$name`.
#
#       dest (optional)
#         [path] Location the binary will be placed within `bin/`.
#
#
#   tests (optional)
#     [list of scopes] Defines the test binaries in the package. A test is
#     typically produced by the build system and is placed in the `test/`
#     directory of the assembled package.
#
#     Entries in a scope in the tests list:
#
#       name (required)
#         [string] Name of the test.
#
#       args (optional)
#         [list of strings] Arguments for the test binary.
#
#       dest (optional)
#         [path] Location the binary will be placed within `test/`.
#
#       disabled (optional)
#         [bool] Whether to disable the test on continuous integration
#         jobs. This can be used when a test is temporarily broken, or if
#         it is too flaky or slow for CI. The test will also be skipped by
#         the `runtests` command.
#
#     For each tests entry this expects a corresponding cmx file in meta directory.
#
#   resources (optional)
#     [list of scopes] Defines the resources in the package. A resource is a
#     data file that may be produced by the build system, checked in to a
#     source repository, or produced by another system that runs before the
#     build. Resources are placed in the `data/` directory of the assembled
#     package.
#
#     Entries in a scope in the resources list:
#
#       path (required)
#         [path] Location of resource in source or build directory. If the
#         resource is checked in, this will typically be specified as a
#         path relative to the BUILD.gn file containing the `package()`
#         target. If the resource is generated, this will typically be
#         specified relative to `$target_gen_dir`.
#
#       dest (required)
#         [path] Location the resource will be placed within `data/`.
#
#   extra (optional)
#     [list of paths] Manifest files containing extra entries, which
#     might be generated by the build.
#
#   deps (optional)
#   public_deps (optional)
#   data_deps (optional)
#     Usual GN meanings.
#
template("unittest_package") {
  package_tests = []
  manifest_labels = []

  foreach(test, invoker.tests) {
    test_dest = test.name
    if (defined(test.dest)) {
      test_dest = test.dest
    }
    test_args = []
    if (defined(test.args)) {
      test_args = test.args
    }
    test_manifest = "${target_gen_dir}/meta/${test_dest}.cmx"

    package_tests += [
      {
        forward_variables_from(test,
                               [
                                 "name",
                                 "dest",
                                 "disabled",
                                 "environments",
                               ])
        manifest = test_manifest
      },
    ]

    manifest_label = "get_test_package_manifest_${test_dest}.cmx"
    generated_file(manifest_label) {
      outputs = [ test_manifest ]

      # TODO(fxbug.dev/4748): As of today, CMX files require the args list to be either
      # absent or of at least one element. There is a case to be made to relax
      # this constraint, and simply allow empty lists as well. Depending on
      # decision by CF team, the code below could be simplified to avoid
      # conditionally building the contents.
      # Note that given current approach, cyclomatic complexity is exponential
      # in the number of possibly empty lists which need to be included in the
      # generated CMX.
      if (test_args == []) {
        contents = {
          program = {
            binary = "test/${test_dest}"
          }
        }
      } else {
        contents = {
          program = {
            binary = "test/${test_dest}"
            args = test_args
          }
        }
      }
      output_conversion = "json"
    }
    manifest_labels += [ ":$manifest_label" ]
  }

  test_package(target_name) {
    forward_variables_from(invoker,
                           [
                             "binaries",
                             "data_deps",
                             "extra",
                             "public_deps",
                             "resources",
                             "drivers",
                             "loadable_modules",
                             "package_name",
                             "meta",
                           ])
    tests = package_tests
    deps = []
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    deps += manifest_labels
  }
}

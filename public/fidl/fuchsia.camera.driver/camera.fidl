// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library fuchsia.camera.driver;

const uint32 MAX_FORMATS_PER_RESPONSE = 16;

// Status to be set when a frame is signalled available.
enum FrameStatus {
  OK = 0;
  // An error occurred during the production of a frame.
  // No data will be available in the data buffer corresponding to this
  // notification.
  ERROR_FRAME = 1;

  // No space was available in the data buffer, resulting in a dropped frame.
  ERROR_BUFFER_FULL = 2;
};

struct Metadata {
    int64 timestamp;
};

// Sent by the driver to the client when a frame is available for processing,
// or an error occurred.
struct FrameAvailableEvent {
  // Non zero if an error occurred.
  FrameStatus frame_status;

  // Number of bytes in the frame.
  uint32 frame_size;

  // The position (in bytes) of the start of the frame in the data buffer.
  uint64 frame_offset;

  Metadata metadata;
};

struct FrameRate {
  // The frame rate is frames_per_sec_numerator / frames_per_sec_denominator.
  uint32 frames_per_sec_numerator;
  uint32 frames_per_sec_denominator;
};

struct VideoFormat {
  fuchsia.sysmem.ImageFormat format;
  FrameRate rate;
};

// These are the original interfaces, which are being used for compatibility.
// The names are preserved from the ones in camera.h for porting ease.
[Discoverable]
interface Control {
  // Get the available format types for this device
  // NOTE: The formats are paginated to MAX_FORMATS_PER_RESPONSE, multiple GetFormats
  //       need to be issued until total_format_count are received
  1: GetFormats(uint32 index) -> (vector<VideoFormat> formats, uint32 total_format_count, zx.status status);

  // Sent by the client to indicate desired stream characteristics.
  // If setting the format is successful, the stream request will be honored.
  2: SetFormat(VideoFormat format,
               request<Stream> stream,
               request<StreamEvents> stream_events) -> (uint32 max_frame_size, zx.status status);
};

interface StreamEvents {
  // Sent by the driver to the client when a frame is available for processing,
  // or an error occurred.
  1: -> OnFrameAvailable(FrameAvailableEvent frame);

  // Frame streaming stopped
  2: -> Stopped();
};

interface Stream {
  // Set buffer storage used by camera capture.
  // NOTE: The client must transfer a VMO handle for the data buffer
  // with read-write permissions. The size of the VMO should be an
  // integral multiple of max_frame_size returned in SET_FORMAT.
  1: SetBuffer(handle<vmo> buffer) -> (zx.status status);

  // Starts the streaming of frames.
  2: Start() -> (zx.status status);

  // Stops the streaming of frames.
  3: Stop() -> (zx.status status);

  // Unlocks the specified frame, allowing the driver to reuse the memory.
  4: ReleaseFrame(uint64 data_offset) -> (zx.status status);
};

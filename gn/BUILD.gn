# Copyright 2016 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//packages/gn/packages.gni")
import("//build/config/fuchsia/bootdata.gni")
import("//build/toolchain/clang_toolchain.gni")

declare_args() {
  # path to autorun script
  autorun = ""

  # Manifest file describing target libraries from the Clang toolchain.
  toolchain_manifest = "${clang_prefix}/../lib/${clang_target}.manifest"

  # Groups to include from the Zircon /boot manifest into /boot.
  # This is either "all" or a comma-separated list of one or more of:
  #   core -- necessary to boot
  #   misc -- utilities in /bin
  #   test -- test binaries in /bin and /test
  # TODO(mcgrathr): Change to default to "core".
  zircon_boot_groups = "all"

  # Additional bootdata items needed from the Zircon build.  This
  # build does not use Zircon's bootdata.bin but instead uses Zircon's
  # bootfs.manifest, so this must list any necessary additional inputs
  # the Zircon build puts into its bootdata.bin.
  if (target_cpu == "arm64") {
    zircon_additional_bootdata = [
      "platform-id.bin",
      "mdi.bin",
    ]
  } else {
    zircon_additional_bootdata = []
  }

  # A list of labels for `bootdata` targets (see //build/bootdata.gni)
  # to roll into the final bootable image.  These targets must use the
  # default `output_name` and `output_extension`.
  extra_bootdata = []
}

declare_args() {
  # Groups to include from the Zircon /boot manifest into /system
  # (instead of into /boot like Zircon's own bootdata.bin does).
  # Should not include any groups that are also in zircon_boot_groups,
  # which see.  If zircon_boot_groups is "all" then this should be "".
  zircon_system_groups = ""
  if (zircon_boot_groups != "all") {
    # TODO(mcgrathr): Could default to "" for !is_debug, or "production build".
    zircon_system_groups = "misc,test"
  }
}

if (zircon_boot_groups == "all") {
  assert(zircon_system_groups == "",
         "zircon_boot_groups already has everything")
} else {
  assert(zircon_system_groups != "all" && zircon_system_groups != "core",
         "zircon_system_groups cannot include core (or all)")
}

# TODO(TO-471): The toolchain package will provide this file
# but it doesn't yet, so generate it with this kludge.
toolchain_manifest = "${root_out_dir}/toolchain.manifest"
action("generate_toolchain_manifest") {
  script = "toolchain_manifest.py"
  outputs = [
    toolchain_manifest,
  ]
  inputs = [
    "${clang_prefix}/clang",
  ]
  args = [
    "--output",
    rebase_path(toolchain_manifest),
    "--prefix=$clang_prefix",
    "--target=$clang_target",
    "libc++.so.2",
    "libc++abi.so.1",
    "libunwind.so.1",
    "asan/libc++.so.2",
    "asan/libc++abi.so.1",
    "asan/libunwind.so.1",
    "libclang_rt.asan-${clang_cpu}.so",
    "libclang_rt.ubsan_standalone-${clang_cpu}.so",
  ]
}

# Permit dependencies on testonly targets from packages.
testonly = true

group("default") {
  deps = [
    ":mkbootfs",
  ]
}

zircon_out_dir = "//out/build-zircon/build-${zircon_project}"
zircon_boot_manifest = "${zircon_out_dir}/bootfs.manifest"
zircon_ulib_manifest = "${zircon_out_dir}-ulib/bootfs.manifest"

final_boot_manifest = "$root_out_dir/boot.manifest"
final_system_manifest = "$root_out_dir/system.manifest"

action("finalize_manifests") {
  visibility = [ ":*" ]

  packages_file = "$target_gen_dir/packages"
  boot_manifest_file = "$target_gen_dir/boot.bootfs.manifest"
  system_manifest_file = "$target_gen_dir/system.bootfs.manifest"
  build_id_file = "$root_out_dir/ids.txt"

  deps = exec_script("process_modules.py",
                     [
                       "--packages",
                       rebase_path(packages_file),
                       "--boot-manifest",
                       rebase_path(boot_manifest_file),
                       "--system-manifest",
                       rebase_path(system_manifest_file),
                       "--modules",
                       fuchsia_packages,
                       "--build-root",
                       rebase_path(root_build_dir),
                       "--arch",
                       target_cpu,
                     ],
                     "list lines",
                     rebase_path(packages_imported))
  package_list = read_file(packages_file, "list lines")

  script = "finalize_manifests.py"
  inputs = [
    "elfinfo.py",
    "manifest.py",
    "variant.py",
  ]

  depfile = "$root_out_dir/finalize_manifests.d"
  outputs = [
    final_boot_manifest,
    final_system_manifest,
    build_id_file,
  ]

  sources = []
  args = [
    "--depfile=" + rebase_path(depfile, root_build_dir),
    "--build-id-file=" + rebase_path(build_id_file, root_build_dir),
  ]

  # First the toolchain and Zircon "ulib" manifests are pure auxiliaries:
  # they just supply libraries that might satisfy dependencies.

  # TODO(TO-471): Remove this dep when toolchain_manifest is in the source tree.
  deps += [ ":generate_toolchain_manifest" ]
  sources += [ toolchain_manifest ]
  toolchain_manifest_cwd = get_path_info(rebase_path(toolchain_manifest), "dir")
  args += [
    "--cwd=$toolchain_manifest_cwd",
    "--manifest=" + rebase_path(toolchain_manifest),
  ]

  sources += [ zircon_ulib_manifest ]
  zircon_manifest_cwd = rebase_path("//out/build-zircon")
  args += [
    "--cwd=$zircon_manifest_cwd",
    "--manifest=" + rebase_path(zircon_ulib_manifest),
  ]

  # Next, everything that will go into the final /boot manifest.
  args += [ "--output=" + rebase_path(final_boot_manifest, root_build_dir) ]

  sources += [ zircon_boot_manifest ]
  args += [
    "--cwd=$zircon_manifest_cwd",
    "--groups=$zircon_boot_groups",
    "--manifest=" + rebase_path(zircon_boot_manifest),

    # All the manifests generated by this build are relative to root_build_dir.
    "--cwd=.",
    "--groups=all",
  ]

  # TODO(mcgrathr,jamesr): When process_modules.py drops support for
  # package JSON files adding files directly, this can go away.
  # GN won't let us make it a source because it's in the build directory
  # but is written implicitly at gen time rather than by a proper action.
  # We're relying on the depfile to notice its changes.
  #sources += [ boot_manifest_file ]
  args += [ "--manifest=" + rebase_path(boot_manifest_file) ]

  foreach(package, package_list) {
    package_manifest = "$root_build_dir/package/$package/boot_manifest"

    # GN won't let us make these sources because they're in the build
    # directory but written implicitly at gen time rather than by a proper
    # action.  We're relying on the depfile to notice their changes.
    #sources += [ package_manifest ]

    args += [ "--optional-manifest=" + rebase_path(package_manifest) ]
  }

  # Finally, everything that will go into the final /system manifest.
  args += [
    "--output=" + rebase_path(final_system_manifest, root_build_dir),
    "--cwd=$zircon_manifest_cwd",
    "--groups=$zircon_system_groups",
    "--manifest=" + rebase_path(zircon_boot_manifest),

    # All the manifests generated by this build are relative to root_build_dir.
    "--cwd=.",
    "--groups=all",
  ]

  if (autorun != "") {
    autorun_manifest = "$target_gen_dir/autorun.manifest"
    write_file(autorun_manifest, [ "autorun=$autorun" ])
    sources += [ autorun_manifest ]
    args += [ "--manifest=" + rebase_path(autorun_manifest) ]
  }

  # TODO(mcgrathr,jamesr): When process_modules.py drops support for
  # package JSON files adding files directly, this can go away.
  # GN won't let us make it a source because it's in the build directory
  # but is written implicitly at gen time rather than by a proper action.
  # We're relying on the depfile to notice its changes.
  #sources += [ system_manifest_file ]
  args += [ "--manifest=" + rebase_path(system_manifest_file) ]

  foreach(package, package_list) {
    package_manifest = "$root_build_dir/package/$package/system_manifest"

    # GN won't let us make these sources because they're in the build
    # directory but written implicitly at gen time rather than by a proper
    # action.  We're relying on the depfile to notice their changes.
    #sources += [ package_manifest ]

    args += [ "--optional-manifest=" + rebase_path(package_manifest) ]
  }
}

# Package up the /boot filesystem along with Zircon's additional bootdata.
# This `boot_bootfs.bin` along with the Zircon kernel is enough to boot.
bootdata("boot_bootfs") {
  deps = [
    ":finalize_manifests",
  ]
  inputs = [
    final_boot_manifest,
  ]
  boot = true

  foreach(item, zircon_additional_bootdata) {
    inputs += [ "$zircon_out_dir/$item" ]
  }
}

# Package up the /system filesystem.
bootdata("system_bootfs") {
  deps = [
    ":finalize_manifests",
  ]
  inputs = [
    final_system_manifest,
  ]
}

# Roll those together into the image for booting with /system from RAM disk.
bootdata("mkbootfs") {
  output_name = "user"
  output_extension = "bootfs"

  deps = [
    ":boot_bootfs",
    ":system_bootfs",
  ]
  inputs = []
  foreach(label, deps) {
    inputs += get_target_outputs(label)
  }

  deps += extra_bootdata
  foreach(label, extra_bootdata) {
    # get_target_outputs only works on labels defined in the same file.
    # So just assume each `bootdata` target used the defaults so its
    # output file is computable directly from the target name.
    inputs += [ "$root_out_dir/" + get_label_info(label, "name") + ".bin" ]
  }
}

# Copyright 2017 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

declare_args() {
  # List of packages (a GN list of strings).  If unset, guessed based
  # on which layer is found in the //.jiri_manifest file.
  fuchsia_packages = []

  # List of extra packages to synthesize on the fly.  This is only for
  # things that do not appear normally in the source tree.  Synthesized
  # packages can contain build artifacts only if they already exist in some
  # part of the build.  They can contain arbitrary verbatim files.
  # Synthesized packages can't express dependencies on other packages.
  #
  # Each element of this list is a scope that is very much like the body of
  # a package() template invocation (see //build/package.gni).  That scope
  # must set `name` to the string naming the package, as would be the name
  # in the package() target written in a GN file.  This must be unique
  # among all package names.
  synthesize_packages = []
}

if (fuchsia_packages == []) {
  _jiri_manifest = "//.jiri_manifest"
  foreach(layer,
          exec_script("//build/gn/guess_layer.py",
                      [ rebase_path(_jiri_manifest) ],
                      "list lines",
                      [ _jiri_manifest ])) {
    fuchsia_packages += [ "$layer/packages/default" ]
  }
}

# Resolve all the `fuchsia_packages` JSON files and their imports
# into the two lists of GN labels, below.
_preprocessed_packages = exec_script("prepreprocess_build_packages.py",
                                     [
                                       # A list of strings in GN syntax is
                                       # valid JSON too.
                                       "--packages=$fuchsia_packages",
                                     ],
                                     "json")

# Tell GN that the files preprocess_build_packages.py ran are inputs to the
# generation step, by declaring them as file inputs to a (silly) exec_script
# invocation.
exec_script("/bin/sh", ["-c", ":"], "", _preprocessed_packages.files_read)

# Every GN package() target included in the build.  The image-building
# steps iterate over this to aggregate all the internal targets defined by
# the package() template.
package_targets = []
foreach(pkg, _preprocessed_packages.targets) {
  # Expand the label to its full name.
  package_targets += [ get_label_info(pkg, "label_no_toolchain") ]
}

# Every extra GN target the package JSON requests be built on the side.
# This is for things like install_host_tools() targets whose output should
# be on hand for a developer to use in conjuction with a Fuchsia package.
package_data_deps = []
foreach(pkg, _preprocessed_packages.data_deps) {
  # Expand the label to its full name.
  package_data_deps += [ get_label_info(pkg, "label_no_toolchain") ]
}

# Labels of test() targets to be copied into $root_build_dir/host_tests.
package_host_tests = []
foreach(label, _preprocessed_packages.host_tests) {
  # Expand the label to its full name.
  package_host_tests += [ get_label_info(label, "label_no_toolchain") ]
}

# Synthesized packages are instantiated in //build/gn/BUILD.gn,
# so the package() target is //build/gn:package_name.
foreach(pkg, synthesize_packages) {
  pkg = "//build/gn:${pkg.name}"
  package_targets += [ get_label_info(pkg, "label_no_toolchain") ]
}

// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"


namespace test {
namespace name {

class Interface;
using InterfacePtr = ::fidl::InterfacePtr<Interface>;
class Interface_Proxy;
class Interface_Stub;
class Interface_EventSender;
class Interface_Sync;
using InterfaceSyncPtr = ::fidl::SynchronousInterfacePtr<Interface>;
class Interface_SyncProxy;
class Struct;
class Union;
class Table;

// interface comment #1
//
// interface comment #3
class Interface {
 public:
  using Proxy_ = Interface_Proxy;
  using Stub_ = Interface_Stub;
  using EventSender_ = Interface_EventSender;
  using Sync_ = Interface_Sync;
  virtual ~Interface();
  
  // method comment #1
  //
  // method comment #3
  virtual void Method() = 0;
};

class Interface_EventSender {
 public:
  virtual ~Interface_EventSender();
};

class Interface_Sync {
 public:
  using Proxy_ = Interface_SyncProxy;
  virtual ~Interface_Sync();
  virtual zx_status_t Method() = 0;
};

class Interface_Proxy : public ::fidl::internal::Proxy, public Interface {
 public:
  explicit Interface_Proxy(::fidl::internal::ProxyController* controller);
  ~Interface_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void Method() override;

 private:
  Interface_Proxy(const Interface_Proxy&) = delete;
  Interface_Proxy& operator=(const Interface_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class Interface_Stub : public ::fidl::internal::Stub, public Interface_EventSender {
 public:
  typedef class Interface Interface_clazz;
  explicit Interface_Stub(Interface_clazz* impl);
  ~Interface_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  Interface_clazz* impl_;
};

class Interface_SyncProxy : public Interface_Sync {
 public:
  explicit Interface_SyncProxy(::zx::channel channel);
  ~Interface_SyncProxy() override;

  ::fidl::internal::SynchronousProxy& proxy() { return proxy_; }
  zx_status_t Method() override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
};

// struct comment #1
//
// struct comment #3
class Struct  {
 public:
  static const fidl_type_t* FidlType;
  
  // struct member comment #1
  //
  // struct member comment #3
  int32_t Field{};

  static inline ::std::unique_ptr<Struct> New() { return ::std::make_unique<Struct>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset);
  static void Decode(::fidl::Decoder* decoder, Struct* value, size_t offset);
  zx_status_t Clone(Struct* result) const;
};

bool operator==(const Struct& lhs, const Struct& rhs);
inline bool operator!=(const Struct& lhs, const Struct& rhs) {
  return !(lhs == rhs);
}

inline zx_status_t Clone(const ::test::name::Struct& value,
                         ::test::name::Struct* result) {
  return value.Clone(result);
}

using StructPtr = ::std::unique_ptr<Struct>;

// union comment #1
//
// union comment #3
class Union {
 public:
  Union();
  ~Union();

  Union(Union&&);
  Union& operator=(Union&&);

  enum class Tag : fidl_union_tag_t {
    kField = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<Union> New() { return ::std::make_unique<Union>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset);
  static void Decode(::fidl::Decoder* decoder, Union* value, size_t offset);
  zx_status_t Clone(Union* result) const;

  bool has_invalid_tag() const { return tag_ == ::std::numeric_limits<::fidl_union_tag_t>::max(); }

  bool is_Field() const { return tag_ == 0; }
  
  // union member comment #1
  //
  // union member comment #3
  int32_t& Field() { return Field_; }
  
  // union member comment #1
  //
  // union member comment #3
  const int32_t& Field() const { return Field_; }
  void set_Field(int32_t value);

  Tag Which() const { return Tag(tag_); }

 private:
  friend bool operator==(const Union& lhs, const Union& rhs);
  void Destroy();

  ::fidl_union_tag_t tag_;
  union {
    int32_t Field_;
  };
};

bool operator==(const Union& lhs, const Union& rhs);
inline bool operator!=(const Union& lhs, const Union& rhs) {
  return !(lhs == rhs);
}

inline zx_status_t Clone(const ::test::name::Union& value,
                         ::test::name::Union* result) {
  return value.Clone(result);
}

using UnionPtr = ::std::unique_ptr<Union>;

// table comment #1
//
// table comment #3
class Table  {
 public:
  static const fidl_type_t* FidlType;
  
  // table field comment #1
  //
  // table field comment #3
  const int32_t* Field() const {
    return has_Field_ ? &Field_.value : nullptr;
  }
  bool has_Field() const {
    return has_Field_;
  }
  
  // table field comment #1
  //
  // table field comment #3
  int32_t* mutable_Field() {
    if (!has_Field_) {
      has_Field_ = true;
      Construct(&Field_.value);
    }
    return &Field_.value;
  }
  void set_Field(int32_t value) {
    if (!has_Field_) {
      has_Field_ = true;
      Construct(&Field_.value, std::move(value));
    } else {
      Field_.value = std::move(value);
    }
  }
  void clear_Field() {
    if (!has_Field_) {
      return;
    }
    has_Field_ = false;
    Destruct(&Field_.value);
  }

  Table();
  Table(Table&& other);
  ~Table();
  Table& operator=(Table&& other);

  static inline ::std::unique_ptr<Table> New() { return ::std::make_unique<Table>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset);
  static void Decode(::fidl::Decoder* decoder, Table* value, size_t offset);
  zx_status_t Clone(Table* result) const;

 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }
  bool has_Field_ : 1;
  union ValueUnion_Field {
    ValueUnion_Field() {}
    ~ValueUnion_Field() {}

    int32_t value;
  };
  ValueUnion_Field Field_;
};

bool operator==(const Table& lhs, const Table& rhs);
inline bool operator!=(const Table& lhs, const Table& rhs) {
  return !(lhs == rhs);
}

using TablePtr = ::std::unique_ptr<Table>;

// const comment #1
//
// const comment #3
constexpr int32_t C = 4;
}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::Struct>
    : public EncodableCodingTraits<::test::name::Struct, 4> {};

inline zx_status_t Clone(const ::test::name::Struct& value,
                         ::test::name::Struct* result) {
  return ::test::name::Clone(value, result);
}
template <>
struct CodingTraits<::test::name::Union>
    : public EncodableCodingTraits<::test::name::Union, 8> {};

inline zx_status_t Clone(const ::test::name::Union& value,
                         ::test::name::Union* result) {
  return ::test::name::Clone(value, result);
}
template <>
struct CodingTraits<::test::name::Table>
    : public EncodableCodingTraits<::test::name::Table, 16> {};

inline zx_status_t Clone(const ::test::name::Table& value,
                         ::test::name::Table* result) {
  return value.Clone(result);
}}  // namespace fidl

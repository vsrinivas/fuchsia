// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array_wrapper.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>

#include <zircon/fidl.h>

namespace test {
namespace name {

class Interface;
struct Struct;
struct Union;

// interface comment #1
//
// interface comment #3
class Interface {
 public:
  Interface();
  virtual ~Interface();

  // method comment #1
  //
  // method comment #3
  zx_status_t Method();

};

extern "C" const fidl_type_t test_name_StructTable;

// struct comment #1
//
// struct comment #3
struct Struct {
  static constexpr const fidl_type_t* Type = &test_name_StructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // struct member comment #1
  //
  // struct member comment #3
  int32_t Field{};
};

extern "C" const fidl_type_t test_name_UnionTable;

// union comment #1
//
// union comment #3
struct Union {
  enum class Tag : fidl_union_tag_t {
    kField = 0,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_Field() const { return tag_ == Tag::kField; }

  // union member comment #1
  //
  // union member comment #3
  int32_t& mutable_Field() {
    tag_ = Tag::kField;
    return Field_;
  }

  // union member comment #1
  //
  // union member comment #3
  const int32_t& Field() const { return Field_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &test_name_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    int32_t Field_;
  };
};

// const comment #1
//
// const comment #3
constexpr int32_t C = 4;

}  // namespace name
}  // namespace test

namespace fidl {

template <>
struct IsFidlType<::test::name::Struct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test::name::Struct>);
static_assert(offsetof(::test::name::Struct, Field) == 0);
static_assert(sizeof(::test::name::Struct) == ::test::name::Struct::PrimarySize);

static_assert(std::is_standard_layout_v<::test::name::Union>);

}  // namespace fidl

// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

success("SingleHandle") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(),
    },
    value = SingleHandle {
        h: #0,
    },
    bytes = {
        v1 = [
            repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0,
        ],
    }
}

success("SingleOptionalHandlePresent") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(),
    },
    value = SingleOptionalHandle {
        h: #0,
    },
    bytes = {
        v1 = [
            repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0,
        ],
    }
}

success("SingleOptionalHandleAbsent") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    value = SingleOptionalHandle {},
    bytes = {
        v1 = [
            repeat(0x00):4, padding:4,
        ],
    }
}

success("ArrayOfHandles") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(),
        #1 = event(),
        #2 = event(),
    },
    value = ArrayOfHandles {
        a: [#2, #0, #1],
    },
    bytes = {
        v1 = [
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #2, #0, #1,
        ],
    }
}

success("ArrayOfOptionalHandles") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(),
    },
    value = ArrayOfOptionalHandles {
        a: [null, #0, null],
    },
    bytes = {
        v1 = [
            repeat(0x00):4, repeat(0xff):4, repeat(0x00):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0,
        ],
    }
}

success("VectorOfHandles") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(),
        #1 = event(),
        #2 = event(),
    },
    value = VectorOfHandles {
        v: [#2, #0, #1],
    },
    bytes = {
        v1 = [
            num(3):8, repeat(0xff):8,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #2, #0, #1,
        ],
    }
}

success("VectorOfOptionalHandles") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [go,rust],
    handle_defs = {
        #0 = event(),
    },
    value = VectorOfOptionalHandles {
        v: [null, #0, null],
    },
    bytes = {
        v1 = [
            num(3):8, repeat(0xff):8,
            repeat(0x00):4, repeat(0xff):4, repeat(0x00):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0,
        ],
    }
}

success("MultipleHandleSubtypes") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = channel(),
        #1 = event(),
        #2 = channel(),
    },
    value = MultipleHandleSubtypes {
        untyped: #0,
        event: #1,
        channel: #2,
    },
    bytes = {
        v1 = [
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0, #1, #2,
        ],
    }
}

decode_failure("TooManyHandles") {
    // TODO(fxbug.dev/36441): Implement handles in all backends.
    // TODO(fxbug.dev/58385): Close handles on encode/decode failure in Dart, Rust.
    bindings_allowlist = [],
    handle_defs = {
        #0 = event(),
        #1 = event(),
    },
    type = SingleHandle,
    bytes = {
        v1 = [
            repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0, #1,
        ],
    },
    err = EXTRA_HANDLES,
}

// TODO(fxbug.dev/59449): Check for extra handles in Dart so that this fails.
decode_success("TooManyHandlesSuccess") {
    bindings_allowlist = [dart],
    handle_defs = {
        #0 = event(),
        #1 = event(),
    },
    value = SingleHandle {
        h: #0,
    },
    bytes = {
        v1 = [
            repeat(0xff):4, padding:4,
        ],
    },
    handles = {
        v1 = [
            #0, #1,
        ],
    }
}

decode_failure("TooFewHandles") {
    // TODO(fxbug.dev/58385): Close handles on encode/decode failure in Rust.
    bindings_allowlist = [go,dart],
    type = SingleHandle,
    bytes = {
        v1 = [
            repeat(0xff):4, padding:4,
        ],
    },
    err = TOO_FEW_HANDLES,
}

// Currently channels max out at 64-handles.
success("ChannelMaxHandles") {
    // TODO(fxb.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(), #1 = event(), #2 = event(), #3 = event(),
        #4 = event(), #5 = event(), #6 = event(), #7 = event(),
        #8 = event(), #9 = event(), #10 = event(), #11 = event(),
        #12 = event(), #13 = event(), #14 = event(), #15 = event(),
        #16 = event(), #17 = event(), #18 = event(), #19 = event(),
        #20 = event(), #21 = event(), #22 = event(), #23 = event(),
        #24 = event(), #25 = event(), #26 = event(), #27 = event(),
        #28 = event(), #29 = event(), #30 = event(), #31 = event(),
        #32 = event(), #33 = event(), #34 = event(), #35 = event(),
        #36 = event(), #37 = event(), #38 = event(), #39 = event(),
        #40 = event(), #41 = event(), #42 = event(), #43 = event(),
        #44 = event(), #45 = event(), #46 = event(), #47 = event(),
        #48 = event(), #49 = event(), #50 = event(), #51 = event(),
        #52 = event(), #53 = event(), #54 = event(), #55 = event(),
        #56 = event(), #57 = event(), #58 = event(), #59 = event(),
        #60 = event(), #61 = event(), #62 = event(), #63 = event(),
    },
    value = VectorOfHandles {
        v: [
            #0, #1, #2, #3, #4, #5, #6, #7,
            #8, #9, #10, #11, #12, #13, #14, #15,
            #16, #17, #18, #19, #20, #21, #22, #23,
            #24, #25, #26, #27, #28, #29, #30, #31,
            #32, #33, #34, #35, #36, #37, #38, #39,
            #40, #41, #42, #43, #44, #45, #46, #47,
            #48, #49, #50, #51, #52, #53, #54, #55,
            #56, #57, #58, #59, #60, #61, #62, #63,
        ],
    },
    bytes = {
        v1 = [
            num(64):8, repeat(0xff):8,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
            repeat(0xff):4, repeat(0xff):4, repeat(0xff):4, repeat(0xff):4,
        ],
    },
    handles = {
        v1 = [
            #0, #1, #2, #3, #4, #5, #6, #7,
            #8, #9, #10, #11, #12, #13, #14, #15,
            #16, #17, #18, #19, #20, #21, #22, #23,
            #24, #25, #26, #27, #28, #29, #30, #31,
            #32, #33, #34, #35, #36, #37, #38, #39,
            #40, #41, #42, #43, #44, #45, #46, #47,
            #48, #49, #50, #51, #52, #53, #54, #55,
            #56, #57, #58, #59, #60, #61, #62, #63,
        ],
    }
}

// There should be support for at least 64 handles in unknown fields.
decode_success("ChannelMaxUnknownHandles") {
    // TODO(fxb.dev/36441): Implement handles in all backends.
    bindings_allowlist = [dart,go,rust],
    handle_defs = {
        #0 = event(), #1 = event(), #2 = event(), #3 = event(),
        #4 = event(), #5 = event(), #6 = event(), #7 = event(),
        #8 = event(), #9 = event(), #10 = event(), #11 = event(),
        #12 = event(), #13 = event(), #14 = event(), #15 = event(),
        #16 = event(), #17 = event(), #18 = event(), #19 = event(),
        #20 = event(), #21 = event(), #22 = event(), #23 = event(),
        #24 = event(), #25 = event(), #26 = event(), #27 = event(),
        #28 = event(), #29 = event(), #30 = event(), #31 = event(),
        #32 = event(), #33 = event(), #34 = event(), #35 = event(),
        #36 = event(), #37 = event(), #38 = event(), #39 = event(),
        #40 = event(), #41 = event(), #42 = event(), #43 = event(),
        #44 = event(), #45 = event(), #46 = event(), #47 = event(),
        #48 = event(), #49 = event(), #50 = event(), #51 = event(),
        #52 = event(), #53 = event(), #54 = event(), #55 = event(),
        #56 = event(), #57 = event(), #58 = event(), #59 = event(),
        #60 = event(), #61 = event(), #62 = event(), #63 = event(),
    },
    value = ReservedFieldTableStruct {
        table: ReservedFieldTable{},
    },
    bytes = {
        v1 = [
            num(1):8, repeat(0xff):8, // Table header
            num(0):4, num(64):4, repeat(0xff):8, // Reserved envelope
        ],
    },
    handles = {
        v1 = [
            #0, #1, #2, #3, #4, #5, #6, #7,
            #8, #9, #10, #11, #12, #13, #14, #15,
            #16, #17, #18, #19, #20, #21, #22, #23,
            #24, #25, #26, #27, #28, #29, #30, #31,
            #32, #33, #34, #35, #36, #37, #38, #39,
            #40, #41, #42, #43, #44, #45, #46, #47,
            #48, #49, #50, #51, #52, #53, #54, #55,
            #56, #57, #58, #59, #60, #61, #62, #63,
        ],
    }
}

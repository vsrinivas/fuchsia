// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fidl.test.dartbindingstest;

using zx;

type HandleStruct = resource struct {
    foo string;
    bar int32;
    baz zx.handle;
};

type NoHandleStruct = struct {
    foo string;
    bar int32;
    baz vector<uint8>;
};

type NumberHandleNumber = resource struct {
    n1 uint32;
    h zx.handle;
    n2 uint32;
};

type ExampleStruct = struct {
    foo string;
    bar int32;
    baz vector<uint8>:optional;
};

type ExampleTable = table {
    1: foo string;
    2: bar int32;
    3: baz vector<uint8>;
};

type ExampleXunion = flexible resource union {
    1: foo string;
    2: bar int32;
    3: baz vector<uint8>;
    4: with_handle NumberHandleNumber;
};

type ExampleStrictXunion = strict resource union {
    1: foo string;
    2: bar int32;
    3: baz vector<uint8>;
    4: with_handle NumberHandleNumber;
};

type ExampleBits = strict bits {
    MEMBER_A = 2;
    MEMBER_B = 4;
    MEMBER_C = 8;
};

type FlexibleBits = flexible bits {
    ONE = 0b01;
    TWO = 0b10;
};

@discoverable
closed protocol TestServer {
    strict OneWayNoArgs();
    strict ReceivedOneWayNoArgs() -> (struct {
        received bool;
    });

    strict OneWayStringArg(struct {
        value string;
    });
    strict ReceivedOneWayString() -> (struct {
        value string;
    });

    strict OneWayThreeArgs(struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    });
    strict ReceivedOneWayThreeArgs() -> (struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    });

    strict OneWayExampleTable(struct {
        value ExampleTable;
    });
    strict ReceivedOneWayExampleTable() -> (struct {
        received ExampleTable;
    });

    strict TwoWayNoArgs() -> ();
    strict TwoWayStringArg(struct {
        value string;
    }) -> (struct {
        value string;
    });
    strict TwoWayThreeArgs(struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    }) -> (struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    });
    strict TwoWayOneHandleArg(resource struct {
        h1 HandleStruct;
    }) -> (resource struct {
        h1 HandleStruct;
    });
    strict TwoWayTwoHandleArgs(resource struct {
        h1 HandleStruct;
        h2 HandleStruct;
    }) -> (resource struct {
        h1 HandleStruct;
        h2 HandleStruct;
    });

    strict OneWayExampleXunion(resource struct {
        value ExampleXunion;
    });
    strict ReceivedOneWayExampleXunion() -> (resource struct {
        received ExampleXunion;
    });

    strict OneWayExampleBits(struct {
        value ExampleBits;
    });
    strict ReceivedOneWayExampleBits() -> (struct {
        received ExampleBits;
    });

    strict SendEmptyEvent();
    strict -> EmptyEvent();

    strict SendStringEvent(struct {
        value string;
    });
    strict -> StringEvent(struct {
        value string;
    });

    strict SendThreeArgEvent(struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    });
    strict -> ThreeArgEvent(struct {
        x int32;
        y uint64;
        z NoHandleStruct;
    });

    strict SendMultipleEvents(struct {
        count int32;
        intervalSeconds float64;
    });
    strict -> MultipleEvent(struct {
        index int32;
    });

    strict ReplySlowly(struct {
        value string;
        delaySeconds float64;
    }) -> (struct {
        value string;
    });

    strict ReplyWithErrorZero(struct {
        with_error bool;
    }) -> (struct {}) error uint32;
    strict ReplyWithErrorOne(struct {
        with_error bool;
        value string;
    }) -> (struct {
        value string;
    }) error uint32;
    strict ReplyWithErrorMore(struct {
        with_error bool;
        value string;
        other_value bool;
    }) -> (struct {
        value string;
        other_value bool;
    }) error uint32;

    strict ReplyWithErrorEnumZero(struct {
        with_error bool;
    }) -> (struct {}) error EnumOne;
    strict ReplyWithErrorEnumOne(struct {
        with_error bool;
        value string;
    }) -> (struct {
        value string;
    }) error EnumOne;
    strict ReplyWithErrorEnumMore(struct {
        with_error bool;
        value string;
        other_value bool;
    }) -> (struct {
        value string;
        other_value bool;
    }) error EnumOne;

    strict CloseConnection(struct {
        delaySeconds float64;
    });
    strict CloseConnectionWithEpitaph(struct {
        status int32;
        delaySeconds float64;
    });

    strict -> NeverEvent();

    strict SendEvent(resource struct {
        h zx.handle:EVENT;
    });
    strict EchoChannelAsEvent(resource struct {
        h zx.handle:CHANNEL;
    }) -> (resource struct {
        h zx.handle:EVENT;
    });
    strict EventEvent(resource struct {
        h zx.handle:EVENT;
    });

    strict SendErrorEvent(strict union {
        1: result string;
        2: err int32;
    });
    strict -> ErrorEvent(struct {
        result string;
    }) error int32;
};

closed protocol HandleRightsTestServer {
    strict SendEvent(resource struct {
        h zx.handle:EVENT;
    });
    strict SendChannel(resource struct {
        h zx.handle:CHANNEL;
    });
};

type EnumOne = strict enum {
    ONE = 1;
    TWO = 2;
    THREE = 3;
};

type EnumTwo = strict enum {
    ONE = 1;
    TWO = 2;
    THREE = 3;
};

type FlexibleEnumThree = flexible enum : uint64 {
    ONE = 1;
    TWO = 2;
    THREE = 3;
};

type FlexibleEnumFour = flexible enum : int32 {
    ONE = 1;
    TWO = 2;
    THREE = 3;
    @unknown
    CUSTOM_UNKNOWN = -123;
};

type EmptyFlexibleEnum = flexible enum : int32 {};

type UnionOne = strict union {
    1: foo string;
    2: bar string;
    3: baz uint32;
};

type UnionTwo = strict union {
    1: foo string;
    2: bar string;
    3: baz uint32;
};

closed protocol SimpleServer {
    strict Ping() -> ();
};

type ChannelWithDefaultRights = resource struct {
    c zx.handle:<CHANNEL, zx.DEFAULT_CHANNEL_RIGHTS>;
};

type ChannelWithReducedRights = resource struct {
    c zx.handle:<CHANNEL, zx.rights.TRANSFER>;
};

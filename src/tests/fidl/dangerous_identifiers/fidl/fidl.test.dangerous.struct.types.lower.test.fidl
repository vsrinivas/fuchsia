// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.lower;
using membertype = uint32;

struct abstract {
    membertype member = 1;
};

struct alignas {
    membertype member = 1;
};

struct alignof {
    membertype member = 1;
};

struct and {
    membertype member = 1;
};

struct and_eq {
    membertype member = 1;
};

struct as {
    membertype member = 1;
};

struct asm {
    membertype member = 1;
};

struct assert {
    membertype member = 1;
};

struct async {
    membertype member = 1;
};

struct atomic_cancel {
    membertype member = 1;
};

struct atomic_commit {
    membertype member = 1;
};

struct atomic_noexcept {
    membertype member = 1;
};

struct auto {
    membertype member = 1;
};

struct await {
    membertype member = 1;
};

struct become {
    membertype member = 1;
};

struct bitand {
    membertype member = 1;
};

struct bitor {
    membertype member = 1;
};

struct bool {
    membertype member = 1;
};

struct box {
    membertype member = 1;
};

struct break {
    membertype member = 1;
};

struct byte {
    membertype member = 1;
};

struct bytes {
    membertype member = 1;
};

struct case {
    membertype member = 1;
};

struct catch {
    membertype member = 1;
};

struct chan {
    membertype member = 1;
};

struct char {
    membertype member = 1;
};

struct char16_t {
    membertype member = 1;
};

struct char32_t {
    membertype member = 1;
};

struct class {
    membertype member = 1;
};

struct co_await {
    membertype member = 1;
};

struct co_return {
    membertype member = 1;
};

struct co_yield {
    membertype member = 1;
};

struct coding_traits {
    membertype member = 1;
};

struct compl {
    membertype member = 1;
};

struct concept {
    membertype member = 1;
};

struct const {
    membertype member = 1;
};

struct const_cast {
    membertype member = 1;
};

struct constexpr {
    membertype member = 1;
};

struct continue {
    membertype member = 1;
};

struct controller {
    membertype member = 1;
};

struct covariant {
    membertype member = 1;
};

struct crate {
    membertype member = 1;
};

struct decltype {
    membertype member = 1;
};

struct decoder {
    membertype member = 1;
};

struct default {
    membertype member = 1;
};

struct defer {
    membertype member = 1;
};

struct deferred {
    membertype member = 1;
};

struct delete {
    membertype member = 1;
};

struct do {
    membertype member = 1;
};

struct double {
    membertype member = 1;
};

struct dynamic {
    membertype member = 1;
};

struct dynamic_cast {
    membertype member = 1;
};

struct else {
    membertype member = 1;
};

struct encoder {
    membertype member = 1;
};

struct ensure_values_instantiated {
    membertype member = 1;
};

struct enum {
    membertype member = 1;
};

struct empty {
    membertype member = 1;
};

struct err {
    membertype member = 1;
};

struct explicit {
    membertype member = 1;
};

struct export {
    membertype member = 1;
};

struct extends {
    membertype member = 1;
};

struct extern {
    membertype member = 1;
};

struct external {
    membertype member = 1;
};

struct factory {
    membertype member = 1;
};

struct fallthrough {
    membertype member = 1;
};

struct false {
    membertype member = 1;
};

struct fidl {
    membertype member = 1;
};

struct fidl_type {
    membertype member = 1;
};

struct final {
    membertype member = 1;
};

struct finally {
    membertype member = 1;
};

struct float {
    membertype member = 1;
};

struct fn {
    membertype member = 1;
};

struct for {
    membertype member = 1;
};

struct friend {
    membertype member = 1;
};

struct func {
    membertype member = 1;
};

struct future {
    membertype member = 1;
};

struct futures {
    membertype member = 1;
};

struct get {
    membertype member = 1;
};

struct go {
    membertype member = 1;
};

struct goto {
    membertype member = 1;
};

struct has_invalid_tag {
    membertype member = 1;
};

struct hash_code {
    membertype member = 1;
};

struct if {
    membertype member = 1;
};

struct impl {
    membertype member = 1;
};

struct implements {
    membertype member = 1;
};

struct import {
    membertype member = 1;
};

struct in {
    membertype member = 1;
};

struct index {
    membertype member = 1;
};

struct inline {
    membertype member = 1;
};

struct int {
    membertype member = 1;
};

struct int16 {
    membertype member = 1;
};

struct int32 {
    membertype member = 1;
};

struct int64 {
    membertype member = 1;
};

struct int8 {
    membertype member = 1;
};

struct interface {
    membertype member = 1;
};

struct internal_tag {
    membertype member = 1;
};

struct is {
    membertype member = 1;
};

struct let {
    membertype member = 1;
};

struct lhs {
    membertype member = 1;
};

struct library {
    membertype member = 1;
};

struct list {
    membertype member = 1;
};

struct long {
    membertype member = 1;
};

struct loop {
    membertype member = 1;
};

struct macro {
    membertype member = 1;
};

struct map {
    membertype member = 1;
};

struct match {
    membertype member = 1;
};

struct mixin {
    membertype member = 1;
};

struct mod {
    membertype member = 1;
};

struct module {
    membertype member = 1;
};

struct move {
    membertype member = 1;
};

struct mut {
    membertype member = 1;
};

struct mutable {
    membertype member = 1;
};

struct namespace {
    membertype member = 1;
};

struct never {
    membertype member = 1;
};

struct new {
    membertype member = 1;
};

struct no_such_method {
    membertype member = 1;
};

struct noexcept {
    membertype member = 1;
};

struct none {
    membertype member = 1;
};

struct not {
    membertype member = 1;
};

struct not_eq {
    membertype member = 1;
};

struct null {
    membertype member = 1;
};

struct nullptr {
    membertype member = 1;
};

struct num {
    membertype member = 1;
};

struct object {
    membertype member = 1;
};

struct offset {
    membertype member = 1;
};

struct offsetof {
    membertype member = 1;
};

struct ok {
    membertype member = 1;
};

struct on_open {
    membertype member = 1;
};

struct operator {
    membertype member = 1;
};

struct option {
    membertype member = 1;
};

struct or {
    membertype member = 1;
};

struct or_eq {
    membertype member = 1;
};

struct override {
    membertype member = 1;
};

struct package {
    membertype member = 1;
};

struct part {
    membertype member = 1;
};

struct priv {
    membertype member = 1;
};

struct private {
    membertype member = 1;
};

struct proc {
    membertype member = 1;
};

struct protected {
    membertype member = 1;
};

struct proxy {
    membertype member = 1;
};

struct pub {
    membertype member = 1;
};

struct public {
    membertype member = 1;
};

struct pure {
    membertype member = 1;
};

struct range {
    membertype member = 1;
};

struct ref {
    membertype member = 1;
};

struct register {
    membertype member = 1;
};

struct reinterpret_cast {
    membertype member = 1;
};

struct requires {
    membertype member = 1;
};

struct result {
    membertype member = 1;
};

struct rethrow {
    membertype member = 1;
};

struct return {
    membertype member = 1;
};

struct rhs {
    membertype member = 1;
};

struct rune {
    membertype member = 1;
};

struct runtime_type {
    membertype member = 1;
};

struct select {
    membertype member = 1;
};

struct self {
    membertype member = 1;
};

struct send {
    membertype member = 1;
};

struct set {
    membertype member = 1;
};

struct set_controller {
    membertype member = 1;
};

struct short {
    membertype member = 1;
};

struct signed {
    membertype member = 1;
};

struct sizeof {
    membertype member = 1;
};

struct some {
    membertype member = 1;
};

struct static {
    membertype member = 1;
};

struct static_assert {
    membertype member = 1;
};

struct static_cast {
    membertype member = 1;
};

struct stream {
    membertype member = 1;
};

struct string {
    membertype member = 1;
};

struct struct {
    membertype member = 1;
};

struct stub {
    membertype member = 1;
};

struct super {
    membertype member = 1;
};

struct switch {
    membertype member = 1;
};

struct synchronized {
    membertype member = 1;
};

struct template {
    membertype member = 1;
};

struct this {
    membertype member = 1;
};

struct thread_local {
    membertype member = 1;
};

struct throw {
    membertype member = 1;
};

struct to_string {
    membertype member = 1;
};

struct trait {
    membertype member = 1;
};

struct true {
    membertype member = 1;
};

struct try {
    membertype member = 1;
};

struct type {
    membertype member = 1;
};

struct typedef {
    membertype member = 1;
};

struct typeid {
    membertype member = 1;
};

struct typename {
    membertype member = 1;
};

struct typeof {
    membertype member = 1;
};

struct uint16 {
    membertype member = 1;
};

struct uint64 {
    membertype member = 1;
};

struct uint8 {
    membertype member = 1;
};

struct union {
    membertype member = 1;
};

struct unknown {
    membertype member = 1;
};

struct unknown_bytes {
    membertype member = 1;
};

[BindingsDenylist = "dart"]
struct unknown_data {
    membertype member = 1;
};

struct unsafe {
    membertype member = 1;
};

struct unsigned {
    membertype member = 1;
};

struct unsized {
    membertype member = 1;
};

struct use {
    membertype member = 1;
};

struct using {
    membertype member = 1;
};

struct value {
    membertype member = 1;
};

struct value_of {
    membertype member = 1;
};

struct value_union {
    membertype member = 1;
};

struct values_map {
    membertype member = 1;
};

struct var {
    membertype member = 1;
};

struct vec {
    membertype member = 1;
};

struct virtual {
    membertype member = 1;
};

struct void {
    membertype member = 1;
};

struct volatile {
    membertype member = 1;
};

struct wchar_t {
    membertype member = 1;
};

struct where {
    membertype member = 1;
};

struct which {
    membertype member = 1;
};

struct while {
    membertype member = 1;
};

struct with {
    membertype member = 1;
};

struct xor {
    membertype member = 1;
};

struct xor_eq {
    membertype member = 1;
};

struct xunion {
    membertype member = 1;
};

struct yield {
    membertype member = 1;
};

struct zx {
    membertype member = 1;
};

struct DangerousMembers {
    abstract f0;
    alignas f1;
    alignof f2;
    and f3;
    and_eq f4;
    as f5;
    asm f6;
    assert f7;
    async f8;
    atomic_cancel f9;
    atomic_commit f10;
    atomic_noexcept f11;
    auto f12;
    await f13;
    become f14;
    bitand f15;
    bitor f16;
    bool f17;
    box f18;
    break f19;
    byte f20;
    bytes f214;
    case f21;
    catch f22;
    chan f23;
    char f24;
    char16_t f25;
    char32_t f26;
    class f27;
    co_await f28;
    co_return f29;
    co_yield f30;
    coding_traits f31;
    compl f32;
    concept f33;
    const f34;
    const_cast f35;
    constexpr f36;
    continue f37;
    controller f38;
    covariant f39;
    crate f40;
    decltype f41;
    decoder f42;
    default f43;
    defer f44;
    deferred f45;
    delete f46;
    do f47;
    double f48;
    dynamic f49;
    dynamic_cast f50;
    else f51;
    encoder f52;
    ensure_values_instantiated f53;
    enum f54;
    empty f55;
    err f56;
    explicit f57;
    export f58;
    extends f59;
    extern f60;
    external f61;
    factory f62;
    fallthrough f63;
    false f64;
    fidl f65;
    fidl_type f66;
    final f67;
    finally f68;
    float f69;
    fn f70;
    for f71;
    friend f72;
    func f73;
    future f74;
    futures f75;
    get f76;
    go f77;
    goto f78;
    has_invalid_tag f79;
    hash_code f80;
    if f81;
    impl f82;
    implements f83;
    import f84;
    in f85;
    index f86;
    inline f87;
    int f88;
    int16 f89;
    int32 f90;
    int64 f91;
    int8 f92;
    interface f93;
    internal_tag f94;
    is f95;
    let f96;
    lhs f97;
    library f98;
    list f99;
    long f100;
    loop f101;
    macro f102;
    map f103;
    match f104;
    mixin f105;
    mod f106;
    module f107;
    move f108;
    mut f109;
    mutable f110;
    namespace f111;
    never f112;
    new f113;
    no_such_method f114;
    noexcept f115;
    none f116;
    not f117;
    not_eq f118;
    null f119;
    nullptr f120;
    num f121;
    object f122;
    offset f123;
    offsetof f124;
    ok f125;
    on_open f126;
    operator f127;
    option f128;
    or f129;
    or_eq f130;
    override f131;
    package f132;
    part f133;
    priv f134;
    private f135;
    proc f136;
    protected f137;
    proxy f138;
    pub f139;
    public f140;
    pure f141;
    range f142;
    ref f143;
    register f144;
    reinterpret_cast f145;
    requires f146;
    result f147;
    rethrow f148;
    return f149;
    rhs f150;
    rune f151;
    runtime_type f152;
    select f153;
    self f154;
    send f155;
    set f156;
    set_controller f157;
    short f158;
    signed f159;
    sizeof f160;
    some f161;
    static f162;
    static_assert f163;
    static_cast f164;
    stream f165;
    string f166;
    struct f167;
    stub f168;
    super f169;
    switch f170;
    synchronized f171;
    template f172;
    this f173;
    thread_local f174;
    throw f175;
    to_string f176;
    trait f177;
    true f178;
    try f179;
    type f180;
    typedef f181;
    typeid f182;
    typename f183;
    typeof f184;
    uint16 f185;
    uint32 f186;
    uint64 f187;
    uint8 f188;
    union f189;
    unknown f215;
    unknown_bytes f216;
    [BindingsDenylist = "dart"]
    unknown_data f217;
    unsafe f190;
    unsigned f191;
    unsized f192;
    use f193;
    using f194;
    value f195;
    value_of f196;
    value_union f197;
    values_map f198;
    var f199;
    vec f200;
    virtual f201;
    void f202;
    volatile f203;
    wchar_t f204;
    where f205;
    which f206;
    while f207;
    with f208;
    xor f209;
    xor_eq f210;
    xunion f211;
    yield f212;
    zx f213;
};

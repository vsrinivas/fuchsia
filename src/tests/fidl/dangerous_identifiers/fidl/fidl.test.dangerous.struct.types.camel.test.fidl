// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.camel;
using membertype = uint32;

struct Abstract {
    membertype member = 1;
};

struct Alignas {
    membertype member = 1;
};

struct Alignof {
    membertype member = 1;
};

struct And {
    membertype member = 1;
};

struct AndEq {
    membertype member = 1;
};

struct As {
    membertype member = 1;
};

struct Asm {
    membertype member = 1;
};

struct Assert {
    membertype member = 1;
};

struct Async {
    membertype member = 1;
};

struct AtomicCancel {
    membertype member = 1;
};

struct AtomicCommit {
    membertype member = 1;
};

struct AtomicNoexcept {
    membertype member = 1;
};

struct Auto {
    membertype member = 1;
};

struct Await {
    membertype member = 1;
};

struct Become {
    membertype member = 1;
};

struct Bitand {
    membertype member = 1;
};

struct Bitor {
    membertype member = 1;
};

struct Bool {
    membertype member = 1;
};

struct Box {
    membertype member = 1;
};

struct Break {
    membertype member = 1;
};

struct Byte {
    membertype member = 1;
};

struct Bytes {
    membertype member = 1;
};

struct Case {
    membertype member = 1;
};

struct Catch {
    membertype member = 1;
};

struct Chan {
    membertype member = 1;
};

struct Char {
    membertype member = 1;
};

struct Char16T {
    membertype member = 1;
};

struct Char32T {
    membertype member = 1;
};

struct Class {
    membertype member = 1;
};

struct CoAwait {
    membertype member = 1;
};

struct CoReturn {
    membertype member = 1;
};

struct CoYield {
    membertype member = 1;
};

struct CodingTraits {
    membertype member = 1;
};

struct Compl {
    membertype member = 1;
};

struct Concept {
    membertype member = 1;
};

struct Const {
    membertype member = 1;
};

struct ConstCast {
    membertype member = 1;
};

struct Constexpr {
    membertype member = 1;
};

struct Continue {
    membertype member = 1;
};

struct Controller {
    membertype member = 1;
};

struct Covariant {
    membertype member = 1;
};

struct Crate {
    membertype member = 1;
};

struct Decltype {
    membertype member = 1;
};

struct Decoder {
    membertype member = 1;
};

struct Default {
    membertype member = 1;
};

struct Defer {
    membertype member = 1;
};

struct Deferred {
    membertype member = 1;
};

struct Delete {
    membertype member = 1;
};

struct Do {
    membertype member = 1;
};

struct Double {
    membertype member = 1;
};

struct Dynamic {
    membertype member = 1;
};

struct DynamicCast {
    membertype member = 1;
};

struct Else {
    membertype member = 1;
};

struct Encoder {
    membertype member = 1;
};

struct EnsureValuesInstantiated {
    membertype member = 1;
};

struct Enum {
    membertype member = 1;
};

struct Empty {
    membertype member = 1;
};

struct Err {
    membertype member = 1;
};

struct Explicit {
    membertype member = 1;
};

struct Export {
    membertype member = 1;
};

struct Extends {
    membertype member = 1;
};

struct Extern {
    membertype member = 1;
};

struct External {
    membertype member = 1;
};

struct Factory {
    membertype member = 1;
};

struct Fallthrough {
    membertype member = 1;
};

struct False {
    membertype member = 1;
};

struct Fidl {
    membertype member = 1;
};

struct FidlType {
    membertype member = 1;
};

struct Final {
    membertype member = 1;
};

struct Finally {
    membertype member = 1;
};

struct Float {
    membertype member = 1;
};

struct Fn {
    membertype member = 1;
};

struct For {
    membertype member = 1;
};

struct Friend {
    membertype member = 1;
};

struct Func {
    membertype member = 1;
};

struct Future {
    membertype member = 1;
};

struct Futures {
    membertype member = 1;
};

struct Get {
    membertype member = 1;
};

struct Go {
    membertype member = 1;
};

struct Goto {
    membertype member = 1;
};

struct HasInvalidTag {
    membertype member = 1;
};

struct HashCode {
    membertype member = 1;
};

struct If {
    membertype member = 1;
};

struct Impl {
    membertype member = 1;
};

struct Implements {
    membertype member = 1;
};

struct Import {
    membertype member = 1;
};

struct In {
    membertype member = 1;
};

struct Index {
    membertype member = 1;
};

struct Inline {
    membertype member = 1;
};

struct Int {
    membertype member = 1;
};

struct Int16 {
    membertype member = 1;
};

struct Int32 {
    membertype member = 1;
};

struct Int64 {
    membertype member = 1;
};

struct Int8 {
    membertype member = 1;
};

struct Interface {
    membertype member = 1;
};

struct InternalTag {
    membertype member = 1;
};

struct Is {
    membertype member = 1;
};

struct Let {
    membertype member = 1;
};

struct Lhs {
    membertype member = 1;
};

struct Library {
    membertype member = 1;
};

struct List {
    membertype member = 1;
};

struct Long {
    membertype member = 1;
};

struct Loop {
    membertype member = 1;
};

struct Macro {
    membertype member = 1;
};

struct Map {
    membertype member = 1;
};

struct Match {
    membertype member = 1;
};

struct Mixin {
    membertype member = 1;
};

struct Mod {
    membertype member = 1;
};

struct Module {
    membertype member = 1;
};

struct Move {
    membertype member = 1;
};

struct Mut {
    membertype member = 1;
};

struct Mutable {
    membertype member = 1;
};

struct Namespace {
    membertype member = 1;
};

struct Never {
    membertype member = 1;
};

struct New {
    membertype member = 1;
};

struct NoSuchMethod {
    membertype member = 1;
};

struct Noexcept {
    membertype member = 1;
};

struct None {
    membertype member = 1;
};

struct Not {
    membertype member = 1;
};

struct NotEq {
    membertype member = 1;
};

struct Null {
    membertype member = 1;
};

struct Nullptr {
    membertype member = 1;
};

struct Num {
    membertype member = 1;
};

struct Object {
    membertype member = 1;
};

struct Offset {
    membertype member = 1;
};

struct Offsetof {
    membertype member = 1;
};

struct Ok {
    membertype member = 1;
};

struct OnOpen {
    membertype member = 1;
};

struct Operator {
    membertype member = 1;
};

struct Option {
    membertype member = 1;
};

struct Or {
    membertype member = 1;
};

struct OrEq {
    membertype member = 1;
};

struct Override {
    membertype member = 1;
};

struct Package {
    membertype member = 1;
};

struct Part {
    membertype member = 1;
};

struct Priv {
    membertype member = 1;
};

struct Private {
    membertype member = 1;
};

struct Proc {
    membertype member = 1;
};

struct Protected {
    membertype member = 1;
};

struct Proxy {
    membertype member = 1;
};

struct Pub {
    membertype member = 1;
};

struct Public {
    membertype member = 1;
};

struct Pure {
    membertype member = 1;
};

struct Range {
    membertype member = 1;
};

struct Ref {
    membertype member = 1;
};

struct Register {
    membertype member = 1;
};

struct ReinterpretCast {
    membertype member = 1;
};

struct Requires {
    membertype member = 1;
};

struct Result {
    membertype member = 1;
};

struct Rethrow {
    membertype member = 1;
};

struct Return {
    membertype member = 1;
};

struct Rhs {
    membertype member = 1;
};

struct Rune {
    membertype member = 1;
};

struct RuntimeType {
    membertype member = 1;
};

struct Select {
    membertype member = 1;
};

struct Self {
    membertype member = 1;
};

struct Send {
    membertype member = 1;
};

struct Set {
    membertype member = 1;
};

struct SetController {
    membertype member = 1;
};

struct Short {
    membertype member = 1;
};

struct Signed {
    membertype member = 1;
};

struct Sizeof {
    membertype member = 1;
};

struct Some {
    membertype member = 1;
};

struct Static {
    membertype member = 1;
};

struct StaticAssert {
    membertype member = 1;
};

struct StaticCast {
    membertype member = 1;
};

struct Stream {
    membertype member = 1;
};

struct String {
    membertype member = 1;
};

struct Struct {
    membertype member = 1;
};

struct Stub {
    membertype member = 1;
};

struct Super {
    membertype member = 1;
};

struct Switch {
    membertype member = 1;
};

struct Synchronized {
    membertype member = 1;
};

struct Template {
    membertype member = 1;
};

struct This {
    membertype member = 1;
};

struct ThreadLocal {
    membertype member = 1;
};

struct Throw {
    membertype member = 1;
};

struct ToString {
    membertype member = 1;
};

struct Trait {
    membertype member = 1;
};

struct True {
    membertype member = 1;
};

struct Try {
    membertype member = 1;
};

struct Type {
    membertype member = 1;
};

struct Typedef {
    membertype member = 1;
};

struct Typeid {
    membertype member = 1;
};

struct Typename {
    membertype member = 1;
};

struct Typeof {
    membertype member = 1;
};

struct Uint16 {
    membertype member = 1;
};

struct Uint32 {
    membertype member = 1;
};

struct Uint64 {
    membertype member = 1;
};

struct Uint8 {
    membertype member = 1;
};

struct Union {
    membertype member = 1;
};

struct Unsafe {
    membertype member = 1;
};

struct Unsigned {
    membertype member = 1;
};

struct Unsized {
    membertype member = 1;
};

struct Use {
    membertype member = 1;
};

struct Using {
    membertype member = 1;
};

struct Value {
    membertype member = 1;
};

struct ValueOf {
    membertype member = 1;
};

struct ValueUnion {
    membertype member = 1;
};

struct ValuesMap {
    membertype member = 1;
};

struct Var {
    membertype member = 1;
};

struct Vec {
    membertype member = 1;
};

struct Virtual {
    membertype member = 1;
};

struct Void {
    membertype member = 1;
};

struct Volatile {
    membertype member = 1;
};

struct WcharT {
    membertype member = 1;
};

struct Where {
    membertype member = 1;
};

struct Which {
    membertype member = 1;
};

struct While {
    membertype member = 1;
};

struct With {
    membertype member = 1;
};

struct Xor {
    membertype member = 1;
};

struct XorEq {
    membertype member = 1;
};

struct Xunion {
    membertype member = 1;
};

struct Yield {
    membertype member = 1;
};

struct Zx {
    membertype member = 1;
};

struct DangerousMembers {
    Abstract f0;
    Alignas f1;
    Alignof f2;
    And f3;
    AndEq f4;
    As f5;
    Asm f6;
    Assert f7;
    Async f8;
    AtomicCancel f9;
    AtomicCommit f10;
    AtomicNoexcept f11;
    Auto f12;
    Await f13;
    Become f14;
    Bitand f15;
    Bitor f16;
    Bool f17;
    Box f18;
    Break f19;
    Byte f20;
    Bytes f214;
    Case f21;
    Catch f22;
    Chan f23;
    Char f24;
    Char16T f25;
    Char32T f26;
    Class f27;
    CoAwait f28;
    CoReturn f29;
    CoYield f30;
    CodingTraits f31;
    Compl f32;
    Concept f33;
    Const f34;
    ConstCast f35;
    Constexpr f36;
    Continue f37;
    Controller f38;
    Covariant f39;
    Crate f40;
    Decltype f41;
    Decoder f42;
    Default f43;
    Defer f44;
    Deferred f45;
    Delete f46;
    Do f47;
    Double f48;
    Dynamic f49;
    DynamicCast f50;
    Else f51;
    Encoder f52;
    EnsureValuesInstantiated f53;
    Enum f54;
    Empty f55;
    Err f56;
    Explicit f57;
    Export f58;
    Extends f59;
    Extern f60;
    External f61;
    Factory f62;
    Fallthrough f63;
    False f64;
    Fidl f65;
    FidlType f66;
    Final f67;
    Finally f68;
    Float f69;
    Fn f70;
    For f71;
    Friend f72;
    Func f73;
    Future f74;
    Futures f75;
    Get f76;
    Go f77;
    Goto f78;
    HasInvalidTag f79;
    HashCode f80;
    If f81;
    Impl f82;
    Implements f83;
    Import f84;
    In f85;
    Index f86;
    Inline f87;
    Int f88;
    Int16 f89;
    Int32 f90;
    Int64 f91;
    Int8 f92;
    Interface f93;
    InternalTag f94;
    Is f95;
    Let f96;
    Lhs f97;
    Library f98;
    List f99;
    Long f100;
    Loop f101;
    Macro f102;
    Map f103;
    Match f104;
    Mixin f105;
    Mod f106;
    Module f107;
    Move f108;
    Mut f109;
    Mutable f110;
    Namespace f111;
    Never f112;
    New f113;
    NoSuchMethod f114;
    Noexcept f115;
    None f116;
    Not f117;
    NotEq f118;
    Null f119;
    Nullptr f120;
    Num f121;
    Object f122;
    Offset f123;
    Offsetof f124;
    Ok f125;
    OnOpen f126;
    Operator f127;
    Option f128;
    Or f129;
    OrEq f130;
    Override f131;
    Package f132;
    Part f133;
    Priv f134;
    Private f135;
    Proc f136;
    Protected f137;
    Proxy f138;
    Pub f139;
    Public f140;
    Pure f141;
    Range f142;
    Ref f143;
    Register f144;
    ReinterpretCast f145;
    Requires f146;
    Result f147;
    Rethrow f148;
    Return f149;
    Rhs f150;
    Rune f151;
    RuntimeType f152;
    Select f153;
    Self f154;
    Send f155;
    Set f156;
    SetController f157;
    Short f158;
    Signed f159;
    Sizeof f160;
    Some f161;
    Static f162;
    StaticAssert f163;
    StaticCast f164;
    Stream f165;
    String f166;
    Struct f167;
    Stub f168;
    Super f169;
    Switch f170;
    Synchronized f171;
    Template f172;
    This f173;
    ThreadLocal f174;
    Throw f175;
    ToString f176;
    Trait f177;
    True f178;
    Try f179;
    Type f180;
    Typedef f181;
    Typeid f182;
    Typename f183;
    Typeof f184;
    Uint16 f185;
    Uint32 f186;
    Uint64 f187;
    Uint8 f188;
    Union f189;
    Unsafe f190;
    Unsigned f191;
    Unsized f192;
    Use f193;
    Using f194;
    Value f195;
    ValueOf f196;
    ValueUnion f197;
    ValuesMap f198;
    Var f199;
    Vec f200;
    Virtual f201;
    Void f202;
    Volatile f203;
    WcharT f204;
    Where f205;
    Which f206;
    While f207;
    With f208;
    Xor f209;
    XorEq f210;
    Xunion f211;
    Yield f212;
    Zx f213;
};

// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_CONSUMER_STAGE_H_
#define SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_CONSUMER_STAGE_H_

#include <fidl/fuchsia.audio.mixer/cpp/common_types.h>
#include <lib/syslog/cpp/macros.h>
#include <lib/zx/time.h>

#include <optional>
#include <variant>

#include "src/media/audio/services/common/logging.h"
#include "src/media/audio/services/mixer/common/basic_types.h"
#include "src/media/audio/services/mixer/common/thread_safe_queue.h"
#include "src/media/audio/services/mixer/mix/packet_view.h"
#include "src/media/audio/services/mixer/mix/pipeline_stage.h"

namespace media_audio {

// A consumer has one source stream and zero destination streams. All data "consumed" from the
// source stream is written to an object that implements the `ConsumerStage::Writer` interface.
// Data is "consumed" in whole frame units, hence this class represents frame units with int64_t
// instead of Fixed.
class ConsumerStage : public PipelineStage {
 public:
  struct StartCommand {
    // Reference timestamp at which the consumer should be started.
    zx::time start_presentation_time;
    // The first frame to consume at `start_presentation_time`.
    int64_t start_frame;
    // Callback invoked after the consumer has started.
    // Optional: can be nullptr.
    // TODO(fxbug.dev/87651): use fit::inline_callback or a different mechanism
    std::function<void()> callback;
  };

  struct StopCommand {
    // The frame just after the last frame to consume before stopping. This must be `> start_frame`
    // of the prior StartCommand and it must be integral. See comment below for an ordering
    // discussion.
    int64_t stop_frame;
    // Callback invoked after the consumer has stopped.
    // Optional: can be nullptr.
    // TODO(fxbug.dev/87651): use fit::inline_callback or a different mechanism
    std::function<void()> callback;
  };

  // Start and Stop commands must arrive in an alternating sequence, with Start arriving first.
  // Subsequent Stop and Start commands must have monotonically increasing frame numbers and
  // presentation times. For Stop, the effective presentation time is computed relative to the prior
  // Start command:
  //
  // ```
  // stop_presentation_time = start_presentation_time + ns_per_frame * (stop_frame - start_frame)
  // ```
  using Command = std::variant<StartCommand, StopCommand>;
  using CommandQueue = ThreadSafeQueue<Command>;

  // This interface is used to write all packets generated by this ConsumerStage. Packets are
  // written in increasing order by start frame. Underflows will lead to gaps between packets.
  // When the ConsumerStage is stopped, it calls `End()` after writing the final packet. If the
  // ConsumerStage is started again, it starts writing more packets (there is no explicit "start"
  // signal). This interface is implemented by various kinds of audio sinks, such as packet queues
  // and ring buffers.
  //
  // Consumers always write data on integral boundaries. Hence these functions use `int64_t` frames
  // instead of `Fixed` frames to avoid ambiguity and unnecessary `Floor()` operations.
  //
  // TODO(fxbug.dev/87651): Further clarify the semantics: is start_frame allowed to go backwards?
  class Writer {
   public:
    virtual ~Writer() = default;
    virtual void WriteData(int64_t start_frame, int64_t length, const void* data) = 0;
    virtual void WriteSilence(int64_t start_frame, int64_t length) = 0;
    virtual void End() = 0;
  };

  // Arguments for the constructor.
  struct Args {
    // Name of this stage.
    std::string_view name;

    // Whether this ConsumerStage participates in an input pipeline or an output pipeline.
    PipelineDirection pipeline_direction;

    // Initial presentation delay. For output pipelines, this is the downstream presentation delay.
    // For input pipelines, this the upstream presentation delay.
    // TODO(fxbug.dev/87651): Figure out how this is updated.
    zx::duration presentation_delay;

    // Format of audio consumed by this stage.
    Format format;

    // Reference clock used by this consumer.
    UnreadableClock reference_clock;

    // Message queue for pending commands. Will be drained by each call to RunMixJob.
    std::shared_ptr<CommandQueue> command_queue;

    // How to write all consumed packets.
    std::shared_ptr<Writer> writer;
  };

  explicit ConsumerStage(Args args);

  // Returned by RunMixJob to signal that the consumer is still running at the end of the mix job.
  // Caller should continuously run mix jobs until receiving StoppedStatus.
  struct StartedStatus {};

  // Returned by RunMixJob to signal that the consumer is stopped at the end of the mix job. Caller
  // does not need to run another mix job until the reference clock reads `next_mix_job_start_time`.
  struct StoppedStatus {
    // If specified, this is the time when the consumer is scheduled to start again. The consumer
    // is guaranteed to return StoppedStatus for all calls `RunMixJob(ctx, start, period)` where
    // `start + period < next_mix_job_start_time`. If not specified, the next start time is unknown.
    //
    // TODO(fxbug.dev/87651): The above guarantee may not hold preciely if the delay is dynamically
    // changing
    std::optional<zx::time> next_mix_job_start_time;
  };

  using Status = std::variant<StartedStatus, StoppedStatus>;

  // Executes a single mix job that consumes `period` worth of audio data. This method should be
  // called at some time during range `R = [mix_job_start_time, mix_job_start_time + period)`,
  // relative to our reference clock, with the expectation that RunMixJob should complete before
  // `R.end`. This expectation is not checked -- it's the caller's responsibility to check for
  // overruns and underflows as desired.
  //
  // Put differently, within RunMixJob, all calls to `ref_clock->now()` should return a value in
  // range `R`. The range `R` bounds the "actual current time" according to this consumer's
  // reference clock, not the presentation times of audio frames to consume. As described below, the
  // mix job actually consumes frames presented outside of range `R` -- either after `R` (in output
  // pipelines) or before `R` (in input pipelines).
  //
  // TODO(fxbug.dev/87651): Add a discussion of "safe write range" and "safe read range" to
  // ../docs/delay.md and reference that here.
  //
  // ## Output pipelines
  //
  // Since this job may run until `mix_job_start_time + period`, we cannot consume any frames that
  // will be presented before `T = mix_job_start_time + period + downstream_delay`. Hence, we
  // consume frames in the range `[T, T + period)`.
  //
  // ## Input pipelines
  //
  // Since this job starts running as early as `mix_job_start_time`, we cannot consume any frames
  // that are presented after `T = mix_job_start_time - upstream_delay`. Hence, we consume frames in
  // the range `[T - period, T)`.
  Status RunMixJob(MixJobContext& ctx, zx::time mix_job_start_time, zx::duration period);

  // Returns the number of consumers downstream of this consumer. This is > 0 only if this
  // ConsumerStage is embedded within a SplitterNode.
  int64_t downstream_consumers() const { return downstream_consumers_; }
  // TODO(fxbug.dev/87651): update this after designing the SplitterNode implementation
  void set_downstream_consumers(int n) { downstream_consumers_ = n; }

  // Implements `PipelineStage`.
  void AddSource(PipelineStagePtr source, AddSourceOptions options) final;
  void RemoveSource(PipelineStagePtr source) final;
  void UpdatePresentationTimeToFracFrame(std::optional<TimelineFunction> f) final;

 private:
  void FlushPendingCommandsUntil(zx::time now);
  bool ApplyStartCommand(const StartCommand& cmd, zx::time now);
  bool ApplyStopCommand(const StopCommand& cmd, zx::time now);

  // For output pipelines, this reports the presentation delay downstream of this consumer.
  zx::duration downstream_delay() const {
    FX_CHECK(pipeline_direction_ == PipelineDirection::kOutput);
    return presentation_delay_;
  }

  // For input pipelines, this reports the presentation delay upstream of this consumer.
  zx::duration upstream_delay() const {
    FX_CHECK(pipeline_direction_ == PipelineDirection::kInput);
    return presentation_delay_;
  }

  // Implements `PipelineStage`.
  void AdvanceSelfImpl(Fixed frame) final {
    UNREACHABLE << "Consumers cannot be advanced: there is no destination stream";
  }
  void AdvanceSourcesImpl(MixJobContext& ctx, Fixed frame) final {
    UNREACHABLE << "Consumers cannot be advanced: there is no destination stream";
  }
  std::optional<Packet> ReadImpl(MixJobContext& ctx, Fixed start_frame, int64_t frame_count) final {
    UNREACHABLE << "Consumers cannot be read: there is no destination stream";
  }

  const PipelineDirection pipeline_direction_;
  const zx::duration presentation_delay_;  // downstream or upstream delay
  const std::shared_ptr<Writer> writer_;   // how to write consumed packets
  const std::shared_ptr<CommandQueue> pending_commands_;

  // Source stream, if any.
  PipelineStagePtr source_;

  // The last `mix_job_start_time + period` passed to RunMixJob.
  std::optional<zx::time> last_mix_job_end_time_;

  // See downstream_consumers().
  int64_t downstream_consumers_{0};

  // Internal versions of StartCommand and StopCommand that drop the callback.
  struct InternalStartCommand {
    zx::time start_presentation_time;
    int64_t start_frame;
  };
  struct InternalStopCommand {
    zx::time stop_presentation_time;
    int64_t stop_frame;
  };

  // InternalStatus is like Status, but InternalStatus operates on presentation times while Status
  // operates on raw reference times (before applying `consume_offset` -- see code in RunMixJob).
  // We begin in a "stopped" state.
  struct InternalStartedStatus {
    InternalStartCommand prior_cmd;
    std::optional<zx::time> next_stop_presentation_time;  // for the next pending StopCommand
  };
  struct InternalStoppedStatus {
    std::optional<InternalStopCommand> prior_cmd;
    std::optional<zx::time> next_start_presentation_time;  // for the next pending StartCommand
  };
  using InternalStatus = std::variant<InternalStartedStatus, InternalStoppedStatus>;
  static Status ToStatus(const InternalStatus& internal_status, zx::duration consume_offset);

  InternalStatus internal_status_{InternalStoppedStatus{}};
};

}  // namespace media_audio

#endif  // SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_CONSUMER_STAGE_H_

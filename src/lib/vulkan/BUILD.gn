# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/sdk/sdk_atom.gni")
import("//build/testing/host_test_data.gni")
import("//src/lib/vulkan/build/config.gni")
import("//src/lib/vulkan/compact_image.gni")
import("//src/lib/vulkan/image_pipe_swapchain.gni")
import("//src/lib/vulkan/layers.gni")
import("//src/sys/build/components.gni")

# Centralizing the GN points of entry into Vulkan ecosystem repositories here is helpful
# for grasping the full scope.  Note, there are also entry points in //sdk/BUILD.gn.

# Provides the Vulkan headers and entry points via the Vulkan loader.
group("vulkan") {
  public_configs = [ ":vulkan_hpp" ]

  # Targets always use in-tree Vulkan implementation.
  if (!is_host) {
    public_deps = [
      ":headers",
      "//third_party/Vulkan-Loader:libvulkan",
    ]
  }

  # Host target with "null" Vulkan should use Vulkan headers and
  # link the null Vulkan implementation statically.
  if (is_host && use_null_vulkan_on_host) {
    public_deps = [
      ":headers",
      "//src/lib/vulkan/third_party/null_vulkan",
    ]
  }

  # Host target with non-null Vulkan should link against prebuilt
  # Vulkan SDK.
  if (is_host && !use_null_vulkan_on_host) {
    public_configs += [ ":vulkan_host_config" ]
    public_deps = [ ":copy_vulkan_runtime" ]
  }
}

group("vulkan_headers_and_loader") {
  public_deps = [
    ":headers",
    "//third_party/Vulkan-Loader:libvulkan",
  ]
}

# Provides only the Vulkan headers without the loader.
group("headers") {
  public_deps = [ "//third_party/Vulkan-Headers:vulkan_headers" ]
}

# Support code for building layers without bloat.
group("micro_layer_common") {
  public_deps = [ "//third_party/Vulkan-ValidationLayers:micro_layer_common" ]
}

# Tests for the Vulkan loader and validation layers.
group("loader_and_validation_tests") {
  testonly = true
  public_deps = [
    "//third_party/Vulkan-Loader:tests",
    "//third_party/Vulkan-ValidationLayers:tests",
  ]
}

# The vulkaninfo application.
group("vulkaninfo") {
  public_deps = [ "//third_party/Vulkan-Tools:vulkaninfo" ]
}

config("vulkan_hpp") {
  defines = [
    "VULKAN_HPP_ASSERT(expr)=do {} while(0)",
    "VULKAN_HPP_NO_EXCEPTIONS",
  ]
}

resource("validation-layers") {
  sources = []
  foreach(resource, vulkan_validation_layers.resources) {
    sources += [ resource.path ]
  }
  outputs = [ "data/vulkan/explicit_layer.d/{{source_file_part}}" ]
}

resource("image-pipe-swapchain-fb") {
  sources = []
  foreach(resource, image_pipe_swapchain_fb.resources) {
    sources += [ resource.path ]
  }
  outputs = [ "data/vulkan/explicit_layer.d/{{source_file_part}}" ]
}

sdk_atom("vulkan_layers") {
  id = "sdk://pkg/vulkan_layers"

  category = "partner"

  files = []

  resources = vulkan_validation_layers.resources +
              image_pipe_swapchain.resources + compact_image.resources

  loadable_modules = vulkan_validation_layers.loadable_modules +
                     image_pipe_swapchain.loadable_modules
  non_sdk_deps = vulkan_validation_layers.public_deps +
                 image_pipe_swapchain.public_deps + compact_image.public_deps

  sdk_resources = []
  foreach(resource, resources) {
    destination = "pkg/vulkan_layers/data/" + resource.dest
    files += [
      {
        source = resource.path
        dest = destination
      },
    ]
    sdk_resources += [ destination ]
  }

  sdk_binaries = []
  foreach(loadable_module, loadable_modules) {
    destination = "arch/$target_cpu/dist/" + loadable_module.name
    files += [
      {
        source = "$root_out_dir/" + loadable_module.name
        dest = destination
      },
    ]
    sdk_binaries += [ destination ]
  }

  meta = {
    dest = "pkg/vulkan_layers/meta.json"
    schema = "loadable_module"
    value = {
      type = "loadable_module"
      name = "vulkan_layers"
      root = "pkg/vulkan_layers"
      resources = []
      resources = sdk_resources
      binaries = {
      }
      if (target_cpu == "arm64") {
        binaries.arm64 = sdk_binaries
      } else if (target_cpu == "x64") {
        binaries.x64 = sdk_binaries
      } else {
        assert(false, "Unknown CPU type: %target_cpu")
      }
    }
  }
}

#
# Copy Vulkan runtime (loader, validation layers library and layers descriptor)
# to test_data directory.
#
if (is_host) {
  copy("copy_vulkan_libs") {
    assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
    _lib_dir = vulkan_host_runtime_sub_dirs.lib
    if (is_linux) {
      sources = [
        "$vulkan_host_runtime_dir/$_lib_dir/libVkLayer_khronos_validation.so",
        "$vulkan_host_runtime_dir/$_lib_dir/libvulkan.so.1",
      ]
      if (use_swiftshader_vulkan_icd_on_host) {
        sources += [
          "$vulkan_host_runtime_dir/$_lib_dir/libvk_swiftshader.so",
          "$vulkan_host_runtime_dir/$_lib_dir/vk_swiftshader_icd.json",
        ]
      }
    }
    if (is_mac) {
      sources = [
        "$vulkan_host_runtime_dir/$_lib_dir/MoltenVK_icd.json",
        "$vulkan_host_runtime_dir/$_lib_dir/libMoltenVK.dylib",
        "$vulkan_host_runtime_dir/$_lib_dir/libVkLayer_khronos_validation.dylib",

        # Note also libvulkan.1.dylib below which has to be treated specially
        # because of its symlink to libvulkan.dylib.
      ]
      if (use_swiftshader_vulkan_icd_on_host) {
        sources += [
          "$vulkan_host_runtime_dir/$_lib_dir/libvk_swiftshader.dylib",
          "$vulkan_host_runtime_dir/$_lib_dir/vk_swiftshader_icd.json",
        ]
      }
    }
    outputs = [ "${root_out_dir}/${vulkan_host_runtime_out_root}/${_lib_dir}/{{source_file_part}}" ]
  }

  # On Linux, libvulkan.so is a symbolic link to libvulkan.so.1. For symbolic
  # links, ninja records the modification time of the linked file into its log,
  # so we need to ensure that the original library file is copied before the
  # symbolic link. We do this by adding "copy_vulkan_libs" as its dependency.
  if (is_linux) {
    copy("vulkan_lib_links") {
      assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
      _lib_dir = vulkan_host_runtime_sub_dirs.lib
      sources = [ "$vulkan_host_runtime_dir/$_lib_dir/libvulkan.so" ]
      outputs = [ "${root_out_dir}/${vulkan_host_runtime_out_root}/${_lib_dir}/{{source_file_part}}" ]
      deps = [ ":copy_vulkan_libs" ]
    }
  }

  # On macOS, copy target will makes copies of all symlinks instead of keeping
  # the links. Having two separated libvulkan.1.dylib and libvulkan.dylib will
  # cause Vulkan loader crash, thus we set the symlink after the actual dylib
  # libvulkan.dylib is copied to build out directory. Additionally, because
  # ninja looks at the timestamp of the linked-to target, and a copy() will
  # hardlink, we do a real copy here of libvulkan.1.dylib to update its
  # timestamp before softlinking, otherwise the timestamp of the link (an
  # output of this rule) will never be newer than the .stamp file, so this rule
  # will always be dirty. https://fxbug.dev/65872.
  if (is_mac) {
    action("vulkan_lib_links") {
      assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
      script = "//src/lib/vulkan/build/copy_and_symlink.py"
      _lib_dir = vulkan_host_runtime_sub_dirs.lib
      sources = [ "$vulkan_host_runtime_dir/$_lib_dir/libvulkan.1.dylib" ]
      outputs = [
        "${root_out_dir}/${vulkan_host_runtime_out_root}/${_lib_dir}/libvulkan.1.dylib",
        "${root_out_dir}/${vulkan_host_runtime_out_root}/${_lib_dir}/libvulkan.dylib",
      ]
      args = [
        rebase_path(sources[0], root_build_dir),  # source.
        rebase_path(outputs[0], root_build_dir),  # copy_to.
        rebase_path(outputs[1], root_build_dir),  # link_to.
      ]
      deps = [ ":copy_vulkan_libs" ]
    }
  }

  copy("copy_vulkan_etc") {
    assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
    _layers_dir = vulkan_host_runtime_sub_dirs.layers
    sources = [
      "$vulkan_host_runtime_dir/$_layers_dir/VkLayer_khronos_validation.json",
    ]
    if (is_linux) {
      # On Linux we also add VkLayer_standard_validation to support Vulkan 1.0
      # drivers.
      sources += [ "$vulkan_host_runtime_dir/$_layers_dir/VkLayer_standard_validation.json" ]
    }
    outputs = [ "${root_out_dir}/${vulkan_host_runtime_out_root}/${_layers_dir}/{{source_file_part}}" ]
  }

  host_test_data("vulkan_test_data") {
    assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
    _lib_dir = vulkan_host_runtime_sub_dirs.lib
    _layers_dir = vulkan_host_runtime_sub_dirs.layers
    _data_dir = "${root_out_dir}/${vulkan_host_runtime_out_root}"
    sources = [
      "${_data_dir}/${_layers_dir}",
      "${_data_dir}/${_lib_dir}",
    ]
    deps = [
      ":copy_vulkan_etc",
      ":copy_vulkan_libs",
      ":vulkan_lib_links",
    ]
  }

  group("copy_vulkan_runtime") {
    assert(has_prebuilt_vulkan_runtime, "Prebuilt Vulkan runtime not found.")
    deps = [
      ":copy_vulkan_etc",
      ":copy_vulkan_libs",
      ":vulkan_lib_links",
    ]
  }
}

#
# Vulkan dependencies required for Vulkan executables / tests / source sets.
# This includes headers, loader linkage, and copying of runtime files for host
# executables.
#
config("vulkan_host_config") {
  if (current_cpu == "x64" && is_host) {
    include_dirs = [ "$vulkan_host_sdk_dir/include" ]
    lib_dirs = [ "$vulkan_host_sdk_dir/lib" ]

    # Link Vulkan loader to host executables.
    libs = [ "vulkan" ]

    if (is_mac) {
      defines = [
        "VK_USE_PLATFORM_MACOS_MVK",
        "VK_USE_PLATFORM_METAL_EXT",
      ]
    }
  }
}

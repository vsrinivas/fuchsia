// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by src/lib/fdio/rust/bindgen.sh using bindgen 0.60.1

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub const FDIO_MAX_FD: u32 = 1024;
pub const FDIO_CHUNK_SIZE: u32 = 8192;
pub const FDIO_MAX_FILENAME: u32 = 255;
pub const FDIO_FLAG_USE_FOR_STDIO: u32 = 32768;
pub const FDIO_EVT_READABLE: u32 = 1;
pub const FDIO_EVT_WRITABLE: u32 = 4;
pub const FDIO_EVT_ERROR: u32 = 8;
pub const FDIO_SPAWN_CLONE_JOB: u32 = 1;
pub const FDIO_SPAWN_DEFAULT_LDSVC: u32 = 2;
pub const FDIO_SPAWN_CLONE_NAMESPACE: u32 = 4;
pub const FDIO_SPAWN_CLONE_STDIO: u32 = 8;
pub const FDIO_SPAWN_CLONE_ENVIRON: u32 = 16;
pub const FDIO_SPAWN_CLONE_UTC_CLOCK: u32 = 32;
pub const FDIO_SPAWN_CLONE_ALL: u32 = 65535;
pub const FDIO_SPAWN_ACTION_CLONE_FD: u32 = 1;
pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 2;
pub const FDIO_SPAWN_ACTION_ADD_NS_ENTRY: u32 = 3;
pub const FDIO_SPAWN_ACTION_ADD_HANDLE: u32 = 4;
pub const FDIO_SPAWN_ACTION_SET_NAME: u32 = 5;
pub const FDIO_SPAWN_ACTION_CLONE_DIR: u32 = 6;
pub const FDIO_SPAWN_ERR_MSG_MAX_LENGTH: u32 = 1024;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type zx_time_t = i64;
pub type zx_handle_t = u32;
pub type zx_status_t = i32;
pub type zx_signals_t = u32;
extern "C" {
    pub fn fdio_fd_create(handle: zx_handle_t, fd_out: *mut ::std::os::raw::c_int) -> zx_status_t;
}
extern "C" {
    pub fn fdio_cwd_clone(out_handle: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_clone(fd: ::std::os::raw::c_int, out_handle: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_transfer(fd: ::std::os::raw::c_int, out_handle: *mut zx_handle_t)
        -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_transfer_or_clone(
        fd: ::std::os::raw::c_int,
        out_handle: *mut zx_handle_t,
    ) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio {
    _unused: [u8; 0],
}
pub type fdio_t = fdio;
extern "C" {
    pub fn fdio_create(handle: zx_handle_t, out_io: *mut *mut fdio_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_default_create() -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_null_create() -> *mut fdio_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zxio_tag {
    _unused: [u8; 0],
}
pub type zxio_t = zxio_tag;
extern "C" {
    pub fn fdio_get_zxio(io: *mut fdio_t) -> *mut zxio_t;
}
extern "C" {
    pub fn fdio_fd_create_null() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_bind_to_fd(
        io: *mut fdio_t,
        fd: ::std::os::raw::c_int,
        starting_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_unbind_from_fd(fd: ::std::os::raw::c_int, io_out: *mut *mut fdio_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_service_handle(fd: ::std::os::raw::c_int, out: *mut zx_handle_t)
        -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zxio_storage {
    _unused: [u8; 0],
}
pub type zxio_storage_t = zxio_storage;
extern "C" {
    pub fn fdio_zxio_create(out_storage: *mut *mut zxio_storage_t) -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_service_connect(
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_connect_at(
        directory: zx_handle_t,
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_connect_by_name(
        name: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open(
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_at(
        directory: zx_handle_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_fd(
        path: *const ::std::os::raw::c_char,
        flags: u32,
        out_fd: *mut ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_fd_at(
        dir_fd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        out_fd: *mut ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_clone(node: zx_handle_t) -> zx_handle_t;
}
extern "C" {
    pub fn fdio_service_clone_to(node: zx_handle_t, request: zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_wait_fd(
        fd: ::std::os::raw::c_int,
        events: u32,
        pending: *mut u32,
        deadline: zx_time_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_handle_fd(
        h: zx_handle_t,
        signals_in: zx_signals_t,
        signals_out: zx_signals_t,
        shared_handle: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_pipe_half(
        out_fd: *mut ::std::os::raw::c_int,
        out_handle: *mut zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_copy(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_clone(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_exact(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_exec(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_namespace {
    _unused: [u8; 0],
}
pub type fdio_ns_t = fdio_namespace;
extern "C" {
    pub fn fdio_ns_create(out: *mut *mut fdio_ns_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_destroy(ns: *mut fdio_ns_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_bind(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        h: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_unbind(ns: *mut fdio_ns_t, path: *const ::std::os::raw::c_char) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_is_bound(ns: *mut fdio_ns_t, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn fdio_ns_bind_fd(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        fd: ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_opendir(ns: *mut fdio_ns_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_ns_chdir(ns: *mut fdio_ns_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_get_installed(ns: *mut *mut fdio_ns_t) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_flat_namespace {
    pub count: size_t,
    pub handle: *mut zx_handle_t,
    pub type_: *mut u32,
    pub path: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_flat_namespace() {
    assert_eq!(
        ::std::mem::size_of::<fdio_flat_namespace>(),
        32usize,
        concat!("Size of: ", stringify!(fdio_flat_namespace))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_flat_namespace>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_flat_namespace))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_flat_namespace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(count))
        );
    }
    test_field_count();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_flat_namespace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(handle))
        );
    }
    test_field_handle();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_flat_namespace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(type_))
        );
    }
    test_field_type();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_flat_namespace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(path))
        );
    }
    test_field_path();
}
impl Default for fdio_flat_namespace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fdio_flat_namespace_t = fdio_flat_namespace;
extern "C" {
    pub fn fdio_ns_export(ns: *mut fdio_ns_t, out: *mut *mut fdio_flat_namespace_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_export_root(out: *mut *mut fdio_flat_namespace_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_connect(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_open(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_service_connect(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_free_flat_ns(ns: *mut fdio_flat_namespace_t);
}
extern "C" {
    pub fn fdio_spawn(
        job: zx_handle_t,
        flags: u32,
        path: *const ::std::os::raw::c_char,
        argv: *const *const ::std::os::raw::c_char,
        process_out: *mut zx_handle_t,
    ) -> zx_status_t;
}
pub type fdio_spawn_action_t = fdio_spawn_action;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fdio_spawn_action {
    pub action: u32,
    pub __bindgen_anon_1: fdio_spawn_action__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fdio_spawn_action__bindgen_ty_1 {
    pub fd: fdio_spawn_action__bindgen_ty_1__bindgen_ty_1,
    pub ns: fdio_spawn_action__bindgen_ty_1__bindgen_ty_2,
    pub h: fdio_spawn_action__bindgen_ty_1__bindgen_ty_3,
    pub name: fdio_spawn_action__bindgen_ty_1__bindgen_ty_4,
    pub dir: fdio_spawn_action__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_1 {
    pub local_fd: ::std::os::raw::c_int,
    pub target_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1))
    );
    fn test_field_local_fd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(local_fd)
            )
        );
    }
    test_field_local_fd();
    fn test_field_target_fd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_fd) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(target_fd)
            )
        );
    }
    test_field_target_fd();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 {
    pub prefix: *const ::std::os::raw::c_char,
    pub handle: zx_handle_t,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2))
    );
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_3 {
    pub id: u32,
    pub handle: zx_handle_t,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_3 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_3 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_4 {
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_4 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_5 {
    pub prefix: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5))
    );
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < fdio_spawn_action__bindgen_ty_1__bindgen_ty_5 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1),
                "::",
                stringify!(ns)
            )
        );
    }
    test_field_ns();
    fn test_field_h() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1),
                "::",
                stringify!(h)
            )
        );
    }
    test_field_h();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_dir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fdio_spawn_action__bindgen_ty_1),
                "::",
                stringify!(dir)
            )
        );
    }
    test_field_dir();
}
impl Default for fdio_spawn_action__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for fdio_spawn_action__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "fdio_spawn_action__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_fdio_spawn_action() {
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action>(),
        24usize,
        concat!("Size of: ", stringify!(fdio_spawn_action))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action))
    );
    fn test_field_action() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fdio_spawn_action>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(fdio_spawn_action), "::", stringify!(action))
        );
    }
    test_field_action();
}
impl Default for fdio_spawn_action {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for fdio_spawn_action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "fdio_spawn_action {{ action: {:?}, __bindgen_anon_1: {:?} }}",
            self.action, self.__bindgen_anon_1
        )
    }
}
extern "C" {
    pub fn fdio_spawn_etc(
        job: zx_handle_t,
        flags: u32,
        path: *const ::std::os::raw::c_char,
        argv: *const *const ::std::os::raw::c_char,
        environ: *const *const ::std::os::raw::c_char,
        action_count: size_t,
        actions: *const fdio_spawn_action_t,
        process_out: *mut zx_handle_t,
        err_msg_out: *mut ::std::os::raw::c_char,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_spawn_vmo(
        job: zx_handle_t,
        flags: u32,
        executable_vmo: zx_handle_t,
        argv: *const *const ::std::os::raw::c_char,
        environ: *const *const ::std::os::raw::c_char,
        action_count: size_t,
        actions: *const fdio_spawn_action_t,
        process_out: *mut zx_handle_t,
        err_msg_out: *mut ::std::os::raw::c_char,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_unsafe_fd_to_io(fd: ::std::os::raw::c_int) -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_unsafe_borrow_channel(io: *mut fdio_t) -> zx_handle_t;
}
extern "C" {
    pub fn fdio_unsafe_release(io: *mut fdio_t);
}
extern "C" {
    pub fn fdio_unsafe_wait_begin(
        io: *mut fdio_t,
        events: u32,
        handle_out: *mut zx_handle_t,
        signals_out: *mut zx_signals_t,
    );
}
extern "C" {
    pub fn fdio_unsafe_wait_end(io: *mut fdio_t, signals: zx_signals_t, events_out: *mut u32);
}
pub type watchdir_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dirfd: ::std::os::raw::c_int,
        event: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
        cookie: *mut ::std::os::raw::c_void,
    ) -> zx_status_t,
>;
extern "C" {
    pub fn fdio_watch_directory(
        dirfd: ::std::os::raw::c_int,
        cb: watchdir_func_t,
        deadline: zx_time_t,
        cookie: *mut ::std::os::raw::c_void,
    ) -> zx_status_t;
}

// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by src/lib/usb_bulk/bindgen.sh using bindgen 0.60.1

// Allow non-conventional naming for imports from C/C++.
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

// This attribute ensures proper linkage. Applying it to an empty block to satisfy
// linking requirements for later blocks is explicitly suggested by
// https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute.
#[link(name = "usb_bulk", kind = "static")]
extern "C" {}

// Configure linkage for MacOS.
#[cfg(target_os = "macos")]
#[link(name = "IOKit", kind = "framework")]
#[link(name = "CoreFoundation", kind = "framework")]
extern "C" {}

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __ssize_t = ::std::os::raw::c_long;
pub type ssize_t = __ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ifc_info {
    pub dev_vendor: ::std::os::raw::c_ushort,
    pub dev_product: ::std::os::raw::c_ushort,
    pub dev_class: ::std::os::raw::c_uchar,
    pub dev_subclass: ::std::os::raw::c_uchar,
    pub dev_protocol: ::std::os::raw::c_uchar,
    pub ifc_class: ::std::os::raw::c_uchar,
    pub ifc_subclass: ::std::os::raw::c_uchar,
    pub ifc_protocol: ::std::os::raw::c_uchar,
    pub has_bulk_in: ::std::os::raw::c_uchar,
    pub has_bulk_out: ::std::os::raw::c_uchar,
    pub writable: ::std::os::raw::c_uchar,
    pub serial_number: [u8; 256usize],
    pub device_path: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_usb_ifc_info() {
    assert_eq!(
        ::std::mem::size_of::<usb_ifc_info>(),
        526usize,
        concat!("Size of: ", stringify!(usb_ifc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ifc_info>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_ifc_info))
    );
    fn test_field_dev_vendor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_vendor) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_vendor))
        );
    }
    test_field_dev_vendor();
    fn test_field_dev_product() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_product) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_product))
        );
    }
    test_field_dev_product();
    fn test_field_dev_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_class) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_class))
        );
    }
    test_field_dev_class();
    fn test_field_dev_subclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_subclass) as usize - ptr as usize
            },
            5usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_subclass))
        );
    }
    test_field_dev_subclass();
    fn test_field_dev_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_protocol) as usize - ptr as usize
            },
            6usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(dev_protocol))
        );
    }
    test_field_dev_protocol();
    fn test_field_ifc_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_class) as usize - ptr as usize
            },
            7usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_class))
        );
    }
    test_field_ifc_class();
    fn test_field_ifc_subclass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_subclass) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_subclass))
        );
    }
    test_field_ifc_subclass();
    fn test_field_ifc_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_protocol) as usize - ptr as usize
            },
            9usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(ifc_protocol))
        );
    }
    test_field_ifc_protocol();
    fn test_field_has_bulk_in() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_bulk_in) as usize - ptr as usize
            },
            10usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(has_bulk_in))
        );
    }
    test_field_has_bulk_in();
    fn test_field_has_bulk_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_bulk_out) as usize - ptr as usize
            },
            11usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(has_bulk_out))
        );
    }
    test_field_has_bulk_out();
    fn test_field_writable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writable) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(writable))
        );
    }
    test_field_writable();
    fn test_field_serial_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serial_number) as usize - ptr as usize
            },
            13usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(serial_number))
        );
    }
    test_field_serial_number();
    fn test_field_device_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<usb_ifc_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_path) as usize - ptr as usize
            },
            269usize,
            concat!("Offset of field: ", stringify!(usb_ifc_info), "::", stringify!(device_path))
        );
    }
    test_field_device_path();
}
impl Default for usb_ifc_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ifc_match_func = ::std::option::Option<
    unsafe extern "C" fn(ifc: *mut usb_ifc_info, data: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UsbInterface {
    _unused: [u8; 0],
}
extern "C" {
    pub fn interface_open(
        callback: ifc_match_func,
        callback_data: *mut ::std::os::raw::c_void,
        timeout_ms: u32,
    ) -> *mut UsbInterface;
}
extern "C" {
    pub fn interface_read(
        interface: *mut UsbInterface,
        data: *mut ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn interface_write(
        interface: *mut UsbInterface,
        data: *const ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn interface_close(interface: *mut UsbInterface);
}

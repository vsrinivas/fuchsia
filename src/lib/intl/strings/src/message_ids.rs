// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    crate::parser,
    anyhow::{Context, Result},
    handlebars::Handlebars,
    serde::Serialize,
    std::collections::hash_map::DefaultHasher,
    std::hash::{Hash, Hasher},
    std::io,
};

/// One constant:
///
/// ```ignore
/// // comment[0]
/// // comment[1]
/// // ...
/// name = value;
/// ```
#[derive(Serialize, Debug, Clone)]
pub struct Constant {
    name: String,
    value: u64,
    comments: Vec<String>,
}

// Generates a locally unique identifier for [message].  The unique identifier
// is generated based on the content, so any two messages identical in content
// end up having the same identifier here.
fn gen_id(message: impl AsRef<str>) -> u64 {
    let mut hasher = DefaultHasher::new();
    message.as_ref().hash(&mut hasher);
    hasher.finish()
}

// Splits the given internationalized messages into quoted strings of fixed size.  Used to give
// reasonably formatted usage hint in the generated code.
fn split_message(message: impl AsRef<str>) -> Vec<String> {
    const SLICE: usize = 50;
    // This is not iterating over grapheme clusters, but for now will have
    // to do.
    message
        .as_ref()
        // Split up into individual characters, and slice them up into
        // mostly equally-sized slices.
        .chars()
        .collect::<Vec<char>>()
        .chunks(SLICE)
        // Build up a string from each of such slices.
        .map(|c| c.iter().collect::<String>())
        // Sanitize newlines (since they will mess with code generation)
        .map(|s| format!("'{}'", s.replace("\n", " ")))
        .collect::<Vec<String>>()
}

/// Builds a message ID [Model] from a parser dictionary.
pub fn from_dictionary(dict: &parser::Dictionary, library_name: impl AsRef<str>) -> Result<Model> {
    let constants = dict
        .iter()
        .map(|(name, message)| Constant::new(name, gen_id(message), &split_message(message)))
        .collect::<Vec<Constant>>();
    let model = Model::new(library_name, &constants);
    Ok(model)
}

impl Constant {
    /// Creates a new Constant from supplied components.  The components are rendered verbatim.
    pub fn new(name: impl AsRef<str>, value: u64, comments: &[impl AsRef<str>]) -> Constant {
        Constant {
            name: name.as_ref().to_owned(),
            value,
            comments: comments.iter().map(|s| s.as_ref().to_owned()).collect(),
        }
    }
}

/// The data model for a FIDL constants file.
///
/// Example:
///
/// ```
/// # use fidl::message_ids;
/// let data = message_ids::Fidl::new(
///   "library_name",
///   &vec![
///     message_ids::Constant::new("constant_name", 42 /* value */,
///       vec!["comment 1", "comment 2"],
///     ),
///   ],
/// );
#[derive(Serialize, Debug)]
pub struct Model {
    library: String,
    constants: Vec<Constant>,
}

impl Model {
    /// Creates a new Model from supplied components.
    pub fn new(library: impl AsRef<str>, constants: &[Constant]) -> Model {
        Model {
            library: library.as_ref().to_owned(),
            constants: constants.iter().map(|c| c.clone()).collect(),
        }
    }
}

static FIDL_FILE_TEMPLATE: &'static str = r#"// Generated by strings_to_fidl. DO NOT EDIT!

library {{library}};

enum MessageIds : uint64 {
  {{~#each constants~}}
  {{~#each comments}}
    // {{this}}
  {{~/each}}
    {{name}} = {{value}};
  {{~/each}}
};
"#;

/// Renders the data model in [fidl] into a template, writing to [output].
pub fn render<W: io::Write>(fidl: Model, output: &mut W) -> Result<()> {
    let mut renderer = Handlebars::new();
    renderer
        .register_template_string("fidl", FIDL_FILE_TEMPLATE)
        .with_context(|| "while registering the file template")?;
    renderer
        .render_to_write("fidl", &fidl, output)
        .with_context(|| format!("while rendering content: {:?}", &fidl))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use {
        super::parser,
        super::*,
        anyhow::{Error, Result},
        xml::reader::EventReader,
    };

    #[test]
    fn render_template() -> Result<()> {
        let data = Model::new(
            "lib",
            &vec![Constant::new("constant_name", 42, &vec!["comment 1", "comment 2"])],
        );
        let mut output: Vec<u8> = vec![];
        render(data, &mut output).with_context(|| "test render_template")?;
        let result = String::from_utf8(output).with_context(|| "utf-8")?;
        assert_eq!(
            r#"// Generated by strings_to_fidl. DO NOT EDIT!

library lib;

enum MessageIds : uint64 {
    // comment 1
    // comment 2
    constant_name = 42;
};
"#,
            &result
        );
        Ok(())
    }

    #[test]
    fn xml_to_fidl() -> Result<(), Error> {
        struct TestCase {
            name: &'static str,
            content: &'static str,
            expected: &'static str,
        };
        let tests = vec![
            TestCase {
                name: "basic",
                content: r#"
               <!-- comment -->
               <?xml version="1.0" encoding="utf-8"?>
               <resources>
                 <!-- comment -->
                 <string
                   name="string_name"
                     >text_string</string>
               </resources>
            "#,
                expected: r#"// Generated by strings_to_fidl. DO NOT EDIT!

library library;

enum MessageIds : uint64 {
    // 'text_string'
    string_name = 16479498444549137679;
};
"#,
            },
            TestCase {
                name: "long string goes to the comments",
                content: r#"
               <!-- comment -->
               <?xml version="1.0" encoding="utf-8"?>
               <resources>
                 <!-- comment -->
                 <string
                   name="string_name"
                     >long long long long long long long long long long long long long</string>
               </resources>
            "#,
                expected: r#"// Generated by strings_to_fidl. DO NOT EDIT!

library library;

enum MessageIds : uint64 {
    // 'long long long long long long long long long long '
    // 'long long long'
    string_name = 18059451882864842113;
};
"#,
            },
            TestCase {
                name: "string with newline in comments",
                content: r#"
               <!-- comment -->
               <?xml version="1.0" encoding="utf-8"?>
               <resources>
                 <!-- comment -->
                 <string
                   name="string_name"
                     >text with
an intervening newline</string>
               </resources>
            "#,
                expected: r#"// Generated by strings_to_fidl. DO NOT EDIT!

library library;

enum MessageIds : uint64 {
    // 'text with an intervening newline'
    string_name = 7254939001732941199;
};
"#,
            },
            TestCase {
                // Not sure if we want to prevent this.
                name: "two identical strings with different IDs",
                content: r#"
               <!-- comment -->
               <?xml version="1.0" encoding="utf-8"?>
               <resources>
                 <!-- comment -->
                 <string
                   name="string_name"
                     >text</string>
                 <string
                   name="string_name_2"
                     >text</string>
               </resources>
            "#,
                expected: r#"// Generated by strings_to_fidl. DO NOT EDIT!

library library;

enum MessageIds : uint64 {
    // 'text'
    string_name = 9737151508951142383;
    // 'text'
    string_name_2 = 9737151508951142383;
};
"#,
            },
            TestCase {
                // Correct grapheme cluster split is *not* supported yet.
                name: "pangram in Serbian is split across lines correctly",
                content: r#"
               <!-- comment -->
               <?xml version="1.0" encoding="utf-8"?>
               <resources>
                 <!-- comment -->
                 <string
                   name="string_name"
                     >љубазни фењерџија чађавог лица хоће да ми покаже штос</string>
               </resources>
            "#,
                expected: r#"// Generated by strings_to_fidl. DO NOT EDIT!

library library;

enum MessageIds : uint64 {
    // 'љубазни фењерџија чађавог лица хоће да ми покаже ш'
    // 'тос'
    string_name = 10417041116524418271;
};
"#,
            },
        ];
        for test in tests {
            let input = EventReader::from_str(&test.content);
            let mut parser = parser::Instance::new(false /* verbose */);
            let dict = parser.parse(input).with_context(|| format!("test: {}", &test.name))?;
            let mut output: Vec<u8> = vec![];
            let model = from_dictionary(dict, "library")
                .with_context(|| format!("test name: {}", &test.name))?;
            render(model, &mut output).with_context(|| format!("test name: {}", &test.name))?;
            let actual =
                String::from_utf8(output).with_context(|| format!("test name: {}", &test.name))?;
            assert_eq!(&test.expected, &actual);
        }
        Ok(())
    }
}

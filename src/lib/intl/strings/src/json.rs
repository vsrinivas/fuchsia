// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! # The JSON message internationalization format
//!
//! This module contains the code used to turn a dictionary of localized messages into a
//! JSON-formatted file usable by Fuchsia's localization lookup system.
//!
//! The data model used for the JSON schema is defined below.  No formal JSON schema has been
//! specified yet. (But probably should be!)

use {
    crate::message_ids,
    crate::parser,
    anyhow::Result,
    serde::{Deserialize, Serialize},
    serde_json,
    std::collections::BTreeMap,
    std::io,
};

/// The message catalog.  Maps unique IDs (as generated by the message_id::gen_ids) to individual
/// message.  The catalog does not know about the locale it is intended for, and additional
/// metadata is needed to assert that.  See [Model] for details on how it fits together.
pub type Messages = BTreeMap<u64, String>;

#[cfg(test)]
pub fn as_messages(pairs: &Vec<(u64, String)>) -> Messages {
    let mut result = Messages::new();
    for (k, v) in pairs {
        result.insert(*k, v.clone());
    }
    result as Messages
}

/// The data model for a set of internationalized messages.  Every
/// file has a locale ID that it applies to, as well as the number
/// of total messages analyzed when this locale was produced
///
/// Use [Model::from_json_reader] to make a new instance of the
/// Model from its JSON serialization.  Use [Model::from_dictionaries] to make a new instance of
/// the Model based on the supplied dictionaries.
///
/// In tests, you can use [Model::from_parts] to create [Model] quickly without any checks.
#[derive(Serialize, Deserialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct Model {
    /// The locale for the messages described in this file.  An
    /// example value could be "en-US".
    locale_id: String,

    /// The source-of-truth locale from which this model was
    /// generated.  Source of truth locales exist so as to provide
    /// fallback messages or such.
    source_locale_id: String,

    /// The total number of messages that are expected to exist in
    /// this bundle.  This number is not the same as the number of
    /// key-value pairs in [messages] below, though.
    num_messages: usize,

    /// The message catalog, listing the mapping of message IDs to
    /// respective messages.  This mapping does not define a fallback
    /// language.  The ordering of the messages in this map is not
    /// defined: all serializations that end up with an identical
    /// map model are equally valid.
    messages: Messages,
}

impl Model {
    /// Deserializes the Model from the supplied reader.  Use to
    /// create a functional Model from JSON.
    pub fn from_json_reader<R: io::Read>(r: R) -> Result<Model> {
        serde_json::from_reader(r).map_err(|e| e.into())
    }

    /// Writes the Model into the supplied writer encoded as JSON.  Use to persist the Model into
    /// JSON.  The message ordering is not guaranteed.
    pub fn to_json_writer<W: io::Write>(&self, writer: W) -> Result<()> {
        serde_json::to_writer(writer, self)
            .map_err(|e| -> io::Error { e.into() })
            .map_err(|e| -> anyhow::Error { e.into() })
    }

    /// Creates a new [Model] from the supplied dictionaries.
    ///
    /// [source_locale_id] is the source locale (very typically would be "en-US" or some such);
    /// [target_locale_id] is the target locale (i.e. the locale to translate into, e.g. "ru-RU");
    /// source_dictionary is the dictionary of untranslated messages , presumably coming from the
    /// declared source locale; and [target_dictionary] is the dictionary of available translated
    /// messages, presumably in the target locale.
    ///
    /// Both the source and target dictionaries are needed, because we need to determine whether
    /// all messages are present.  At the moment we require that all messages present in the source
    /// dictionary are also present in the target dictionary.  furthermore, messages that are
    /// present in the target but not present in the source are omitted entirely.
    pub fn from_dictionaries(
        source_locale_id: &str,
        source_dictionary: &parser::Dictionary,
        target_locale_id: &str,
        target_dictionary: &parser::Dictionary,
    ) -> Result<Model> {
        let mut messages: Messages = BTreeMap::new();
        for (name, message) in source_dictionary.iter() {
            match target_dictionary.get(name) {
                None => {
                    return Err(anyhow::anyhow!(
                        "not found: translation for\n\tname: '{}'\n\tmessage: '{}'",
                        name,
                        message
                    ));
                }
                Some(translated) => {
                    let message_id = message_ids::gen_id(name, message);
                    messages.insert(message_id, translated.to_string());
                }
            }
        }

        let messages = messages;
        Ok(Model {
            locale_id: target_locale_id.to_string(),
            source_locale_id: source_locale_id.to_string(),
            num_messages: source_dictionary.len(),
            messages,
        })
    }

    /// Creates a [Model] quickly from supplied parts and without any checks,
    /// for use in tests only.
    #[cfg(test)]
    pub fn from_parts(
        locale_id: &str,
        source_locale_id: &str,
        num_messages: usize,
        messages: Messages,
    ) -> Model {
        Model {
            locale_id: locale_id.to_string(),
            source_locale_id: source_locale_id.to_string(),
            num_messages,
            messages,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Context;

    #[test]
    fn read_json_test() -> Result<()> {
        let message = r#"
        {
            "locale_id": "ru-RU",
            "source_locale_id": "en-US",
            "num_messages": 1000,
            "messages": {
                "42": "Привет",
                "100": "Что это сорок-два?"
            }
        }
        "#;
        let model = Model::from_json_reader(message.as_bytes())
            .with_context(|| format!("while loading JSON: \n{}", message))?;
        assert_eq!(model.locale_id, "ru-RU");
        assert_eq!(model.num_messages, 1000);
        assert_eq!(model.messages.get(&42).unwrap(), "Привет");
        Ok(())
    }

    /// Note that we don't care about the message ordering just yet.
    #[test]
    fn round_trip_test() -> Result<()> {
        struct TestCase {
            name: &'static str,
            message: &'static str,
        }
        let tests = vec![
            TestCase {
                name: "Random text in Russian",
                message: r#"
                {
                    "locale_id": "ru-RU",
                    "source_locale_id": "en-US",
                    "num_messages": 42,
                    "messages": {
                        "42": "Привет",
                        "100": "Что это сорок-два?"
                    }
                }
                "#,
            },
            TestCase {
                name: "Serbian pangram",
                message: r#"
                {
                    "locale_id": "sr-RS",
                    "source_locale_id": "en-US",
                    "num_messages": 2,
                    "messages": {
                        "1": "Љубазни фењерџија чађавог лица хоће да ми покаже штос"
                    }
                }
                "#,
            },
        ];
        for test in tests {
            let model = Model::from_json_reader(test.message.as_bytes()).with_context(|| {
                format!("in test '{}', while loading JSON: \n{}", test.name, test.message)
            })?;
            let mut output: Vec<u8> = vec![];
            model
                .to_json_writer(&mut output)
                .with_context(|| format!("while writing JSON, in test '{}'", test.name))?;
            let model2 = Model::from_json_reader(&output[..])
                .with_context(|| format!("while reading JSON again, in test '{}'", test.name))?;
            assert_eq!(model, model2);
        }
        Ok(())
    }

    #[test]
    fn build_from_dictionary() -> Result<()> {
        struct TestCase {
            name: &'static str,
            source: parser::Dictionary,
            target: parser::Dictionary,
            expected_num_messages: usize,
            expected: Vec<(u64, String)>,
        };
        let tests = vec![
            TestCase {
                name: "basic pseudo-French",
                source: parser::Dictionary::from_init(&vec![("string_name", "text_string")]),
                target: parser::Dictionary::from_init(&vec![
                    // Behold my French-language-foo!
                    ("string_name", "un_string_textique"),
                ]),
                expected_num_messages: 1,
                // The magic numbers here and below are stable IDs generated for messages
                // by `message_ids::gen_id`.
                expected: vec![(17128972970596363087, "un_string_textique".to_string())],
            },
            TestCase {
                name: "known message ID",
                source: parser::Dictionary::from_init(&vec![("string_name", "text")]),
                target: parser::Dictionary::from_init(&vec![("string_name", "le text")]),
                expected_num_messages: 1,
                // The magic number here is a known golden result from the call to:
                // `message_ids::gen_id("string_name", "text")`.  There should not
                // be a change of the numeric message ID, unless `gen_id` algorithm
                // is also modified.
                expected: vec![(15068421743305203572, "le text".to_string())],
            },
            TestCase {
                name: "several messages",
                source: parser::Dictionary::from_init(&vec![
                    ("string_1", "text"),
                    ("string_2", "more text"),
                    ("string_3", "even more text"),
                ]),
                target: parser::Dictionary::from_init(&vec![
                    ("string_1", "le text"),
                    ("string_2", "le more text"),
                    ("string_3", "le even more text"),
                    ("string_4", "le text which has been abandoned"),
                ]),
                expected_num_messages: 3,
                expected: vec![
                    (2935634291568311942, "le text".to_string()),
                    (14010255246293253599, "le more text".to_string()),
                    (11619890714301104023, "le even more text".to_string()),
                ],
            },
        ];
        for test in tests {
            let model =
                Model::from_dictionaries("und-x-src", &test.source, "und-x-dest", &test.target)
                    .with_context(|| format!("in test '{}', while building model", test.name))?;
            let expected = Model::from_parts(
                "und-x-dest",
                "und-x-src",
                test.expected_num_messages,
                super::as_messages(&test.expected),
            );
            assert_eq!(expected, model);
        }
        Ok(())
    }

    #[test]
    fn build_from_dictionary_fails() -> Result<()> {
        struct TestCase {
            name: &'static str,
            source: parser::Dictionary,
            target: parser::Dictionary,
        };
        let tests = vec![TestCase {
            name: "untranslated messages are disallowed",
            source: parser::Dictionary::from_init(&vec![
                ("string_1", "text"),
                ("string_2", "more text"),
                ("string_3", "even more text"),
                ("string_4", "untranslated text"),
            ]),
            target: parser::Dictionary::from_init(&vec![
                ("string_1", "le text"),
                ("string_2", "le more text"),
                ("string_3", "le even more text"),
            ]),
        }];
        for test in tests {
            let model =
                Model::from_dictionaries("und-x-src", &test.source, "und-x-dest", &test.target);
            match model {
                Ok(_) => return Err(anyhow::anyhow!("unexpectedly passing test: '{}'", test.name)),
                Err(_) => { /* expected */ }
            }
        }
        Ok(())
    }
}

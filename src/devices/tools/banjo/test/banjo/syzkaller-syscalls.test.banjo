// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library banjo.examples.syzkaller.syscalls;

resource handle: ZX_HANDLE_INVALID;
resource handle<process>: ZX_HANDLE_INVALID;
resource handle<thread>: ZX_HANDLE_INVALID;
resource handle<vmo>: ZX_HANDLE_INVALID;
resource handle<channel>: ZX_HANDLE_INVALID;
resource handle<event>: ZX_HANDLE_INVALID;
resource handle<port>: ZX_HANDLE_INVALID;
resource handle<interrupt>: ZX_HANDLE_INVALID;
resource handle<log>: ZX_HANDLE_INVALID;
resource handle<socket>: ZX_HANDLE_INVALID;
resource handle<resource>: ZX_HANDLE_INVALID;
resource handle<eventpair>: ZX_HANDLE_INVALID;
resource handle<job>: ZX_HANDLE_INVALID;
resource handle<vmar>: ZX_HANDLE_INVALID;
resource handle<fifo>: ZX_HANDLE_INVALID;
resource handle<guest>: ZX_HANDLE_INVALID;
resource handle<timer>: ZX_HANDLE_INVALID;
resource handle<bti>: ZX_HANDLE_INVALID;
resource handle<profile>: ZX_HANDLE_INVALID;
resource handle<debuglog>: ZX_HANDLE_INVALID;
resource handle<vcpu>: ZX_HANDLE_INVALID;
resource handle<iommu>: ZX_HANDLE_INVALID;
resource handle<pager>: ZX_HANDLE_INVALID;
resource handle<pmt>: ZX_HANDLE_INVALID;
resource zx.time: 0, ZX_TIME_INFINITE;
resource zx.koid: 0;


//
//
// Time
//
//

enum zx_clock_id : zx.clock {
    ZX_CLOCK_MONOTONIC = 0;
    ZX_CLOCK_UTC = 1;
    ZX_CLOCK_THREAD = 2;
};

//
//
// System information
//
//

enum zx_feature_kind : uint32 {
    ZX_FEATURE_KIND_CPU = 0;
    ZX_FEATURE_KIND_HW_BREAKPOINT_COUNT = 1;
    ZX_FEATURE_KIND_HW_WATCHPOINT_COUNT = 2;
};

enum zx_event_kind : uint32 {
    ZX_SYSTEM_EVENT_LOW_MEMORY = 0;
};

//
//
// Abstraction of machine operations
//
//

enum zx_cache_flush_options : uint32 {
    ZX_CACHE_FLUSH_DATA = 1;        // 1u << 0
    ZX_CACHE_FLUSH_INVALIDATE = 2;  // 1u << 1
    ZX_CACHE_FLUSH_INSN = 4;        // 1u << 2
};

//
//
// Generic handle operations
//
//

enum zx_rights : zx.rights {
    ZX_RIGHT_NONE = 0;                  // 0u
    ZX_RIGHT_DUPLICATE = 1;             // 1u << 0
    ZX_RIGHT_TRANSFER = 2;              // 1u << 1
    ZX_RIGHT_READ = 4;                  // 1u << 2
    ZX_RIGHT_WRITE = 8;                 // 1u << 3
    ZX_RIGHT_EXECUTE = 16;              // 1u << 4
    ZX_RIGHT_MAP = 32;                  // 1u << 5
    ZX_RIGHT_GET_PROPERTY = 64;         // 1u << 6
    ZX_RIGHT_SET_PROPERTY = 128;        // 1u << 7
    ZX_RIGHT_ENUMERATE = 256;           // 1u << 8
    ZX_RIGHT_DESTROY = 512;             // 1u << 9
    ZX_RIGHT_SET_POLICY = 1024;         // 1u << 10
    ZX_RIGHT_GET_POLICY = 2048;         // 1u << 11
    ZX_RIGHT_SIGNAL = 4096;             // 1u << 12
    ZX_RIGHT_SIGNAL_PEER = 8192;        // 1u << 13
    ZX_RIGHT_WAIT = 16384;              // 1u << 14
    ZX_RIGHT_INSPECT = 32768;           // 1u << 15
    ZX_RIGHT_MANAGE_JOB = 65536;        // 1u << 16
    ZX_RIGHT_MANAGE_PROCESS = 131072;   // 1u << 17
    ZX_RIGHT_MANAGE_THREAD = 262144;    // 1u << 18
    ZX_RIGHT_APPLY_PROFILE = 524288;    // 1u << 19
    ZX_RIGHT_SAME_RIGHTS = 2147483648;  // 1u << 31
};

//
//
// Generic object operations
//
//

enum zx_object_wait_async_options : uint32 {
    ZX_WAIT_ASYNC_TIMESTAMP = 1;
};

// TODO(SEC-368): conditional declaration
enum zx_object_property_values : uint32 {
    ZX_PROP_NAME = 3;
    // if __x86_64__
    //ZX_PROP_REGISTER_GS = 2;
    //ZX_PROP_REGISTER_FS = 4;
    // #endif
    ZX_PROP_PROCESS_DEBUG_ADDR = 5;
    ZX_PROP_PROCESS_VDSO_BASE_ADDRESS = 6;
    ZX_PROP_SOCKET_RX_THRESHOLD = 12;
    ZX_PROP_SOCKET_TX_THRESHOLD = 13;
    ZX_PROP_JOB_KILL_ON_OOM = 15;
    ZX_PROP_EXCEPTION_STATE = 16;
};

// 1-1 mapping with zx_object_property_values
union zx_object_property_handles {
    handle type1;           // ZX_PROP_NAME
    handle<process> type2;  // ZX_PROP_PROCESS_DEBUG_ADDR
    handle<process> type3;  // ZX_PROP_PROCESS_VDSO_BASE_ADDRESS
    handle<socket> type4;   // ZX_PROP_SOCKET_RX_THRESHOLD
    handle<socket> type5;   // ZX_PROP_SOCKET_TX_THRESHOLD
    handle<job> type6;      // ZX_PROP_JOB_KILL_ON_OOM
    handle type7;           // ZX_PROP_EXCEPTION_STATE
};

enum zx_object_info_topics : uint32 {
    ZX_INFO_NONE = 0;
    ZX_INFO_HANDLE_VALID = 1;
    ZX_INFO_HANDLE_BASIC = 2;
    ZX_INFO_PROCESS = 3;
    ZX_INFO_PROCESS_THREADS = 4;
    ZX_INFO_VMAR = 7;
    ZX_INFO_JOB_CHILDREN = 8;
    ZX_INFO_JOB_PROCESSES = 9;
    ZX_INFO_THREAD = 10;
    ZX_INFO_THREAD_EXCEPTION_REPORT = 11;
    ZX_INFO_TASK_STATS = 12;
    ZX_INFO_PROCESS_MAPS = 13;
    ZX_INFO_PROCESS_VMOS = 14;
    ZX_INFO_THREAD_STATS = 15;
    ZX_INFO_CPU_STATS = 16;
    ZX_INFO_KMEM_STATS = 17;
    ZX_INFO_RESOURCE = 18;
    ZX_INFO_HANDLE_COUNT = 19;
    ZX_INFO_BTI = 20;
    ZX_INFO_PROCESS_HANDLE_STATS = 21;
    ZX_INFO_SOCKET = 22;
    ZX_INFO_VMO = 23;
    ZX_INFO_JOB = 24;
};

// 1-1 mapping with zx_object_info_topics
[argtype = "type1 OUT",
 argtype = "type2 OUT",
 argtype = "type3 OUT",
 argtype = "type4 OUT",
 argtype = "type5 OUT",
 argtype = "type6 OUT",
 argtype = "type7 OUT",
 argtype = "type8 OUT",
 argtype = "type9 OUT",
 argtype = "type10 OUT",
 argtype = "type11 OUT"
 argtype = "type12 OUT",
 argtype = "type13 OUT",
 argtype = "type14 OUT",
 argtype = "type15 OUT",
 argtype = "type16 OUT",
 argtype = "type17 OUT",
 argtype = "type18 OUT",
 argtype = "type19 OUT",
 argtype = "type20 OUT",
 argtype = "type21 OUT",
 argtype = "type22 OUT",
 argtype = "type23 OUT"]
union zx_object_info_types {
    array<bool>:1 type1;                            // ZX_INFO_NONE
    array<bool>:1 type2;                            // ZX_INFO_HANDLE_VALID
    array<zx_info_handle_basic>:1 type3;            // ZX_INFO_HANDLE_BASIC
    array<zx_info_process>:1 type4;                 // ZX_INFO_PROCESS
    array<zx.koid>:unknown type5;                   // ZX_INFO_PROCESS_THREADS
    array<zx_info_vmar>:1 type6;                    // ZX_INFO_VMAR
    array<zx.koid>:unknown type7;                   // ZX_INFO_JOB_CHILDREN
    array<zx.koid>:unknown type8;                   // ZX_INFO_JOB_PROCESSES
    array<zx_info_thread>:1 type9;                  // ZX_INFO_THREAD
    array<zx_exception_report>:1 type10;            // ZX_INFO_THREAD_EXCEPTION_REPORT
    array<zx_info_task_stats>:1 type11;             // ZX_INFO_TASK_STATS
    array<zx_info_maps>:unknown type12;             // ZX_INFO_PROCESS_MAPS
    array<zx_info_vmo>:unknown type13;              // ZX_INFO_PROCESS_VMOS
    array<zx_info_thread_stats>:1 type14;           // ZX_INFO_THREAD_STATS
    array<zx_info_cpu_stats>:unknown type15;        // ZX_INFO_CPU_STATS
    array<zx_info_kmem_stats>:1 type16;             // ZX_INFO_KMEM_STATS
    array<zx_info_resource>:1 type17;               // ZX_INFO_RESOURCE
    array<zx_info_handle_count>:1 type18;           // ZX_INFO_HANDLE_COUNT
    array<zx_info_bti>:1 type19;                    // ZX_INFO_BTI
    array<zx_info_process_handle_stats>:1 type20;   // ZX_INFO_PROCESS_HANDLE_STATS
    array<zx_info_socket>:1 type21;                 // ZX_INFO_SOCKET
    array<zx_info_vmo>:1 type22;                    // ZX_INFO_VMO
    array<zx_info_job>:1 type23;                    // ZX_INFO_JOB
};

// 1-1 mapping with zx_object_info_topics
union zx_object_info_handles {
    handle type1;               // ZX_INFO_NONE
    handle type2;               // ZX_INFO_HANDLE_VALID
    handle type3;               // ZX_INFO_HANDLE_BASIC
    handle<process> type4;      // ZX_INFO_PROCESS
    handle<process> type5;      // ZX_INFO_PROCESS_THREADS
    handle<vmar> type6;         // ZX_INFO_VMAR
    handle<job> type7;          // ZX_INFO_JOB_CHILDREN
    handle<job> type8;          // ZX_INFO_JOB_PROCESSES
    handle<thread> type9;       // ZX_INFO_THREAD
    handle<thread> type10;      // ZX_INFO_THREAD_EXCEPTION_REPORT
    handle<process> type11;     // ZX_INFO_TASK_STATS
    handle<process> type12;     // ZX_INFO_PROCESS_MAPS
    handle<process> type13;     // ZX_INFO_PROCESS_VMOS
    handle<thread> type14;      // ZX_INFO_THREAD_STATS
    handle<resource> type15;    // ZX_INFO_CPU_STATS ?
    handle<resource> type16;    // ZX_INFO_KMEM_STATS ?
    handle<resource> type17;    // ZX_INFO_RESOURCE
    handle type18;              // ZX_INFO_HANDLE_COUNT
    handle<bti> type19;         // ZX_INFO_BTI
    handle<process> type20;     // ZX_INFO_PROCESS_HANDLE_STATS
    handle<socket> type21;      // ZX_INFO_SOCKET
    handle<vmo> type22;         // ZX_INFO_VMO
    handle<job> type23;         // ZX_INFO_JOB
};

enum zx_obj_types : uint32 {
    ZX_OBJ_TYPE_NONE = 0;
    ZX_OBJ_TYPE_PROCESS = 1;
    ZX_OBJ_TYPE_THREAD = 2;
    ZX_OBJ_TYPE_VMO = 3;
    ZX_OBJ_TYPE_CHANNEL = 4;
    ZX_OBJ_TYPE_EVENT = 5;
    ZX_OBJ_TYPE_PORT = 6;
    ZX_OBJ_TYPE_INTERRUPT = 9;
    ZX_OBJ_TYPE_PCI_DEVICE = 11;
    ZX_OBJ_TYPE_LOG = 12;
    ZX_OBJ_TYPE_SOCKET = 14;
    ZX_OBJ_TYPE_RESOURCE = 15;
    ZX_OBJ_TYPE_EVENTPAIR = 16;
    ZX_OBJ_TYPE_JOB = 17;
    ZX_OBJ_TYPE_VMAR = 18;
    ZX_OBJ_TYPE_FIFO = 19;
    ZX_OBJ_TYPE_GUEST = 20;
    ZX_OBJ_TYPE_VCPU = 21;
    ZX_OBJ_TYPE_TIMER = 22;
    ZX_OBJ_TYPE_IOMMU = 23;
    ZX_OBJ_TYPE_BTI = 24;
    ZX_OBJ_TYPE_PROFILE = 25;
    ZX_OBJ_TYPE_PMT = 26;
    ZX_OBJ_TYPE_SUSPEND_TOKEN = 27;
    ZX_OBJ_TYPE_PAGER = 28;
    ZX_OBJ_TYPE_EXCEPTION = 29;
};

[valueset = "rights zx_rights",
 valueset = "props zx_obj_props",
 valueset = "type zx_obj_types"]
struct zx_info_handle_basic {
    zx.koid koid;
    zx.rights rights;
    uint32 type;
    zx.koid related_koid;
    uint32 props;
};

struct zx_info_handle_count {
    uint32 handle_count;
};

[argtype = "handle_count OUT"]
struct zx_info_process_handle_stats {
    array<uint32>:64 handle_count; // #define ZX_OBJ_TYPE_UPPER_BOUND ((zx_obj_type_t)64u)
};

struct zx_info_process {
    int64 return_code;
    bool started;
    bool exited;
    bool debugger_attached;
};

struct zx_info_job {
    int64 return_code;
    bool exited;
    bool kill_on_oom;
    bool debugger_attached;
};

enum zx_thread_state_values : uint32 {
    ZX_THREAD_STATE_NEW = 0;                    // 0x0000u
    ZX_THREAD_STATE_RUNNING = 1;                // 0x0001u
    ZX_THREAD_STATE_SUSPENDED = 2;              // 0x0002u
    ZX_THREAD_STATE_BLOCKED = 3;                // 0x0003u
    ZX_THREAD_STATE_DYING = 4;                  // 0x0004u
    ZX_THREAD_STATE_DEAD = 5;                   // 0x0005u
    ZX_THREAD_STATE_BLOCKED_EXCEPTION = 259;    // 0x0103u
    ZX_THREAD_STATE_BLOCKED_SLEEPING = 515;     // 0x0203u
    ZX_THREAD_STATE_BLOCKED_FUTEX = 771;        // 0x0303u
    ZX_THREAD_STATE_BLOCKED_PORT = 1027;        // 0x0403u
    ZX_THREAD_STATE_BLOCKED_CHANNEL = 1283;     // 0x0503u
    ZX_THREAD_STATE_BLOCKED_WAIT_ONE = 1539;    // 0x0603u
    ZX_THREAD_STATE_BLOCKED_WAIT_MANY = 1795;   // 0x0703u
    ZX_THREAD_STATE_BLOCKED_INTERRUPT = 2051;   // 0x0803u
    ZX_THREAD_STATE_BLOCKED_PAGER = 2307;       // 0x0903u
};

enum zx_exception_channel_types : uint32 {
    ZX_EXCEPTION_CHANNEL_TYPE_NONE = 0;
    ZX_EXCEPTION_CHANNEL_TYPE_DEBUGGER = 1;
    ZX_EXCEPTION_CHANNEL_TYPE_THREAD = 2;
    ZX_EXCEPTION_CHANNEL_TYPE_PROCESS = 3;
    ZX_EXCEPTION_CHANNEL_TYPE_JOB = 4;
    ZX_EXCEPTION_CHANNEL_TYPE_JOB_DEBUGGER = 5;
};


[valueset = "state zx_thread_state_values"
 valueset = "wait_exception_channel_type zx_exception_channel_types"]
struct zx_info_thread {
    uint32 state;
    uint32 wait_exception_channel_type;
};

struct zx_info_thread_stats {
    zx.duration total_runtime;
};

struct zx_info_task_stats {
    usize mem_mapped_bytes;
    usize mem_private_bytes;
    usize mem_shared_bytes;
    usize mem_scaled_shared_bytes;
};

struct zx_info_vmar {
    usize base;     // uintptr_t base;
    usize len;
};

struct zx_info_bti {
    uint64 minimum_contiguity;
    uint64 aspace_size;
    uint64 pmo_count;
    uint64 quarantine_count;
};

[valueset = "options zx_socket_create_options"]
struct zx_info_socket {
    uint32 options;
    usize rx_buf_max;
    usize rx_buf_size;
    usize rx_buf_available;
    usize tx_buf_max;
    usize tx_buf_size;
};

struct zx_info_maps_mapping {
    zx.vm_option mmu_flags;
    zx.koid vmo_koid;
    uint64 vmo_offset;
    usize committed_pages;
};

enum zx_info_maps_type_vals : uint32 {
    ZX_INFO_MAPS_TYPE_NONE = 0;
    ZX_INFO_MAPS_TYPE_ASPACE = 1;
    ZX_INFO_MAPS_TYPE_VMAR = 2;
    ZX_INFO_MAPS_TYPE_MAPPING = 3;
};

// TODO(SEC-369): nested named union
[valueset = "type zx_info_maps_type_vals",
 argtype = "name IN"]
struct zx_info_maps {
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
    zx.vaddr base;
    usize size;
    usize depth;
    uint32 type;
    //union {
        //zx_info_maps_mapping mapping;
    //} u;
};

enum zx_cache_policy_options : uint32 {
    ZX_CACHE_POLICY_CACHED = 0;
    ZX_CACHE_POLICY_UNCACHED = 1;
    ZX_CACHE_POLICY_UNCACHED_DEVICE = 2;
    ZX_CACHE_POLICY_WRITE_COMBINING = 3;
    ZX_CACHE_POLICY_MASK = 3;
};

// TODO: bitwise or of flag values also needed
enum zx_info_vmo_type_vals : uint32 {
    ZX_INFO_VMO_TYPE_PAGED = 1;     // 1u << 0
    ZX_INFO_VMO_TYPE_PHYSICAL = 0;  // 0u << 0
    ZX_INFO_VMO_RESIZABLE = 2;      // 1u << 1
    ZX_INFO_VMO_IS_COW_CLONE = 4;   // 1u << 2
    ZX_INFO_VMO_VIA_HANDLE = 8;     // 1u << 3
    ZX_INFO_VMO_VIA_MAPPING = 16;   // 1u << 4
    ZX_INFO_VMO_PAGER_BACKED = 32;  // 1u << 5
    ZX_INFO_VMO_CONTIGUOUS = 64;    // 1u << 6
};

[valueset = "cache_policy zx_cache_policy_options",
 valueset = "flags zx_info_vmo_type_vals",
 valueset = "handle_rights zx_rights",
 argtype = "name IN"]
struct zx_info_vmo {
    zx.koid koid;
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
    uint64 size_bytes;
    zx.koid parent_koid;
    usize num_children;
    usize num_mappings;
    usize share_count;
    uint32 flags;
    uint64 committed_bytes;
    zx.rights handle_rights;
    uint32 cache_policy;
};

struct zx_info_cpu_stats {
    uint32 cpu_number;
    uint32 flags;
    zx.duration idle_time;
    uint64 reschedules;
    uint64 context_switches;
    uint64 irq_preempts;
    uint64 preempts;
    uint64 yields;
    uint64 ints;
    uint64 timer_ints;
    uint64 timers;
    uint64 page_faults;
    uint64 exceptions;
    uint64 syscalls;
    uint64 reschedule_ipis;
    uint64 generic_ipis;
};

struct zx_info_kmem_stats {
    uint64 total_bytes;
    uint64 free_bytes;
    uint64 wired_bytes;
    uint64 total_heap_bytes;
    uint64 free_heap_bytes;
    uint64 vmo_bytes;
    uint64 mmu_overhead_bytes;
    uint64 ipc_bytes;
    uint64 other_bytes;
};

[valueset = "kind zx_rsrc_kind_vals",
 argtype = "name IN"]
struct zx_info_resource {
    uint32 kind;
    uint32 flags;
    uint64 base;
    usize size;
    // TODO: #define ZX_MAX_NAME_LEN ((size_t)32u)
    array<int8>:32 name;
};

struct zx_wait_item {
    handle handle;
    zx.signals waitfor;
    zx.signals pending;
};

struct zx_exception_header {
    uint32 size;
    uint32 type; // zx_excp_type_t type;
};

struct zx_x86_64_exc_data {
    uint64 vector;
    uint64 err_code;
    uint64 cr2;
};

struct zx_arm64_exc_data {
    uint32 esr;
    uint64 far;
};

struct zx_exception_context {
    //struct {
        //union {
            //zx_x86_64_exc_data x86_64;
            //zx_arm64_exc_data  arm_64;
        //} u;
    //} arch;
};

struct zx_exception_report {
    zx_exception_header header;
    zx_exception_context context;
};

//
//
// IPC: Sockets
//
//

enum zx_socket_create_options : uint32 {
    ZX_SOCKET_STREAM = 0;       // 0u
    ZX_SOCKET_DATAGRAM = 1;     // 1u << 0
    ZX_SOCKET_HAS_CONTROL = 2;  // 1u << 1
    ZX_SOCKET_HAS_ACCEPT = 4;   // 1u << 2
};

enum zx_socket_read_options : uint32 {
    ZX_SOCKET_CONTROL = 4;  // 1u << 2
    ZX_SOCKET_PEEK = 8;     // 1u << 3
};

enum zx_socket_write_options : uint32 {
    ZX_SOCKET_CONTROL = 4;  // 1u << 2

};

enum zx_socket_shutdown_options : uint32 {
    ZX_SOCKET_SHUTDOWN_WRITE = 1;   // 1u << 0
    ZX_SOCKET_SHUTDOWN_READ = 2;    // 1u << 1
};


//
//
// Threads
//
//

enum thread_state_kind : uint32 {
    ZX_THREAD_STATE_GENERAL_REGS = 0;
    ZX_THREAD_STATE_FP_REGS = 1;
    ZX_THREAD_STATE_VECTOR_REGS = 2;
    ZX_THREAD_STATE_DEBUG_REGS = 4;
    ZX_THREAD_STATE_SINGLE_STEP = 5;
    ZX_THREAD_X86_REGISTER_FS = 6;
    ZX_THREAD_X86_REGISTER_GS = 7;
};

// TODO(SEC-368): These unions need the architecture
// dependent struct declarations to be present

//// 1-1 mapping with thread_state_kind
//[argtype = "type1 OUT",
 //argtype = "type2 OUT",
 //argtype = "type3 OUT",
 //argtype = "type4 OUT",
 //argtype = "type5 OUT",
 //argtype = "type6 OUT",
 //argtype = "type7 OUT"]
//union zx_thread_read_state_types {
    //array<zx_thread_state_general_regs>:1 type1;
    //array<zx_thread_state_fp_regs>:1 type2;
    //array<zx_thread_state_vector_regs>:1 type3;
    //array<zx_thread_state_debug_regs>:1 type4;
    //array<uint32>:1 type5;
    //array<uint32>:1 type6;
    //array<uint32>:1 type7;
//};
//
//// 1-1 mapping with thread_state_kind
//[argtype = "type1 IN",
 //argtype = "type2 IN",
 //argtype = "type3 IN",
 //argtype = "type4 IN",
 //argtype = "type5 IN",
 //argtype = "type6 IN",
 //argtype = "type7 IN"]
//union zx_thread_write_state_types {
    //array<zx_thread_state_general_regs>:1 type1;
    //array<zx_thread_state_fp_regs>:1 type2;
    //array<zx_thread_state_vector_regs>:1 type3;
    //array<zx_thread_state_debug_regs>:1 type4;
    //array<uint32>:1 type5;
    //array<uint32>:1 type6;
    //array<uint32>:1 type7;
//};

// TODO(SEC-368): conditional declaration
//#if defined(__x86_64__)
//struct zx_thread_state_general_regs {
    //uint64 rax;
    //uint64 rbx;
    //uint64 rcx;
    //uint64 rdx;
    //uint64 rsi;
    //uint64 rdi;
    //uint64 rbp;
    //uint64 rsp;
    //uint64 r8;
    //uint64 r9;
    //uint64 r10;
    //uint64 r11;
    //uint64 r12;
    //uint64 r13;
    //uint64 r14;
    //uint64 r15;
    //uint64 rip;
    //uint64 rflags;
    //uint64 fs_base;
    //uint64 gs_base;
//};
//
//struct zx_thread_state_fp_regs {
    //uint16 fcw; // Control word.
    //uint16 fsw; // Status word.
    //uint8 ftw;  // Tag word.
    //uint8 reserved;
    //uint16 fop; // Opcode.
    //uint64 fip; // Instruction pointer.
    //uint64 fdp; // Data pointer.
    ////__ALIGNED(16)
    ////struct {
        ////uint64 low;
        ////uint64 high;
    ////} st[8];
//};
//
//
//[argtype = "opmask IN"]
//struct zx_thread_state_vector_regs {
    ////struct {
        ////uint64 v[8];
    ////} zmm[32];
    //array<uint64>:8 opmask;
    //uint32 mxcsr;
//};
//
//[argtype = "dr IN"]
//struct zx_thread_state_debug_regs {
    //array<uint64>:4 dr;
    //uint64 dr6;
    //uint64 dr7;
    //uint64 dr6_status;
    //uint64 dr7_control;
//};

//#elif defined(__aarch64__)
//#endif

//
//
// Jobs
//
//

enum zx_job_policy_options : uint32 {
    ZX_JOB_POL_RELATIVE = 0;
    ZX_JOB_POL_ABSOLUTE = 1;
};

enum zx_job_policy_topic : uint32 {
    ZX_JOB_POL_BASIC = 0;
    ZX_JOB_POL_TIMER_SLACK = 1;
};

// 1-1 mapping with zx_job_policy_topic
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_job_policy_types {
    array<zx_policy_basic>:1 type1;
    array<zx_policy_timer_slack>:1 type2;
};

[valueset="condition zx_job_policy_conditions",
 valueset="policy zx_job_policy_actions"]
struct zx_policy_basic {
    uint32 condition;
    uint32 policy;
};

struct zx_policy_timer_slack {
    zx.duration min_slack;
    uint32 default_mode;
};

enum zx_job_policy_conditions : uint32 {
    ZX_POL_BAD_HANDLE = 0;
    ZX_POL_WRONG_OBJECT = 1;
    ZX_POL_VMAR_WX = 2;
    ZX_POL_NEW_ANY = 3;
    ZX_POL_NEW_VMO = 4;
    ZX_POL_NEW_CHANNEL = 5;
    ZX_POL_NEW_EVENT = 6;
    ZX_POL_NEW_EVENTPAIR = 7;
    ZX_POL_NEW_PORT = 8;
    ZX_POL_NEW_SOCKET = 9;
    ZX_POL_NEW_FIFO = 10;
    ZX_POL_NEW_TIMER = 11;
    ZX_POL_NEW_PROCESS = 12;
    ZX_POL_NEW_PROFILE = 13;
    ZX_POL_AMBIENT_MARK_VMO_EXEC = 14;
    // #ifdef _KERNEL
    //ZX_POL_MAX = 15;
    // #endif
};

enum zx_job_policy_actions : uint32 {
    ZX_POL_ACTION_ALLOW = 0;
    ZX_POL_ACTION_DENY = 1;
    ZX_POL_ACTION_ALLOW_EXCEPTION = 2;
    ZX_POL_ACTION_DENY_EXCEPTION = 3;
    ZX_POL_ACTION_KILL = 4;
    // #ifdef _KERNEL
    //ZX_POL_ACTION_MAX = 5;
    // #endif
};

//
//
// Ports
//
//

enum zx_port_create_options : uint32 {
    ZX_PORT_BIND_TO_INTERRUPT = 1;  // 0x1u << 0

};

enum zx_port_packet_type : uint32 {
    ZX_PKT_TYPE_USER = 0;           // 0x00u
    ZX_PKT_TYPE_SIGNAL_ONE = 1;     // 0x01u
    ZX_PKT_TYPE_GUEST_BELL = 3;     // 0x03u
    ZX_PKT_TYPE_GUEST_MEM = 4;      // 0x04u
    ZX_PKT_TYPE_GUEST_IO = 5;       // 0x05u
    ZX_PKT_TYPE_GUEST_VCPU = 6;     // 0x06u
    ZX_PKT_TYPE_INTERRUPT = 7;      // 0x07u
    ZX_PKT_TYPE_PAGE_REQUEST = 9;   // 0x09u
};

[argtype = "u64 IN",
 argtype = "u32 IN",
 argtype = "u16 IN",
 argtype = "c8 IN"]
union zx_packet_user {
    array<uint64>:4 u64;
    array<uint32>:8 u32;
    array<uint16>:16 u16;
    array<int8>:32 c8;
};

struct zx_packet_signal {
    zx.signals trigger;
    zx.signals observed;
    uint64 count;
    uint64 reserved0;
    uint64 reserved1;
};

struct zx_packet_guest_bell {
    zx.gpaddr addr;
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

// TODO(SEC-368): conditional declaration
[argtype = "inst_buf IN",
 argtype = "reserved IN"]
struct zx_packet_guest_mem {
    zx.gpaddr addr;
//#if __aarch64__
    //uint8 access_size;
    //bool sign_extend;
    //uint8 xt;
    //bool read;
    //uint64 data;
    //uint64 reserved;
//#elif __x86_64__
    uint8 inst_len;
    array<int8>:15 inst_buf;
    uint8 default_operand_size;
    array<uint8>:7 reserved;
//#endif
};

// TODO(SEC-369): anonymous union
struct zx_packet_guest_io {
    uint16 port;
    uint8 access_size;
    bool input;
    //union {
        //uint8 u8;
        //uint16 u16;
        //uint32 u32;
        //array<uint8>:4 data;
    //};
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

// TODO(SEC-369): anonymous union
struct zx_packet_guest_vcpu {
    //union {
        //struct {
            //uint64 mask;
            //uint8 vector;
        //} interrupt;
        //struct {
            //uint64 id;
            //zx.gpaddr entry;
        //} startup;
    //};
    uint8 type;
    uint64 reserved;
};

struct zx_packet_interrupt {
    zx.time timestamp;
    uint64 reserved0;
    uint64 reserved1;
    uint64 reserved2;
};

struct zx_packet_page_request {
    uint16 command;
    uint16 flags;
    uint32 reserved0;
    uint64 offset;
    uint64 length;
    uint64 reserved1;
};

// TODO(SEC-369): anonymous union
[valueset = "type zx_port_packet"]
struct zx_port_packet {
    uint64 key;
    uint32 type;
    zx.status status;
    //union {
        //zx_packet_user user;
        //zx_packet_signal signal;
        //zx_packet_guest_bell guest_bell;
        //zx_packet_guest_mem guest_mem;
        //zx_packet_guest_io guest_io;
        //zx_packet_guest_vcpu guest_vcpu;
        //zx_packet_interrupt interrupt;
        //zx_packet_page_request page_request;
    //};
};


//
//
// Timers
//
//

enum zx_timer_options : uint32 {
    ZX_TIMER_SLACK_CENTER = 0;
    ZX_TIMER_SLACK_EARLY = 1;
    ZX_TIMER_SLACK_LATE = 2;
};

//
//
// Memory management
//
//

enum zx_vmo_create_options : uint32 {
    ZX_VMO_RESIZABLE = 2;   // 1u << 1
};

enum zx_vmo_opcodes : uint32 {
    ZX_VMO_OP_COMMIT = 1;
    ZX_VMO_OP_DECOMMIT = 2;
    ZX_VMO_OP_LOCK = 3;
    ZX_VMO_OP_UNLOCK = 4;
    // opcode 5 was ZX_VMO_OP_LOOKUP, but is now unused.
    ZX_VMO_OP_CACHE_SYNC = 6;
    ZX_VMO_OP_CACHE_INVALIDATE = 7;
    ZX_VMO_OP_CACHE_CLEAN = 8;
    ZX_VMO_OP_CACHE_CLEAN_INVALIDATE = 9;
};

enum zx_vmo_cache_policy_options : uint32 {
    ZX_CACHE_POLICY_CACHED = 0;
    ZX_CACHE_POLICY_UNCACHED = 1;
    ZX_CACHE_POLICY_UNCACHED_DEVICE = 2;
    ZX_CACHE_POLICY_WRITE_COMBINING = 3;
    ZX_CACHE_POLICY_MASK = 3;
};

enum zx_vmo_clone_options : uint32 {
    ZX_VMO_CLONE_COPY_ON_WRITE = 1; // 1u << 0
    ZX_VMO_CHILD_COPY_ON_WRITE = 1; // 1u << 0
    ZX_VMO_CHILD_RESIZABLE = 4;     // 1u << 2
};

//
//
// Address space management
//
//

enum zx_vmar_allocate_map_options : zx.vm_option {
    ZX_VM_PERM_READ = 1;                // 1u << 0
    ZX_VM_PERM_WRITE = 2;               // 1u << 1
    ZX_VM_PERM_EXECUTE = 4;             // 1u << 2
    ZX_VM_COMPACT = 8;                  // 1u << 3
    ZX_VM_SPECIFIC = 16;                // 1u << 4
    ZX_VM_SPECIFIC_OVERWRITE = 32;      // 1u << 5
    ZX_VM_CAN_MAP_SPECIFIC = 64;        // 1u << 6
    ZX_VM_CAN_MAP_READ = 128;           // 1u << 7
    ZX_VM_CAN_MAP_WRITE = 256;          // 1u << 8
    ZX_VM_CAN_MAP_EXECUTE = 512;        // 1u << 9
    ZX_VM_MAP_RANGE = 1024;             // 1u << 10
    ZX_VM_REQUIRE_NON_RESIZABLE = 2048; // 1u << 11
    ZX_VM_ALLOW_FAULTS = 4096;          // 1u << 12

    ZX_VM_ALIGN_1KB = 167772160;        // 10u << 24
    ZX_VM_ALIGN_2KB = 184549376;        // 11u << 24
    ZX_VM_ALIGN_4KB = 201326592;        // 12u << 24
    ZX_VM_ALIGN_8KB = 218103808;        // 13u << 24
    ZX_VM_ALIGN_16KB = 234881024;       // 14u << 24
    ZX_VM_ALIGN_32KB = 251658240;       // 15u << 24
    ZX_VM_ALIGN_64KB = 268435456;       // 16u << 24
    ZX_VM_ALIGN_128KB = 285212672;      // 17u << 24
    ZX_VM_ALIGN_256KB = 301989888;      // 18u << 24
    ZX_VM_ALIGN_512KB = 318767104;      // 19u << 24
    ZX_VM_ALIGN_1MB = 335544320;        // 20u << 24
    ZX_VM_ALIGN_2MB = 352321536;        // 21u << 24
    ZX_VM_ALIGN_4MB = 369098752;        // 22u << 24
    ZX_VM_ALIGN_8MB = 385875968;        // 23u << 24
    ZX_VM_ALIGN_16MB = 402653184;       // 24u << 24
    ZX_VM_ALIGN_32MB = 419430400;       // 25u << 24
    ZX_VM_ALIGN_64MB = 436207616;       // 26u << 24
    ZX_VM_ALIGN_128MB = 452984832;      // 27u << 24
    ZX_VM_ALIGN_256MB = 469762048;      // 28u << 24
    ZX_VM_ALIGN_512MB = 486539264;      // 29u << 24
    ZX_VM_ALIGN_1GB = 503316480;        // 30u << 24
    ZX_VM_ALIGN_2GB = 520093696;        // 31u << 24
    ZX_VM_ALIGN_4GB = 536870912;        // 32u << 24
};

enum zx_vmar_protect_options : zx.vm_option {
    ZX_VM_PERM_READ = 1;    // 1u << 0
    ZX_VM_PERM_WRITE = 2;   // 1u << 1
    ZX_VM_PERM_EXECUTE = 4; // 1u << 2
};

//
//
// Profiles
//
//

enum zx_profile_scheduler_priority : int32 {
    ZX_PRIORITY_LOWEST = 0;
    ZX_PRIORITY_LOW = 8;
    ZX_PRIORITY_DEFAULT = 16;
    ZX_PRIORITY_HIGH = 24;
    ZX_PRIORITY_HIGHEST = 31;
};

enum zx_profile_info_type : uint32 {
    ZX_PROFILE_INFO_SCHEDULER = 1;
};

[valuset="priority zx_profile_scheduler_priority"]
struct zx_profile_scheduler {
    int32 priority;
    uint32 boost;
    uint32 deboost;
    uint32 quantum;
};


// TODO(SEC-369): anonymous union
[valueset = "type zx_profile_info_type"]
struct zx_profile_info {
    uint32 type;
    //union {
        //zx_profile_scheduler scheduler;
    //};
};

//
//
// Logging
//
//

enum zx_debuglog_create_options : uint32 {
    ZX_LOG_FLAG_READABLE = 1073741824;  // 0x40000000
};


//
//
// DDK Syscalls: Interrupts
//
//

enum zx_interrupt_options : uint32 {
    ZX_INTERRUPT_REMAP_IRQ = 1;         // 0x1u
    ZX_INTERRUPT_MODE_DEFAULT = 0;      // 0u << 1
    ZX_INTERRUPT_MODE_EDGE_LOW = 2;     // 1u << 1
    ZX_INTERRUPT_MODE_EDGE_HIGH = 4;    // 2u << 1
    ZX_INTERRUPT_MODE_LEVEL_LOW = 6;    // 3u << 1
    ZX_INTERRUPT_MODE_LEVEL_HIGH = 8;   // 4u << 1
    ZX_INTERRUPT_MODE_EDGE_BOTH = 10;   // 5u << 1
    ZX_INTERRUPT_MODE_MASK = 14;        // 0xe
    ZX_INTERRUPT_VIRTUAL = 16;          // 0x10
};

//
//
// DDK Syscalls: Device Memory Access
//
//

enum zx_iommu_type : uint32 {
    ZX_IOMMU_TYPE_DUMMY = 0;
    ZX_IOMMU_TYPE_INTEL = 1;
};

// 1-1 mapping with zx_iommu_type
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_iommu_types {
    array<zx_iommu_desc_dummy>:1 type1;
    array<zx_iommu_desc_intel>:1 type2;
};

struct zx_iommu_desc_dummy {
    uint8 reserved;
};

// TODO: include commented out structs from iommu.h
[argtype = "_reserved IN"]
struct zx_iommu_desc_intel {
    uint64 register_base;
    uint16 pci_segment;
    bool whole_segment;
    uint8 scope_bytes;
    uint16 reserved_memory_bytes;
    array<uint8>:2 _reserved;
};

enum zx_bti_pin_options : uint32 {
    ZX_BTI_PERM_READ = 1;       // 1u << 0
    ZX_BTI_PERM_WRITE = 2;      // 1u << 1
    ZX_BTI_PERM_EXECUTE = 4;    // 1u << 2
    ZX_BTI_COMPRESS = 8;        // 1u << 3
    ZX_BTI_CONTIGUOUS = 16;     // 1u << 4
};

//
//
// DDK Syscalls: PCI
//
//

struct zx_pci_bar {
    uint32 id;
    uint32 type;
    usize size;
    //union {
        //usize addr; // uintptr_t addr
        //handle handle;
    //};
};

struct zx_pcie_device_info {
    uint16 vendor_id;
    uint16 device_id;
    uint8  base_class;
    uint8  sub_class;
    uint8  program_interface;
    uint8  revision_id;
    uint8  bus_id;
    uint8  dev_id;
    uint8  func_id;
};

struct zx_pci_init_arg {
    //zx_pci_irq_swizzle_lut_t dev_pin_to_global_irq;
    uint32 num_irqs;
    //struct {
        //uint32 global_irq;
        //bool level_triggered;
        //bool active_high;
    //} irqs[ZX_PCI_MAX_IRQS];
    uint32 addr_window_count;
    //struct {
        //uint64_t base;
        //size_t size;
        //uint8 bus_start;
        //uint8 bus_end;
        //uint8 cfg_space_type;
        //bool has_ecam;
    //} addr_windows[];
};

//
//
// DDK Syscalls: SMC Calls
//
//

struct zx_smc_parameters {
    uint32 func_id;
    uint64 arg1;
    uint64 arg2;
    uint64 arg3;
    uint64 arg4;
    uint64 arg5;
    uint64 arg6;
    uint16 client_id;
    uint16 secure_os_id;
};

struct zx_smc_result {
    uint64 arg0;
    uint64 arg1;
    uint64 arg2;
    uint64 arg3;
    uint64 arg6;
};

//
//
// Resources
//
//

enum zx_rsrc_kind_vals : uint32 {
    ZX_RSRC_KIND_MMIO = 0;
    ZX_RSRC_KIND_IRQ = 1;
    ZX_RSRC_KIND_IOPORT = 2;
    ZX_RSRC_KIND_HYPERVISOR = 3;
    ZX_RSRC_KIND_ROOT = 4;
    ZX_RSRC_KIND_VMEX = 5;
    ZX_RSRC_KIND_SMC = 6;
};

//
//
// Hypervisor
//
//

enum zx_guest_trap_kind : uint32 {
    ZX_GUEST_TRAP_BELL = 0;
    ZX_GUEST_TRAP_MEM = 1;
    ZX_GUEST_TRAP_IO = 2;
};

enum zx_vcpu_read_state_kind : uint32 {
    ZX_VCPU_STATE = 0;
};

enum zx_vcpu_write_state_kind : uint32 {
    ZX_VCPU_STATE = 0;
    ZX_VCPU_IO = 1;
};

// 1-1 mapping with zx_vcpu_read_state_kind
[argtype = "type1 OUT"]
union zx_vcpu_read_state_types {
    array<zx_vcpu_state>:1 type1;
};

// 1-1 mapping with zx_vcpu_write_state_kind
[argtype = "type1 IN",
 argtype = "type2 IN"]
union zx_vcpu_write_state_types {
    array<zx_vcpu_state>:1 type1;
    array<zx_vcpu_io>:1 type2;
};

// TODO(SEC-368): conditional declaration
struct zx_vcpu_state {
//#if __aarch64__
    //array<uint64>:31 x;
    //uint64 sp;
    // Contains only the user-controllable upper 4-bits (NZCV).
    //uint32 cpsr;
//#elif __x86_64__
    uint64 rax;
    uint64 rcx;
    uint64 rdx;
    uint64 rbx;
    uint64 rsp;
    uint64 rbp;
    uint64 rsi;
    uint64 rdi;
    uint64 r8;
    uint64 r9;
    uint64 r10;
    uint64 r11;
    uint64 r12;
    uint64 r13;
    uint64 r14;
    uint64 r15;
    // Contains only the user-controllable lower 32-bits.
    uint64 rflags;
//#endif
};

// TODO(SEC-369): anonymous union
struct zx_vcpu_io {
    uint8 access_size;
    //union {
        //uint8 u8;
        //uint16 u16;
        //uint32 u32;
        //array<uint8>:4 data;
    //};
};

//
//
// System Control
//
//

enum zx_system_powerctl_cmd : uint32 {
    ZX_SYSTEM_POWERCTL_ENABLE_ALL_CPUS = 1;
    ZX_SYSTEM_POWERCTL_DISABLE_ALL_CPUS_BUT_PRIMARY = 2;
    ZX_SYSTEM_POWERCTL_ACPI_TRANSITION_S_STATE = 3;
    ZX_SYSTEM_POWERCTL_X86_SET_PKG_PL1 = 4;
    ZX_SYSTEM_POWERCTL_REBOOT = 5;
    ZX_SYSTEM_POWERCTL_REBOOT_BOOTLOADER = 6;
    ZX_SYSTEM_POWERCTL_REBOOT_RECOVERY = 7;
    ZX_SYSTEM_POWERCTL_SHUTDOWN = 8;
};

struct zx_system_powerctl_arg {
    //union {
        //struct {
            //uint8 target_s_state;
            //uint8 sleep_type_a;
            //uint8 sleep_type_b;
        //} acpi_transition_s_state;
        //struct {
            //uint32 power_limit;
            //uint32 time_window;
            //uint8 clamp;
            //uint8 enable;
        //} x86_power_limit;
    //};
};


// TODO: [extern] struct uintptr_t {}; add to zx.banjo?
// TODO: [extern] struct zx_futex_t {}; add to zx.banjo?

protocol Api {

    //
    //
    // Time
    //
    //

    /// Acquire the current time.
    [valueset = "clock_id zx_clock_id"]
    clock_get(zx.clock clock_id) -> (zx.status status, zx.time out);

    /// Acquire the current time.
    [valueset = "clock_id zx_clock_id"]
    clock_get_new(zx.clock clock_id) -> (zx.status status, zx.time out);

    /// Acquire the current monotonic time.
    clock_get_monotonic() -> (zx.time time);

    /// High resolution sleep.
    [rights="None.",
     blocking]
    nanosleep(zx.time deadline) -> (zx.status status);

    /// Read the number of high-precision timer ticks since boot.
    [vdsocall]
    ticks_get() -> (zx.ticks ticks);

    /// Read the number of high-precision timer ticks in a second.
    [vdsocall,
     const]
    ticks_per_second() -> (zx.ticks ticks);

    /// Convert a time relative to now to an absolute deadline.
    [vdsocall]
    deadline_after(zx.duration nanoseconds) -> (zx.time time);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     valueset = "clock_id zx_clock_id"]
    clock_adjust(handle<resource> handle, zx.clock clock_id, int64 offset) -> (zx.status status);

    //
    //
    // System information
    //
    //

    [vdsocall,
     const]
    system_get_dcache_line_size() -> (uint32 size);

    /// Get number of logical processors on the system.
    [vdsocall,
     const]
    system_get_num_cpus() -> (uint32 count);

    /// Get version string for system.
    [vdsocall,
     argtype="version OUT"]
    system_get_version(string:version_size version, usize version_size) ->
        (zx.status status);

    /// Get amount of physical memory on the system.
    [vdsocall]
    system_get_physmem() -> (uint64 physmem);

    /// Get supported hardware capabilities.
    [vdsocall,
     argtype="features features",
     valueset="kind zx_feature_kind"]
    system_get_features(uint32 kind) -> (zx.status status, uint32 features);

    /// Retrieve a handle to a system event.
    [rights="None.",
     valueset = "kind zx_event_kind"]
    system_get_event(handle<job> root_job, uint32 kind) -> (zx.status status, handle<event> event);

    //
    //
    // Abstraction of machine operations
    //
    //

    /// Flush CPU data and/or instruction caches.
    [vdsocall,
     argtype="addr IN",
     valueset = "options zx_cache_flush_options"]
    cache_flush(array<voidptr>:size addr, usize size, uint32 options) -> (zx.status status);

    //
    //
    // Generic handle operations
    //
    //

    /// Close a handle.
    [rights="None.",
     argtype="handle handle_release_always"]
    handle_close(handle handle) -> (zx.status status);

    /// Close a number of handles.
    [rights="None.",
     argtype="handles IN"]
    handle_close_many(array<handle>:num_handles handles, usize num_handles) -> (zx.status status);

    /// Duplicate a handle.
    [rights="handle must have ZX_RIGHT_DUPLICATE.",
     argtype="out handle_acquire",
     valueset = "rights zx_rights"]
    handle_duplicate(handle handle, zx.rights rights) -> (zx.status status, handle out);

    /// Replace a handle.
    [rights="None.",
     argtype="handle handle_release_always",
     argtype="out handle_acquire",
     valueset = "rights zx_rights"]
    handle_replace(handle handle, zx.rights rights) -> (zx.status status, handle out);

    //
    //
    // Generic object operations
    //
    //
    /// Wait for signals on an object.
    [rights="handle must have ZX_RIGHT_WAIT.",
     blocking,
     argtype="observed optional"]
    object_wait_one(handle handle, zx.signals signals, zx.time deadline) ->
        (zx.status status, zx.signals observed);

    /// Wait for signals on multiple objects.
    [rights="Every entry of items must have a handle field with ZX_RIGHT_WAIT.",
     blocking,
     argtype="items INOUT"]
    object_wait_many(array<zx_wait_item>:count items, usize count, zx.time deadline) ->
        (zx.status status);

    /// Subscribe for signals on an object.
    [rights="handle must have ZX_RIGHT_WAIT.",
     rights="port must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE.",
     valueset = "options zx_object_wait_async_options"]
    object_wait_async(handle handle, handle<port> port, uint64 key,
                      zx.signals signals, uint32 options) ->
        (zx.status status);

    /// Signal an object.
    [rights="handle must have ZX_RIGHT_SIGNAL."]
    object_signal(handle handle, uint32 clear_mask, uint32 set_mask) -> (zx.status status);

    /// Signal an object's peer.
    [rights="handle must have ZX_RIGHT_SIGNAL_PEER."]
    object_signal_peer(handle handle, uint32 clear_mask, uint32 set_mask) -> (zx.status status);

    /// Ask for various properties of various kernel objects.
    [rights="handle must have ZX_RIGHT_GET_PROPERTY.",
     rights="If property is ZX_PROP_PROCESS_DEBUG_ADDR, handle must be of type ZX_OBJ_TYPE_PROCESS.",
     rights="If property is ZX_PROP_PROCESS_VDSO_BASE_ADDRESS, handle must be of type ZX_OBJ_TYPE_PROCESS.",
     rights="If property is ZX_PROP_SOCKET_RX_THRESHOLD, handle must be of type ZX_OBJ_TYPE_SOCKET.",
     rights="If property is ZX_PROP_SOCKET_TX_THRESHOLD, handle must be of type ZX_OBJ_TYPE_SOCKET.",
     argtype="value OUT",
     valueset="property zx_object_property_values",
     typeset="handle zx_object_property_handles",
     dependency="property handle"]
    object_get_property(handle handle, uint32 property,
                        array<voidptr>:value_size value, usize value_size) ->
        (zx.status status);

    /// Set various properties of various kernel objects.
    [rights="handle must have ZX_RIGHT_SET_PROPERTY.",
     rights="If property is ZX_PROP_PROCESS_DEBUG_ADDR, handle must be of type ZX_OBJ_TYPE_PROCESS.",
    // TODO(ZX-2967): TODO(scottmg): Why is the above useful?
     rights="If property is ZX_PROP_SOCKET_RX_THRESHOLD, handle must be of type ZX_OBJ_TYPE_SOCKET.",
     rights="If property is ZX_PROP_SOCKET_TX_THRESHOLD, handle must be of type ZX_OBJ_TYPE_SOCKET.",
     rights="If property is ZX_PROP_JOB_KILL_ON_OOM, handle must be of type ZX_OBJ_TYPE_JOB.",
     argtype="value IN",
     valueset="property zx_object_property_values",
     typeset="handle zx_object_property_handles",
     dependency="property handle"]
    object_set_property(handle handle, uint32 property,
                        array<voidptr>:value_size value, usize value_size) ->
        (zx.status status);

    /// Query information about an object.
    [rights="If topic is ZX_INFO_PROCESS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_JOB, handle must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_PROCESS_THREADS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_ENUMERATE.",
     rights="If topic is ZX_INFO_JOB_CHILDREN, handle must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_ENUMERATE.",
     rights="If topic is ZX_INFO_JOB_PROCESSES, handle must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_ENUMERATE.",
     rights="If topic is ZX_INFO_THREAD, handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_THREAD_EXCEPTION_REPORT, handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_THREAD_STATS, handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_TASK_STATS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_PROCESS_MAPS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_PROCESS_VMOS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_VMO, handle must be of type ZX_OBJ_TYPE_VMO.",
    // TODO(ZX-2967),   Should this require INSPECT?
     rights="If topic is ZX_INFO_VMAR, handle must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_CPU_STATS, handle must have resource kind ZX_RSRC_KIND_ROOT.",
     rights="If topic is ZX_INFO_KMEM_STATS, handle must have resource kind ZX_RSRC_KIND_ROOT.",
     rights="If topic is ZX_INFO_RESOURCE, handle must be of type ZX_OBJ_TYPE_RESOURCE and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_HANDLE_COUNT, handle must have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_BTI, handle must be of type ZX_OBJ_TYPE_BTI and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_PROCESS_HANDLE_STATS, handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_INSPECT.",
     rights="If topic is ZX_INFO_SOCKET, handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_INSPECT.",
     argtype="buffer OUT",
     argtype="actual optional",
     argtype="avail optional",
     valueset="topic zx_object_info_topics",
     typeset="buffer zx_object_info_types",
     typeset="handle zx_object_info_handles",
     dependency="topic buffer",
     dependency="topic handle"]
    object_get_info(handle handle, uint32 topic,
                    array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status, usize actual, usize avail);

    /// Given a kernel object with children objects, obtain a handle to the child specified by the provided kernel object id.
    [rights="handle must have ZX_RIGHT_ENUMERATE.",
     valueset="rights zx_rights"]
    // TODO(ZX-2399): handle rights must be the same or greater than |rights|
    object_get_child(handle handle, zx.koid koid, zx.rights rights) ->
        (zx.status status, handle out);

    /// Apply a scheduling profile to a thread.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_MANAGE_THREAD.",
     rights="profile must be of type ZX_OBJ_TYPE_PROFILE and have ZX_RIGHT_APPLY_PROFILE."]
    object_set_profile(handle<thread> handle, handle<profile> profile, uint32 options) -> (zx.status status);

    //
    //
    // IPC: Channels
    //
    //

    // TODO: include channels

    //
    //
    // IPC: Sockets
    //
    //

    /// Create a socket.
    [argtype="out0 handle_acquire",
     argtype="out1 handle_acquire",
     valueset="options zx_socket_create_options"]
    socket_create(uint32 options) -> (zx.status status, handle<socket> out0, handle<socket> out1);

    /// Write data to a socket.
    [rights="handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_WRITE.",
     argtype="buffer IN",
     argtype="actual optional",
     valueset="options zx_socket_write_options"]
    socket_write(handle<socket> handle, uint32 options,
                 array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status, usize actual);

    /// Read data from a socket.
    [rights="handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_READ.",
     argtype="buffer OUT",
     argtype="actual optional",
     valueset="options zx_socket_read_options"]
    socket_read(handle<socket> handle, uint32 options,
                array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status, usize actual);

    /// Send another socket object via a socket.
    [rights="handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_WRITE.",
     rights="socket_to_share must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_TRANSFER."]
    socket_share(handle<socket> handle, handle<socket> socket_to_share) -> (zx.status status);

    /// Receive another socket object via a socket.
    [rights="handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_READ.",
     argtype="out_socket handle_acquire"]
    socket_accept(handle<socket> handle) -> (zx.status status, handle<socket> out_socket);

    /// Prevent reading or writing.
    [rights="handle must be of type ZX_OBJ_TYPE_SOCKET and have ZX_RIGHT_WRITE.",
     valueset="options zx_socket_shutdown_options"]
    socket_shutdown(handle<socket> handle, uint32 options) -> (zx.status status);

    //
    //
    // Threads
    //
    //

    /// Terminate the current running thread.
    [noreturn]
    thread_exit();

    /// Create a thread.
    [rights="process must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_MANAGE_THREAD.",
     argtype="name IN",
     argtype="out handle_acquire"]
    thread_create(handle<process> process,
                  string:name_size name,
                  usize name_size,
                  uint32 options) ->
        (zx.status status, handle<thread> out);

    /// Start execution on a thread.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_MANAGE_THREAD."]
    thread_start(handle<thread> handle, zx.vaddr thread_entry, zx.vaddr stack,
                 usize arg1, usize arg2) ->
        (zx.status status);

    /// Read one aspect of thread state.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_READ.",
     argtype="buffer OUT",
     valueset="kind thread_state_kind"]
    thread_read_state(handle<thread> handle, uint32 kind,
                      array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    /// Write one aspect of thread state.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_WRITE.",
     argtype="buffer IN",
     valueset="kind thread_state_kind"]
    thread_write_state(handle<thread> handle, uint32 kind,
                       array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    //
    //
    // Processes
    //
    //

    /// Exits the currently running process.
    [noreturn]
    process_exit(int64 retcode);

    /// Create a new process.
    [rights="job must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_MANAGE_PROCESS.",
     argtype="name IN",
     argtype="proc_handle handle_acquire",
     argtype="vmar_handle handle_acquire"]
    // TODO(ZX-2967): job with ZX_RIGHT_WRITE is also accepted.
    process_create(handle<job> job, string:name_size name, usize name_size, uint32 options) ->
        (zx.status status, handle<process> proc_handle, handle<vmar> vmar_handle);

    /// Start execution on a process.
    [rights="handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_WRITE.",
     rights="thread must be of type ZX_OBJ_TYPE_THREAD and have ZX_RIGHT_WRITE.",
     rights="arg1 must have ZX_RIGHT_TRANSFER.",
     argtype="arg1 handle_release_always"]
    process_start(handle<process> handle, handle<thread> thread,
                  zx.vaddr entry, zx.vaddr stack,
                  handle arg1, usize arg2) ->
        (zx.status status);

    /// Read from the given process's address space.
    [rights="handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_READ and have ZX_RIGHT_WRITE.",
     argtype="buffer OUT"]
    process_read_memory(handle<process> handle, zx.vaddr vaddr,
                        array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status, usize actual);

    /// Write into the given process's address space.
    [rights="handle must be of type ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_WRITE.",
     argtype="buffer IN"]
    process_write_memory(handle<process> handle, zx.vaddr vaddr,
                         array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status, usize actual);


    //
    //
    // Jobs
    //
    //

    /// Create a new job.
    [rights="parent_job must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_MANAGE_JOB.",
     argtype="out handle_acquire"]
    // TODO(ZX-2967): parent_job with ZX_RIGHT_WRITE is also accepted.
    job_create(handle<job> parent_job, uint32 options) -> (zx.status status, handle<job> out);

    /// Set job security and resource policies.
    [rights="handle must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_SET_POLICY.",
     argtype="policy IN",
     valueset="options zx_job_policy_options",
     valueset="topic zx_job_policy_topic",
     typeset="policy zx_job_policy_types",
     dependency="topic policy"]
    job_set_policy(handle<job>handle, uint32 options, uint32 topic,
                   array<voidptr>:count policy, uint32 count) ->
        (zx.status status);


    //
    //
    // Tasks (shared between threads, processes, and jobs)
    //
    //

    /// Suspend the given task. Currently only thread or process handles may be suspended.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD or ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_WRITE.",
     argtype="token handle_acquire"]
    // TODO(banjo): handle<task>?
    task_suspend(handle handle) -> (zx.status status, handle token);

    /// Suspend the given task. Currently only thread or process handles may be suspended.
    [rights="handle must be of type ZX_OBJ_TYPE_THREAD or ZX_OBJ_TYPE_PROCESS and have ZX_RIGHT_WRITE.",
     argtype="token handle_acquire"]
    // TODO(banjo): handle<task>?
    task_suspend_token(handle handle) -> (zx.status status, handle token);

    /// Create an exception channel for a given job, process, or thread.
    [rights="handle must have ZX_RIGHT_INSPECT and have ZX_RIGHT_DUPLICATE and have ZX_RIGHT_TRANSFER and have ZX_RIGHT_MANAGE_THREAD.",
     rights="If handle is of type ZX_OBJ_TYPE_JOB or ZX_OBJ_TYPE_PROCESS, it must have ZX_RIGHT_ENUMERATE.",
     argtype="out handle_acquire",
     valueset="options zx_task_exception_channel_options"]
    // TODO(banjo): handle<task>?
    // TODO(banjo): is out a real handle<channel> or just something similar?
    task_create_exception_channel(handle handle, uint32 options) ->
        (zx.status status, handle<channel> out);

    /// Kill the provided task (job, process, or thread).
    [rights="handle must have ZX_RIGHT_DESTROY."]
    // TODO(banjo): handle<task>?
    task_kill(handle handle) -> (zx.status status);

    //
    //
    // Exceptions
    //
    //

    /// Create a handle for the exception's thread.
    [rights="handle must be of type ZX_OBJ_TYPE_EXCEPTION.",
     argtype="out handle_acquire"]
    // TODO(banjo): handle as handle<exception>
    exception_get_thread(handle handle) -> (zx.status status, handle<thread> out);

    /// Create a handle for the exception's process.
    [rights="handle must be of type ZX_OBJ_TYPE_EXCEPTION.",
     argtype="out handle_acquire"]
    // TODO(banjo): handle as handle<exception>
    exception_get_process(handle handle) -> (zx.status status, handle<process> out);

    //
    //
    // Synchronization
    //
    //

    /// Create an event.
    [argtype="out handle_acquire"]
    event_create(uint32 options) -> (zx.status status, handle<event> out);

    /// Create an event pair.
    [argtype="out0 handle_acquire",
     argtype="out1 handle_acquire"]
    eventpair_create(uint32 options) ->
        (zx.status status, handle<eventpair> out0, handle<eventpair> out1);

    /// Wait on a futex.
    [rights="None.",
     blocking,
     argtype="value_ptr IN"]
    futex_wait(array<int32>:1 value_ptr, int32 current_value,
               handle new_futex_owner, zx.time deadline) ->
        (zx.status status);

    /// Wake some number of threads waiting on a futex, optionally transferring ownership to the thread which was woken in the process.
    [rights="None.",
     argtype="value_ptr IN"]
    futex_wake(array<int32>:1 value_ptr, uint32 wake_count) -> (zx.status status);

    /// Wake some number of threads waiting on a futex, and move more waiters to another wait queue.
    [rights="None.",
     argtype="value_ptr IN",
     argtype="requeue_ptr IN"]
    futex_requeue(array<int32>:1 value_ptr,
                  uint32 wake_count,
                  int32 current_value,
                  array<int32>:1 requeue_ptr, uint32 requeue_count,
                  handle new_requeue_owner) ->
        (zx.status status);

    /// Wake some number of threads waiting on a futex, optionally transferring ownership to the thread which was woken in the process.
    [rights="None.",
     argtype="value_ptr IN"]
    futex_wake_single_owner(array<int32>:1 value_ptr) -> (zx.status status);

    /// Wake some number of threads waiting on a futex, and move more waiters to another wait queue.
    [rights="None.",
     argtype="value_ptr IN",
     argtype="requeue_ptr IN"]
    futex_requeue_single_owner(array<int32>:1 value_ptr,
                               int32 current_value,
                               array<int32>:1 requeue_ptr, uint32 requeue_count,
                               handle new_requeue_owner) ->
        (zx.status status);

    /// Fetch the koid current owner of a futex, if any.
    [rights="None.",
     argtype="value_ptr IN",
     argtype="koid OUT"]
    futex_get_owner(array<int32>:1 value_ptr, array<zx.koid>:1 koid) -> (zx.status status);


    //
    //
    // Ports
    //
    //

    /// Create an IO port.
    [argtype="out handle_acquire"]
    port_create(uint32 options) -> (zx.status status, handle<port> out);

    /// Queue a packet to a port.
    [rights="handle must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE.",
     argtype="packet IN"]
    port_queue(handle<port> handle, array<zx_port_packet>:1 packet) -> (zx.status status);

    /// Wait for a packet arrival in a port.
    [rights="handle must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_READ.",
     blocking,
     argtype="packet OUT"]
    port_wait(handle<port> handle, zx.time deadline, array<zx_port_packet>:1 packet) ->
        (zx.status status);

    /// Cancels async port notifications on an object.
    [rights="handle must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE."]
    port_cancel(handle<port> handle, handle source, uint64 key) -> (zx.status status);


    //
    //
    // Timers
    //
    //

    /// Create a timer.
    [argtype="out handle_acquire",
     valueset="options zx_timer_options",
     valueset="clock_id zx_clock_id"]
    timer_create(uint32 options, zx.clock clock_id) -> (zx.status status, handle<timer> out);

    /// Start a timer.
    [rights="handle must be of type ZX_OBJ_TYPE_TIMER and have ZX_RIGHT_WRITE."]
    timer_set(handle<timer> handle, zx.time deadline, zx.duration slack) -> (zx.status status);

    /// Cancel a timer.
    [rights="handle must be of type ZX_OBJ_TYPE_TIMER and have ZX_RIGHT_WRITE."]
    timer_cancel(handle<timer> handle) -> (zx.status status);

    //
    //
    // Memory management
    //
    //

    /// Create a VM object.
    [argtype="out handle_acquire",
     valueset="options zx_vmo_create_options"]
    vmo_create(uint64 size, uint32 options) -> (zx.status status, handle<vmo> out);

    /// Read bytes from the VMO.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     blocking,
     argtype="buffer OUT"]
    vmo_read(handle<vmo> handle,
             array<voidptr>:buffer_size buffer,
             uint64 offset,
             usize buffer_size) ->
        (zx.status status);

    /// Write bytes to the VMO.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE.",
     blocking,
     argtype="buffer IN"]
    vmo_write(handle<vmo> handle,
              array<voidptr>:buffer_size buffer,
              uint64 offset,
              usize buffer_size)
        -> (zx.status status);

    /// Read the current size of a VMO object.
    // TODO(ZX-2967): No rights required?
    vmo_get_size(handle<vmo> handle) -> (zx.status status, uint64 size);

    /// Resize a VMO object.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE."]
    vmo_set_size(handle<vmo> handle, uint64 size) -> (zx.status status);

    /// Perform an operation on a range of a VMO.
    [rights="If op is ZX_VMO_OP_COMMIT, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE.",
     rights="If op is ZX_VMO_OP_DECOMMIT, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE.",
     rights="If op is ZX_VMO_OP_CACHE_SYNC, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     rights="If op is ZX_VMO_OP_CACHE_INVALIDATE, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE.",
     rights="If op is ZX_VMO_OP_CACHE_CLEAN, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     rights="If op is ZX_VMO_OP_CACHE_CLEAN_INVALIDATE, handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     blocking,
     argtype="buffer INOUT",
     valueset="op zx_vmo_opcodes"]
    vmo_op_range(handle<vmo> handle, uint32 op, uint64 offset, uint64 size,
                 array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    /// Create a child of a VM Object.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_DUPLICATE and have ZX_RIGHT_READ.",
     argtype="out handle_acquire",
     valueset="options zx_vmo_clone_options"]
    vmo_create_child(handle<vmo> handle, uint32 options, uint64 offset, uint64 size) ->
        (zx.status status, handle<vmo> out);

    /// Set the caching policy for pages held by a VMO.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_MAP.",
     valueset="cache_policy zx_vmo_cache_policy_options"]
    vmo_set_cache_policy(handle<vmo> handle, uint32 cache_policy) -> (zx.status status);

    /// Add execute rights to a VMO.
    [rights="handle must be of type ZX_OBJ_TYPE_VMO.",
     rights="vmex must have resource kind ZX_RSRC_KIND_VMEX.",
     argtype="handle handle_release_always",
     argtype="out handle_acquire"]
    // TODO(ZX-2967): handle: No rights required, ZX_RIGHT_EXECUTE added to dup out
    // TODO(ZX-2967): vmex == ZX_HANDLE_INVALID also accepted.
    vmo_replace_as_executable(handle<vmo> handle, handle<resource> vmex) ->
        (zx.status status, handle<vmo> out);


    //
    //
    // Address space management
    //
    //

    /// Allocate a new subregion.
    [rights="If options & ZX_VM_CAN_MAP_READ, parent_vmar must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_READ.",
     rights="If options & ZX_VM_CAN_MAP_WRITE, parent_vmar must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_WRITE.",
     rights="If options & ZX_VM_CAN_MAP_EXECUTE, parent_vmar must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_EXECUTE.",
     argtype="child_vmar handle_acquire",
     valueset="options zx_vmar_allocate_map_options"]
    vmar_allocate(handle<vmar> parent_vmar, zx.vm_option options, uint64 offset, uint64 size) ->
        (zx.status status, handle<vmar> child_vmar, zx.vaddr child_addr);

    /// Destroy a virtual memory address region.
    // TODO(ZX-2967): handle No rights required?
    vmar_destroy(handle<vmar> handle) -> (zx.status status);

    /// Add a memory mapping.
    [rights="handle must be of type ZX_OBJ_TYPE_VMAR.",
     rights="vmo must be of type ZX_OBJ_TYPE_VMO.",
     valueset="options zx_vmar_allocate_map_options"]
    // TODO(ZX-2399): TODO handle and vmo and options must all match, and options can't specify them.
    vmar_map(handle<vmar> handle, zx.vm_option options, uint64 vmar_offset,
             handle<vmo> vmo, uint64 vmo_offset,
             uint64 len) ->
        (zx.status status, zx.vaddr mapped_addr);

    /// Unmap virtual memory pages.
    // TODO(ZX-2967): handle No rights required?
    vmar_unmap(handle<vmo> handle, zx.vaddr addr, uint64 len) -> (zx.status status);

    /// Set protection of virtual memory pages.
    [rights="If options & ZX_VM_PERM_READ, handle must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_READ.",
     rights="If options & ZX_VM_PERM_WRITE, handle must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_WRITE.",
     rights="If options & ZX_VM_PERM_EXECUTE, handle must be of type ZX_OBJ_TYPE_VMAR and have ZX_RIGHT_EXECUTE.",
     valueset="options zx_vmar_protect_options"]
    vmar_protect(handle<vmo> handle, zx.vm_option options, zx.vaddr addr, uint64 len) ->
        (zx.status status);


    //
    //
    // Random Number generator
    //
    //

    [internal,
     argtype="buffer OUT"]
    cprng_draw_once(array<voidptr>:buffer_size buffer, usize buffer_size) -> (zx.status status);

    /// Draw from the kernel's CPRNG.
    [vdsocall,
     argtype="buffer OUT"]
    cprng_draw(array<voidptr>:buffer_size buffer, usize buffer_size) -> ();

    /// Add entropy to the kernel CPRNG.
    [argtype="buffer IN"]
    cprng_add_entropy(array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);


    //
    //
    // IPC: Fifos
    //
    //

    /// Create a fifo.
    [argtype="out0 handle_acquire",
     argtype="out1 handle_acquire"]
    fifo_create(usize elem_count, usize elem_size, uint32 options) ->
        (zx.status status, handle<fifo> out0, handle<fifo> out1);

    /// Read data from a fifo.
    [rights="handle must be of type ZX_OBJ_TYPE_FIFO and have ZX_RIGHT_READ.",
     argtype="data OUT",
     argtype="actual_count optional",
     arraysize="data count*elem_size"]
    fifo_read(handle<fifo> handle, usize elem_size, array<voidptr>:N data, usize count) ->
        (zx.status status, usize actual_count);

    /// Write data to a fifo.
    [rights="handle must be of type ZX_OBJ_TYPE_FIFO and have ZX_RIGHT_WRITE.",
     argtype="data IN",
     argtype="actual_count optional",
     arraysize="data count*elem_size"]
    fifo_write(handle<fifo> handle, usize elem_size, array<voidptr>:N data, usize count) ->
        (zx.status status, usize actual_count);


    //
    //
    // Profiles
    //
    //

    /// Create a scheduler profile.
    [rights="root_job must be of type ZX_OBJ_TYPE_JOB and have ZX_RIGHT_MANAGE_PROCESS.",
     argtype="profile IN",
     argtype="out handle_acquire"]
    profile_create(handle<job> root_job, uint32 options, array<zx_profile_info>:1 profile) ->
        (zx.status status, handle<profile> out);


    //
    //
    // Multi-function
    //
    //

    /// Unmap memory, close handle, exit.
    [vdsocall,
     argtype="close_handle handle_release"]
    // TODO(ZX-2399): ???
    vmar_unmap_handle_close_thread_exit(handle<vmar> vmar_handle,
                                        zx.vaddr addr, usize size,
                                        handle close_handle) ->
        (zx.status status);

    /// Write to futex, wake futex, close handle, exit.
    [vdsocall,
     noreturn,
     argtype="value_ptr IN",
     argtype="close_handle handle_release"]
    futex_wake_handle_close_thread_exit(array<int32>:1 value_ptr,
                                        uint32 wake_count,
                                        int32 new_value,
                                        handle close_handle);


    //
    //
    // Logging
    //
    //

    // TODO(ZX-2967): handle == ZX_HANDLE_INVALID accepted.
    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="out handle_acquire",
     valueset="options zx_debuglog_create_options"]
    debuglog_create(handle<resource> resource, uint32 options) ->
        (zx.status status, handle<debuglog> out);

    [rights="handle must be of type ZX_OBJ_TYPE_LOG and have ZX_RIGHT_WRITE.",
     argtype="buffer IN"]
    debuglog_write(handle<debuglog> handle, uint32 options,
                   array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    [rights="handle must be of type ZX_OBJ_TYPE_LOG and have ZX_RIGHT_READ.",
     argtype="buffer OUT"]
    debuglog_read(handle<debuglog> handle, uint32 options,
                  array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);


    //
    //
    // Tracing
    //
    //

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="data OUT"]
    ktrace_read(handle<resource> handle,
                array<voidptr>:data_size data,
                uint32 offset,
                usize data_size) ->
        (zx.status status, usize actual);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="ptr INOUT"]
    ktrace_control(handle<resource> handle, uint32 action, uint32 options,
                   array<voidptr>:action ptr) ->
        (zx.status status);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT."]
    ktrace_write(handle<resource> handle, uint32 id, uint32 arg0, uint32 arg1) ->
        (zx.status status);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="ptr INOUT"]
    mtrace_control(handle<resource> handle, uint32 kind, uint32 action, uint32 options,
                   array<voidptr>:ptr_size ptr, usize ptr_size) ->
        (zx.status status);


    //
    //
    // Legacy LK debug syscalls
    //
    //

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="buffer OUT",
     argtype="buffer_size INOUT"]
    // TODO(banjo): size of buffer being buffer_size sems odd, but that's what
    // that abigen says, maybe it's special cased to dereference.
    debug_read(handle<resource> handle, string:buffer_size buffer, array<usize>:1 buffer_size) ->
        (zx.status status);

    [argtype="buffer IN"]
    debug_write(string:buffer_size buffer, usize buffer_size) -> (zx.status status);

    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="buffer IN"]
    debug_send_command(handle<resource> resource, string:buffer_size buffer, usize buffer_size) ->
        (zx.status status);


    //
    //
    // DDK Syscalls: Interrupts
    //
    //

    /// Create an interrupt object.
    [rights="src_obj must have resource kind ZX_RSRC_KIND_IRQ.",
     valueset = "options zx_interrupt_options"]
    interrupt_create(handle<resource> src_obj, uint32 src_num, uint32 options) ->
        (zx.status status, handle<interrupt> out_handle);

    /// Bind an interrupt object to a port.
    [rights="handle must be of type ZX_OBJ_TYPE_INTERRUPT and have ZX_RIGHT_READ.",
     rights="port_handle must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE."]
    interrupt_bind(handle<interrupt> handle, handle<port> port_handle,
                   uint64 key, uint32 options) ->
        (zx.status status);

    /// Wait for an interrupt.
    [rights="handle must be of type ZX_OBJ_TYPE_INTERRUPT and have ZX_RIGHT_WAIT.",
     blocking,
     argtype="out_timestamp optional"]
    interrupt_wait(handle<interrupt> handle) -> (zx.status status, zx.time out_timestamp);

    /// Destroys an interrupt object.
    // TODO(ZX-2967): No DESTROY rights here.
    interrupt_destroy(handle<interrupt> handle) -> (zx.status status);

    /// Acknowledge an interrupt and re-arm it.
    [rights="handle must be of type ZX_OBJ_TYPE_INTERRUPT and have ZX_RIGHT_WRITE."]
    interrupt_ack(handle<interrupt> handle) -> (zx.status status);

    /// Triggers a virtual interrupt object.
    [rights="handle must be of type ZX_OBJ_TYPE_INTERRUPT and have ZX_RIGHT_SIGNAL."]
    interrupt_trigger(handle<interrupt> handle, uint32 options, zx.time timestamp) ->
        (zx.status status);

    /// Bind an interrupt object to a VCPU.
    [rights="handle must be of type ZX_OBJ_TYPE_INTERRUPT and have ZX_RIGHT_READ.",
     rights="vcpu must be of type ZX_OBJ_TYPE_VCPU and have ZX_RIGHT_WRITE."]
    interrupt_bind_vcpu(handle<interrupt> handle, handle<vcpu> vcpu, uint32 options) ->
        (zx.status status);


    //
    //
    // DDK Syscalls: MMIO and IoPorts
    //
    //

    [rights="resource must have resource kind ZX_RSRC_KIND_IOPORT."]
    ioports_request(handle<resource> resource, uint16 io_addr, uint32 len) -> (zx.status status);

    [rights="bti must be of type ZX_OBJ_TYPE_BTI and have ZX_RIGHT_MAP.",
     argtype="out handle_acquire"]
    vmo_create_contiguous(handle<bti> bti, usize size, uint32 alignment_log2) ->
        (zx.status status, handle<vmo> out);

    /// Create a VM object referring to a specific contiguous range of physical memory.
    [rights="resource must have resource kind ZX_RSRC_KIND_MMIO.",
     argtype="out handle_acquire"]
    vmo_create_physical(handle<vmo> resource, zx.paddr paddr, usize size) ->
        (zx.status status, handle<vmo> out);



    //
    //
    // DDK Syscalls: Device Memory Access
    //
    //

    /// Create a new IOMMU object in the kernel.
    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="desc IN",
     argtype="out handle_acquire",
     valueset="type zx_iommu_type",
     typeset="desc zx_iommu_types",
     dependency="type desc"]
    iommu_create(handle<resource> resource, uint32 type,
                 array<voidptr>:desc_size desc, usize desc_size) ->
        (zx.status status, handle<iommu> out);

    /// Create a new bus transaction initiator.
    [rights="iommu must be of type ZX_OBJ_TYPE_IOMMU and have ZX_RIGHT_NONE.",
     argtype="out handle_acquire"]
    // TODO(ZX-2967): This is unusual.
    bti_create(handle<iommu> iommu, uint32 options, uint64 bti_id) ->
        (zx.status status, handle<bti> out);

    /// Pin pages and grant devices access to them.
    [rights="handle must be of type ZX_OBJ_TYPE_BTI and have ZX_RIGHT_MAP.",
     rights="vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_MAP.",
     rights="If options & ZX_BTI_PERM_READ, vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     rights="If options & ZX_BTI_PERM_WRITE, vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_WRITE.",
    // READ is intentional in the following EXECUTE condition.
     rights="If options & ZX_BTI_PERM_EXECUTE, vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     argtype="addrs OUT",
     argtype="pmt handle_acquire",
     valueset="options zx_bti_pin_options"]
    bti_pin(handle<bti> handle, uint32 options, handle<vmo> vmo, uint64 offset, uint64 size,
            array<zx.paddr>:addrs_count addrs, usize addrs_count) ->
        (zx.status status, handle<pmt> pmt);

    /// Releases all quarantined PMTs.
    [rights="handle must be of type ZX_OBJ_TYPE_BTI and have ZX_RIGHT_WRITE."]
    bti_release_quarantine(handle<bti> handle) -> (zx.status status);

    /// Unpin pages and revoke device access to them.
    [argtype="handle handle_release_always"]
    // TODO(ZX-2967): handle ZX_OBJ_TYPE_PMT; No rights required?
    pmt_unpin(handle<pmt> handle) -> (zx.status status);


    //
    //
    // DDK Syscalls: Misc Info
    //
    //

    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT."]
    framebuffer_get_info(handle<resource> resource) ->
        (zx.status status, uint32 format, uint32 width, uint32 height, uint32 stride);

    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT."]
    // TODO(ZX-2967): vmo ZX_OBJ_TYPE_VMO; No rights required?
    framebuffer_set_range(handle<resource> resource,
                          handle<vmo> vmo, uint32 len, uint32 format,
                          uint32 width, uint32 height, uint32 stride) ->
        (zx.status status);


    //
    //
    // DDK Syscalls: PCI
    //
    //

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="out_handle handle_acquire"]
    // TODO(banjo): out_handle as handle<device>
    pci_get_nth_device(handle<resource> handle, uint32 index) ->
        (zx.status status, zx_pcie_device_info out_info, handle out_handle);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_WRITE."]
    // TODO(banjo): handle as handle<device>
    pci_enable_bus_master(handle handle, bool enable) -> (zx.status status);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_WRITE."]
    // TODO(banjo): handle as handle<device>
    pci_reset_device(handle handle) -> (zx.status status);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_READ and have ZX_RIGHT_WRITE.",
     argtype="out_val OUT"]
    // TODO(banjo): handle as handle<device>
    pci_config_read(handle handle, uint16 offset, usize width, array<uint32>:1 out_val) ->
        (zx.status status);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_READ and have ZX_RIGHT_WRITE."]
    // TODO(banjo): handle as handle<device>
    pci_config_write(handle handle, uint16 offset, usize width, uint32 val) -> (zx.status status);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="val INOUT"]
    pci_cfg_pio_rw(handle<resource> handle, uint8 bus, uint8 dev, uint8 func, uint8 offset,
                   array<uint32>:1 val, usize width, bool write) ->
        (zx.status status);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_READ and have ZX_RIGHT_WRITE.",
     argtype="out_bar OUT",
     argtype="out_handle handle_acquire"]
    // TODO(banjo): handle as handle<device>
    // TODO(banjo): type of out_handle?
    pci_get_bar(handle handle, uint32 bar_num, array<zx_pci_bar>:1 out_bar) ->
        (zx.status status, handle out_handle);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_READ.",
     argtype="out_handle handle_acquire"]
    // TODO(banjo): handle as handle<device>
    pci_map_interrupt(handle handle, int32 which_irq) -> (zx.status status, handle out_handle);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_READ."]
    // TODO(banjo): handle as handle<device>
    pci_query_irq_mode(handle handle, uint32 mode) -> (zx.status status, uint32 out_max_irqs);

    [rights="handle must be of type ZX_OBJ_TYPE_PCI_DEVICE and have ZX_RIGHT_WRITE."]
    // TODO(banjo): handle as handle<device>
    pci_set_irq_mode(handle handle, uint32 mode, uint32 requested_irq_count) -> (zx.status status);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="init_buf IN"]
    pci_init(handle<resource> handle, array<zx_pci_init_arg>:len init_buf, uint32 len) ->
        (zx.status status);

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT."]
    pci_add_subtract_io_range(handle<resource> handle, bool mmio,
                              uint64 base, uint64 len, bool add) ->
        (zx.status status);


    //
    //
    // DDK Syscalls: ACPI Glue
    //
    //

    [rights="handle must have resource kind ZX_RSRC_KIND_ROOT."]
    pc_firmware_tables(handle<resource> handle) ->
        (zx.status status, zx.paddr acpi_rsdp, zx.paddr smbios);


    //
    //
    // DDK Syscalls: SMC Calls
    //
    //

    /// Make Secure Monitor Call (SMC) from user space.
    [argtype="parameters IN",
     argtype="out_smc_result OUT"]
    // TODO(ZX-2967): handle No rights required?
    smc_call(handle handle, array<zx_smc_parameters>:1 parameters) ->
        (zx.status status, zx_smc_result out_smc_result);


    //
    //
    // Resources
    //
    //

    /// Create a resource object.
    [rights="parent_rsrc must be of type ZX_OBJ_TYPE_RESOURCE and have ZX_RIGHT_WRITE.",
     argtype="name IN",
     argtype="resource_out handle_acquire"]
    resource_create(handle<resource> parent_rsrc, uint32 options, uint64 base, usize size,
                    string:name_size name, usize name_size) ->
        (zx.status status, handle<resource> resource_out);


    //
    //
    // Hypervisor
    //
    //

    /// Create a guest.
    [rights="resource must have resource kind ZX_RSRC_KIND_HYPERVISOR.",
     argtype="guest_handle handle_acquire",
     argtype="vmar_handle handle_acquire"]
    guest_create(handle<resource> resource, uint32 options) ->
        (zx.status status, handle<guest> guest_handle, handle<vmar> vmar_handle);

    /// Sets a trap within a guest.
    [rights="handle must be of type ZX_OBJ_TYPE_GUEST and have ZX_RIGHT_WRITE.",
     rights="port_handle must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE.",
     valueset="kind zx_guest_trap_kind"]
    guest_set_trap(handle<guest> handle, uint32 kind, zx.vaddr addr, usize size,
                   handle<port> port_handle, uint64 key) ->
        (zx.status status);

    /// Create a VCPU.
    [rights="guest must be of type ZX_OBJ_TYPE_GUEST and have ZX_RIGHT_MANAGE_PROCESS.",
     argtype="out handle_acquire"]
    vcpu_create(handle<guest> guest, uint32 options, zx.vaddr entry) ->
        (zx.status status, handle<vcpu> out);

    /// Resume execution of a VCPU.
    [rights="handle must be of type ZX_OBJ_TYPE_VCPU and have ZX_RIGHT_EXECUTE.",
     blocking,
     argtype="packet OUT"]
    vcpu_resume(handle<vcpu> handle) -> (zx.status status, zx_port_packet packet);

    /// Raise an interrupt on a VCPU.
    [rights="handle must be of type ZX_OBJ_TYPE_VCPU and have ZX_RIGHT_SIGNAL."]
    vcpu_interrupt(handle<vcpu> handle, uint32 vector) -> (zx.status status);

    /// Read the state of a VCPU.
    [rights="handle must be of type ZX_OBJ_TYPE_VCPU and have ZX_RIGHT_READ.",
     argtype="buffer OUT",
     valueset="kind zx_vcpu_read_state_kind",
     typeset="buffer zx_vcpu_read_state_types",
     dependency="kind buffer"]
    // TODO(banjo): handle as vcpu
    vcpu_read_state(handle handle, uint32 kind,
                    array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    /// Write the state of a VCPU.
    [rights="handle must be of type ZX_OBJ_TYPE_VCPU and have ZX_RIGHT_WRITE.",
     argtype="buffer IN",
     valueset="kind zx_vcpu_write_state_kind",
     typeset="buffer zx_vcpu_write_state_types",
     dependency="kind buffer"]
    // TODO(banjo): handle as vcpu
    vcpu_write_state(handle handle, uint32 kind,
                     array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);


    //
    //
    // System Control
    //
    //

    /// Soft reboot the system with a new kernel and bootimage.
    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     rights="kernel_vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ.",
     rights="bootimage_vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ."]
    system_mexec(handle<resource> resource, handle<vmo> kernel_vmo, handle<vmo> bootimage_vmo) ->
        (zx.status status);

    /// Return a ZBI containing ZBI entries necessary to boot this system.
    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="buffer OUT"]
    system_mexec_payload_get(handle<resource> resource,
                             array<voidptr>:buffer_size buffer, usize buffer_size) ->
        (zx.status status);

    [rights="resource must have resource kind ZX_RSRC_KIND_ROOT.",
     argtype="arg IN",
     valueset="cmd zx_system_powerctl_cmd"]
    system_powerctl(handle<resource> resource, uint32 cmd, array<zx_system_powerctl_arg>:1 arg) ->
        (zx.status status);


    //
    //
    // User pager
    //
    //

    /// Create a new pager object.
    [rights="None.",
     argtype="out handle_acquire"]
    pager_create(uint32 options) -> (zx.status status, handle<pager> out);

    /// Create a pager owned vmo.
    [rights="pager must be of type ZX_OBJ_TYPE_PAGER.",
     rights="port must be of type ZX_OBJ_TYPE_PORT and have ZX_RIGHT_WRITE.",
     argtype="out handle_acquire"]
    pager_create_vmo(handle<pager> pager, uint32 options,
                     handle<port> port, uint64 key, uint64 size) ->
        (zx.status status, handle<vmo> out);

    /// Detaches a vmo from a pager.
    [rights="pager must be of type ZX_OBJ_TYPE_PAGER.",
     rights="vmo must be of type ZX_OBJ_TYPE_VMO."]
    pager_detach_vmo(handle<pager> pager, handle<vmo> vmo) -> (zx.status status);

    /// Supply pages into a pager owned vmo.
    [rights="pager must be of type ZX_OBJ_TYPE_PAGER.",
     rights="pager_vmo must be of type ZX_OBJ_TYPE_VMO.",
     rights="aux_vmo must be of type ZX_OBJ_TYPE_VMO and have ZX_RIGHT_READ and have ZX_RIGHT_WRITE."]
    pager_supply_pages(handle<pager> pager, handle<vmo> pager_vmo, uint64 offset, uint64 length,
                       handle<vmo> aux_vmo, uint64 aux_offset) ->
        (zx.status status);

};

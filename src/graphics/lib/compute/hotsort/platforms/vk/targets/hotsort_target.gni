# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("../../../../gn/glsl_shader_rules.gni")
import("../../../hotsort_gen/hotsort_gen.gni")

_hotsort_dir = "${graphics_compute_dir}/hotsort"

# List of supported GPU architectures, i.e. valid values for the "gpu_arch"
# variable when calling the hotsort_target() rule below.
#
# NOTE: Each one of them should have a corresponding
# hotsort_target_gpu_arch_<name> GN template defined below after
# hotsort_target_internal.
#
_hotsort_gpu_archs = [
  "amd_gcn3",
  "arm_bifrost4",
  "arm_bifrost8",
  "intel_gen8",
  "nvidia_sm35",
  "google_swiftshader",
]

# IMPORTANT TECHNICAL NOTE: Regarding HotSort shader_names lists.
#
# Each hotsort_target_cpu_arch_<name> below should have a |shader_names|
# value that corresponds to the list of shader names generated by
# "hotsort_gen" during the build.
#
# GN needs to have this list very early. One way to get it is to execute
# the Python script under hotsort_gen/hotsort_gen_list_shaders.py, but doing
# it is slow (i.e. it is currently called 26 times for a total of 1.5 seconds).
#
# To avoid this, the |shader_names| lists the names of the shaders. If you
# don't know what the correct value is, remove the variable, and "gn gen"
# will print the correct value for you on the terminal.
#
# There is also a global settings under hotsort_gen/hotsort_gen.gni called
# _hotsort_check_shader_names that can be set to true manually to verify
# the list values on every "gn gen" call. It is disabled by default.
#
# Note that for GLSL, the shader list only depends on the |warps_per_group|,
# |merge_*| values below, as an implementation detail.
#

# This template is used indirectly from hotsort_target(), it should be called
# from one of the hotsort_target_gpu_arch_<name> templates and expects the
# following set of variables:
#
#   - All variables expected by hotsort_target(), except gpu_arch.
#   - All variables expected by hotsort_gen_target() as well.
#
# In addition to this:
#
#   vendor_config: A vendor-specific name used to grab the corresponding
#     hs_glsl_macros_config.h and hs_target_requirements.inl files.
#
template("hotsort_target_internal") {
  # NOTE: If $hotsort_target_name is provided, the generated HotSort target
  # and its artifacts are output to the root of $target_gen_dir. Otherwise,
  # the outputs are found in $target_gen_dir/$target_name.
  #
  if (defined(invoker.hotsort_target_name)) {
    _hs_target_name = invoker.hotsort_target_name
    _hs_output_dir = "${target_gen_dir}"
  } else {
    _hs_target_name = get_label_info(target_name, "name")
    _hs_output_dir = "${target_gen_dir}/${_hs_target_name}"
  }

  _hs_public_include_dirs = target_gen_dir

  #
  # Either dump a binary or produce a static library
  #
  _hs_target_dump =
      defined(invoker.hotsort_target_dump) && invoker.hotsort_target_dump

  #
  # define generated sources, includes and deps
  #
  _hs_target_gen_includes = [
    "${_hs_output_dir}/hs_config.h",
    "${_hs_output_dir}/hs_target.h",
  ]

  _hs_target_gen_sources = [ "${_hs_output_dir}/" + _hs_target_name + ".c" ]
  _hs_target_gen_inlines = [ "${_hs_output_dir}/hs_modules.inl" ]

  #
  # define static library sources
  #
  _hs_target_include_dirs = [
    _hs_output_dir,
    "${_hotsort_dir}/platforms/vk/targets",
    "${_hotsort_dir}/platforms/vk",
  ]

  _hs_target_sources =
      _hs_target_gen_includes + _hs_target_gen_sources + _hs_target_gen_inlines

  #
  # generate the .comp shaders
  #
  _gen_comp_target_name = "gen_comp_${_hs_target_name}"
  hotsort_gen_target(_gen_comp_target_name) {
    forward_variables_from(
        invoker,
        hotsort_gen_target_gpu_variables + hotsort_gen_target_glsl_variables)

    hotsort_target_name = _hs_target_name
    shader_lang = "glsl"
    output_dir = _hs_output_dir
  }

  #
  # copy any configuration files to the target directory
  #
  _gen_config_dir =
      "${_hotsort_dir}/platforms/vk/targets/vendors/${invoker.vendor_config}"
  _gen_config_files = [
    "${_gen_config_dir}/hs_glsl_macros_config.h",
    "${_gen_config_dir}/hs_target_requirements.inl",
  ]
  if (defined(invoker.hotsort_target_config_files)) {
    _gen_config_files += invoker.hotsort_target_config_files
  }
  _gen_copy_target_name = "gen_copy_${_hs_target_name}"
  copy(_gen_copy_target_name) {
    sources = _gen_config_files
    outputs = [ "${_hs_output_dir}/{{source_file_part}}" ]
  }

  #
  # compile the .comp shaders to SPIR-V modules
  #
  _gen_spv_target_name = "gen_spv_${_hs_target_name}"
  graphics_compute_compile_glsl_shader_foreach(_gen_spv_target_name) {
    # Ensure we only keep the .comp files as sources for this step.
    sources = []
    foreach(src, get_target_outputs(":${_gen_comp_target_name}")) {
      if (get_path_info(src, "extension") == "comp") {
        sources += [ src ]
      }
    }
    inputs = [ "${_hotsort_dir}/platforms/vk/targets/hs_glsl_macros.h" ] +
             _hs_target_gen_includes +
             get_target_outputs(":${_gen_copy_target_name}")
    output_dir = _hs_output_dir
    args = [
      "--target-env",
      "vulkan1.1",
    ]
    include_dirs = _hs_target_include_dirs
    deps = [
      ":${_gen_comp_target_name}",
      ":${_gen_copy_target_name}",
    ]
  }

  #
  # dump the modules as uint32_t literals
  #
  _gen_modules_target_name = "gen_modules_${_hs_target_name}"
  compiled_action(_gen_modules_target_name) {
    tool = "${_hotsort_dir}/platforms/vk/targets:hotsort_modules_to_literals"
    inputs = get_target_outputs(":${_gen_spv_target_name}")
    outputs = _hs_target_gen_inlines
    args = rebase_path(outputs, root_build_dir) +
           rebase_path(inputs, root_build_dir)
    deps = [ ":${_gen_spv_target_name}" ]
  }

  #
  # either dump a binary or return a static library
  #
  if (_hs_target_dump) {
    #
    # executable for dumping a binary image of target
    #
    _hs_target_dump_name = "hotsort_dump_" + invoker.hotsort_target_name

    executable(_hs_target_dump_name) {
      defines = [ "HS_DUMP" ]
      sources = _hs_target_gen_sources
      include_dirs = _hs_target_include_dirs
      deps = [ "${_gen_comp_target_name}" ]
    }

    #
    # dump a binary image of target
    #
    _gen_bin_target_name = "gen_bin_${_hs_target_name}"
    compiled_action(_gen_bin_target_name) {
      tool = ":$_hs_target_dump_name"
      sources = _hs_target_sources
      outputs = [ "${_hs_output_dir}/hs_target.bin" ]
      args = rebase_path(outputs, root_build_dir)
      public_deps = [ ":$_hs_target_dump_name" ]
    }

    #
    # dummy group invokes $host_toolchain
    #
    group(target_name) {
      public_deps = [ ":${_gen_bin_target_name}($host_toolchain)" ]
    }
  } else {
    #
    # target is a static library
    #
    _config_name = "${target_name}_public_config"
    config(_config_name) {
      include_dirs = [ _hs_public_include_dirs ]
    }

    static_library(target_name) {
      output_name = "hotsort_vk_${_hs_target_name}"
      public = [
        "${_hs_output_dir}/hs_config.h",
        "${_hs_output_dir}/hs_target.h",
      ]
      sources = _hs_target_sources
      include_dirs = _hs_target_include_dirs
      public_configs = [ ":${_config_name}" ]
      deps = [
        ":${_gen_comp_target_name}",
        ":${_gen_modules_target_name}",
        ":${_gen_spv_target_name}",
      ]
    }
  }
}

# The following templates are used by hotsort_target() to group GPU
# architecture settings (corresponding to the 'gpu_arch' variable).
#
# They all expect the variables listed in _hotsort_target_forward_variables
#
_hotsort_target_forward_variables = [
  "glsl_bindings",
  "hotsort_target",
  "hotsort_target_args",
  "hotsort_target_config_files",
  "hotsort_target_dump",
  "hotsort_target_name",
  "type_dwords",
]

# AMD GCN3
#
# Configurations (32-bit + 64-bit):
#
# $HS_GEN -v -a "glsl" -D HS_AMD_GCN3 -t 1 -w 64 -r 16 -s 32768 -S 32768 -b 16 -m 1 -M 1 -f 1 -F 1 -c 1 -C 1 -z
# $HS_GEN -v -a "glsl" -D HS_AMD_GCN3 -t 2 -w 64 -r 8  -s 32768 -S 32768 -b 16 -m 1 -M 1 -f 1 -F 1 -c 1 -C 1 -z
#
template("hotsort_target_gpu_arch_amd_gcn3") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "amd/gcn3"
    if (type_dwords == 2) {
      thread_regs = 8
    } else {
      thread_regs = 16
    }
    warp_lanes = 64
    warps_per_group = 16
    smem_bs = 32768
    smem_bc = 32768
    merge_flip_lo = 1
    merge_flip_hi = 1
    merge_half_lo = 1
    merge_half_hi = 1
    warps_min = 1
    warps_mod = 1
    autotune = true

    # See technical note at the top of this file.
    # NOTE: Shader list only depends no |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bs_4.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_bc_4.comp",
      "hs_fm_1_0.comp",
      "hs_fm_1_1.comp",
      "hs_fm_1_2.comp",
      "hs_fm_1_3.comp",
      "hs_fm_1_4.comp",
      "hs_hm_1.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

# Intel GEN8
#
# Configurations (32-bit + 64-bit):
#
# $HS_GEN -v -a "glsl" -D HS_INTEL_GEN8 -t 1 -w 16 -r 8  -s 21504 -S 65536 -b 16 -B 48 -m 1 -M 1 -f 0 -F 0 -c 0 -C 0 -z
# $HS_GEN -v -a "glsl" -D HS_INTEL_GEN8 -t 2 -w 8  -r 16 -s 21504 -S 65536 -b 16 -B 48 -m 1 -M 1 -f 1 -F 1 -c 1 -C 1 -z
#
template("hotsort_target_gpu_arch_intel_gen8") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "intel/gen8"
    if (type_dwords == 2) {
      warp_lanes = 8
      warps_per_group = 16
      warps_max = 48
      thread_regs = 16
      smem_bs = 21504
      smem_bc = 65536
      merge_flip_lo = 1
      merge_flip_hi = 1
      merge_half_lo = 1
      merge_half_hi = 1
      warps_min = 1
      warps_mod = 1
      autotune = true
    } else {
      warp_lanes = 8
      warps_per_group = 16
      warps_max = 48
      thread_regs = 16
      smem_bs = 21504
      smem_bc = 65536
      merge_flip_lo = 1
      merge_flip_hi = 1
      merge_half_lo = 1
      merge_half_hi = 1
      warps_min = 1
      warps_mod = 1
      autotune = true
    }

    # See technical note at the top of this file.
    # NOTE: Shader list only depends on |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bs_4.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_bc_4.comp",
      "hs_fm_1_0.comp",
      "hs_fm_1_1.comp",
      "hs_fm_1_2.comp",
      "hs_fm_1_3.comp",
      "hs_fm_1_4.comp",
      "hs_hm_1.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

# Nvidia SM35 and over.
#
# Configurations (32-bit + 64-bit):
#
# $HS_GEN -v -a "glsl" -D HS_NVIDIA_SM35 -t 1 -w 32 -r 16 -s 32768 -S 32768 -b 16 -m 1 -M 1 -p 1 -P 1 -f 0 -F 0 -c 0 -C 0 -z
# $HS_GEN -v -a "glsl" -D HS_NVIDIA_SM35 -t 2 -w 32 -r 8  -s 32768 -S 32768 -b 16 -m 1 -M 1 -p 1 -P 1 -f 0 -F 0 -c 0 -C 0 -z
#
template("hotsort_target_gpu_arch_nvidia_sm35") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "nvidia/sm35"
    if (type_dwords == 2) {
      thread_regs = 8
    } else {
      thread_regs = 16
    }
    warp_lanes = 32
    warps_per_group = 16
    smem_bs = 32768
    smem_bc = 32768
    merge_flip_lo = 0
    merge_flip_hi = 0
    merge_half_lo = 0
    merge_half_hi = 0
    merge_flip_warps = 1
    merge_half_warps = 1
    warps_min = 1
    warps_mod = 1
    autotune = true

    # See technical note at the top of this file.
    # NOTE: Shader list only depends on |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bs_4.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_bc_4.comp",
      "hs_fm_0_0.comp",
      "hs_fm_0_1.comp",
      "hs_fm_0_2.comp",
      "hs_fm_0_3.comp",
      "hs_hm_0.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

# Google SwiftShader
#
# Configurations (32-bit + 64-bit):
#
# FIXME(allanmac):
#  * these are placeholder configuration values
#  * the same configuration is being used for both x86/SSE and ARM/NEON
#
template("hotsort_target_gpu_arch_google_swiftshader") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "google/swiftshader"
    if (type_dwords == 2) {
      thread_regs = 16
    } else {
      thread_regs = 16
    }
    warp_lanes = 4
    warps_per_group = 16
    smem_bs = 32768
    smem_bc = 32768
    merge_flip_lo = 1
    merge_flip_hi = 1
    merge_half_lo = 1
    merge_half_hi = 1
    autotune = true

    # See technical note at the top of this file.
    # NOTE: Shader list only depends on |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bs_4.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_bc_4.comp",
      "hs_fm_1_0.comp",
      "hs_fm_1_1.comp",
      "hs_fm_1_2.comp",
      "hs_fm_1_3.comp",
      "hs_fm_1_4.comp",
      "hs_hm_1.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

# ARM Mali Bifrost4
#
# Configurations (32-bit + 64-bit):
#
# NOTE(allanmac):
#
#  * these appear to be reasonable configuration values but more time
#    could be spent determining if they're optimal.
#
template("hotsort_target_gpu_arch_arm_bifrost4") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "arm/bifrost4"
    if (type_dwords == 2) {
      thread_regs = 8
    } else {
      thread_regs = 16
    }
    warp_lanes = 4
    warps_per_group = 8
    smem_bs = 4096
    smem_bc = 4096
    merge_flip_lo = 1
    merge_flip_hi = 1
    merge_half_lo = 1
    merge_half_hi = 1
    autotune = true

    # See technical note at the top of this file.
    # NOTE: Shader list only depends on |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_fm_1_0.comp",
      "hs_fm_1_1.comp",
      "hs_fm_1_2.comp",
      "hs_fm_1_3.comp",
      "hs_hm_1.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

# ARM Mali Bifrost8
#
# Configurations (32-bit + 64-bit):
#
# NOTE(allanmac):
#
#  * these appear to be reasonable configuration values but more time
#    could be spent determining if they're optimal.
#
template("hotsort_target_gpu_arch_arm_bifrost8") {
  hotsort_target_internal(target_name) {
    forward_variables_from(invoker, _hotsort_target_forward_variables)
    vendor_config = "arm/bifrost8"
    if (type_dwords == 2) {
      thread_regs = 8
    } else {
      thread_regs = 16
    }
    warp_lanes = 8
    warps_per_group = 8
    smem_bs = 4096
    smem_bc = 4096
    merge_flip_lo = 1
    merge_flip_hi = 1
    merge_half_lo = 1
    merge_half_hi = 1
    autotune = true

    # See technical note at the top of this file.
    # NOTE: Shader list only depends on |merge_*| and |warps_per_group| values.
    shader_names = [
      "hs_bs_0.comp",
      "hs_bs_1.comp",
      "hs_bs_2.comp",
      "hs_bs_3.comp",
      "hs_bc_0.comp",
      "hs_bc_1.comp",
      "hs_bc_2.comp",
      "hs_bc_3.comp",
      "hs_fm_1_0.comp",
      "hs_fm_1_1.comp",
      "hs_fm_1_2.comp",
      "hs_fm_1_3.comp",
      "hs_hm_1.comp",
      "hs_fill_in.comp",
      "hs_fill_out.comp",
      "hs_transpose.comp",
    ]
  }
}

#
# Generates a "HotSort target", which contains a compiled compute kernel to
# perform sorting of 32-bit or 64-bit integers, highly optimized for a given
# GPU architecture.
#
# To use a hotsort target in your code, do the following:
#
#   1) Declare a hotsort_target(<target_name>) target in your BUILD.gn
#      that sets the appropriate configuration parameters (see below).
#
#   2) Add <target_name> to your source file's GN target deps variable.
#
#   3) In your source file, #include "<target_name>/hs_target.h", an
#      auto-generated header that defines a single variable declared as:
#
#       extern struct hotsort_vk_target const * const <target_name>;
#
#      NOTE: This GN template ensures that anything that depends on this
#            GN target will have the right include_dirs set to do so.
#
#   4) Pass the <target_name> address to hotsort_vk_create().
#
#
# Variables:
#
#    gpu_arch: Name of a GPU architecture supported by Spinel.
#      NOTE: An assert message will list available ones if you are not sure.
#
#    type_dwords: number of 32-bit words per sort entry. Must be 1 or 2.
#
#    glsl_bindings: A string containing four comma-separated unsigned integers,
#      related to GLSL, they represent the descriptor sets and bindings of
#      the input and output arrays.
#
# The following variables are still supported for legacy reasons.
#
#  hotsort_target_name:
#    A name that conveys the configuration of the generated HotSort
#    algorithm. If not provided, defaults to the short name of
#    ${target_name}.
#
#  hotsort_target_config_files:
#    An optional list of additional configuration files, which will be added
#    to the specific configuration file determined from the "gpu_arch"
#    variable.
#
#  hotsort_target_dump:
#    Boolean, if true the generated GN target is a group that references a
#    target binary produced by the host toolchain.  Otherwise, a static library
#    is produced on the current toolchain.
#
#  hotsort_target_args:
#    Extra arguments passed to the 'hotsort_gen' HotSort algorithm code
#    generator.
#
template("hotsort_target") {
  # Sanity checking the "gpu_arch" variable now to avoid a cryptic GN error
  # message if it is not supported.
  assert(defined(invoker.gpu_arch),
         "gpu_arch must be defined to one of ${_hotsort_gpu_archs}")
  _found_gpu_arch = false
  foreach(arch, _hotsort_gpu_archs) {
    if (arch == invoker.gpu_arch) {
      _found_gpu_arch = true
    }
  }
  assert(
      _found_gpu_arch,
      "Unsupported gpu_arch value '${invoker.gpu_arch}', try one of ${_hotsort_gpu_archs}")

  # Now invoke the gpu_arch-specific GN template, that should be defined above.
  _target_type = "hotsort_target_gpu_arch_${invoker.gpu_arch}"
  target(_target_type, target_name) {
    forward_variables_from(invoker, "*", [ "gpu_arch" ])
  }
}

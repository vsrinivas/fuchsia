// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    bt_manifest_integration_lib::add_fidl_service_handler,
    fidl::endpoints::DiscoverableProtocolMarker,
    fidl_fuchsia_bluetooth_a2dp as fidl_a2dp, fidl_fuchsia_bluetooth_avdtp as fidl_avdtp,
    fidl_fuchsia_bluetooth_avrcp as fidl_avrcp,
    fidl_fuchsia_bluetooth_bredr::{ProfileMarker, ProfileRequestStream},
    fidl_fuchsia_bluetooth_internal_a2dp::{ControllerMarker, ControllerProxy},
    fidl_fuchsia_cobalt::{LoggerFactoryMarker, LoggerFactoryRequestStream},
    fidl_fuchsia_media::{
        AudioDeviceEnumeratorMarker, AudioDeviceEnumeratorRequestStream,
        SessionAudioConsumerFactoryMarker, SessionAudioConsumerFactoryRequestStream,
    },
    fidl_fuchsia_media_sessions2::{
        DiscoveryMarker, DiscoveryRequestStream, PublisherMarker, PublisherRequestStream,
    },
    fidl_fuchsia_mediacodec::{CodecFactoryMarker, CodecFactoryRequestStream},
    fidl_fuchsia_settings::{AudioMarker, AudioRequestStream},
    fidl_fuchsia_sysmem::{AllocatorMarker, AllocatorRequestStream},
    fidl_fuchsia_tracing_provider::{RegistryMarker, RegistryRequestStream},
    fuchsia_async as fasync,
    fuchsia_component::server::ServiceFs,
    fuchsia_component_test::{
        builder::{ComponentSource, RealmBuilder, RouteEndpoint},
        mock::{Mock, MockHandles},
    },
    futures::{channel::mpsc, SinkExt, StreamExt},
    std::{collections::HashSet, iter::FromIterator},
    tracing::info,
};

/// A2DP component URL.
const A2DP_URL: &str = "fuchsia-pkg://fuchsia.com/bt-a2dp-smoke-test#meta/bt-a2dp-topology-fake.cm";

/// The different events generated by this test.
/// Note: In order to prevent the component under test from terminating, any FIDL request or
/// Proxy is preserved.
enum Event {
    Profile(Option<ProfileRequestStream>),
    Avdtp(Option<fidl_avdtp::PeerManagerProxy>),
    AudioMode(Option<fidl_a2dp::AudioModeProxy>),
    A2dpMediaStream(Option<ControllerProxy>),
    Avrcp(Option<fidl_avrcp::PeerManagerRequestStream>),
    Codec(Option<CodecFactoryRequestStream>),
    Registry(Option<RegistryRequestStream>),
    Session(Option<SessionAudioConsumerFactoryRequestStream>),
    AudioSettings(Option<AudioRequestStream>),
    Cobalt(Option<LoggerFactoryRequestStream>),
    MediaSession(Option<DiscoveryRequestStream>),
    MediaPublisher(Option<PublisherRequestStream>),
    AudioDevice(Option<AudioDeviceEnumeratorRequestStream>),
    Allocator(Option<AllocatorRequestStream>),
}

impl From<ProfileRequestStream> for Event {
    fn from(src: ProfileRequestStream) -> Self {
        Self::Profile(Some(src))
    }
}

impl From<fidl_avrcp::PeerManagerRequestStream> for Event {
    fn from(src: fidl_avrcp::PeerManagerRequestStream) -> Self {
        Self::Avrcp(Some(src))
    }
}

impl From<CodecFactoryRequestStream> for Event {
    fn from(src: CodecFactoryRequestStream) -> Self {
        Self::Codec(Some(src))
    }
}

impl From<RegistryRequestStream> for Event {
    fn from(src: RegistryRequestStream) -> Self {
        Self::Registry(Some(src))
    }
}

impl From<SessionAudioConsumerFactoryRequestStream> for Event {
    fn from(src: SessionAudioConsumerFactoryRequestStream) -> Self {
        Self::Session(Some(src))
    }
}

impl From<AudioRequestStream> for Event {
    fn from(src: AudioRequestStream) -> Self {
        Self::AudioSettings(Some(src))
    }
}

impl From<LoggerFactoryRequestStream> for Event {
    fn from(src: LoggerFactoryRequestStream) -> Self {
        Self::Cobalt(Some(src))
    }
}

impl From<DiscoveryRequestStream> for Event {
    fn from(src: DiscoveryRequestStream) -> Self {
        Self::MediaSession(Some(src))
    }
}

impl From<PublisherRequestStream> for Event {
    fn from(src: PublisherRequestStream) -> Self {
        Self::MediaPublisher(Some(src))
    }
}

impl From<AudioDeviceEnumeratorRequestStream> for Event {
    fn from(src: AudioDeviceEnumeratorRequestStream) -> Self {
        Self::AudioDevice(Some(src))
    }
}

impl From<AllocatorRequestStream> for Event {
    fn from(src: AllocatorRequestStream) -> Self {
        Self::Allocator(Some(src))
    }
}

/// Represents a fake A2DP client that requests the `avdtp.PeerManager` and `a2dp.AudioMode` services.
async fn mock_a2dp_client(
    mut sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let peer_manager_svc = handles.connect_to_service::<fidl_avdtp::PeerManagerMarker>()?;
    sender.send(Event::Avdtp(Some(peer_manager_svc))).await.expect("failed sending ack to test");

    let audio_mode_svc = handles.connect_to_service::<fidl_a2dp::AudioModeMarker>()?;
    sender.send(Event::AudioMode(Some(audio_mode_svc))).await.expect("failed sending ack to test");

    let a2dp_media_stream_svc = handles.connect_to_service::<ControllerMarker>()?;
    sender
        .send(Event::A2dpMediaStream(Some(a2dp_media_stream_svc)))
        .await
        .expect("failed sending ack to test");
    Ok(())
}

/// The component mock that provides all the services that A2DP requires.
async fn mock_component(sender: mpsc::Sender<Event>, handles: MockHandles) -> Result<(), Error> {
    let mut fs = ServiceFs::new();

    add_fidl_service_handler::<fidl_avrcp::PeerManagerMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<ProfileMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<LoggerFactoryMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<AudioDeviceEnumeratorMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<SessionAudioConsumerFactoryMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<PublisherMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<CodecFactoryMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<AudioMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<AllocatorMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<RegistryMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<DiscoveryMarker, _>(&mut fs, sender);

    let _ = fs.serve_connection(handles.outgoing_dir.into_channel())?;
    fs.collect::<()>().await;

    Ok(())
}

/// Local name of the A2DP component in the Realm.
const A2DP_MONIKER: &str = "a2dp";
/// Local name of the A2DP client in the Realm.
const A2DP_CLIENT_MONIKER: &str = "fake-a2dp-client";
/// Local name of the component which provides services used by A2DP in the Realm.
const SERVICE_PROVIDER_MONIKER: &str = "fake-service-provider";

fn add_a2dp_dependency_route<S: DiscoverableProtocolMarker>(builder: &mut RealmBuilder) {
    let _ = builder
        .add_protocol_route::<S>(
            RouteEndpoint::component(SERVICE_PROVIDER_MONIKER),
            vec![RouteEndpoint::component(A2DP_MONIKER)],
        )
        .expect("Failed adding route for service");
}

/// Tests that the v2 A2DP component has the correct topology and verifies that
/// it connects and provides the expected services.
#[fasync::run_singlethreaded(test)]
async fn a2dp_v2_component_topology() {
    fuchsia_syslog::init().unwrap();
    info!("Starting A2DP v2 smoke test...");

    let (sender, mut receiver) = mpsc::channel(0);
    let fake_client_tx = sender.clone();
    let service_tx = sender.clone();

    let mut builder = RealmBuilder::new().await.expect("Failed to create test realm builder");

    // The v2 component under test.
    let _ = builder
        .add_component(A2DP_MONIKER, ComponentSource::url(A2DP_URL.to_string()))
        .await
        .expect("Failed adding a2dp to topology");

    // Generic backend component that provides a slew of services that will be requested.
    let _ = builder
        .add_component(
            SERVICE_PROVIDER_MONIKER,
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = service_tx.clone();
                    Box::pin(mock_component(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding profile mock to topology");

    // Mock A2DP client that will request the PeerManager and AudioMode services
    // which are provided by the A2DP component.
    let _ = builder
        .add_eager_component(
            A2DP_CLIENT_MONIKER,
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = fake_client_tx.clone();
                    Box::pin(mock_a2dp_client(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding a2dp client mock to topology");

    // Capabilities provided by A2DP.
    let _ = builder
        .add_protocol_route::<fidl_avdtp::PeerManagerMarker>(
            RouteEndpoint::component(A2DP_MONIKER),
            vec![RouteEndpoint::component(A2DP_CLIENT_MONIKER)],
        )
        .expect("Failed adding route for avdtp.PeerManager service")
        .add_protocol_route::<fidl_a2dp::AudioModeMarker>(
            RouteEndpoint::component(A2DP_MONIKER),
            vec![RouteEndpoint::component(A2DP_CLIENT_MONIKER)],
        )
        .expect("Failed adding route for a2dp.AudioMode service")
        .add_protocol_route::<ControllerMarker>(
            RouteEndpoint::component(A2DP_MONIKER),
            vec![RouteEndpoint::component(A2DP_CLIENT_MONIKER)],
        )
        .expect("Failed adding route for internal.a2dp.Controller service");

    // Capabilities provided by the generic service provider component, which are consumed
    // by the A2DP component.
    add_a2dp_dependency_route::<fidl_avrcp::PeerManagerMarker>(&mut builder);
    add_a2dp_dependency_route::<ProfileMarker>(&mut builder);
    add_a2dp_dependency_route::<LoggerFactoryMarker>(&mut builder);
    add_a2dp_dependency_route::<AudioDeviceEnumeratorMarker>(&mut builder);
    add_a2dp_dependency_route::<SessionAudioConsumerFactoryMarker>(&mut builder);
    add_a2dp_dependency_route::<PublisherMarker>(&mut builder);
    add_a2dp_dependency_route::<CodecFactoryMarker>(&mut builder);
    add_a2dp_dependency_route::<AudioMarker>(&mut builder);
    add_a2dp_dependency_route::<AllocatorMarker>(&mut builder);
    add_a2dp_dependency_route::<RegistryMarker>(&mut builder);
    // Capability used by AVRCP Target, a child of A2DP. Route this service to A2DP to be
    // transitively routed to it.
    add_a2dp_dependency_route::<DiscoveryMarker>(&mut builder);

    // Logging service, used by all children in this test.
    let _ = builder
        .add_protocol_route::<fidl_fuchsia_logger::LogSinkMarker>(
            RouteEndpoint::AboveRoot,
            vec![
                RouteEndpoint::component(A2DP_MONIKER),
                RouteEndpoint::component(A2DP_CLIENT_MONIKER),
                RouteEndpoint::component(SERVICE_PROVIDER_MONIKER),
            ],
        )
        .expect("Failed adding LogSink route to test components");
    let test_topology = builder.build().create().await.unwrap();

    let _ = test_topology.root.connect_to_binder().unwrap();

    // If the routing is correctly configured, we expect 15 events:
    //   - `bt-a2dp` connecting to the 10 services specified in its manifest.
    //   - `bt-avrcp-target` (a child of bt-a2dp) connecting to the `avrcp.PeerManager` and
    //     `Discovery` services.
    //   - `fake-a2dp-client` connecting to the `avdtp.PeerManager`, `AudioMode`, & `Controller`
    //     services which are provided by `bt-a2dp`.
    let mut events = Vec::new();
    let expected_number_of_events = 15;
    for i in 0..expected_number_of_events {
        let msg = format!("Unexpected error waiting for {:?} event", i);
        events.push(receiver.next().await.expect(&msg));
    }
    assert_eq!(events.len(), expected_number_of_events);

    let discriminants: Vec<_> = events.iter().map(std::mem::discriminant).collect();

    // We expect two avrcp.PeerManager events since both bt-a2dp and bt-avrcp-target use it.
    assert_eq!(
        discriminants.iter().filter(|&&d| d == std::mem::discriminant(&Event::Avrcp(None))).count(),
        2
    );
    // There should be only one duplicate service request (avrcp.PeerManager), the rest
    // should be unique requests (14 in total).
    let discriminant_set: HashSet<_> = HashSet::from_iter(discriminants.iter());
    assert_eq!(discriminant_set.len(), 14);

    info!("Finished A2DP smoke test");
}

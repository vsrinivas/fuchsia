// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    fidl_fuchsia_bluetooth_bredr::{ProfileMarker, ProfileRequest},
    fidl_fuchsia_bluetooth_hfp::{HfpMarker, HfpProxy},
    fidl_fuchsia_bluetooth_hfp_test::{HfpTestMarker, HfpTestProxy},
    fidl_fuchsia_io as fio,
    fidl_fuchsia_media::{AudioDeviceEnumeratorMarker, AudioDeviceEnumeratorRequestStream},
    fidl_fuchsia_power::{BatteryManagerMarker, BatteryManagerRequestStream},
    fuchsia_audio_dai::test::mock_dai_dev_with_io_devices,
    fuchsia_component::server::ServiceFs,
    fuchsia_component_test::new::{
        Capability, ChildOptions, LocalComponentHandles, RealmBuilder, Ref, Route,
    },
    futures::{channel::mpsc, SinkExt, StreamExt},
    realmbuilder_mock_helpers::{add_fidl_service_handler, mock_component, mock_dev},
    std::{collections::HashSet, iter::FromIterator},
    tracing::info,
};

/// HFP Audio Gateway component URL.
const HFP_AG_URL: &str =
    "fuchsia-pkg://fuchsia.com/bt-hfp-audio-gateway-smoke-test#meta/bt-hfp-audio-gateway.cm";

/// Local name of the HFP component under test.
const HFP_MONIKER: &str = "hfp";
/// Local name of the mock that is providing the `bredr.Profile` service.
const FAKE_PROFILE_MONIKER: &str = "fake-profile";
/// Local name of the mock that is providing services used by HFP.
const FAKE_CAPABILITY_PROVIDER_MONIKER: &str = "fake-audio-device-provider";
const MOCK_DEV_MONIKER: &str = "mock-dev";
/// Local name of the fake HFP client that is connecting to `HFP_MONIKER`s services.
const HFP_CLIENT_MONIKER: &str = "fake-hfp-client";

/// The different events generated by this test.
/// Note: In order to prevent the component under test from terminating, any FIDL request or
/// Proxy is preserved.
enum Event {
    /// A BR/EDR Profile event.
    Profile(Option<ProfileRequest>),
    /// HFP service client connection.
    Hfp(Option<HfpProxy>),
    /// HFP Test service client connection.
    HfpTest(Option<HfpTestProxy>),
    /// Battery Manager service connection.
    BatteryManager(Option<BatteryManagerRequestStream>),
    /// AudioDeviceEnumerator service connection.
    AudioDevice(Option<AudioDeviceEnumeratorRequestStream>),
}

impl From<ProfileRequest> for Event {
    fn from(src: ProfileRequest) -> Self {
        Self::Profile(Some(src))
    }
}

impl From<BatteryManagerRequestStream> for Event {
    fn from(src: BatteryManagerRequestStream) -> Self {
        Self::BatteryManager(Some(src))
    }
}

impl From<AudioDeviceEnumeratorRequestStream> for Event {
    fn from(src: AudioDeviceEnumeratorRequestStream) -> Self {
        Self::AudioDevice(Some(src))
    }
}

async fn mock_capability_provider(
    sender: mpsc::Sender<Event>,
    handles: LocalComponentHandles,
) -> Result<(), Error> {
    let mut fs = ServiceFs::new();
    add_fidl_service_handler::<AudioDeviceEnumeratorMarker, _>(&mut fs, sender.clone());
    add_fidl_service_handler::<BatteryManagerMarker, _>(&mut fs, sender.clone());
    let _ = fs.serve_connection(handles.outgoing_dir.into_channel())?;
    fs.collect::<()>().await;
    Ok(())
}

/// Represents a fake HFP client that requests the `Hfp` and `HfpTest` services.
async fn mock_hfp_client(
    mut sender: mpsc::Sender<Event>,
    handles: LocalComponentHandles,
) -> Result<(), Error> {
    let hfp_svc = handles.connect_to_protocol::<HfpMarker>()?;
    sender.send(Event::Hfp(Some(hfp_svc))).await.expect("failed sending ack to test");

    let hfp_test_svc = handles.connect_to_protocol::<HfpTestMarker>()?;
    sender.send(Event::HfpTest(Some(hfp_test_svc))).await.expect("failed sending ack to test");
    Ok(())
}

/// Tests that the v2 HFP Audio Gateway component has the correct topology and verifies that
/// it provides and connects to the expected services.
#[fuchsia::test]
async fn hfp_audio_gateway_v2_capability_routing() {
    info!("Starting HFP Audio Gateway v2 smoke test...");

    let (sender, mut receiver) = mpsc::channel(4);

    let builder = RealmBuilder::new().await.expect("Failed to create test realm builder");
    // The v2 component under test.
    let hfp = builder
        .add_child(HFP_MONIKER, HFP_AG_URL.to_string(), ChildOptions::new().eager())
        .await
        .expect("Failed adding HFP-AG to topology");
    // Mock Profile component to receive `bredr.Profile` requests.
    let sender_clone = sender.clone();
    let fake_profile = builder
        .add_local_child(
            FAKE_PROFILE_MONIKER,
            move |handles: LocalComponentHandles| {
                Box::pin(mock_component::<ProfileMarker, _>(sender_clone.clone(), handles))
            },
            ChildOptions::new(),
        )
        .await
        .expect("Failed adding profile mock to topology");
    // Mock component to handle HFP capability requests.
    let sender_clone = sender.clone();
    let fake_capability_provider = builder
        .add_local_child(
            FAKE_CAPABILITY_PROVIDER_MONIKER,
            move |handles: LocalComponentHandles| {
                Box::pin(mock_capability_provider(sender_clone.clone(), handles))
            },
            ChildOptions::new(),
        )
        .await
        .expect("Failed adding capability provider mock to topology");

    let mock_dev = builder
        .add_local_child(
            MOCK_DEV_MONIKER,
            move |handles: LocalComponentHandles| {
                Box::pin(mock_dev(
                    handles,
                    mock_dai_dev_with_io_devices("input1".to_string(), "output1".to_string()),
                ))
            },
            ChildOptions::new().eager(),
        )
        .await
        .expect("Failed adding mock /dev provider to topology");
    // Mock HFP-AG client that will request the `Hfp` and `HfpTest` services
    // which are provided by `bt-hfp-audio-gateway.cml`.
    let sender_clone = sender.clone();
    let hfp_client = builder
        .add_local_child(
            HFP_CLIENT_MONIKER,
            move |handles: LocalComponentHandles| {
                Box::pin(mock_hfp_client(sender_clone.clone(), handles))
            },
            ChildOptions::new().eager(),
        )
        .await
        .expect("Failed adding hfp client mock to topology");

    // Set up capabilities.
    builder
        .add_route(
            Route::new()
                .capability(Capability::protocol::<HfpMarker>())
                .capability(Capability::protocol::<HfpTestMarker>())
                .from(&hfp)
                .to(&hfp_client),
        )
        .await
        .expect("Failed adding route for Hfp services");
    builder
        .add_route(
            Route::new()
                .capability(Capability::protocol::<ProfileMarker>())
                .from(&fake_profile)
                .to(&hfp),
        )
        .await
        .expect("Failed adding route for Profile service");
    builder
        .add_route(
            Route::new()
                .capability(Capability::protocol::<AudioDeviceEnumeratorMarker>())
                .from(&fake_capability_provider)
                .to(&hfp),
        )
        .await
        .expect("Failed adding route for AudioDeviceEnumerator service");
    builder
        .add_route(
            Route::new()
                .capability(Capability::protocol::<BatteryManagerMarker>())
                .from(&fake_capability_provider)
                .to(&hfp),
        )
        .await
        .expect("Failed adding route for BatteryManager service");
    builder
        .add_route(
            Route::new()
                .capability(
                    Capability::directory("dev-dai")
                        .path("/dev/class/dai")
                        .rights(fio::RW_STAR_DIR),
                )
                .from(&mock_dev)
                .to(&hfp),
        )
        .await
        .expect("Failed adding route for DAI device directory");
    builder
        .add_route(
            Route::new()
                .capability(Capability::protocol::<fidl_fuchsia_logger::LogSinkMarker>())
                .from(Ref::parent())
                .to(&hfp)
                .to(&fake_profile)
                .to(&fake_capability_provider)
                .to(&hfp_client),
        )
        .await
        .expect("Failed adding LogSink route to test components");
    let mut test_topology = builder.build().await.unwrap();
    let realm_destroyed = test_topology.root.take_destroy_waiter();

    // If the routing is correctly configured, we expect 6 events:
    //   1. `hfp-audio-gateway` connecting to the Profile service to Advertise.
    //   2. `hfp-audio-gateway` connecting to the Profile service to Search.
    //   3. `hfp-audio-gateway` connecting to the AudioDeviceEnumerator service.
    //   4. `hfp-audio-gateway` connecting to the BatteryManager service.
    //   5/6. `fake-hfp-client` connecting to the Hfp & HfpTest services which are provided by
    //      `hfp-audio-gateway`.
    let mut events = Vec::new();
    let expected_number_of_events = 6;
    for i in 0..expected_number_of_events {
        let msg = format!("Unexpected error waiting for {:?} event", i);
        events.push(receiver.next().await.expect(&msg));
    }
    assert_eq!(events.len(), expected_number_of_events);
    let discriminants: HashSet<_> = HashSet::from_iter(events.iter().map(std::mem::discriminant));

    // Expect all events.
    let expected: HashSet<_> = HashSet::from_iter(
        vec![
            Event::Profile(None),
            Event::Hfp(None),
            Event::HfpTest(None),
            Event::AudioDevice(None),
            Event::BatteryManager(None),
        ]
        .iter()
        .map(std::mem::discriminant),
    );
    assert_eq!(discriminants, expected);

    // Expect two `Profile` events.
    assert_eq!(
        events
            .iter()
            .filter(|&d| std::mem::discriminant(d) == std::mem::discriminant(&Event::Profile(None)))
            .count(),
        2
    );

    // Ensure realm components terminate before the local executor stops mocked components. Prevents
    // issues with mocked dependencies disappearing before termination.
    drop(test_topology);
    let _ = realm_destroyed.await.expect("realm destruction wait failed");
    info!("Finished HFP Audio Gateway smoke test");
}

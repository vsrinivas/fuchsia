// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    fidl::client::QueryResponseFut,
    futures::{
        future::Future,
        ready,
        stream::{FusedStream, Stream},
        task::{Context, Poll},
        FutureExt,
    },
    std::pin::Pin,
};

/// A GeneratedFutureStream generates a stream by polling a future that is generated by a function that
/// is provded to it.  Every time the future completes, the stream returns the item, and will call
/// the generator function to get the future for the next item the next time it is polled.
/// uses the generator function to get the future or the next item.
///
/// If the generator returns None, the stream will finish with None.
/// GeneratedFutureStreams are FusedStreams, meaning they will never return Some again after returning
/// None.
pub struct GeneratedFutureStream<Fut, T>
where
    Fut: Future<Output = T> + Unpin + Send,
{
    /// The generator to produce a new Future for the next item.
    /// None if the generator has returned None meaning there are no more items.
    generator: Option<Box<dyn FnMut() -> Option<Fut> + Send>>,
    /// The future that will produce the next item.  None if the next future needs to be generated.
    future: Option<Fut>,
}

impl<Fut, T> GeneratedFutureStream<Fut, T>
where
    Fut: Future<Output = T> + Unpin + Send,
{
    pub fn new(generator: Box<dyn FnMut() -> Option<Fut> + Send>) -> Self {
        Self { generator: Some(generator), future: None }
    }
}

impl<Fut, T> FusedStream for GeneratedFutureStream<Fut, T>
where
    Fut: Future<Output = T> + Unpin + Send,
{
    fn is_terminated(&self) -> bool {
        self.generator.is_none()
    }
}

impl<Fut, T> Stream for GeneratedFutureStream<Fut, T>
where
    Fut: Future<Output = T> + Unpin + Send,
{
    type Item = T;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        if self.generator.is_none() {
            return Poll::Ready(None);
        }
        if self.future.is_none() {
            let generator = self.generator.as_mut().expect("generator should be set");
            self.future = match (generator)() {
                None => {
                    self.generator = None;
                    self.future = None;
                    return Poll::Ready(None);
                }
                Some(next_item_fut) => Some(next_item_fut),
            };
        }
        let result = ready!(self.future.as_mut().expect("future should be set").poll_unpin(cx));
        self.future = None;
        Poll::Ready(Some(result))
    }
}

/// HangingGetStream is a GeneratedFutureStream that is oriented towards being a client to the
/// "Hanging Get" design pattern for flow control as in //docs/development/api/fidl.md#Flow-Control
pub type HangingGetStream<FidlResult> =
    GeneratedFutureStream<QueryResponseFut<FidlResult>, Result<FidlResult, fidl::Error>>;

#[cfg(test)]
mod tests {

    use super::*;
    use {
        fuchsia_async as fasync,
        futures::{self, StreamExt},
    };

    #[test]
    fn generates_items() {
        let mut exec = fasync::Executor::new().expect("executor should build");
        let mut count = 0;
        let mut stream = GeneratedFutureStream::new(Box::new(move || {
            count += 1;
            Some(futures::future::ready(count))
        }));

        assert_eq!(Poll::Ready(Some(1)), exec.run_until_stalled(&mut stream.next()));
        assert_eq!(Poll::Ready(Some(2)), exec.run_until_stalled(&mut stream.next()));
        assert_eq!(Poll::Ready(Some(3)), exec.run_until_stalled(&mut stream.next()));
    }

    #[test]
    fn terminates_when_none() {
        let mut exec = fasync::Executor::new().expect("executor should build");
        let mut stream =
            GeneratedFutureStream::<futures::future::Ready<u32>, u32>::new(Box::new(|| None));

        assert_eq!(Poll::Ready(None), exec.run_until_stalled(&mut stream.next()));
        assert!(stream.is_terminated());
    }
}

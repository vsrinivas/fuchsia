# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

if (zx != "/") {
  import("//build/unification/global_variables.gni")
}

config("headers") {
  visibility = [
    "$zx/system/ulib/c:*",
    "./*",
  ]
  cflags = [
    "-idirafter",
    rebase_path("include", root_build_dir),
  ]
  asmflags = cflags
}

group("musl_internal") {
  visibility = [
    "$zx/system/ulib/c/*",
    "$zx/third_party/scudo/*",
    "./*",
  ]
  public_deps = [
    "$zx/system/ulib/processargs",
    "$zx/system/ulib/runtime",
    "$zx/system/ulib/zircon",
    "$zx/system/ulib/zircon-internal",
  ]
  public_configs = [
    ":headers",
    ":musl_internal.config",
  ]
}

group("musl_internal_testing") {
  testonly = true
  visibility = [
    "$zx/system/ulib/c/*",
    "$zx/system/utest/libc:*",
    "./*",
  ]
  public_deps = [ ":musl_internal" ]
}

config("musl_internal.config") {
  visibility = [ ":musl_internal" ]

  include_dirs = [
    "src/internal",
    "arch/${toolchain.cpu}",
  ]

  defines = [ "_XOPEN_SOURCE=700" ]

  # TODO(kulakowski): Clean up the junkier -Wno flags below.
  cflags = [
    "-Wno-sign-compare",
    "-Wno-implicit-fallthrough",
  ]
  cflags_c = [ "-Werror=incompatible-pointer-types" ]

  if (!is_gcc) {
    # Some of this code runs before the TLS area for the canary is set up.
    # TODO(mcgrathr): Isolate this to exactly what code needs it.
    cflags += [ "-fno-stack-protector" ]
  }

  # libfuzzer also uses libc internally, by removing the fuzzing
  # instrumentation we avoid it adding noise to the fuzzing coverage.
  # TODO(25073): Once a cleaner solution is found, remove this.
  configs = [ "$zx_build_config:no_fuzzer" ]
}

if ((zx == "/" && toolchain.base_environment == "user") ||
    (zx != "/" && toolchain_variant.base ==
                  "//zircon/system/ulib/c:user.libc_$target_cpu")) {
  group("musl") {
    visibility = [ "$zx/system/ulib/c:*" ]
    deps = [
      "ldso",
      "pthread",
      "src/complex",
      "src/conf",
      "src/ctype",
      "src/dirent",
      "src/env",
      "src/errno",
      "src/exit",
      "src/fcntl",
      "src/fenv",
      "src/internal",
      "src/ipc",
      "src/ldso",
      "src/legacy",
      "src/linux",
      "src/locale",
      "src/math",
      "src/misc",
      "src/mman",
      "src/multibyte",
      "src/network",
      "src/passwd",
      "src/prng",
      "src/process",
      "src/regex",
      "src/sched",
      "src/signal",
      "src/stat",
      "src/stdio",
      "src/stdlib",
      "src/string",
      "src/temp",
      "src/termios",
      "src/thread",
      "src/time",
      "src/unistd",
      "third_party/smoothsort",
      "third_party/tre",
    ]
  }
}

if (zx != "/") {
  # We share just this internal header with fdio so it can implement
  # getifaddrs re-using this address manipulation code.
  source_set("getifaddrs-internal") {
    visibility = [
      "src/network:*",
      "//sdk/lib/fdio:*",
      "//sdk/lib/fdio:fdio_sdk_manifest",
      "//sdk/lib/fdio:fdio_sdk_manifest_meta_copy",
    ]
    sources = [ "src/network/getifaddrs.h" ]
    public_configs = [ ":getifaddrs_include_dirs" ]

    # TODO(fxb/58162): delete the below and fix compiler warnings
    configs += [ "//build/config:Wno-conversion" ]
  }

  config("getifaddrs_include_dirs") {
    visibility = [ ":*" ]
    include_dirs = [ "." ]
  }
}

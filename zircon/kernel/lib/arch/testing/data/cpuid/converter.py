#!/usr/bin/env python3.8
# Copyright 2020 The Fuchsia Authors
#
# Use of this source code is governed by a MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT

import re
import sys
from datetime import datetime

# The regexes for the "CPU" line preamble and that of a set of CPUID values for
# a given (leaf, subleaf), respectively. Both assume the leading and trailing
# whitespace have been stripped.
CPU_LINE_RE = re.compile("^CPU(\s[0-9]+)?:$")
CPUID_LINE_RE = re.compile(
    "^(0x[a-z0-9]{8})\s(0x[a-z0-9]{2}):\seax=(0x[a-z0-9]{8})\sebx=(0x[a-z0-9]{8})\secx=(0x[a-z0-9]{8})\sedx=(0x[a-z0-9]{8})$"
)

HEADER = """// Copyright %s The Fuchsia Authors
//
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT

// GENERATED BY `converter.py`. DO NOT EDIT.
//
// This file gives the set of CPUID values for a particular x86 microprocessor.
// It is meant to be #include'd with the DEFINE_CPUID_VALUES macro defined.
// Each line gives (leaf, subleaf, EAX, EBX, ECX, EDX) for a particular set of
// values, in that order.
""" % datetime.today().year


# Prints to stderr, reserving stdout (via `print`) for the final output.
def Log(msg):
    sys.stderr.write("%s\n" % msg)


def main():
    Log("reading from stdin...")
    data = sys.stdin.readlines()

    Log("writing to stdout...")
    print(HEADER)

    if not data:
        Log("error: no data provided")
        return 1
    elif not CPU_LINE_RE.match(data[0]):
        Log(
            "error: expected `%s` for a first line; not \"%s\"" %
            (CPU_LINE_RE, data[0]))
        return 1
    data = data[1:]

    for line in data:
        line = line.strip()

        if not line:
            return

        # If we happen on another "CPU..." line, assume that we are viewing
        # concatenated CPUID values for different CPUs (as is the case with
        # `cpuid -r`) - and that we have already fully collected the data from
        # a previous CPU.
        if CPU_LINE_RE.match(line):
            return

        matches = CPUID_LINE_RE.match(line)
        if matches is None:
            Log("error: could not parse line \"%s\"" % line)
            return 1
        parsed = matches.groups()
        if len(parsed) < 6:
            Log(
                "error: parsed %s from line \"%s\"; expected more values" %
                (parsed, line))
            return 1
        print("DEFINE_CPUID_VALUES(%s, %s, %s, %s, %s, %s)" % tuple(parsed))


if __name__ == "__main__":
    sys.exit(main())

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace lifecycle {
namespace test {

struct TestDevice_SubscribeToLifecycle_Response;
struct TestDevice_SubscribeToLifecycle_Result;
struct TestDevice_RemoveChild_Response;
struct TestDevice_RemoveChild_Result;
struct TestDevice_AddChild_Response;
struct TestDevice_AddChild_Result;
class Lifecycle;
class TestDevice;

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;

struct TestDevice_SubscribeToLifecycle_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;

struct TestDevice_SubscribeToLifecycle_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  TestDevice_SubscribeToLifecycle_Result();
  ~TestDevice_SubscribeToLifecycle_Result();

  TestDevice_SubscribeToLifecycle_Result(TestDevice_SubscribeToLifecycle_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  TestDevice_SubscribeToLifecycle_Result& operator=(TestDevice_SubscribeToLifecycle_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static TestDevice_SubscribeToLifecycle_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response* val) {
    TestDevice_SubscribeToLifecycle_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static TestDevice_SubscribeToLifecycle_Result WithErr(int32_t* val) {
    TestDevice_SubscribeToLifecycle_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_SubscribeToLifecycle_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(TestDevice_SubscribeToLifecycle_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;

struct TestDevice_RemoveChild_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;

struct TestDevice_RemoveChild_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  TestDevice_RemoveChild_Result();
  ~TestDevice_RemoveChild_Result();

  TestDevice_RemoveChild_Result(TestDevice_RemoveChild_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  TestDevice_RemoveChild_Result& operator=(TestDevice_RemoveChild_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static TestDevice_RemoveChild_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response* val) {
    TestDevice_RemoveChild_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static TestDevice_RemoveChild_Result WithErr(int32_t* val) {
    TestDevice_RemoveChild_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_RemoveChild_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(TestDevice_RemoveChild_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;

struct TestDevice_AddChild_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint64_t child_id = {};
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;

struct TestDevice_AddChild_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  TestDevice_AddChild_Result();
  ~TestDevice_AddChild_Result();

  TestDevice_AddChild_Result(TestDevice_AddChild_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  TestDevice_AddChild_Result& operator=(TestDevice_AddChild_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static TestDevice_AddChild_Result WithResponse(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response* val) {
    TestDevice_AddChild_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static TestDevice_AddChild_Result WithErr(int32_t* val) {
    TestDevice_AddChild_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDevice_AddChild_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(TestDevice_AddChild_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;

class Lifecycle final {
  Lifecycle() = delete;
 public:

  struct OnChildPreReleaseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t child_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_LifecycleOnChildPreReleaseEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };

  struct EventHandlers {
    // Sent when the ChildPreRelease hook is called.
    fit::callback<zx_status_t(uint64_t child_id)> on_child_pre_release;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:

   public:
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:

   public:
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Lifecycle;
    using _Base = ::fidl::CompleterBase;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // Sent when the ChildPreRelease hook is called.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, uint64_t child_id);

  // Sent when the ChildPreRelease hook is called.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t child_id);

  // Sent when the ChildPreRelease hook is called.
  // Messages are encoded in-place.
  static zx_status_t SendOnChildPreReleaseEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnChildPreReleaseResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void OnChildPreReleaseResponse(const ::fidl::DecodedMessage<Lifecycle::OnChildPreReleaseResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceAddChildRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceAddChildRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
extern "C" const fidl_type_t fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;

class TestDevice final {
  TestDevice() = delete;
 public:

  struct AddChildResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDeviceAddChildResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using AddChildRequest = ::fidl::AnyZeroArgMessage;

  struct RemoveChildResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RemoveChildRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t child_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDeviceRemoveChildRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RemoveChildResponse;
  };

  struct SubscribeToLifecycleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SubscribeToLifecycleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel client;

    static constexpr const fidl_type_t* Type = &fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_device_lifecycle_test_TestDeviceSubscribeToLifecycleRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SubscribeToLifecycleResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class AddChild_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      AddChild_Impl(::zx::unowned_channel _client_end);
      ~AddChild_Impl() = default;
      AddChild_Impl(AddChild_Impl&& other) = default;
      AddChild_Impl& operator=(AddChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveChild_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RemoveChild_Impl(::zx::unowned_channel _client_end, uint64_t child_id);
      ~RemoveChild_Impl() = default;
      RemoveChild_Impl(RemoveChild_Impl&& other) = default;
      RemoveChild_Impl& operator=(RemoveChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SubscribeToLifecycle_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::zx::channel client);
      ~SubscribeToLifecycle_Impl() = default;
      SubscribeToLifecycle_Impl(SubscribeToLifecycle_Impl&& other) = default;
      SubscribeToLifecycle_Impl& operator=(SubscribeToLifecycle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using AddChild = AddChild_Impl<AddChildResponse>;
    using RemoveChild = RemoveChild_Impl<RemoveChildResponse>;
    using SubscribeToLifecycle = SubscribeToLifecycle_Impl<SubscribeToLifecycleResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class AddChild_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      AddChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~AddChild_Impl() = default;
      AddChild_Impl(AddChild_Impl&& other) = default;
      AddChild_Impl& operator=(AddChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class RemoveChild_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RemoveChild_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);
      ~RemoveChild_Impl() = default;
      RemoveChild_Impl(RemoveChild_Impl&& other) = default;
      RemoveChild_Impl& operator=(RemoveChild_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SubscribeToLifecycle_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SubscribeToLifecycle_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);
      ~SubscribeToLifecycle_Impl() = default;
      SubscribeToLifecycle_Impl(SubscribeToLifecycle_Impl&& other) = default;
      SubscribeToLifecycle_Impl& operator=(SubscribeToLifecycle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using AddChild = AddChild_Impl<AddChildResponse>;
    using RemoveChild = RemoveChild_Impl<RemoveChildResponse>;
    using SubscribeToLifecycle = SubscribeToLifecycle_Impl<SubscribeToLifecycleResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Adds a child device and returns a unique |id| for the created device.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::AddChild AddChild();

    // Adds a child device and returns a unique |id| for the created device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddChild AddChild(::fidl::BytePart _response_buffer);

    // Removes the child device of the given |id|.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::RemoveChild RemoveChild(uint64_t child_id);

    // Removes the child device of the given |id|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RemoveChild RemoveChild(::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Registers the client for device lifecycle events.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::channel client);

    // Registers the client for device lifecycle events.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SubscribeToLifecycle SubscribeToLifecycle(::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Adds a child device and returns a unique |id| for the created device.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::AddChild AddChild(::zx::unowned_channel _client_end);

    // Adds a child device and returns a unique |id| for the created device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddChild AddChild(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Removes the child device of the given |id|.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::RemoveChild RemoveChild(::zx::unowned_channel _client_end, uint64_t child_id);

    // Removes the child device of the given |id|.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RemoveChild RemoveChild(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t child_id, ::fidl::BytePart _response_buffer);

    // Registers the client for device lifecycle events.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::unowned_channel _client_end, ::zx::channel client);

    // Registers the client for device lifecycle events.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SubscribeToLifecycle SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel client, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Adds a child device and returns a unique |id| for the created device.
    static ::fidl::DecodeResult<AddChildResponse> AddChild(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Removes the child device of the given |id|.
    static ::fidl::DecodeResult<RemoveChildResponse> RemoveChild(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RemoveChildRequest> params, ::fidl::BytePart response_buffer);

    // Registers the client for device lifecycle events.
    static ::fidl::DecodeResult<SubscribeToLifecycleResponse> SubscribeToLifecycle(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SubscribeToLifecycleRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = TestDevice;
    using _Base = ::fidl::CompleterBase;

    class AddChildCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result);
      void ReplySuccess(uint64_t child_id);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t child_id);
      void Reply(::fidl::DecodedMessage<AddChildResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddChildCompleter = ::fidl::Completer<AddChildCompleterBase>;

    virtual void AddChild(AddChildCompleter::Sync _completer) = 0;

    class RemoveChildCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<RemoveChildResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RemoveChildCompleter = ::fidl::Completer<RemoveChildCompleterBase>;

    virtual void RemoveChild(uint64_t child_id, RemoveChildCompleter::Sync _completer) = 0;

    class SubscribeToLifecycleCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SubscribeToLifecycleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SubscribeToLifecycleCompleter = ::fidl::Completer<SubscribeToLifecycleCompleterBase>;

    virtual void SubscribeToLifecycle(::zx::channel client, SubscribeToLifecycleCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void AddChildRequest(const ::fidl::DecodedMessage<TestDevice::AddChildRequest>& _msg);
    static void AddChildResponse(const ::fidl::DecodedMessage<TestDevice::AddChildResponse>& _msg);
    static void RemoveChildRequest(const ::fidl::DecodedMessage<TestDevice::RemoveChildRequest>& _msg);
    static void RemoveChildResponse(const ::fidl::DecodedMessage<TestDevice::RemoveChildResponse>& _msg);
    static void SubscribeToLifecycleRequest(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleRequest>& _msg);
    static void SubscribeToLifecycleResponse(const ::fidl::DecodedMessage<TestDevice::SubscribeToLifecycleResponse>& _msg);
  };
};

}  // namespace test
}  // namespace lifecycle
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_SubscribeToLifecycle_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_RemoveChild_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response>);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response, child_id) == 0);
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response) == ::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::lifecycle::test::TestDevice_AddChild_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::Lifecycle::OnChildPreReleaseResponse, child_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::AddChildResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildRequest, child_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::RemoveChildResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleRequest, client) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse)
    == ::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::lifecycle::test::TestDevice::SubscribeToLifecycleResponse, result) == 16);

}  // namespace fidl

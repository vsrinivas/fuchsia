// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/device/mock/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace mock {

void ::llcpp::fuchsia::device::mock::Action::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Action) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Action, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Action, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_PerformActions_Ordinal = 0x4368272e00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_PerformActions_GenOrdinal = 0x1e51d6eb0ce75baclu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadPerformActionsRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadPerformActionsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceThreadPerformActionsResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_AddDeviceDone_Ordinal = 0x5a75b43900000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_AddDeviceDone_GenOrdinal = 0x5f70f15bcdf559belu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadAddDeviceDoneRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadAddDeviceDoneEventTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceThreadAddDeviceDoneEventTable;
[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_UnbindReplyDone_Ordinal = 0x6c9ed25d00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDeviceThread_UnbindReplyDone_GenOrdinal = 0x7cadbb1dcfd931b3lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadUnbindReplyDoneRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceThreadUnbindReplyDoneEventTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceThreadUnbindReplyDoneEventTable;

}  // namespace

MockDeviceThread::ResultOf::PerformActions_Impl::PerformActions_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<PerformActionsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  PerformActionsRequest _request = {};
  _request.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<PerformActionsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      MockDeviceThread::InPlace::PerformActions(std::move(_client_end), std::move(_decoded_request)));
}

MockDeviceThread::ResultOf::PerformActions MockDeviceThread::SyncClient::PerformActions(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
    return ResultOf::PerformActions(::zx::unowned_channel(this->channel_), std::move(actions));
}

MockDeviceThread::ResultOf::PerformActions MockDeviceThread::Call::PerformActions(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  return ResultOf::PerformActions(std::move(_client_end), std::move(actions));
}


MockDeviceThread::UnownedResultOf::PerformActions_Impl::PerformActions_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_request_buffer.capacity() < PerformActionsRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  PerformActionsRequest _request = {};
  _request.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<PerformActionsRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      MockDeviceThread::InPlace::PerformActions(std::move(_client_end), std::move(_decoded_request)));
}

MockDeviceThread::UnownedResultOf::PerformActions MockDeviceThread::SyncClient::PerformActions(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  return UnownedResultOf::PerformActions(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(actions));
}

MockDeviceThread::UnownedResultOf::PerformActions MockDeviceThread::Call::PerformActions(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  return UnownedResultOf::PerformActions(std::move(_client_end), std::move(_request_buffer), std::move(actions));
}

::fidl::internal::StatusAndError MockDeviceThread::InPlace::PerformActions(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<PerformActionsRequest> params) {
  MockDeviceThread::SetTransactionHeaderFor::PerformActionsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

zx_status_t MockDeviceThread::SyncClient::HandleEvents(MockDeviceThread::EventHandlers handlers) {
  return MockDeviceThread::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t MockDeviceThread::Call::HandleEvents(::zx::unowned_channel client_end, MockDeviceThread::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<AddDeviceDoneResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<AddDeviceDoneResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<UnbindReplyDoneResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<UnbindReplyDoneResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (AddDeviceDoneResponse::MaxNumHandles >= x) {
      x = AddDeviceDoneResponse::MaxNumHandles;
    }
    if (UnbindReplyDoneResponse::MaxNumHandles >= x) {
      x = UnbindReplyDoneResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kMockDeviceThread_AddDeviceDone_Ordinal:
    case kMockDeviceThread_AddDeviceDone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AddDeviceDoneResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.add_device_done(std::move(message->action_id));
    }
    case kMockDeviceThread_UnbindReplyDone_Ordinal:
    case kMockDeviceThread_UnbindReplyDone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnbindReplyDoneResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.unbind_reply_done(std::move(message->action_id));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool MockDeviceThread::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kMockDeviceThread_PerformActions_Ordinal:
    case kMockDeviceThread_PerformActions_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<PerformActionsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->PerformActions(std::move(message->actions),
          Interface::PerformActionsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool MockDeviceThread::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t MockDeviceThread::SendAddDeviceDoneEvent(::zx::unowned_channel _chan, uint64_t action_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddDeviceDoneResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AddDeviceDoneResponse*>(_write_bytes);
  MockDeviceThread::SetTransactionHeaderFor::AddDeviceDoneResponse(
      ::fidl::DecodedMessage<AddDeviceDoneResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddDeviceDoneResponse::PrimarySize,
              AddDeviceDoneResponse::PrimarySize)));
  _response.action_id = std::move(action_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AddDeviceDoneResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<AddDeviceDoneResponse>(std::move(_response_bytes)));
}

zx_status_t MockDeviceThread::SendAddDeviceDoneEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t action_id) {
  if (_buffer.capacity() < AddDeviceDoneResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<AddDeviceDoneResponse*>(_buffer.data());
  MockDeviceThread::SetTransactionHeaderFor::AddDeviceDoneResponse(
      ::fidl::DecodedMessage<AddDeviceDoneResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AddDeviceDoneResponse::PrimarySize,
              AddDeviceDoneResponse::PrimarySize)));
  _response.action_id = std::move(action_id);
  _buffer.set_actual(sizeof(AddDeviceDoneResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<AddDeviceDoneResponse>(std::move(_buffer)));
}

zx_status_t MockDeviceThread::SendAddDeviceDoneEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<AddDeviceDoneResponse> params) {
  MockDeviceThread::SetTransactionHeaderFor::AddDeviceDoneResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


zx_status_t MockDeviceThread::SendUnbindReplyDoneEvent(::zx::unowned_channel _chan, uint64_t action_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindReplyDoneResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnbindReplyDoneResponse*>(_write_bytes);
  MockDeviceThread::SetTransactionHeaderFor::UnbindReplyDoneResponse(
      ::fidl::DecodedMessage<UnbindReplyDoneResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnbindReplyDoneResponse::PrimarySize,
              UnbindReplyDoneResponse::PrimarySize)));
  _response.action_id = std::move(action_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnbindReplyDoneResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<UnbindReplyDoneResponse>(std::move(_response_bytes)));
}

zx_status_t MockDeviceThread::SendUnbindReplyDoneEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t action_id) {
  if (_buffer.capacity() < UnbindReplyDoneResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<UnbindReplyDoneResponse*>(_buffer.data());
  MockDeviceThread::SetTransactionHeaderFor::UnbindReplyDoneResponse(
      ::fidl::DecodedMessage<UnbindReplyDoneResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnbindReplyDoneResponse::PrimarySize,
              UnbindReplyDoneResponse::PrimarySize)));
  _response.action_id = std::move(action_id);
  _buffer.set_actual(sizeof(UnbindReplyDoneResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<UnbindReplyDoneResponse>(std::move(_buffer)));
}

zx_status_t MockDeviceThread::SendUnbindReplyDoneEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<UnbindReplyDoneResponse> params) {
  MockDeviceThread::SetTransactionHeaderFor::UnbindReplyDoneResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}



void MockDeviceThread::SetTransactionHeaderFor::PerformActionsRequest(const ::fidl::DecodedMessage<MockDeviceThread::PerformActionsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDeviceThread_PerformActions_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDeviceThread::SetTransactionHeaderFor::AddDeviceDoneResponse(const ::fidl::DecodedMessage<MockDeviceThread::AddDeviceDoneResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDeviceThread_AddDeviceDone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDeviceThread::SetTransactionHeaderFor::UnbindReplyDoneResponse(const ::fidl::DecodedMessage<MockDeviceThread::UnbindReplyDoneResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDeviceThread_UnbindReplyDone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kMockDevice_Bind_Ordinal = 0x7c80f6ec00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Bind_GenOrdinal = 0x61f85ea4a79aaf98lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceBindRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceBindResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Release_Ordinal = 0x244f460200000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Release_GenOrdinal = 0x3e34cd45b096f7dflu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceReleaseRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceReleaseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceReleaseResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_GetProtocol_Ordinal = 0x2260377000000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_GetProtocol_GenOrdinal = 0x4b589335ced5818flu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceGetProtocolRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceGetProtocolResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceGetProtocolResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Open_Ordinal = 0x78822f4600000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Open_GenOrdinal = 0x667693e248252a7blu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceOpenRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceOpenResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Close_Ordinal = 0x1cb8023800000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Close_GenOrdinal = 0x77d1ae25197af4b4lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceCloseRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Unbind_Ordinal = 0x4184fddd00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Unbind_GenOrdinal = 0x5edfb40dac65de1alu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceUnbindRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceUnbindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceUnbindResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Read_Ordinal = 0x58b86c9100000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Read_GenOrdinal = 0x59a0e040f263ce78lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceReadRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceReadResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceReadResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Write_Ordinal = 0x58d75faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Write_GenOrdinal = 0x4093b59b2ed5bc84lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceWriteRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceWriteResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceWriteResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_GetSize_Ordinal = 0xadc36e600000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_GetSize_GenOrdinal = 0x2fd05ce2a771bba2lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceGetSizeRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceGetSizeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceGetSizeResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Suspend_Ordinal = 0x3a4dd8cb00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Suspend_GenOrdinal = 0x1d086b1540c8badalu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceSuspendRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceSuspendResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceSuspendResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Resume_Ordinal = 0x6f537db800000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Resume_GenOrdinal = 0x405f391966e368celu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceResumeRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceResumeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceResumeResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Message_Ordinal = 0x52488df800000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Message_GenOrdinal = 0x7a14d769ce9e8b14lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceMessageRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceMessageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceMessageResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Rxrpc_Ordinal = 0x2e6fd1b900000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_Rxrpc_GenOrdinal = 0x24f0a836490f4a99lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceRxrpcRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceRxrpcResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceRxrpcResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_AddDeviceDone_Ordinal = 0x10d0aadc00000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_AddDeviceDone_GenOrdinal = 0x40fd824a0e920396lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceAddDeviceDoneRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceAddDeviceDoneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceAddDeviceDoneResponseTable;
[[maybe_unused]]
constexpr uint64_t kMockDevice_UnbindReplyDone_Ordinal = 0x4d0946a100000000lu;
[[maybe_unused]]
constexpr uint64_t kMockDevice_UnbindReplyDone_GenOrdinal = 0x6f057a72a4b6c2e8lu;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceUnbindReplyDoneRequestTable;
extern "C" const fidl_type_t fuchsia_device_mock_MockDeviceUnbindReplyDoneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_device_mock_MockDeviceUnbindReplyDoneResponseTable;

}  // namespace
template <>
MockDevice::ResultOf::Bind_Impl<MockDevice::BindResponse>::Bind_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, BindRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(BindRequest));
  ::fidl::DecodedMessage<BindRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Bind(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Bind MockDevice::SyncClient::Bind(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::Bind(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::Bind MockDevice::Call::Bind(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::Bind(std::move(_client_end), std::move(record));
}

template <>
MockDevice::UnownedResultOf::Bind_Impl<MockDevice::BindResponse>::Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < BindRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<BindResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, BindRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(BindRequest));
  ::fidl::DecodedMessage<BindRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Bind(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Bind MockDevice::SyncClient::Bind(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Bind(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Bind MockDevice::Call::Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Bind(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::BindResponse> MockDevice::InPlace::Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::BindRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::BindResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<BindRequest, BindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::BindResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


MockDevice::ResultOf::Release_Impl::Release_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseRequest));
  ::fidl::DecodedMessage<ReleaseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      MockDevice::InPlace::Release(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::ResultOf::Release MockDevice::SyncClient::Release(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::Release(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::Release MockDevice::Call::Release(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::Release(std::move(_client_end), std::move(record));
}


MockDevice::UnownedResultOf::Release_Impl::Release_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  if (_request_buffer.capacity() < ReleaseRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(ReleaseRequest));
  ::fidl::DecodedMessage<ReleaseRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      MockDevice::InPlace::Release(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::UnownedResultOf::Release MockDevice::SyncClient::Release(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return UnownedResultOf::Release(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record));
}

MockDevice::UnownedResultOf::Release MockDevice::Call::Release(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return UnownedResultOf::Release(std::move(_client_end), std::move(_request_buffer), std::move(record));
}

::fidl::internal::StatusAndError MockDevice::InPlace::Release(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseRequest> params) {
  MockDevice::SetTransactionHeaderFor::ReleaseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
MockDevice::ResultOf::GetProtocol_Impl<MockDevice::GetProtocolResponse>::GetProtocol_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtocolRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetProtocolRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetProtocolRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.protocol_id = std::move(protocol_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetProtocolRequest));
  ::fidl::DecodedMessage<GetProtocolRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::GetProtocol(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::GetProtocol MockDevice::SyncClient::GetProtocol(::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id) {
    return ResultOf::GetProtocol(::zx::unowned_channel(this->channel_), std::move(record), std::move(protocol_id));
}

MockDevice::ResultOf::GetProtocol MockDevice::Call::GetProtocol(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id) {
  return ResultOf::GetProtocol(std::move(_client_end), std::move(record), std::move(protocol_id));
}

template <>
MockDevice::UnownedResultOf::GetProtocol_Impl<MockDevice::GetProtocolResponse>::GetProtocol_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetProtocolRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetProtocolResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetProtocolRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetProtocolRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.protocol_id = std::move(protocol_id);
  _request_buffer.set_actual(sizeof(GetProtocolRequest));
  ::fidl::DecodedMessage<GetProtocolRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::GetProtocol(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::GetProtocol MockDevice::SyncClient::GetProtocol(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProtocol(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(protocol_id), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::GetProtocol MockDevice::Call::GetProtocol(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t protocol_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProtocol(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(protocol_id), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::GetProtocolResponse> MockDevice::InPlace::GetProtocol(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetProtocolRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::GetProtocolRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::GetProtocolResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetProtocolRequest, GetProtocolResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::GetProtocolResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Open_Impl<MockDevice::OpenResponse>::Open_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenRequest));
  ::fidl::DecodedMessage<OpenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Open(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Open MockDevice::SyncClient::Open(::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
    return ResultOf::Open(::zx::unowned_channel(this->channel_), std::move(record), std::move(flags));
}

MockDevice::ResultOf::Open MockDevice::Call::Open(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  return ResultOf::Open(std::move(_client_end), std::move(record), std::move(flags));
}

template <>
MockDevice::UnownedResultOf::Open_Impl<MockDevice::OpenResponse>::Open_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(OpenRequest));
  ::fidl::DecodedMessage<OpenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Open(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Open MockDevice::SyncClient::Open(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Open(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Open MockDevice::Call::Open(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Open(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::OpenResponse> MockDevice::InPlace::Open(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::OpenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::OpenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenRequest, OpenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::OpenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Close_Impl<MockDevice::CloseResponse>::Close_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Close(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Close MockDevice::SyncClient::Close(::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
    return ResultOf::Close(::zx::unowned_channel(this->channel_), std::move(record), std::move(flags));
}

MockDevice::ResultOf::Close MockDevice::Call::Close(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  return ResultOf::Close(std::move(_client_end), std::move(record), std::move(flags));
}

template <>
MockDevice::UnownedResultOf::Close_Impl<MockDevice::CloseResponse>::Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CloseRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CloseResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Close(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Close MockDevice::SyncClient::Close(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Close MockDevice::Call::Close(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::CloseResponse> MockDevice::InPlace::Close(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Unbind_Impl<MockDevice::UnbindResponse>::Unbind_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, UnbindRequest::PrimarySize);
  auto& _request = *reinterpret_cast<UnbindRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnbindRequest));
  ::fidl::DecodedMessage<UnbindRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Unbind(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Unbind MockDevice::SyncClient::Unbind(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::Unbind(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::Unbind MockDevice::Call::Unbind(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::Unbind(std::move(_client_end), std::move(record));
}

template <>
MockDevice::UnownedResultOf::Unbind_Impl<MockDevice::UnbindResponse>::Unbind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UnbindRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UnbindResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, UnbindRequest::PrimarySize);
  auto& _request = *reinterpret_cast<UnbindRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(UnbindRequest));
  ::fidl::DecodedMessage<UnbindRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Unbind(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Unbind MockDevice::SyncClient::Unbind(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unbind(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Unbind MockDevice::Call::Unbind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unbind(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::UnbindResponse> MockDevice::InPlace::Unbind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnbindRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::UnbindRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::UnbindResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnbindRequest, UnbindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::UnbindResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Read_Impl<MockDevice::ReadResponse>::Read_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.count = std::move(count);
  _request.off = std::move(off);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Read(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Read MockDevice::SyncClient::Read(::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off) {
    return ResultOf::Read(::zx::unowned_channel(this->channel_), std::move(record), std::move(count), std::move(off));
}

MockDevice::ResultOf::Read MockDevice::Call::Read(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off) {
  return ResultOf::Read(std::move(_client_end), std::move(record), std::move(count), std::move(off));
}

template <>
MockDevice::UnownedResultOf::Read_Impl<MockDevice::ReadResponse>::Read_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.count = std::move(count);
  _request.off = std::move(off);
  _request_buffer.set_actual(sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Read(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Read MockDevice::SyncClient::Read(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(count), std::move(off), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Read MockDevice::Call::Read(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint64_t count, uint64_t off, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(count), std::move(off), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::ReadResponse> MockDevice::InPlace::Read(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::ReadRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::ReadResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadRequest, ReadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::ReadResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Write_Impl<MockDevice::WriteResponse>::Write_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteRequest _request = {};
  _request.record = std::move(record);
  _request.buffer = std::move(buffer);
  _request.off = std::move(off);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      MockDevice::InPlace::Write(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Write MockDevice::SyncClient::Write(::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off) {
    return ResultOf::Write(::zx::unowned_channel(this->channel_), std::move(record), std::move(buffer), std::move(off));
}

MockDevice::ResultOf::Write MockDevice::Call::Write(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off) {
  return ResultOf::Write(std::move(_client_end), std::move(record), std::move(buffer), std::move(off));
}

template <>
MockDevice::UnownedResultOf::Write_Impl<MockDevice::WriteResponse>::Write_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteRequest _request = {};
  _request.record = std::move(record);
  _request.buffer = std::move(buffer);
  _request.off = std::move(off);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      MockDevice::InPlace::Write(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Write MockDevice::SyncClient::Write(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(buffer), std::move(off), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Write MockDevice::Call::Write(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::VectorView<uint8_t> buffer, uint64_t off, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(buffer), std::move(off), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::WriteResponse> MockDevice::InPlace::Write(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::WriteRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::WriteResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::WriteResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::GetSize_Impl<MockDevice::GetSizeResponse>::GetSize_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSizeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetSizeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSizeRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSizeRequest));
  ::fidl::DecodedMessage<GetSizeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::GetSize(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::GetSize MockDevice::SyncClient::GetSize(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::GetSize(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::GetSize MockDevice::Call::GetSize(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::GetSize(std::move(_client_end), std::move(record));
}

template <>
MockDevice::UnownedResultOf::GetSize_Impl<MockDevice::GetSizeResponse>::GetSize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetSizeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetSizeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetSizeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSizeRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(GetSizeRequest));
  ::fidl::DecodedMessage<GetSizeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::GetSize(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::GetSize MockDevice::SyncClient::GetSize(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSize(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::GetSize MockDevice::Call::GetSize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSize(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::GetSizeResponse> MockDevice::InPlace::GetSize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSizeRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::GetSizeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::GetSizeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetSizeRequest, GetSizeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::GetSizeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Suspend_Impl<MockDevice::SuspendResponse>::Suspend_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SuspendRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SuspendRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SuspendRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SuspendRequest));
  ::fidl::DecodedMessage<SuspendRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Suspend(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Suspend MockDevice::SyncClient::Suspend(::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
    return ResultOf::Suspend(::zx::unowned_channel(this->channel_), std::move(record), std::move(flags));
}

MockDevice::ResultOf::Suspend MockDevice::Call::Suspend(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  return ResultOf::Suspend(std::move(_client_end), std::move(record), std::move(flags));
}

template <>
MockDevice::UnownedResultOf::Suspend_Impl<MockDevice::SuspendResponse>::Suspend_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SuspendRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SuspendResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SuspendRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SuspendRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(SuspendRequest));
  ::fidl::DecodedMessage<SuspendRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Suspend(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Suspend MockDevice::SyncClient::Suspend(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Suspend(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Suspend MockDevice::Call::Suspend(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Suspend(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::SuspendResponse> MockDevice::InPlace::Suspend(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SuspendRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::SuspendRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::SuspendResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SuspendRequest, SuspendResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::SuspendResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Resume_Impl<MockDevice::ResumeResponse>::Resume_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResumeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ResumeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ResumeRequest*>(_write_bytes);
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ResumeRequest));
  ::fidl::DecodedMessage<ResumeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Resume(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Resume MockDevice::SyncClient::Resume(::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
    return ResultOf::Resume(::zx::unowned_channel(this->channel_), std::move(record), std::move(flags));
}

MockDevice::ResultOf::Resume MockDevice::Call::Resume(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags) {
  return ResultOf::Resume(std::move(_client_end), std::move(record), std::move(flags));
}

template <>
MockDevice::UnownedResultOf::Resume_Impl<MockDevice::ResumeResponse>::Resume_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ResumeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ResumeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ResumeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ResumeRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(ResumeRequest));
  ::fidl::DecodedMessage<ResumeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Resume(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Resume MockDevice::SyncClient::Resume(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Resume(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Resume MockDevice::Call::Resume(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Resume(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::ResumeResponse> MockDevice::InPlace::Resume(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ResumeRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::ResumeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::ResumeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ResumeRequest, ResumeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::ResumeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Message_Impl<MockDevice::MessageResponse>::Message_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MessageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, MessageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MessageRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MessageRequest));
  ::fidl::DecodedMessage<MessageRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Message(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Message MockDevice::SyncClient::Message(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::Message(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::Message MockDevice::Call::Message(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::Message(std::move(_client_end), std::move(record));
}

template <>
MockDevice::UnownedResultOf::Message_Impl<MockDevice::MessageResponse>::Message_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MessageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MessageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, MessageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MessageRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(MessageRequest));
  ::fidl::DecodedMessage<MessageRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Message(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Message MockDevice::SyncClient::Message(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Message(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Message MockDevice::Call::Message(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Message(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::MessageResponse> MockDevice::InPlace::Message(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<MessageRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::MessageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::MessageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<MessageRequest, MessageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::MessageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
MockDevice::ResultOf::Rxrpc_Impl<MockDevice::RxrpcResponse>::Rxrpc_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RxrpcRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RxrpcRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RxrpcRequest*>(_write_bytes);
  _request.record = std::move(record);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RxrpcRequest));
  ::fidl::DecodedMessage<RxrpcRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      MockDevice::InPlace::Rxrpc(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

MockDevice::ResultOf::Rxrpc MockDevice::SyncClient::Rxrpc(::llcpp::fuchsia::device::mock::HookInvocation record) {
    return ResultOf::Rxrpc(::zx::unowned_channel(this->channel_), std::move(record));
}

MockDevice::ResultOf::Rxrpc MockDevice::Call::Rxrpc(::zx::unowned_channel _client_end, ::llcpp::fuchsia::device::mock::HookInvocation record) {
  return ResultOf::Rxrpc(std::move(_client_end), std::move(record));
}

template <>
MockDevice::UnownedResultOf::Rxrpc_Impl<MockDevice::RxrpcResponse>::Rxrpc_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RxrpcRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RxrpcResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, RxrpcRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RxrpcRequest*>(_request_buffer.data());
  _request.record = std::move(record);
  _request_buffer.set_actual(sizeof(RxrpcRequest));
  ::fidl::DecodedMessage<RxrpcRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      MockDevice::InPlace::Rxrpc(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

MockDevice::UnownedResultOf::Rxrpc MockDevice::SyncClient::Rxrpc(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rxrpc(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

MockDevice::UnownedResultOf::Rxrpc MockDevice::Call::Rxrpc(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::device::mock::HookInvocation record, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rxrpc(std::move(_client_end), std::move(_request_buffer), std::move(record), std::move(_response_buffer));
}

::fidl::DecodeResult<MockDevice::RxrpcResponse> MockDevice::InPlace::Rxrpc(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RxrpcRequest> params, ::fidl::BytePart response_buffer) {
  MockDevice::SetTransactionHeaderFor::RxrpcRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::RxrpcResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RxrpcRequest, RxrpcResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MockDevice::RxrpcResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


MockDevice::ResultOf::AddDeviceDone_Impl::AddDeviceDone_Impl(::zx::unowned_channel _client_end, uint64_t action_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AddDeviceDoneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AddDeviceDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AddDeviceDoneRequest*>(_write_bytes);
  _request.action_id = std::move(action_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AddDeviceDoneRequest));
  ::fidl::DecodedMessage<AddDeviceDoneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      MockDevice::InPlace::AddDeviceDone(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::ResultOf::AddDeviceDone MockDevice::SyncClient::AddDeviceDone(uint64_t action_id) {
    return ResultOf::AddDeviceDone(::zx::unowned_channel(this->channel_), std::move(action_id));
}

MockDevice::ResultOf::AddDeviceDone MockDevice::Call::AddDeviceDone(::zx::unowned_channel _client_end, uint64_t action_id) {
  return ResultOf::AddDeviceDone(std::move(_client_end), std::move(action_id));
}


MockDevice::UnownedResultOf::AddDeviceDone_Impl::AddDeviceDone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t action_id) {
  if (_request_buffer.capacity() < AddDeviceDoneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AddDeviceDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AddDeviceDoneRequest*>(_request_buffer.data());
  _request.action_id = std::move(action_id);
  _request_buffer.set_actual(sizeof(AddDeviceDoneRequest));
  ::fidl::DecodedMessage<AddDeviceDoneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      MockDevice::InPlace::AddDeviceDone(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::UnownedResultOf::AddDeviceDone MockDevice::SyncClient::AddDeviceDone(::fidl::BytePart _request_buffer, uint64_t action_id) {
  return UnownedResultOf::AddDeviceDone(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(action_id));
}

MockDevice::UnownedResultOf::AddDeviceDone MockDevice::Call::AddDeviceDone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t action_id) {
  return UnownedResultOf::AddDeviceDone(std::move(_client_end), std::move(_request_buffer), std::move(action_id));
}

::fidl::internal::StatusAndError MockDevice::InPlace::AddDeviceDone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddDeviceDoneRequest> params) {
  MockDevice::SetTransactionHeaderFor::AddDeviceDoneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


MockDevice::ResultOf::UnbindReplyDone_Impl::UnbindReplyDone_Impl(::zx::unowned_channel _client_end, uint64_t action_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindReplyDoneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, UnbindReplyDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<UnbindReplyDoneRequest*>(_write_bytes);
  _request.action_id = std::move(action_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnbindReplyDoneRequest));
  ::fidl::DecodedMessage<UnbindReplyDoneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      MockDevice::InPlace::UnbindReplyDone(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::ResultOf::UnbindReplyDone MockDevice::SyncClient::UnbindReplyDone(uint64_t action_id) {
    return ResultOf::UnbindReplyDone(::zx::unowned_channel(this->channel_), std::move(action_id));
}

MockDevice::ResultOf::UnbindReplyDone MockDevice::Call::UnbindReplyDone(::zx::unowned_channel _client_end, uint64_t action_id) {
  return ResultOf::UnbindReplyDone(std::move(_client_end), std::move(action_id));
}


MockDevice::UnownedResultOf::UnbindReplyDone_Impl::UnbindReplyDone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t action_id) {
  if (_request_buffer.capacity() < UnbindReplyDoneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, UnbindReplyDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<UnbindReplyDoneRequest*>(_request_buffer.data());
  _request.action_id = std::move(action_id);
  _request_buffer.set_actual(sizeof(UnbindReplyDoneRequest));
  ::fidl::DecodedMessage<UnbindReplyDoneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      MockDevice::InPlace::UnbindReplyDone(std::move(_client_end), std::move(_decoded_request)));
}

MockDevice::UnownedResultOf::UnbindReplyDone MockDevice::SyncClient::UnbindReplyDone(::fidl::BytePart _request_buffer, uint64_t action_id) {
  return UnownedResultOf::UnbindReplyDone(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(action_id));
}

MockDevice::UnownedResultOf::UnbindReplyDone MockDevice::Call::UnbindReplyDone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t action_id) {
  return UnownedResultOf::UnbindReplyDone(std::move(_client_end), std::move(_request_buffer), std::move(action_id));
}

::fidl::internal::StatusAndError MockDevice::InPlace::UnbindReplyDone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnbindReplyDoneRequest> params) {
  MockDevice::SetTransactionHeaderFor::UnbindReplyDoneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool MockDevice::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kMockDevice_Bind_Ordinal:
    case kMockDevice_Bind_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<BindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Bind(std::move(message->record),
          Interface::BindCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Release_Ordinal:
    case kMockDevice_Release_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Release(std::move(message->record),
          Interface::ReleaseCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_GetProtocol_Ordinal:
    case kMockDevice_GetProtocol_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetProtocolRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetProtocol(std::move(message->record), std::move(message->protocol_id),
          Interface::GetProtocolCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Open_Ordinal:
    case kMockDevice_Open_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->record), std::move(message->flags),
          Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Close_Ordinal:
    case kMockDevice_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Close(std::move(message->record), std::move(message->flags),
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Unbind_Ordinal:
    case kMockDevice_Unbind_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnbindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unbind(std::move(message->record),
          Interface::UnbindCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Read_Ordinal:
    case kMockDevice_Read_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Read(std::move(message->record), std::move(message->count), std::move(message->off),
          Interface::ReadCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Write_Ordinal:
    case kMockDevice_Write_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Write(std::move(message->record), std::move(message->buffer), std::move(message->off),
          Interface::WriteCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_GetSize_Ordinal:
    case kMockDevice_GetSize_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetSizeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetSize(std::move(message->record),
          Interface::GetSizeCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Suspend_Ordinal:
    case kMockDevice_Suspend_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SuspendRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Suspend(std::move(message->record), std::move(message->flags),
          Interface::SuspendCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Resume_Ordinal:
    case kMockDevice_Resume_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ResumeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Resume(std::move(message->record), std::move(message->flags),
          Interface::ResumeCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Message_Ordinal:
    case kMockDevice_Message_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MessageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Message(std::move(message->record),
          Interface::MessageCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_Rxrpc_Ordinal:
    case kMockDevice_Rxrpc_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RxrpcRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rxrpc(std::move(message->record),
          Interface::RxrpcCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_AddDeviceDone_Ordinal:
    case kMockDevice_AddDeviceDone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AddDeviceDoneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AddDeviceDone(std::move(message->action_id),
          Interface::AddDeviceDoneCompleter::Sync(txn));
      return true;
    }
    case kMockDevice_UnbindReplyDone_Ordinal:
    case kMockDevice_UnbindReplyDone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnbindReplyDoneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UnbindReplyDone(std::move(message->action_id),
          Interface::UnbindReplyDoneCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool MockDevice::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void MockDevice::Interface::BindCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  BindResponse _response = {};
  MockDevice::SetTransactionHeaderFor::BindResponse(
      ::fidl::DecodedMessage<BindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              BindResponse::PrimarySize,
              BindResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::BindCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < BindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  BindResponse _response = {};
  MockDevice::SetTransactionHeaderFor::BindResponse(
      ::fidl::DecodedMessage<BindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              BindResponse::PrimarySize,
              BindResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::BindCompleterBase::Reply(::fidl::DecodedMessage<BindResponse> params) {
  MockDevice::SetTransactionHeaderFor::BindResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::GetProtocolCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtocolResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetProtocolResponse _response = {};
  MockDevice::SetTransactionHeaderFor::GetProtocolResponse(
      ::fidl::DecodedMessage<GetProtocolResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetProtocolResponse::PrimarySize,
              GetProtocolResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::GetProtocolCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < GetProtocolResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetProtocolResponse _response = {};
  MockDevice::SetTransactionHeaderFor::GetProtocolResponse(
      ::fidl::DecodedMessage<GetProtocolResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetProtocolResponse::PrimarySize,
              GetProtocolResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::GetProtocolCompleterBase::Reply(::fidl::DecodedMessage<GetProtocolResponse> params) {
  MockDevice::SetTransactionHeaderFor::GetProtocolResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::OpenCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OpenResponse _response = {};
  MockDevice::SetTransactionHeaderFor::OpenResponse(
      ::fidl::DecodedMessage<OpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenResponse::PrimarySize,
              OpenResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::OpenCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < OpenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  OpenResponse _response = {};
  MockDevice::SetTransactionHeaderFor::OpenResponse(
      ::fidl::DecodedMessage<OpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenResponse::PrimarySize,
              OpenResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::OpenCompleterBase::Reply(::fidl::DecodedMessage<OpenResponse> params) {
  MockDevice::SetTransactionHeaderFor::OpenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::CloseCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  CloseResponse _response = {};
  MockDevice::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CloseResponse _response = {};
  MockDevice::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  MockDevice::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::UnbindCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnbindResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  UnbindResponse _response = {};
  MockDevice::SetTransactionHeaderFor::UnbindResponse(
      ::fidl::DecodedMessage<UnbindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnbindResponse::PrimarySize,
              UnbindResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::UnbindCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < UnbindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UnbindResponse _response = {};
  MockDevice::SetTransactionHeaderFor::UnbindResponse(
      ::fidl::DecodedMessage<UnbindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnbindResponse::PrimarySize,
              UnbindResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::UnbindCompleterBase::Reply(::fidl::DecodedMessage<UnbindResponse> params) {
  MockDevice::SetTransactionHeaderFor::UnbindResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::ReadCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadResponse _response = {};
  MockDevice::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::ReadCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < ReadResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadResponse _response = {};
  MockDevice::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::ReadCompleterBase::Reply(::fidl::DecodedMessage<ReadResponse> params) {
  MockDevice::SetTransactionHeaderFor::ReadResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::WriteCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WriteResponse _response = {};
  MockDevice::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::WriteCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < WriteResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WriteResponse _response = {};
  MockDevice::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::WriteCompleterBase::Reply(::fidl::DecodedMessage<WriteResponse> params) {
  MockDevice::SetTransactionHeaderFor::WriteResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::GetSizeCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSizeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetSizeResponse _response = {};
  MockDevice::SetTransactionHeaderFor::GetSizeResponse(
      ::fidl::DecodedMessage<GetSizeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSizeResponse::PrimarySize,
              GetSizeResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::GetSizeCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < GetSizeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetSizeResponse _response = {};
  MockDevice::SetTransactionHeaderFor::GetSizeResponse(
      ::fidl::DecodedMessage<GetSizeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSizeResponse::PrimarySize,
              GetSizeResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::GetSizeCompleterBase::Reply(::fidl::DecodedMessage<GetSizeResponse> params) {
  MockDevice::SetTransactionHeaderFor::GetSizeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::SuspendCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SuspendResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  SuspendResponse _response = {};
  MockDevice::SetTransactionHeaderFor::SuspendResponse(
      ::fidl::DecodedMessage<SuspendResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SuspendResponse::PrimarySize,
              SuspendResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::SuspendCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < SuspendResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SuspendResponse _response = {};
  MockDevice::SetTransactionHeaderFor::SuspendResponse(
      ::fidl::DecodedMessage<SuspendResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SuspendResponse::PrimarySize,
              SuspendResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::SuspendCompleterBase::Reply(::fidl::DecodedMessage<SuspendResponse> params) {
  MockDevice::SetTransactionHeaderFor::SuspendResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::ResumeCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResumeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ResumeResponse _response = {};
  MockDevice::SetTransactionHeaderFor::ResumeResponse(
      ::fidl::DecodedMessage<ResumeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResumeResponse::PrimarySize,
              ResumeResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::ResumeCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < ResumeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ResumeResponse _response = {};
  MockDevice::SetTransactionHeaderFor::ResumeResponse(
      ::fidl::DecodedMessage<ResumeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResumeResponse::PrimarySize,
              ResumeResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::ResumeCompleterBase::Reply(::fidl::DecodedMessage<ResumeResponse> params) {
  MockDevice::SetTransactionHeaderFor::ResumeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::MessageCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MessageResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  MessageResponse _response = {};
  MockDevice::SetTransactionHeaderFor::MessageResponse(
      ::fidl::DecodedMessage<MessageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MessageResponse::PrimarySize,
              MessageResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::MessageCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < MessageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  MessageResponse _response = {};
  MockDevice::SetTransactionHeaderFor::MessageResponse(
      ::fidl::DecodedMessage<MessageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MessageResponse::PrimarySize,
              MessageResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::MessageCompleterBase::Reply(::fidl::DecodedMessage<MessageResponse> params) {
  MockDevice::SetTransactionHeaderFor::MessageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void MockDevice::Interface::RxrpcCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RxrpcResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  RxrpcResponse _response = {};
  MockDevice::SetTransactionHeaderFor::RxrpcResponse(
      ::fidl::DecodedMessage<RxrpcResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RxrpcResponse::PrimarySize,
              RxrpcResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::RxrpcCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::device::mock::Action> actions) {
  if (_buffer.capacity() < RxrpcResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  RxrpcResponse _response = {};
  MockDevice::SetTransactionHeaderFor::RxrpcResponse(
      ::fidl::DecodedMessage<RxrpcResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RxrpcResponse::PrimarySize,
              RxrpcResponse::PrimarySize)));
  _response.actions = std::move(actions);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void MockDevice::Interface::RxrpcCompleterBase::Reply(::fidl::DecodedMessage<RxrpcResponse> params) {
  MockDevice::SetTransactionHeaderFor::RxrpcResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void MockDevice::SetTransactionHeaderFor::BindRequest(const ::fidl::DecodedMessage<MockDevice::BindRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Bind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::BindResponse(const ::fidl::DecodedMessage<MockDevice::BindResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Bind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::ReleaseRequest(const ::fidl::DecodedMessage<MockDevice::ReleaseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Release_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::GetProtocolRequest(const ::fidl::DecodedMessage<MockDevice::GetProtocolRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_GetProtocol_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::GetProtocolResponse(const ::fidl::DecodedMessage<MockDevice::GetProtocolResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_GetProtocol_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::OpenRequest(const ::fidl::DecodedMessage<MockDevice::OpenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Open_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::OpenResponse(const ::fidl::DecodedMessage<MockDevice::OpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Open_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<MockDevice::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<MockDevice::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::UnbindRequest(const ::fidl::DecodedMessage<MockDevice::UnbindRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Unbind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::UnbindResponse(const ::fidl::DecodedMessage<MockDevice::UnbindResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Unbind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::ReadRequest(const ::fidl::DecodedMessage<MockDevice::ReadRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Read_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::ReadResponse(const ::fidl::DecodedMessage<MockDevice::ReadResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Read_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::WriteRequest(const ::fidl::DecodedMessage<MockDevice::WriteRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Write_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::WriteResponse(const ::fidl::DecodedMessage<MockDevice::WriteResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Write_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::GetSizeRequest(const ::fidl::DecodedMessage<MockDevice::GetSizeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_GetSize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::GetSizeResponse(const ::fidl::DecodedMessage<MockDevice::GetSizeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_GetSize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::SuspendRequest(const ::fidl::DecodedMessage<MockDevice::SuspendRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Suspend_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::SuspendResponse(const ::fidl::DecodedMessage<MockDevice::SuspendResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Suspend_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::ResumeRequest(const ::fidl::DecodedMessage<MockDevice::ResumeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Resume_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::ResumeResponse(const ::fidl::DecodedMessage<MockDevice::ResumeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Resume_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::MessageRequest(const ::fidl::DecodedMessage<MockDevice::MessageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Message_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::MessageResponse(const ::fidl::DecodedMessage<MockDevice::MessageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Message_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::RxrpcRequest(const ::fidl::DecodedMessage<MockDevice::RxrpcRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Rxrpc_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void MockDevice::SetTransactionHeaderFor::RxrpcResponse(const ::fidl::DecodedMessage<MockDevice::RxrpcResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_Rxrpc_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::AddDeviceDoneRequest(const ::fidl::DecodedMessage<MockDevice::AddDeviceDoneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_AddDeviceDone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void MockDevice::SetTransactionHeaderFor::UnbindReplyDoneRequest(const ::fidl::DecodedMessage<MockDevice::UnbindReplyDoneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMockDevice_UnbindReplyDone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace mock
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

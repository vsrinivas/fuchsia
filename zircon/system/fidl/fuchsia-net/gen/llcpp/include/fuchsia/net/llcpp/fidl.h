// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace net {

class Connectivity;
struct NameLookup_LookupHostname_Response;
struct MacAddress;
class LookupIpOptions final {
public:
  constexpr LookupIpOptions() : value_(0u) {}
  explicit constexpr LookupIpOptions(uint8_t value) : value_(value) {}
  const static LookupIpOptions V4_ADDRS;
  const static LookupIpOptions V6_ADDRS;
  const static LookupIpOptions CNAME_LOOKUP;
  const static LookupIpOptions mask;

  explicit constexpr inline operator uint8_t() const { return value_; }
  constexpr inline operator bool() const { return value_; }
  constexpr inline LookupIpOptions operator~() const;
  constexpr inline LookupIpOptions operator|(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator&(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator^(const LookupIpOptions& other) const;
  constexpr inline void operator|=(const LookupIpOptions& other);
  constexpr inline void operator&=(const LookupIpOptions& other);
  constexpr inline void operator^=(const LookupIpOptions& other);

private:
  uint8_t value_;
};
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V4_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(1u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V6_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(2u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::CNAME_LOOKUP = ::llcpp::fuchsia::net::LookupIpOptions(4u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::mask = ::llcpp::fuchsia::net::LookupIpOptions(7u);

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator~() const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator|(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator&(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator^(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ ^ other.value_));
}

constexpr inline void LookupIpOptions::operator|=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ |= other.value_;
}

constexpr inline void LookupIpOptions::operator&=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ &= other.value_;
}

constexpr inline void LookupIpOptions::operator^=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ ^= other.value_;
}

enum class LookupError : uint32_t {
  NOT_FOUND = 1u,
  TRANSIENT = 2u,
  INVALID_ARGS = 3u,
  INTERNAL_ERROR = 4u,
};


struct NameLookup_LookupHostname_Result;
struct Ipv6Address;
struct Ipv4Address;
struct IpAddressInfo;
struct NameLookup_LookupIp_Response;
struct NameLookup_LookupIp_Result;
struct IpAddress;
struct Subnet;
class NameLookup;
struct Endpoint;

extern "C" const fidl_type_t fuchsia_net_ConnectivityOnNetworkReachableRequestTable;
extern "C" const fidl_type_t v1_fuchsia_net_ConnectivityOnNetworkReachableRequestTable;
extern "C" const fidl_type_t fuchsia_net_ConnectivityOnNetworkReachableEventTable;
extern "C" const fidl_type_t v1_fuchsia_net_ConnectivityOnNetworkReachableEventTable;

class Connectivity final {
  Connectivity() = delete;
 public:
  static constexpr char Name[] = "fuchsia.net.Connectivity";

  struct OnNetworkReachableResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool reachable;

    static constexpr const fidl_type_t* Type = &fuchsia_net_ConnectivityOnNetworkReachableEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_ConnectivityOnNetworkReachableEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };

  struct EventHandlers {
    // This is triggered on a state change in network reachability. Clients
    // should expect that network requests will succeed when `reachable` is
    // true.
    fit::callback<zx_status_t(bool reachable)> on_network_reachable;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:

   public:
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:

   public:
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Connectivity;
    using _Base = ::fidl::CompleterBase;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Messages are encoded in-place.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnNetworkReachableResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void OnNetworkReachableResponse(const ::fidl::DecodedMessage<Connectivity::OnNetworkReachableResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookup_LookupHostname_ResponseTable;

struct NameLookup_LookupHostname_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookup_LookupHostname_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 256;

  ::fidl::StringView hostname = {};
};

extern "C" const fidl_type_t fuchsia_net_MacAddressTable;
extern "C" const fidl_type_t v1_fuchsia_net_MacAddressTable;

// A MAC address used to identify a network interface on the data link layer within the network.
struct MacAddress {
  static constexpr const fidl_type_t* Type = &fuchsia_net_MacAddressTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_MacAddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 6> octets = {};
};

constexpr uint64_t MAX_HOSTNAME_SIZE = 255u;

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookup_LookupHostname_ResultTable;

struct NameLookup_LookupHostname_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  NameLookup_LookupHostname_Result();
  ~NameLookup_LookupHostname_Result();

  NameLookup_LookupHostname_Result(NameLookup_LookupHostname_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupHostname_Result& operator=(NameLookup_LookupHostname_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static NameLookup_LookupHostname_Result WithResponse(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response* val) {
    NameLookup_LookupHostname_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static NameLookup_LookupHostname_Result WithErr(::llcpp::fuchsia::net::LookupError* val) {
    NameLookup_LookupHostname_Result result;
    result.set_err(val);
    return result;
  }

  ::llcpp::fuchsia::net::LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  ::llcpp::fuchsia::net::LookupError const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookup_LookupHostname_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 272;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(NameLookup_LookupHostname_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response response_;
    ::llcpp::fuchsia::net::LookupError err_;
  };
};

extern "C" const fidl_type_t fuchsia_net_Ipv6AddressTable;
extern "C" const fidl_type_t v1_fuchsia_net_Ipv6AddressTable;

// Ipv6Address is expressed in network byte order, so the most significant byte
// ("ff" in the address "ff02::1") will be at index 0.
struct Ipv6Address {
  static constexpr const fidl_type_t* Type = &fuchsia_net_Ipv6AddressTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_Ipv6AddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 16> addr = {};
};

extern "C" const fidl_type_t fuchsia_net_Ipv4AddressTable;
extern "C" const fidl_type_t v1_fuchsia_net_Ipv4AddressTable;

// Ipv4Address is expressed in network byte order, so the most significant byte
// ("127" in the address "127.0.0.1") will be at index 0.
struct Ipv4Address {
  static constexpr const fidl_type_t* Type = &fuchsia_net_Ipv4AddressTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_Ipv4AddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 4> addr = {};
};

extern "C" const fidl_type_t fuchsia_net_IpAddressInfoTable;
extern "C" const fidl_type_t v1_fuchsia_net_IpAddressInfoTable;

struct IpAddressInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressInfoTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_IpAddressInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 5376;
  static constexpr uint32_t AltPrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 5376;

  // All of the IPv4 addresses for the requested hostname.
  ::fidl::VectorView<::llcpp::fuchsia::net::Ipv4Address> ipv4_addrs = {};

  // All of the IPv6 addresses for the requested hostname.
  ::fidl::VectorView<::llcpp::fuchsia::net::Ipv6Address> ipv6_addrs = {};

  // The canonical name of the requested hostname (usually the DNS CNAME record, if one exists).
  ::fidl::StringView canonical_name = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookup_LookupIp_ResponseTable;

struct NameLookup_LookupIp_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookup_LookupIp_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 5376;
  static constexpr uint32_t AltPrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 5376;

  ::llcpp::fuchsia::net::IpAddressInfo addr = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookup_LookupIp_ResultTable;

struct NameLookup_LookupIp_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  NameLookup_LookupIp_Result();
  ~NameLookup_LookupIp_Result();

  NameLookup_LookupIp_Result(NameLookup_LookupIp_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupIp_Result& operator=(NameLookup_LookupIp_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static NameLookup_LookupIp_Result WithResponse(::llcpp::fuchsia::net::NameLookup_LookupIp_Response* val) {
    NameLookup_LookupIp_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::net::NameLookup_LookupIp_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::NameLookup_LookupIp_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::NameLookup_LookupIp_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::net::NameLookup_LookupIp_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static NameLookup_LookupIp_Result WithErr(::llcpp::fuchsia::net::LookupError* val) {
    NameLookup_LookupIp_Result result;
    result.set_err(val);
    return result;
  }

  ::llcpp::fuchsia::net::LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  ::llcpp::fuchsia::net::LookupError const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookup_LookupIp_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 5376;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 5424;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(NameLookup_LookupIp_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::net::NameLookup_LookupIp_Response response_;
    ::llcpp::fuchsia::net::LookupError err_;
  };
};

extern "C" const fidl_type_t fuchsia_net_IpAddressTable;
extern "C" const fidl_type_t v1_fuchsia_net_IpAddressTable;

// Represents an IP address that may be either v4 or v6.
struct IpAddress {
  enum class Tag : fidl_union_tag_t {
    kIpv4 = 0,
    kIpv6 = 1,
  };

  IpAddress();
  ~IpAddress();

  IpAddress(IpAddress&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  IpAddress& operator=(IpAddress&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_ipv4() const { return ordinal_ == Ordinal::kIpv4; }

  static IpAddress WithIpv4(::llcpp::fuchsia::net::Ipv4Address* val) {
    IpAddress result;
    result.set_ipv4(val);
    return result;
  }

  ::llcpp::fuchsia::net::Ipv4Address& mutable_ipv4();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::Ipv4Address>::value && std::is_copy_assignable<T>::value>
  set_ipv4(const T* v) {
    mutable_ipv4() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::Ipv4Address>::value && std::is_move_assignable<T>::value>
  set_ipv4(T* v) {
    mutable_ipv4() = std::move(*v);
  }

  ::llcpp::fuchsia::net::Ipv4Address const & ipv4() const { return ipv4_; }

  bool is_ipv6() const { return ordinal_ == Ordinal::kIpv6; }

  static IpAddress WithIpv6(::llcpp::fuchsia::net::Ipv6Address* val) {
    IpAddress result;
    result.set_ipv6(val);
    return result;
  }

  ::llcpp::fuchsia::net::Ipv6Address& mutable_ipv6();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::Ipv6Address>::value && std::is_copy_assignable<T>::value>
  set_ipv6(const T* v) {
    mutable_ipv6() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::net::Ipv6Address>::value && std::is_move_assignable<T>::value>
  set_ipv6(T* v) {
    mutable_ipv6() = std::move(*v);
  }

  ::llcpp::fuchsia::net::Ipv6Address const & ipv6() const { return ipv6_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_IpAddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 16;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kIpv4 = 0,
    kIpv6 = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(IpAddress&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::net::Ipv4Address ipv4_;
    ::llcpp::fuchsia::net::Ipv6Address ipv6_;
  };
};

extern "C" const fidl_type_t fuchsia_net_SubnetTable;
extern "C" const fidl_type_t v1_fuchsia_net_SubnetTable;

// Subnet describes an IP subnetwork, where all host IP addresses share the same most significant
// bits.
struct Subnet {
  static constexpr const fidl_type_t* Type = &fuchsia_net_SubnetTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_SubnetTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 16;

  // The Ipv4 or Ipv6 address. Only the `prefix_len` most significant bits may be set in `addr`;
  // all bits in the host portion of the address must be zero.
  ::llcpp::fuchsia::net::IpAddress addr = {};

  // The prefix length of the netmask. E.g. for 192.168.1.0/24, the prefix
  // length is 24, corresponding to a netmask of 255.255.255.0.
  // For Ipv4, prefix_len must be in the range [0, 32].
  // For Ipv6, prefix_len must be in the range [0, 128].
  uint8_t prefix_len = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpRequestTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookupLookupIpRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpResponseTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookupLookupIpResponseTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookupLookupHostnameRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_net_NameLookupLookupHostnameResponseTable;

class NameLookup final {
  NameLookup() = delete;
 public:
  static constexpr char Name[] = "fuchsia.net.NameLookup";

  struct LookupIpResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::NameLookup_LookupIp_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookupLookupIpResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 5376;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 5424;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LookupIpRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView hostname;
    ::llcpp::fuchsia::net::LookupIpOptions options;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookupLookupIpRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 256;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LookupIpResponse;
  };

  struct LookupHostnameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::NameLookup_LookupHostname_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookupLookupHostnameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 272;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LookupHostnameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::net::IpAddress addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_NameLookupLookupHostnameRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 16;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LookupHostnameResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class LookupIp_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LookupIp_Impl(zx::unowned_channel _client_end, ::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options);
      ~LookupIp_Impl() = default;
      LookupIp_Impl(LookupIp_Impl&& other) = default;
      LookupIp_Impl& operator=(LookupIp_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LookupHostname_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LookupHostname_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::net::IpAddress addr);
      ~LookupHostname_Impl() = default;
      LookupHostname_Impl(LookupHostname_Impl&& other) = default;
      LookupHostname_Impl& operator=(LookupHostname_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LookupIp = LookupIp_Impl<LookupIpResponse>;
    using LookupHostname = LookupHostname_Impl<LookupHostnameResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class LookupIp_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LookupIp_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options, ::fidl::BytePart _response_buffer);
      ~LookupIp_Impl() = default;
      LookupIp_Impl(LookupIp_Impl&& other) = default;
      LookupIp_Impl& operator=(LookupIp_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LookupHostname_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LookupHostname_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::IpAddress addr, ::fidl::BytePart _response_buffer);
      ~LookupHostname_Impl() = default;
      LookupHostname_Impl(LookupHostname_Impl&& other) = default;
      LookupHostname_Impl& operator=(LookupHostname_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LookupIp = LookupIp_Impl<LookupIpResponse>;
    using LookupHostname = LookupHostname_Impl<LookupHostnameResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Allocates 296 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::LookupIp LookupIp(::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LookupIp LookupIp(::fidl::BytePart _request_buffer, ::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options, ::fidl::BytePart _response_buffer);

    // Look up a hostname by IP address.
    // Allocates 336 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LookupHostname LookupHostname(::llcpp::fuchsia::net::IpAddress addr);

    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LookupHostname LookupHostname(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::IpAddress addr, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Allocates 296 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::LookupIp LookupIp(zx::unowned_channel _client_end, ::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LookupIp LookupIp(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options, ::fidl::BytePart _response_buffer);

    // Look up a hostname by IP address.
    // Allocates 336 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LookupHostname LookupHostname(zx::unowned_channel _client_end, ::llcpp::fuchsia::net::IpAddress addr);

    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LookupHostname LookupHostname(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::net::IpAddress addr, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    static ::fidl::DecodeResult<LookupIpResponse> LookupIp(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupIpRequest> params, ::fidl::BytePart response_buffer);

    // Look up a hostname by IP address.
    static ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupHostnameRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = NameLookup;
    using _Base = ::fidl::CompleterBase;

    class LookupIpCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::net::NameLookup_LookupIp_Result result);
      void ReplySuccess(::llcpp::fuchsia::net::IpAddressInfo addr);
      void ReplyError(LookupError error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::net::NameLookup_LookupIp_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::net::IpAddressInfo addr);
      void Reply(::fidl::DecodedMessage<LookupIpResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupIpCompleter = ::fidl::Completer<LookupIpCompleterBase>;

    virtual void LookupIp(::fidl::StringView hostname, ::llcpp::fuchsia::net::LookupIpOptions options, LookupIpCompleter::Sync _completer) = 0;

    class LookupHostnameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::net::NameLookup_LookupHostname_Result result);
      void ReplySuccess(::fidl::StringView hostname);
      void ReplyError(LookupError error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::net::NameLookup_LookupHostname_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::StringView hostname);
      void Reply(::fidl::DecodedMessage<LookupHostnameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupHostnameCompleter = ::fidl::Completer<LookupHostnameCompleterBase>;

    virtual void LookupHostname(::llcpp::fuchsia::net::IpAddress addr, LookupHostnameCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void LookupIpRequest(const ::fidl::DecodedMessage<NameLookup::LookupIpRequest>& _msg);
    static void LookupIpResponse(const ::fidl::DecodedMessage<NameLookup::LookupIpResponse>& _msg);
    static void LookupHostnameRequest(const ::fidl::DecodedMessage<NameLookup::LookupHostnameRequest>& _msg);
    static void LookupHostnameResponse(const ::fidl::DecodedMessage<NameLookup::LookupHostnameResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_net_EndpointTable;
extern "C" const fidl_type_t v1_fuchsia_net_EndpointTable;

// Endpoint describes an IP address and port. The network protocol associated
// with the Endpoint will be known from context or communicated through
// additional structures.
struct Endpoint {
  static constexpr const fidl_type_t* Type = &fuchsia_net_EndpointTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_net_EndpointTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 16;

  // The IP address of the endpoint.
  ::llcpp::fuchsia::net::IpAddress addr = {};

  // The port number of the endpoint.
  uint16_t port = {};
};

}  // namespace net
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse)
    == ::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse, reachable) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response, hostname) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response) == ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::MacAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::MacAddress>);
static_assert(offsetof(::llcpp::fuchsia::net::MacAddress, octets) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::MacAddress) == ::llcpp::fuchsia::net::MacAddress::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::LookupIpOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::LookupIpOptions>);
static_assert(sizeof(::llcpp::fuchsia::net::LookupIpOptions) == sizeof(uint8_t));

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv6Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv6Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv6Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv6Address) == ::llcpp::fuchsia::net::Ipv6Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv4Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv4Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv4Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv4Address) == ::llcpp::fuchsia::net::Ipv4Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddressInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddressInfo>);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv4_addrs) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv6_addrs) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, canonical_name) == 32);
static_assert(sizeof(::llcpp::fuchsia::net::IpAddressInfo) == ::llcpp::fuchsia::net::IpAddressInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response) == ::llcpp::fuchsia::net::NameLookup_LookupIp_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddress>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Subnet> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Subnet>);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, prefix_len) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Subnet) == ::llcpp::fuchsia::net::Subnet::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, hostname) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, options) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Endpoint> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Endpoint>);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, port) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Endpoint) == ::llcpp::fuchsia::net::Endpoint::PrimarySize);

}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/sysmem/llcpp/fidl.h>
#include <memory>

namespace fuchsia {
namespace sysmem {

namespace {

[[maybe_unused]]
constexpr uint32_t kBufferCollectionToken_Duplicate_Ordinal = 1580679187u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollectionToken_Sync_Ordinal = 840486752u;
[[maybe_unused]]
constexpr uint32_t kBufferCollectionToken_Close_Ordinal = 565867829u;

}  // namespace

zx_status_t BufferCollectionToken::SyncClient::Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return BufferCollectionToken::Call::Duplicate(zx::unowned_channel(this->channel_), std::move(rights_attenuation_mask), std::move(token_request));
}

zx_status_t BufferCollectionToken::Call::Duplicate(zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DuplicateRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionToken_Duplicate_Ordinal;
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionToken::SyncClient::Duplicate(::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return BufferCollectionToken::Call::Duplicate(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(rights_attenuation_mask), std::move(token_request));
}

zx_status_t BufferCollectionToken::Call::Duplicate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  if (_request_buffer.capacity() < DuplicateRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollectionToken_Duplicate_Ordinal;
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionToken::SyncClient::Duplicate(::fidl::DecodedMessage<DuplicateRequest> params) {
  return BufferCollectionToken::Call::Duplicate(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollectionToken::Call::Duplicate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DuplicateRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionToken_Duplicate_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollectionToken::SyncClient::Sync() {
  return BufferCollectionToken::Call::Sync(zx::unowned_channel(this->channel_));
}

zx_status_t BufferCollectionToken::Call::Sync(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionToken_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  return ZX_OK;
}


zx_status_t BufferCollectionToken::SyncClient::Close() {
  return BufferCollectionToken::Call::Close(zx::unowned_channel(this->channel_));
}

zx_status_t BufferCollectionToken::Call::Close(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionToken_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


bool BufferCollectionToken::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollectionToken_Duplicate_Ordinal: {
      auto result = ::fidl::DecodeAs<DuplicateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Duplicate(std::move(message->rights_attenuation_mask), std::move(message->token_request),
        Interface::DuplicateCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionToken::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollectionToken::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollectionToken_Sync_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kHeap_AllocateVmo_Ordinal = 196714381u;
extern "C" const fidl_type_t fuchsia_sysmem_HeapAllocateVmoResponseTable;
[[maybe_unused]]
constexpr uint32_t kHeap_CreateResource_Ordinal = 900305090u;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceRequestTable;
extern "C" const fidl_type_t fuchsia_sysmem_HeapCreateResourceResponseTable;
[[maybe_unused]]
constexpr uint32_t kHeap_DestroyResource_Ordinal = 668940193u;

}  // namespace

zx_status_t Heap::SyncClient::AllocateVmo(uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo) {
  return Heap::Call::AllocateVmo(zx::unowned_channel(this->channel_), std::move(size), out_s, out_vmo);
}

zx_status_t Heap::Call::AllocateVmo(zx::unowned_channel _client_end, uint64_t size, int32_t* out_s, ::zx::vmo* out_vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_write_bytes);
  _request._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _request.size = std::move(size);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_vmo = std::move(_response.vmo);
  return ZX_OK;
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::SyncClient::AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo) {
  return Heap::Call::AllocateVmo(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(size), std::move(_response_buffer), out_s, out_vmo);
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::Call::AllocateVmo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::vmo* out_vmo) {
  if (_request_buffer.capacity() < AllocateVmoRequest::PrimarySize) {
    return ::fidl::DecodeResult<AllocateVmoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _request.size = std::move(size);
  _request_buffer.set_actual(sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<AllocateVmoResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<AllocateVmoResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_vmo = std::move(_response.vmo);
  return _decode_result;
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::SyncClient::AllocateVmo(::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer) {
  return Heap::Call::AllocateVmo(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::Call::AllocateVmo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Heap::AllocateVmoResponse>());
  }
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Heap::AllocateVmoResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Heap::SyncClient::CreateResource(::zx::vmo vmo, int32_t* out_s, uint64_t* out_id) {
  return Heap::Call::CreateResource(zx::unowned_channel(this->channel_), std::move(vmo), out_s, out_id);
}

zx_status_t Heap::Call::CreateResource(zx::unowned_channel _client_end, ::zx::vmo vmo, int32_t* out_s, uint64_t* out_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_write_bytes);
  _request._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _request.vmo = std::move(vmo);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CreateResourceRequest, CreateResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_id = std::move(_response.id);
  return ZX_OK;
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::SyncClient::CreateResource(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id) {
  return Heap::Call::CreateResource(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer), out_s, out_id);
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::Call::CreateResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_id) {
  if (_request_buffer.capacity() < CreateResourceRequest::PrimarySize) {
    return ::fidl::DecodeResult<CreateResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _request.vmo = std::move(vmo);
  _request_buffer.set_actual(sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CreateResourceResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CreateResourceRequest, CreateResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CreateResourceResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_s = std::move(_response.s);
  *out_id = std::move(_response.id);
  return _decode_result;
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::SyncClient::CreateResource(::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer) {
  return Heap::Call::CreateResource(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::Call::CreateResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_CreateResource_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<Heap::CreateResourceResponse>());
  }
  auto _call_result = ::fidl::Call<CreateResourceRequest, CreateResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<Heap::CreateResourceResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t Heap::SyncClient::DestroyResource(uint64_t id) {
  return Heap::Call::DestroyResource(zx::unowned_channel(this->channel_), std::move(id));
}

zx_status_t Heap::Call::DestroyResource(zx::unowned_channel _client_end, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_write_bytes);
  _request._hdr.ordinal = kHeap_DestroyResource_Ordinal;
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<DestroyResourceRequest, DestroyResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  return ZX_OK;
}

::fidl::DecodeResult<Heap::DestroyResourceResponse> Heap::SyncClient::DestroyResource(::fidl::BytePart _request_buffer, uint64_t id) {
  return Heap::Call::DestroyResource(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id));
}

::fidl::DecodeResult<Heap::DestroyResourceResponse> Heap::Call::DestroyResource(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id) {
  if (_request_buffer.capacity() < DestroyResourceRequest::PrimarySize) {
    return ::fidl::DecodeResult<DestroyResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kHeap_DestroyResource_Ordinal;
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DestroyResourceResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_buffer(_read_bytes, sizeof(_read_bytes));
  auto _call_result = ::fidl::Call<DestroyResourceRequest, DestroyResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DestroyResourceResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  return _decode_result;
}

zx_status_t Heap::SyncClient::DestroyResource(::fidl::DecodedMessage<DestroyResourceRequest> params) {
  return Heap::Call::DestroyResource(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Heap::Call::DestroyResource(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyResourceRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_DestroyResource_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart response_buffer(_read_bytes, sizeof(_read_bytes));
  auto _call_result = ::fidl::Call<DestroyResourceRequest, DestroyResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  return _decode_result.status;
}


bool Heap::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kHeap_AllocateVmo_Ordinal: {
      auto result = ::fidl::DecodeAs<AllocateVmoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateVmo(std::move(message->size),
        Interface::AllocateVmoCompleter::Sync(txn));
      return true;
    }
    case kHeap_CreateResource_Ordinal: {
      auto result = ::fidl::DecodeAs<CreateResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateResource(std::move(message->vmo),
        Interface::CreateResourceCompleter::Sync(txn));
      return true;
    }
    case kHeap_DestroyResource_Ordinal: {
      auto result = ::fidl::DecodeAs<DestroyResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->DestroyResource(std::move(message->id),
        Interface::DestroyResourceCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Heap::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Heap::Interface::AllocateVmoCompleterBase::Reply(int32_t s, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_response_bytes)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::vmo vmo) {
  if (_buffer.capacity() < AllocateVmoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_buffer.data());
  _response._hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  _buffer.set_actual(sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_buffer)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::DecodedMessage<AllocateVmoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_AllocateVmo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::CreateResourceCompleterBase::Reply(int32_t s, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _response.s = std::move(s);
  _response.id = std::move(id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_response_bytes)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t id) {
  if (_buffer.capacity() < CreateResourceResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_buffer.data());
  _response._hdr.ordinal = kHeap_CreateResource_Ordinal;
  _response.s = std::move(s);
  _response.id = std::move(id);
  _buffer.set_actual(sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_buffer)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::DecodedMessage<CreateResourceResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kHeap_CreateResource_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::DestroyResourceCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DestroyResourceResponse*>(_write_bytes);
  _response._hdr.ordinal = kHeap_DestroyResource_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DestroyResourceResponse>(std::move(_response_bytes)));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kDriverConnector_Connect_Ordinal = 813883444u;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorConnectRequestTable;
[[maybe_unused]]
constexpr uint32_t kDriverConnector_GetProtectedMemoryInfo_Ordinal = 282632817u;
extern "C" const fidl_type_t fuchsia_sysmem_DriverConnectorGetProtectedMemoryInfoResponseTable;

}  // namespace

zx_status_t DriverConnector::SyncClient::Connect(::zx::channel allocator_request) {
  return DriverConnector::Call::Connect(zx::unowned_channel(this->channel_), std::move(allocator_request));
}

zx_status_t DriverConnector::Call::Connect(zx::unowned_channel _client_end, ::zx::channel allocator_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConnectRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<ConnectRequest*>(_write_bytes);
  _request._hdr.ordinal = kDriverConnector_Connect_Ordinal;
  _request.allocator_request = std::move(allocator_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DriverConnector::SyncClient::Connect(::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  return DriverConnector::Call::Connect(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(allocator_request));
}

zx_status_t DriverConnector::Call::Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  if (_request_buffer.capacity() < ConnectRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<ConnectRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDriverConnector_Connect_Ordinal;
  _request.allocator_request = std::move(allocator_request);
  _request_buffer.set_actual(sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t DriverConnector::SyncClient::Connect(::fidl::DecodedMessage<ConnectRequest> params) {
  return DriverConnector::Call::Connect(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t DriverConnector::Call::Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_Connect_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t DriverConnector::SyncClient::GetProtectedMemoryInfo(int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size) {
  return DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel(this->channel_), out_status, out_base_address, out_size);
}

zx_status_t DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel _client_end, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtectedMemoryInfoRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetProtectedMemoryInfoRequest*>(_write_bytes);
  _request._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetProtectedMemoryInfoRequest));
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetProtectedMemoryInfoResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetProtectedMemoryInfoRequest, GetProtectedMemoryInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_base_address = std::move(_response.base_address);
  *out_size = std::move(_response.size);
  return ZX_OK;
}

::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse> DriverConnector::SyncClient::GetProtectedMemoryInfo(::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size) {
  return DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_base_address, out_size);
}

::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse> DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_base_address, uint64_t* out_size) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetProtectedMemoryInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetProtectedMemoryInfoRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  _request_buffer.set_actual(sizeof(GetProtectedMemoryInfoRequest));
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetProtectedMemoryInfoResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetProtectedMemoryInfoRequest, GetProtectedMemoryInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetProtectedMemoryInfoResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_base_address = std::move(_response.base_address);
  *out_size = std::move(_response.size);
  return _decode_result;
}

::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse> DriverConnector::SyncClient::GetProtectedMemoryInfo(::fidl::BytePart response_buffer) {
  return DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse> DriverConnector::Call::GetProtectedMemoryInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetProtectedMemoryInfoRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(GetProtectedMemoryInfoRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<GetProtectedMemoryInfoRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<DriverConnector::GetProtectedMemoryInfoResponse>());
  }
  auto _call_result = ::fidl::Call<GetProtectedMemoryInfoRequest, GetProtectedMemoryInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DriverConnector::GetProtectedMemoryInfoResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<DriverConnector::GetProtectedMemoryInfoResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool DriverConnector::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDriverConnector_Connect_Ordinal: {
      auto result = ::fidl::DecodeAs<ConnectRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Connect(std::move(message->allocator_request),
        Interface::ConnectCompleter::Sync(txn));
      return true;
    }
    case kDriverConnector_GetProtectedMemoryInfo_Ordinal: {
      auto result = ::fidl::DecodeAs<GetProtectedMemoryInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetProtectedMemoryInfo(
        Interface::GetProtectedMemoryInfoCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DriverConnector::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(int32_t status, uint64_t base_address, uint64_t size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetProtectedMemoryInfoResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetProtectedMemoryInfoResponse*>(_write_bytes);
  _response._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  _response.status = std::move(status);
  _response.base_address = std::move(base_address);
  _response.size = std::move(size);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetProtectedMemoryInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse>(std::move(_response_bytes)));
}

void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint64_t base_address, uint64_t size) {
  if (_buffer.capacity() < GetProtectedMemoryInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetProtectedMemoryInfoResponse*>(_buffer.data());
  _response._hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  _response.status = std::move(status);
  _response.base_address = std::move(base_address);
  _response.size = std::move(size);
  _buffer.set_actual(sizeof(GetProtectedMemoryInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse>(std::move(_buffer)));
}

void DriverConnector::Interface::GetProtectedMemoryInfoCompleterBase::Reply(::fidl::DecodedMessage<GetProtectedMemoryInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDriverConnector_GetProtectedMemoryInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kAllocator_AllocateNonSharedCollection_Ordinal = 565270487u;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
[[maybe_unused]]
constexpr uint32_t kAllocator_AllocateSharedCollection_Ordinal = 916773828u;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
[[maybe_unused]]
constexpr uint32_t kAllocator_BindSharedCollection_Ordinal = 493382005u;
extern "C" const fidl_type_t fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;

}  // namespace

zx_status_t Allocator::SyncClient::AllocateNonSharedCollection(::zx::channel collection) {
  return Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel(this->channel_), std::move(collection));
}

zx_status_t Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::zx::channel collection) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateNonSharedCollectionRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_write_bytes);
  _request._hdr.ordinal = kAllocator_AllocateNonSharedCollection_Ordinal;
  _request.collection = std::move(collection);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::AllocateNonSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel collection) {
  return Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection));
}

zx_status_t Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection) {
  if (_request_buffer.capacity() < AllocateNonSharedCollectionRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kAllocator_AllocateNonSharedCollection_Ordinal;
  _request.collection = std::move(collection);
  _request_buffer.set_actual(sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::AllocateNonSharedCollection(::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params) {
  return Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Allocator::Call::AllocateNonSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_AllocateNonSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t Allocator::SyncClient::AllocateSharedCollection(::zx::channel token_request) {
  return Allocator::Call::AllocateSharedCollection(zx::unowned_channel(this->channel_), std::move(token_request));
}

zx_status_t Allocator::Call::AllocateSharedCollection(zx::unowned_channel _client_end, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSharedCollectionRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_write_bytes);
  _request._hdr.ordinal = kAllocator_AllocateSharedCollection_Ordinal;
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::AllocateSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  return Allocator::Call::AllocateSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token_request));
}

zx_status_t Allocator::Call::AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  if (_request_buffer.capacity() < AllocateSharedCollectionRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kAllocator_AllocateSharedCollection_Ordinal;
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::AllocateSharedCollection(::fidl::DecodedMessage<AllocateSharedCollectionRequest> params) {
  return Allocator::Call::AllocateSharedCollection(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Allocator::Call::AllocateSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_AllocateSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t Allocator::SyncClient::BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request) {
  return Allocator::Call::BindSharedCollection(zx::unowned_channel(this->channel_), std::move(token), std::move(buffer_collection_request));
}

zx_status_t Allocator::Call::BindSharedCollection(zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindSharedCollectionRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_write_bytes);
  _request._hdr.ordinal = kAllocator_BindSharedCollection_Ordinal;
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::BindSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return Allocator::Call::BindSharedCollection(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token), std::move(buffer_collection_request));
}

zx_status_t Allocator::Call::BindSharedCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  if (_request_buffer.capacity() < BindSharedCollectionRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kAllocator_BindSharedCollection_Ordinal;
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  _request_buffer.set_actual(sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t Allocator::SyncClient::BindSharedCollection(::fidl::DecodedMessage<BindSharedCollectionRequest> params) {
  return Allocator::Call::BindSharedCollection(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t Allocator::Call::BindSharedCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindSharedCollectionRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kAllocator_BindSharedCollection_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


bool Allocator::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kAllocator_AllocateNonSharedCollection_Ordinal: {
      auto result = ::fidl::DecodeAs<AllocateNonSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateNonSharedCollection(std::move(message->collection),
        Interface::AllocateNonSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_AllocateSharedCollection_Ordinal: {
      auto result = ::fidl::DecodeAs<AllocateSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSharedCollection(std::move(message->token_request),
        Interface::AllocateSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_BindSharedCollection_Ordinal: {
      auto result = ::fidl::DecodeAs<BindSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->BindSharedCollection(std::move(message->token), std::move(message->buffer_collection_request),
        Interface::BindSharedCollectionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Allocator::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


::fuchsia::sysmem::BufferSpec::BufferSpec() {
  tag_ = Tag::Invalid;
}

::fuchsia::sysmem::BufferSpec::~BufferSpec() {
  Destroy();
}

void ::fuchsia::sysmem::BufferSpec::Destroy() {
  switch (which()) {
  case Tag::kImage:
    image_.~ImageSpec();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::fuchsia::sysmem::BufferSpec::MoveImpl_(BufferSpec&& other) {
  switch (other.which()) {
  case Tag::kImage:
    mutable_image() = std::move(other.mutable_image());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::fuchsia::sysmem::BufferSpec::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::fuchsia::sysmem::BufferSpec, image_) == 8);
  static_assert(sizeof(::fuchsia::sysmem::BufferSpec) == ::fuchsia::sysmem::BufferSpec::PrimarySize);
}


ImageSpec& ::fuchsia::sysmem::BufferSpec::mutable_image() {
  if (which() != Tag::kImage) {
    Destroy();
    new (&image_) ImageSpec;
  }
  tag_ = Tag::kImage;
  return image_;
}


::fuchsia::sysmem::BufferFormat::BufferFormat() {
  tag_ = Tag::Invalid;
}

::fuchsia::sysmem::BufferFormat::~BufferFormat() {
  Destroy();
}

void ::fuchsia::sysmem::BufferFormat::Destroy() {
  switch (which()) {
  case Tag::kImage:
    image_.~ImageFormat();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::fuchsia::sysmem::BufferFormat::MoveImpl_(BufferFormat&& other) {
  switch (other.which()) {
  case Tag::kImage:
    mutable_image() = std::move(other.mutable_image());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::fuchsia::sysmem::BufferFormat::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::fuchsia::sysmem::BufferFormat, image_) == 8);
  static_assert(sizeof(::fuchsia::sysmem::BufferFormat) == ::fuchsia::sysmem::BufferFormat::PrimarySize);
}


ImageFormat& ::fuchsia::sysmem::BufferFormat::mutable_image() {
  if (which() != Tag::kImage) {
    Destroy();
    new (&image_) ImageFormat;
  }
  tag_ = Tag::kImage;
  return image_;
}


namespace {

[[maybe_unused]]
constexpr uint32_t kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal = 525651766u;
[[maybe_unused]]
constexpr uint32_t kBufferCollectionEvents_OnBuffersAllocated_Ordinal = 1748036703u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal = 1823617849u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;

}  // namespace

zx_status_t BufferCollectionEvents::SyncClient::OnDuplicatedTokensKnownByServer() {
  return BufferCollectionEvents::Call::OnDuplicatedTokensKnownByServer(zx::unowned_channel(this->channel_));
}

zx_status_t BufferCollectionEvents::Call::OnDuplicatedTokensKnownByServer(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnDuplicatedTokensKnownByServerRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<OnDuplicatedTokensKnownByServerRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnDuplicatedTokensKnownByServerRequest));
  ::fidl::DecodedMessage<OnDuplicatedTokensKnownByServerRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollectionEvents::SyncClient::OnBuffersAllocated(int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_collection_info));
}

zx_status_t BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel _client_end, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnBuffersAllocatedRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionEvents_OnBuffersAllocated_Ordinal;
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionEvents::SyncClient::OnBuffersAllocated(::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  return BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_collection_info));
}

zx_status_t BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  if (_request_buffer.capacity() < OnBuffersAllocatedRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollectionEvents_OnBuffersAllocated_Ordinal;
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  _request_buffer.set_actual(sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionEvents::SyncClient::OnBuffersAllocated(::fidl::DecodedMessage<OnBuffersAllocatedRequest> params) {
  return BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollectionEvents::Call::OnBuffersAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnBuffersAllocatedRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionEvents_OnBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(int32_t status, SingleBufferInfo buffer_info) {
  return BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_info));
}

zx_status_t BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, int32_t status, SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnAllocateSingleBufferDoneRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal;
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info) {
  return BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_info));
}

zx_status_t BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, SingleBufferInfo buffer_info) {
  if (_request_buffer.capacity() < OnAllocateSingleBufferDoneRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal;
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  _request_buffer.set_actual(sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params) {
  return BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollectionEvents::Call::OnAllocateSingleBufferDone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


bool BufferCollectionEvents::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal: {
      auto result = ::fidl::DecodeAs<OnDuplicatedTokensKnownByServerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->OnDuplicatedTokensKnownByServer(
        Interface::OnDuplicatedTokensKnownByServerCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnBuffersAllocated_Ordinal: {
      auto result = ::fidl::DecodeAs<OnBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnBuffersAllocated(std::move(message->status), std::move(message->buffer_collection_info),
        Interface::OnBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal: {
      auto result = ::fidl::DecodeAs<OnAllocateSingleBufferDoneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnAllocateSingleBufferDone(std::move(message->status), std::move(message->buffer_info),
        Interface::OnAllocateSingleBufferDoneCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionEvents::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


namespace {

[[maybe_unused]]
constexpr uint32_t kBufferCollection_SetEventSink_Ordinal = 357278768u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_Sync_Ordinal = 364524065u;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_SetConstraints_Ordinal = 1411081086u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_WaitForBuffersAllocated_Ordinal = 456576936u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_CheckBuffersAllocated_Ordinal = 156573902u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_CloseSingleBuffer_Ordinal = 402848328u;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_AllocateSingleBuffer_Ordinal = 463501412u;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_WaitForSingleBufferAllocated_Ordinal = 921069347u;
extern "C" const fidl_type_t fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_CheckSingleBufferAllocated_Ordinal = 318847260u;
[[maybe_unused]]
constexpr uint32_t kBufferCollection_Close_Ordinal = 1618761496u;

}  // namespace

zx_status_t BufferCollection::SyncClient::SetEventSink(::zx::channel events) {
  return BufferCollection::Call::SetEventSink(zx::unowned_channel(this->channel_), std::move(events));
}

zx_status_t BufferCollection::Call::SetEventSink(zx::unowned_channel _client_end, ::zx::channel events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetEventSinkRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_SetEventSink_Ordinal;
  _request.events = std::move(events);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::SetEventSink(::fidl::BytePart _request_buffer, ::zx::channel events) {
  return BufferCollection::Call::SetEventSink(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events));
}

zx_status_t BufferCollection::Call::SetEventSink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events) {
  if (_request_buffer.capacity() < SetEventSinkRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_SetEventSink_Ordinal;
  _request.events = std::move(events);
  _request_buffer.set_actual(sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::SetEventSink(::fidl::DecodedMessage<SetEventSinkRequest> params) {
  return BufferCollection::Call::SetEventSink(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollection::Call::SetEventSink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetEventSinkRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_SetEventSink_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollection::SyncClient::Sync() {
  return BufferCollection::Call::Sync(zx::unowned_channel(this->channel_));
}

zx_status_t BufferCollection::Call::Sync(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SyncRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_Sync_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  return ZX_OK;
}


zx_status_t BufferCollection::SyncClient::SetConstraints(bool has_constraints, BufferCollectionConstraints constraints) {
  return BufferCollection::Call::SetConstraints(zx::unowned_channel(this->channel_), std::move(has_constraints), std::move(constraints));
}

zx_status_t BufferCollection::Call::SetConstraints(zx::unowned_channel _client_end, bool has_constraints, BufferCollectionConstraints constraints) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConstraintsRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_SetConstraints_Ordinal;
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::SetConstraints(::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints) {
  return BufferCollection::Call::SetConstraints(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(has_constraints), std::move(constraints));
}

zx_status_t BufferCollection::Call::SetConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, BufferCollectionConstraints constraints) {
  if (_request_buffer.capacity() < SetConstraintsRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_SetConstraints_Ordinal;
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  _request_buffer.set_actual(sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::SetConstraints(::fidl::DecodedMessage<SetConstraintsRequest> params) {
  return BufferCollection::Call::SetConstraints(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollection::Call::SetConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConstraintsRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_SetConstraints_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollection::SyncClient::WaitForBuffersAllocated(int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info) {
  return BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel(this->channel_), out_status, out_buffer_collection_info);
}

zx_status_t BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<WaitForBuffersAllocatedRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedResponse>();
  std::unique_ptr<uint8_t[]> _read_bytes_unique_ptr(new uint8_t[_kReadAllocSize]);
  uint8_t* _read_bytes = _read_bytes_unique_ptr.get();
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WaitForBuffersAllocatedRequest, WaitForBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_buffer_collection_info = std::move(_response.buffer_collection_info);
  return ZX_OK;
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::SyncClient::WaitForBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info) {
  return BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status, out_buffer_collection_info);
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, BufferCollectionInfo_2* out_buffer_collection_info) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(WaitForBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<WaitForBuffersAllocatedRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  _request_buffer.set_actual(sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WaitForBuffersAllocatedResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WaitForBuffersAllocatedRequest, WaitForBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WaitForBuffersAllocatedResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_buffer_collection_info = std::move(_response.buffer_collection_info);
  return _decode_result;
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::SyncClient::WaitForBuffersAllocated(::fidl::BytePart response_buffer) {
  return BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::Call::WaitForBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(WaitForBuffersAllocatedRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(WaitForBuffersAllocatedRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<BufferCollection::WaitForBuffersAllocatedResponse>());
  }
  auto _call_result = ::fidl::Call<WaitForBuffersAllocatedRequest, WaitForBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<BufferCollection::WaitForBuffersAllocatedResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t BufferCollection::SyncClient::CheckBuffersAllocated(int32_t* out_status) {
  return BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel(this->channel_), out_status);
}

zx_status_t BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel _client_end, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CheckBuffersAllocatedRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<CheckBuffersAllocatedRequest, CheckBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::SyncClient::CheckBuffersAllocated(::fidl::BytePart _response_buffer, int32_t* out_status) {
  return BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CheckBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<CheckBuffersAllocatedRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  _request_buffer.set_actual(sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CheckBuffersAllocatedResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<CheckBuffersAllocatedRequest, CheckBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<CheckBuffersAllocatedResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::SyncClient::CheckBuffersAllocated(::fidl::BytePart response_buffer) {
  return BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::Call::CheckBuffersAllocated(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CheckBuffersAllocatedRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(CheckBuffersAllocatedRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<BufferCollection::CheckBuffersAllocatedResponse>());
  }
  auto _call_result = ::fidl::Call<CheckBuffersAllocatedRequest, CheckBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<BufferCollection::CheckBuffersAllocatedResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t BufferCollection::SyncClient::CloseSingleBuffer(uint64_t buffer_index) {
  return BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSingleBufferRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_CloseSingleBuffer_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::CloseSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CloseSingleBufferRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_CloseSingleBuffer_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::CloseSingleBuffer(::fidl::DecodedMessage<CloseSingleBufferRequest> params) {
  return BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollection::Call::CloseSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSingleBufferRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CloseSingleBuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollection::SyncClient::AllocateSingleBuffer(uint64_t buffer_index) {
  return BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSingleBufferRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_AllocateSingleBuffer_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::AllocateSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < AllocateSingleBufferRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_AllocateSingleBuffer_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::AllocateSingleBuffer(::fidl::DecodedMessage<AllocateSingleBufferRequest> params) {
  return BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollection::Call::AllocateSingleBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSingleBufferRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_AllocateSingleBuffer_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollection::SyncClient::WaitForSingleBufferAllocated(uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info) {
  return BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(buffer_index), out_status, out_buffer_info);
}

zx_status_t BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index, int32_t* out_status, SingleBufferInfo* out_buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WaitForSingleBufferAllocatedRequest, WaitForSingleBufferAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_buffer_info = std::move(_response.buffer_info);
  return ZX_OK;
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::SyncClient::WaitForSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info) {
  return BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index), std::move(_response_buffer), out_status, out_buffer_info);
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer, int32_t* out_status, SingleBufferInfo* out_buffer_info) {
  if (_request_buffer.capacity() < WaitForSingleBufferAllocatedRequest::PrimarySize) {
    return ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WaitForSingleBufferAllocatedRequest, WaitForSingleBufferAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_buffer_info = std::move(_response.buffer_info);
  return _decode_result;
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::SyncClient::WaitForSingleBufferAllocated(::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer) {
  return BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::Call::WaitForSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<BufferCollection::WaitForSingleBufferAllocatedResponse>());
  }
  auto _call_result = ::fidl::Call<WaitForSingleBufferAllocatedRequest, WaitForSingleBufferAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<BufferCollection::WaitForSingleBufferAllocatedResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t BufferCollection::SyncClient::CheckSingleBufferAllocated(uint64_t buffer_index) {
  return BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckSingleBufferAllocatedRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_CheckSingleBufferAllocated_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::CheckSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

zx_status_t BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CheckSingleBufferAllocatedRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kBufferCollection_CheckSingleBufferAllocated_Ordinal;
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t BufferCollection::SyncClient::CheckSingleBufferAllocated(::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params) {
  return BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t BufferCollection::Call::CheckSingleBufferAllocated(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckSingleBufferAllocated_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t BufferCollection::SyncClient::Close() {
  return BufferCollection::Call::Close(zx::unowned_channel(this->channel_));
}

zx_status_t BufferCollection::Call::Close(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<CloseRequest*>(_write_bytes);
  _request._hdr.ordinal = kBufferCollection_Close_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


bool BufferCollection::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kBufferCollection_SetEventSink_Ordinal: {
      auto result = ::fidl::DecodeAs<SetEventSinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetEventSink(std::move(message->events),
        Interface::SetEventSinkCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Sync_Ordinal: {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
        Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_SetConstraints_Ordinal: {
      auto result = ::fidl::DecodeAs<SetConstraintsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetConstraints(std::move(message->has_constraints), std::move(message->constraints),
        Interface::SetConstraintsCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForBuffersAllocated_Ordinal: {
      auto result = ::fidl::DecodeAs<WaitForBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->WaitForBuffersAllocated(
        Interface::WaitForBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckBuffersAllocated_Ordinal: {
      auto result = ::fidl::DecodeAs<CheckBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->CheckBuffersAllocated(
        Interface::CheckBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CloseSingleBuffer_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CloseSingleBuffer(std::move(message->buffer_index),
        Interface::CloseSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_AllocateSingleBuffer_Ordinal: {
      auto result = ::fidl::DecodeAs<AllocateSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSingleBuffer(std::move(message->buffer_index),
        Interface::AllocateSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForSingleBufferAllocated_Ordinal: {
      auto result = ::fidl::DecodeAs<WaitForSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WaitForSingleBufferAllocated(std::move(message->buffer_index),
        Interface::WaitForSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckSingleBufferAllocated_Ordinal: {
      auto result = ::fidl::DecodeAs<CheckSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CheckSingleBufferAllocated(std::move(message->buffer_index),
        Interface::CheckSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Close_Ordinal: {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
        Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollection::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollection::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_Sync_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}


void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, BufferCollectionInfo_2 buffer_collection_info) {
  if (_buffer.capacity() < WaitForBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  _buffer.set_actual(sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForBuffersAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < CheckBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_CheckBuffersAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(int32_t status, SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_write_bytes);
  _response._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, SingleBufferInfo buffer_info) {
  if (_buffer.capacity() < WaitForSingleBufferAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_buffer.data());
  _response._hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  _buffer.set_actual(sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kBufferCollection_WaitForSingleBufferAllocated_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace sysmem
}  // namespace fuchsia

// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/sysmem/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace sysmem {

namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Duplicate_Ordinal = 0x5e37401300000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Duplicate_GenOrdinal = 0x2f9f81bdde4b7292lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenDuplicateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenDuplicateResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Sync_Ordinal = 0x3218cf6000000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Sync_GenOrdinal = 0x16941ac71d960cd0lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Close_Ordinal = 0x21ba753500000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionToken_Close_GenOrdinal = 0x11df1970c2c12176lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionTokenCloseResponseTable;

}  // namespace

BufferCollectionToken::ResultOf::Duplicate_Impl::Duplicate_Impl(::zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DuplicateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DuplicateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_write_bytes);
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionToken::InPlace::Duplicate(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionToken::ResultOf::Duplicate BufferCollectionToken::SyncClient::Duplicate(uint32_t rights_attenuation_mask, ::zx::channel token_request) {
    return ResultOf::Duplicate(::zx::unowned_channel(this->channel_), std::move(rights_attenuation_mask), std::move(token_request));
}

BufferCollectionToken::ResultOf::Duplicate BufferCollectionToken::Call::Duplicate(::zx::unowned_channel _client_end, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return ResultOf::Duplicate(std::move(_client_end), std::move(rights_attenuation_mask), std::move(token_request));
}


BufferCollectionToken::UnownedResultOf::Duplicate_Impl::Duplicate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  if (_request_buffer.capacity() < DuplicateRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, DuplicateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DuplicateRequest*>(_request_buffer.data());
  _request.rights_attenuation_mask = std::move(rights_attenuation_mask);
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(DuplicateRequest));
  ::fidl::DecodedMessage<DuplicateRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionToken::InPlace::Duplicate(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionToken::UnownedResultOf::Duplicate BufferCollectionToken::SyncClient::Duplicate(::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return UnownedResultOf::Duplicate(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(rights_attenuation_mask), std::move(token_request));
}

BufferCollectionToken::UnownedResultOf::Duplicate BufferCollectionToken::Call::Duplicate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t rights_attenuation_mask, ::zx::channel token_request) {
  return UnownedResultOf::Duplicate(std::move(_client_end), std::move(_request_buffer), std::move(rights_attenuation_mask), std::move(token_request));
}

::fidl::internal::StatusAndError BufferCollectionToken::InPlace::Duplicate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DuplicateRequest> params) {
  BufferCollectionToken::SetTransactionHeaderFor::DuplicateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollectionToken::ResultOf::Sync_Impl<BufferCollectionToken::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollectionToken::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

BufferCollectionToken::ResultOf::Sync BufferCollectionToken::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

BufferCollectionToken::ResultOf::Sync BufferCollectionToken::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

::fidl::DecodeResult<BufferCollectionToken::SyncResponse> BufferCollectionToken::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  BufferCollectionToken::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollectionToken::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollectionToken::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollectionToken::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionToken::InPlace::Close(std::move(_client_end)));
}

BufferCollectionToken::ResultOf::Close BufferCollectionToken::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

BufferCollectionToken::ResultOf::Close BufferCollectionToken::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollectionToken::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  BufferCollectionToken::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollectionToken::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kBufferCollectionToken_Duplicate_Ordinal:
    case kBufferCollectionToken_Duplicate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DuplicateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Duplicate(std::move(message->rights_attenuation_mask), std::move(message->token_request),
          Interface::DuplicateCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Sync_Ordinal:
    case kBufferCollectionToken_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionToken_Close_Ordinal:
    case kBufferCollectionToken_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionToken::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollectionToken::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  BufferCollectionToken::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}



void BufferCollectionToken::SetTransactionHeaderFor::DuplicateRequest(const ::fidl::DecodedMessage<BufferCollectionToken::DuplicateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionToken_Duplicate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollectionToken::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<BufferCollectionToken::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionToken_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void BufferCollectionToken::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<BufferCollectionToken::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionToken_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollectionToken::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<BufferCollectionToken::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionToken_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kHeap_AllocateVmo_Ordinal = 0xbb99f8d00000000lu;
[[maybe_unused]]
constexpr uint64_t kHeap_AllocateVmo_GenOrdinal = 0x1c885a457f626eeflu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapAllocateVmoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapAllocateVmoResponseTable;
[[maybe_unused]]
constexpr uint64_t kHeap_CreateResource_Ordinal = 0x35a990c200000000lu;
[[maybe_unused]]
constexpr uint64_t kHeap_CreateResource_GenOrdinal = 0x20f4e8b60cb76063lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapCreateResourceRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapCreateResourceResponseTable;
[[maybe_unused]]
constexpr uint64_t kHeap_DestroyResource_Ordinal = 0x27df37a100000000lu;
[[maybe_unused]]
constexpr uint64_t kHeap_DestroyResource_GenOrdinal = 0x766bee03db72e8falu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapDestroyResourceRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_HeapDestroyResourceResponseTable;

}  // namespace
template <>
Heap::ResultOf::AllocateVmo_Impl<Heap::AllocateVmoResponse>::AllocateVmo_Impl(::zx::unowned_channel _client_end, uint64_t size) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_write_bytes);
  _request.size = std::move(size);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::AllocateVmo Heap::SyncClient::AllocateVmo(uint64_t size) {
    return ResultOf::AllocateVmo(::zx::unowned_channel(this->channel_), std::move(size));
}

Heap::ResultOf::AllocateVmo Heap::Call::AllocateVmo(::zx::unowned_channel _client_end, uint64_t size) {
  return ResultOf::AllocateVmo(std::move(_client_end), std::move(size));
}

template <>
Heap::UnownedResultOf::AllocateVmo_Impl<Heap::AllocateVmoResponse>::AllocateVmo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AllocateVmoRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AllocateVmoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AllocateVmoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateVmoRequest*>(_request_buffer.data());
  _request.size = std::move(size);
  _request_buffer.set_actual(sizeof(AllocateVmoRequest));
  ::fidl::DecodedMessage<AllocateVmoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::AllocateVmo(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::AllocateVmo Heap::SyncClient::AllocateVmo(::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

Heap::UnownedResultOf::AllocateVmo Heap::Call::AllocateVmo(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t size, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateVmo(std::move(_client_end), std::move(_request_buffer), std::move(size), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::AllocateVmoResponse> Heap::InPlace::AllocateVmo(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateVmoRequest> params, ::fidl::BytePart response_buffer) {
  Heap::SetTransactionHeaderFor::AllocateVmoRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AllocateVmoRequest, AllocateVmoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::AllocateVmoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Heap::ResultOf::CreateResource_Impl<Heap::CreateResourceResponse>::CreateResource_Impl(::zx::unowned_channel _client_end, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_write_bytes);
  _request.vmo = std::move(vmo);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::CreateResource(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::CreateResource Heap::SyncClient::CreateResource(::zx::vmo vmo) {
    return ResultOf::CreateResource(::zx::unowned_channel(this->channel_), std::move(vmo));
}

Heap::ResultOf::CreateResource Heap::Call::CreateResource(::zx::unowned_channel _client_end, ::zx::vmo vmo) {
  return ResultOf::CreateResource(std::move(_client_end), std::move(vmo));
}

template <>
Heap::UnownedResultOf::CreateResource_Impl<Heap::CreateResourceResponse>::CreateResource_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CreateResourceRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CreateResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CreateResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CreateResourceRequest*>(_request_buffer.data());
  _request.vmo = std::move(vmo);
  _request_buffer.set_actual(sizeof(CreateResourceRequest));
  ::fidl::DecodedMessage<CreateResourceRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::CreateResource(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::CreateResource Heap::SyncClient::CreateResource(::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateResource(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

Heap::UnownedResultOf::CreateResource Heap::Call::CreateResource(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo vmo, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateResource(std::move(_client_end), std::move(_request_buffer), std::move(vmo), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::CreateResourceResponse> Heap::InPlace::CreateResource(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateResourceRequest> params, ::fidl::BytePart response_buffer) {
  Heap::SetTransactionHeaderFor::CreateResourceRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateResourceRequest, CreateResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::CreateResourceResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Heap::ResultOf::DestroyResource_Impl<Heap::DestroyResourceResponse>::DestroyResource_Impl(::zx::unowned_channel _client_end, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DestroyResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_write_bytes);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Heap::InPlace::DestroyResource(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Heap::ResultOf::DestroyResource Heap::SyncClient::DestroyResource(uint64_t id) {
    return ResultOf::DestroyResource(::zx::unowned_channel(this->channel_), std::move(id));
}

Heap::ResultOf::DestroyResource Heap::Call::DestroyResource(::zx::unowned_channel _client_end, uint64_t id) {
  return ResultOf::DestroyResource(std::move(_client_end), std::move(id));
}

template <>
Heap::UnownedResultOf::DestroyResource_Impl<Heap::DestroyResourceResponse>::DestroyResource_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DestroyResourceRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DestroyResourceResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DestroyResourceRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyResourceRequest*>(_request_buffer.data());
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(DestroyResourceRequest));
  ::fidl::DecodedMessage<DestroyResourceRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Heap::InPlace::DestroyResource(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Heap::UnownedResultOf::DestroyResource Heap::SyncClient::DestroyResource(::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DestroyResource(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id), std::move(_response_buffer));
}

Heap::UnownedResultOf::DestroyResource Heap::Call::DestroyResource(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::DestroyResource(std::move(_client_end), std::move(_request_buffer), std::move(id), std::move(_response_buffer));
}

::fidl::DecodeResult<Heap::DestroyResourceResponse> Heap::InPlace::DestroyResource(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyResourceRequest> params, ::fidl::BytePart response_buffer) {
  Heap::SetTransactionHeaderFor::DestroyResourceRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::DestroyResourceResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DestroyResourceRequest, DestroyResourceResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Heap::DestroyResourceResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Heap::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kHeap_AllocateVmo_Ordinal:
    case kHeap_AllocateVmo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateVmoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateVmo(std::move(message->size),
          Interface::AllocateVmoCompleter::Sync(txn));
      return true;
    }
    case kHeap_CreateResource_Ordinal:
    case kHeap_CreateResource_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CreateResource(std::move(message->vmo),
          Interface::CreateResourceCompleter::Sync(txn));
      return true;
    }
    case kHeap_DestroyResource_Ordinal:
    case kHeap_DestroyResource_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DestroyResourceRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->DestroyResource(std::move(message->id),
          Interface::DestroyResourceCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Heap::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Heap::Interface::AllocateVmoCompleterBase::Reply(int32_t s, ::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateVmoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_write_bytes);
  Heap::SetTransactionHeaderFor::AllocateVmoResponse(
      ::fidl::DecodedMessage<AllocateVmoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AllocateVmoResponse::PrimarySize,
              AllocateVmoResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_response_bytes)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::vmo vmo) {
  if (_buffer.capacity() < AllocateVmoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AllocateVmoResponse*>(_buffer.data());
  Heap::SetTransactionHeaderFor::AllocateVmoResponse(
      ::fidl::DecodedMessage<AllocateVmoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AllocateVmoResponse::PrimarySize,
              AllocateVmoResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.vmo = std::move(vmo);
  _buffer.set_actual(sizeof(AllocateVmoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateVmoResponse>(std::move(_buffer)));
}

void Heap::Interface::AllocateVmoCompleterBase::Reply(::fidl::DecodedMessage<AllocateVmoResponse> params) {
  Heap::SetTransactionHeaderFor::AllocateVmoResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::CreateResourceCompleterBase::Reply(int32_t s, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateResourceResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_write_bytes);
  Heap::SetTransactionHeaderFor::CreateResourceResponse(
      ::fidl::DecodedMessage<CreateResourceResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateResourceResponse::PrimarySize,
              CreateResourceResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.id = std::move(id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_response_bytes)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint64_t id) {
  if (_buffer.capacity() < CreateResourceResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateResourceResponse*>(_buffer.data());
  Heap::SetTransactionHeaderFor::CreateResourceResponse(
      ::fidl::DecodedMessage<CreateResourceResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateResourceResponse::PrimarySize,
              CreateResourceResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.id = std::move(id);
  _buffer.set_actual(sizeof(CreateResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateResourceResponse>(std::move(_buffer)));
}

void Heap::Interface::CreateResourceCompleterBase::Reply(::fidl::DecodedMessage<CreateResourceResponse> params) {
  Heap::SetTransactionHeaderFor::CreateResourceResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Heap::Interface::DestroyResourceCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyResourceResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<DestroyResourceResponse*>(_write_bytes);
  Heap::SetTransactionHeaderFor::DestroyResourceResponse(
      ::fidl::DecodedMessage<DestroyResourceResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DestroyResourceResponse::PrimarySize,
              DestroyResourceResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyResourceResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<DestroyResourceResponse>(std::move(_response_bytes)));
}



void Heap::SetTransactionHeaderFor::AllocateVmoRequest(const ::fidl::DecodedMessage<Heap::AllocateVmoRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_AllocateVmo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Heap::SetTransactionHeaderFor::AllocateVmoResponse(const ::fidl::DecodedMessage<Heap::AllocateVmoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_AllocateVmo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Heap::SetTransactionHeaderFor::CreateResourceRequest(const ::fidl::DecodedMessage<Heap::CreateResourceRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_CreateResource_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Heap::SetTransactionHeaderFor::CreateResourceResponse(const ::fidl::DecodedMessage<Heap::CreateResourceResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_CreateResource_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Heap::SetTransactionHeaderFor::DestroyResourceRequest(const ::fidl::DecodedMessage<Heap::DestroyResourceRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_DestroyResource_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Heap::SetTransactionHeaderFor::DestroyResourceResponse(const ::fidl::DecodedMessage<Heap::DestroyResourceResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kHeap_DestroyResource_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDriverConnector_Connect_Ordinal = 0x3082e03400000000lu;
[[maybe_unused]]
constexpr uint64_t kDriverConnector_Connect_GenOrdinal = 0x663a49f8408b8184lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_DriverConnectorConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_DriverConnectorConnectResponseTable;

}  // namespace

DriverConnector::ResultOf::Connect_Impl::Connect_Impl(::zx::unowned_channel _client_end, ::zx::channel allocator_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ConnectRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ConnectRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConnectRequest*>(_write_bytes);
  _request.allocator_request = std::move(allocator_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      DriverConnector::InPlace::Connect(std::move(_client_end), std::move(_decoded_request)));
}

DriverConnector::ResultOf::Connect DriverConnector::SyncClient::Connect(::zx::channel allocator_request) {
    return ResultOf::Connect(::zx::unowned_channel(this->channel_), std::move(allocator_request));
}

DriverConnector::ResultOf::Connect DriverConnector::Call::Connect(::zx::unowned_channel _client_end, ::zx::channel allocator_request) {
  return ResultOf::Connect(std::move(_client_end), std::move(allocator_request));
}


DriverConnector::UnownedResultOf::Connect_Impl::Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  if (_request_buffer.capacity() < ConnectRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ConnectRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ConnectRequest*>(_request_buffer.data());
  _request.allocator_request = std::move(allocator_request);
  _request_buffer.set_actual(sizeof(ConnectRequest));
  ::fidl::DecodedMessage<ConnectRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      DriverConnector::InPlace::Connect(std::move(_client_end), std::move(_decoded_request)));
}

DriverConnector::UnownedResultOf::Connect DriverConnector::SyncClient::Connect(::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  return UnownedResultOf::Connect(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(allocator_request));
}

DriverConnector::UnownedResultOf::Connect DriverConnector::Call::Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel allocator_request) {
  return UnownedResultOf::Connect(std::move(_client_end), std::move(_request_buffer), std::move(allocator_request));
}

::fidl::internal::StatusAndError DriverConnector::InPlace::Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params) {
  DriverConnector::SetTransactionHeaderFor::ConnectRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool DriverConnector::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDriverConnector_Connect_Ordinal:
    case kDriverConnector_Connect_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ConnectRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Connect(std::move(message->allocator_request),
          Interface::ConnectCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DriverConnector::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void DriverConnector::SetTransactionHeaderFor::ConnectRequest(const ::fidl::DecodedMessage<DriverConnector::ConnectRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDriverConnector_Connect_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateNonSharedCollection_Ordinal = 0x21b157d700000000lu;
[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateNonSharedCollection_GenOrdinal = 0x20f79299bbb4d2c6lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorAllocateNonSharedCollectionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorAllocateNonSharedCollectionResponseTable;
[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateSharedCollection_Ordinal = 0x36a4dbc400000000lu;
[[maybe_unused]]
constexpr uint64_t kAllocator_AllocateSharedCollection_GenOrdinal = 0x7a757a57bfda0f71lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorAllocateSharedCollectionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorAllocateSharedCollectionResponseTable;
[[maybe_unused]]
constexpr uint64_t kAllocator_BindSharedCollection_Ordinal = 0x1d68697500000000lu;
[[maybe_unused]]
constexpr uint64_t kAllocator_BindSharedCollection_GenOrdinal = 0x146eca7ec46ff4eelu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorBindSharedCollectionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_AllocatorBindSharedCollectionResponseTable;

}  // namespace

Allocator::ResultOf::AllocateNonSharedCollection_Impl::AllocateNonSharedCollection_Impl(::zx::unowned_channel _client_end, ::zx::channel collection) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateNonSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateNonSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_write_bytes);
  _request.collection = std::move(collection);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::AllocateNonSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::AllocateNonSharedCollection Allocator::SyncClient::AllocateNonSharedCollection(::zx::channel collection) {
    return ResultOf::AllocateNonSharedCollection(::zx::unowned_channel(this->channel_), std::move(collection));
}

Allocator::ResultOf::AllocateNonSharedCollection Allocator::Call::AllocateNonSharedCollection(::zx::unowned_channel _client_end, ::zx::channel collection) {
  return ResultOf::AllocateNonSharedCollection(std::move(_client_end), std::move(collection));
}


Allocator::UnownedResultOf::AllocateNonSharedCollection_Impl::AllocateNonSharedCollection_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection) {
  if (_request_buffer.capacity() < AllocateNonSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateNonSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateNonSharedCollectionRequest*>(_request_buffer.data());
  _request.collection = std::move(collection);
  _request_buffer.set_actual(sizeof(AllocateNonSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::AllocateNonSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::AllocateNonSharedCollection Allocator::SyncClient::AllocateNonSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel collection) {
  return UnownedResultOf::AllocateNonSharedCollection(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection));
}

Allocator::UnownedResultOf::AllocateNonSharedCollection Allocator::Call::AllocateNonSharedCollection(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel collection) {
  return UnownedResultOf::AllocateNonSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection));
}

::fidl::internal::StatusAndError Allocator::InPlace::AllocateNonSharedCollection(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateNonSharedCollectionRequest> params) {
  Allocator::SetTransactionHeaderFor::AllocateNonSharedCollectionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Allocator::ResultOf::AllocateSharedCollection_Impl::AllocateSharedCollection_Impl(::zx::unowned_channel _client_end, ::zx::channel token_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_write_bytes);
  _request.token_request = std::move(token_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::AllocateSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::AllocateSharedCollection Allocator::SyncClient::AllocateSharedCollection(::zx::channel token_request) {
    return ResultOf::AllocateSharedCollection(::zx::unowned_channel(this->channel_), std::move(token_request));
}

Allocator::ResultOf::AllocateSharedCollection Allocator::Call::AllocateSharedCollection(::zx::unowned_channel _client_end, ::zx::channel token_request) {
  return ResultOf::AllocateSharedCollection(std::move(_client_end), std::move(token_request));
}


Allocator::UnownedResultOf::AllocateSharedCollection_Impl::AllocateSharedCollection_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  if (_request_buffer.capacity() < AllocateSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSharedCollectionRequest*>(_request_buffer.data());
  _request.token_request = std::move(token_request);
  _request_buffer.set_actual(sizeof(AllocateSharedCollectionRequest));
  ::fidl::DecodedMessage<AllocateSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::AllocateSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::AllocateSharedCollection Allocator::SyncClient::AllocateSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  return UnownedResultOf::AllocateSharedCollection(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token_request));
}

Allocator::UnownedResultOf::AllocateSharedCollection Allocator::Call::AllocateSharedCollection(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token_request) {
  return UnownedResultOf::AllocateSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(token_request));
}

::fidl::internal::StatusAndError Allocator::InPlace::AllocateSharedCollection(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSharedCollectionRequest> params) {
  Allocator::SetTransactionHeaderFor::AllocateSharedCollectionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Allocator::ResultOf::BindSharedCollection_Impl::BindSharedCollection_Impl(::zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<BindSharedCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, BindSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_write_bytes);
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Allocator::InPlace::BindSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::ResultOf::BindSharedCollection Allocator::SyncClient::BindSharedCollection(::zx::channel token, ::zx::channel buffer_collection_request) {
    return ResultOf::BindSharedCollection(::zx::unowned_channel(this->channel_), std::move(token), std::move(buffer_collection_request));
}

Allocator::ResultOf::BindSharedCollection Allocator::Call::BindSharedCollection(::zx::unowned_channel _client_end, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return ResultOf::BindSharedCollection(std::move(_client_end), std::move(token), std::move(buffer_collection_request));
}


Allocator::UnownedResultOf::BindSharedCollection_Impl::BindSharedCollection_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  if (_request_buffer.capacity() < BindSharedCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, BindSharedCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<BindSharedCollectionRequest*>(_request_buffer.data());
  _request.token = std::move(token);
  _request.buffer_collection_request = std::move(buffer_collection_request);
  _request_buffer.set_actual(sizeof(BindSharedCollectionRequest));
  ::fidl::DecodedMessage<BindSharedCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Allocator::InPlace::BindSharedCollection(std::move(_client_end), std::move(_decoded_request)));
}

Allocator::UnownedResultOf::BindSharedCollection Allocator::SyncClient::BindSharedCollection(::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return UnownedResultOf::BindSharedCollection(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(token), std::move(buffer_collection_request));
}

Allocator::UnownedResultOf::BindSharedCollection Allocator::Call::BindSharedCollection(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel token, ::zx::channel buffer_collection_request) {
  return UnownedResultOf::BindSharedCollection(std::move(_client_end), std::move(_request_buffer), std::move(token), std::move(buffer_collection_request));
}

::fidl::internal::StatusAndError Allocator::InPlace::BindSharedCollection(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindSharedCollectionRequest> params) {
  Allocator::SetTransactionHeaderFor::BindSharedCollectionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool Allocator::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kAllocator_AllocateNonSharedCollection_Ordinal:
    case kAllocator_AllocateNonSharedCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateNonSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateNonSharedCollection(std::move(message->collection),
          Interface::AllocateNonSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_AllocateSharedCollection_Ordinal:
    case kAllocator_AllocateSharedCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSharedCollection(std::move(message->token_request),
          Interface::AllocateSharedCollectionCompleter::Sync(txn));
      return true;
    }
    case kAllocator_BindSharedCollection_Ordinal:
    case kAllocator_BindSharedCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<BindSharedCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->BindSharedCollection(std::move(message->token), std::move(message->buffer_collection_request),
          Interface::BindSharedCollectionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Allocator::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void Allocator::SetTransactionHeaderFor::AllocateNonSharedCollectionRequest(const ::fidl::DecodedMessage<Allocator::AllocateNonSharedCollectionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kAllocator_AllocateNonSharedCollection_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Allocator::SetTransactionHeaderFor::AllocateSharedCollectionRequest(const ::fidl::DecodedMessage<Allocator::AllocateSharedCollectionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kAllocator_AllocateSharedCollection_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Allocator::SetTransactionHeaderFor::BindSharedCollectionRequest(const ::fidl::DecodedMessage<Allocator::BindSharedCollectionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kAllocator_BindSharedCollection_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(SecureMem_SetPhysicalSecureHeaps_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(SecureMem_SetPhysicalSecureHeaps_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(SecureMem_SetPhysicalSecureHeaps_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(SecureMem_GetPhysicalSecureHeaps_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(SecureMem_GetPhysicalSecureHeaps_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(SecureMem_GetPhysicalSecureHeaps_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kSecureMem_GetPhysicalSecureHeaps_Ordinal = 0x60f3c45a00000000lu;
[[maybe_unused]]
constexpr uint64_t kSecureMem_GetPhysicalSecureHeaps_GenOrdinal = 0x782319d6ce7fa05lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_SecureMemGetPhysicalSecureHeapsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_SecureMemGetPhysicalSecureHeapsResponseTable;
[[maybe_unused]]
constexpr uint64_t kSecureMem_SetPhysicalSecureHeaps_Ordinal = 0x14b0c0000000000lu;
[[maybe_unused]]
constexpr uint64_t kSecureMem_SetPhysicalSecureHeaps_GenOrdinal = 0x75a89c33ee8a5d7elu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_SecureMemSetPhysicalSecureHeapsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_SecureMemSetPhysicalSecureHeapsResponseTable;

}  // namespace
template <>
SecureMem::ResultOf::GetPhysicalSecureHeaps_Impl<SecureMem::GetPhysicalSecureHeapsResponse>::GetPhysicalSecureHeaps_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPhysicalSecureHeapsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetPhysicalSecureHeapsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      SecureMem::InPlace::GetPhysicalSecureHeaps(std::move(_client_end), Super::response_buffer()));
}

SecureMem::ResultOf::GetPhysicalSecureHeaps SecureMem::SyncClient::GetPhysicalSecureHeaps() {
    return ResultOf::GetPhysicalSecureHeaps(::zx::unowned_channel(this->channel_));
}

SecureMem::ResultOf::GetPhysicalSecureHeaps SecureMem::Call::GetPhysicalSecureHeaps(::zx::unowned_channel _client_end) {
  return ResultOf::GetPhysicalSecureHeaps(std::move(_client_end));
}

template <>
SecureMem::UnownedResultOf::GetPhysicalSecureHeaps_Impl<SecureMem::GetPhysicalSecureHeapsResponse>::GetPhysicalSecureHeaps_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetPhysicalSecureHeapsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetPhysicalSecureHeapsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      SecureMem::InPlace::GetPhysicalSecureHeaps(std::move(_client_end), std::move(_response_buffer)));
}

SecureMem::UnownedResultOf::GetPhysicalSecureHeaps SecureMem::SyncClient::GetPhysicalSecureHeaps(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetPhysicalSecureHeaps(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

SecureMem::UnownedResultOf::GetPhysicalSecureHeaps SecureMem::Call::GetPhysicalSecureHeaps(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetPhysicalSecureHeaps(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse> SecureMem::InPlace::GetPhysicalSecureHeaps(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetPhysicalSecureHeapsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetPhysicalSecureHeapsRequest> params(std::move(_request_buffer));
  SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetPhysicalSecureHeapsRequest, GetPhysicalSecureHeapsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::GetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
SecureMem::ResultOf::SetPhysicalSecureHeaps_Impl<SecureMem::SetPhysicalSecureHeapsResponse>::SetPhysicalSecureHeaps_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPhysicalSecureHeapsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetPhysicalSecureHeapsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPhysicalSecureHeapsRequest*>(_write_bytes);
  _request.heaps = std::move(heaps);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      SecureMem::InPlace::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

SecureMem::ResultOf::SetPhysicalSecureHeaps SecureMem::SyncClient::SetPhysicalSecureHeaps(::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps) {
    return ResultOf::SetPhysicalSecureHeaps(::zx::unowned_channel(this->channel_), std::move(heaps));
}

SecureMem::ResultOf::SetPhysicalSecureHeaps SecureMem::Call::SetPhysicalSecureHeaps(::zx::unowned_channel _client_end, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps) {
  return ResultOf::SetPhysicalSecureHeaps(std::move(_client_end), std::move(heaps));
}

template <>
SecureMem::UnownedResultOf::SetPhysicalSecureHeaps_Impl<SecureMem::SetPhysicalSecureHeapsResponse>::SetPhysicalSecureHeaps_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetPhysicalSecureHeapsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetPhysicalSecureHeapsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetPhysicalSecureHeapsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetPhysicalSecureHeapsRequest*>(_request_buffer.data());
  _request.heaps = std::move(heaps);
  _request_buffer.set_actual(sizeof(SetPhysicalSecureHeapsRequest));
  ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      SecureMem::InPlace::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

SecureMem::UnownedResultOf::SetPhysicalSecureHeaps SecureMem::SyncClient::SetPhysicalSecureHeaps(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPhysicalSecureHeaps(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(heaps), std::move(_response_buffer));
}

SecureMem::UnownedResultOf::SetPhysicalSecureHeaps SecureMem::Call::SetPhysicalSecureHeaps(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetPhysicalSecureHeaps(std::move(_client_end), std::move(_request_buffer), std::move(heaps), std::move(_response_buffer));
}

::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse> SecureMem::InPlace::SetPhysicalSecureHeaps(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetPhysicalSecureHeapsRequest> params, ::fidl::BytePart response_buffer) {
  SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetPhysicalSecureHeapsRequest, SetPhysicalSecureHeapsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SecureMem::SetPhysicalSecureHeapsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool SecureMem::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kSecureMem_GetPhysicalSecureHeaps_Ordinal:
    case kSecureMem_GetPhysicalSecureHeaps_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetPhysicalSecureHeapsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetPhysicalSecureHeaps(
          Interface::GetPhysicalSecureHeapsCompleter::Sync(txn));
      return true;
    }
    case kSecureMem_SetPhysicalSecureHeaps_Ordinal:
    case kSecureMem_SetPhysicalSecureHeaps_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetPhysicalSecureHeapsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetPhysicalSecureHeaps(std::move(message->heaps),
          Interface::SetPhysicalSecureHeapsCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool SecureMem::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPhysicalSecureHeapsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetPhysicalSecureHeapsResponse _response = {};
  SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsResponse(
      ::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetPhysicalSecureHeapsResponse::PrimarySize,
              GetPhysicalSecureHeapsResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::ReplySuccess(::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps) {
  SecureMem_GetPhysicalSecureHeaps_Response response;
  response.heaps = std::move(heaps);

  Reply(SecureMem_GetPhysicalSecureHeaps_Result::WithResponse(&response));
}
void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::ReplyError(int32_t error) {
  Reply(SecureMem_GetPhysicalSecureHeaps_Result::WithErr(&error));
}

void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::sysmem::SecureMem_GetPhysicalSecureHeaps_Result result) {
  if (_buffer.capacity() < GetPhysicalSecureHeapsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetPhysicalSecureHeapsResponse _response = {};
  SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsResponse(
      ::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetPhysicalSecureHeapsResponse::PrimarySize,
              GetPhysicalSecureHeapsResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::sysmem::PhysicalSecureHeaps heaps) {
  SecureMem_GetPhysicalSecureHeaps_Response response;
  response.heaps = std::move(heaps);

  Reply(std::move(_buffer), SecureMem_GetPhysicalSecureHeaps_Result::WithResponse(&response));
}

void SecureMem::Interface::GetPhysicalSecureHeapsCompleterBase::Reply(::fidl::DecodedMessage<GetPhysicalSecureHeapsResponse> params) {
  SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetPhysicalSecureHeapsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SetPhysicalSecureHeapsResponse _response = {};
  SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsResponse(
      ::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetPhysicalSecureHeapsResponse::PrimarySize,
              SetPhysicalSecureHeapsResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::ReplySuccess() {
  SecureMem_SetPhysicalSecureHeaps_Response response;

  Reply(SecureMem_SetPhysicalSecureHeaps_Result::WithResponse(&response));
}
void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::ReplyError(int32_t error) {
  Reply(SecureMem_SetPhysicalSecureHeaps_Result::WithErr(&error));
}

void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::sysmem::SecureMem_SetPhysicalSecureHeaps_Result result) {
  if (_buffer.capacity() < SetPhysicalSecureHeapsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SetPhysicalSecureHeapsResponse _response = {};
  SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsResponse(
      ::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetPhysicalSecureHeapsResponse::PrimarySize,
              SetPhysicalSecureHeapsResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  SecureMem_SetPhysicalSecureHeaps_Response response;

  Reply(std::move(_buffer), SecureMem_SetPhysicalSecureHeaps_Result::WithResponse(&response));
}

void SecureMem::Interface::SetPhysicalSecureHeapsCompleterBase::Reply(::fidl::DecodedMessage<SetPhysicalSecureHeapsResponse> params) {
  SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsRequest(const ::fidl::DecodedMessage<SecureMem::GetPhysicalSecureHeapsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSecureMem_GetPhysicalSecureHeaps_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void SecureMem::SetTransactionHeaderFor::GetPhysicalSecureHeapsResponse(const ::fidl::DecodedMessage<SecureMem::GetPhysicalSecureHeapsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSecureMem_GetPhysicalSecureHeaps_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsRequest(const ::fidl::DecodedMessage<SecureMem::SetPhysicalSecureHeapsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSecureMem_SetPhysicalSecureHeaps_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void SecureMem::SetTransactionHeaderFor::SetPhysicalSecureHeapsResponse(const ::fidl::DecodedMessage<SecureMem::SetPhysicalSecureHeapsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kSecureMem_SetPhysicalSecureHeaps_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal = 0x1f54cf3600000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_GenOrdinal = 0x676c26fb29b9556alu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnDuplicatedTokensKnownByServerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnDuplicatedTokensKnownByServerResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnBuffersAllocated_Ordinal = 0x6830ec5f00000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnBuffersAllocated_GenOrdinal = 0x4b74d7c0dc6d8903lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal = 0x6cb2333900000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollectionEvents_OnAllocateSingleBufferDone_GenOrdinal = 0x3acc52158e4ff771lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionEventsOnAllocateSingleBufferDoneResponseTable;

}  // namespace

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer_Impl::OnDuplicatedTokensKnownByServer_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnDuplicatedTokensKnownByServerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnDuplicatedTokensKnownByServerRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnDuplicatedTokensKnownByServerRequest));
  ::fidl::DecodedMessage<OnDuplicatedTokensKnownByServerRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnDuplicatedTokensKnownByServer(std::move(_client_end)));
}

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer BufferCollectionEvents::SyncClient::OnDuplicatedTokensKnownByServer() {
    return ResultOf::OnDuplicatedTokensKnownByServer(::zx::unowned_channel(this->channel_));
}

BufferCollectionEvents::ResultOf::OnDuplicatedTokensKnownByServer BufferCollectionEvents::Call::OnDuplicatedTokensKnownByServer(::zx::unowned_channel _client_end) {
  return ResultOf::OnDuplicatedTokensKnownByServer(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnDuplicatedTokensKnownByServer(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(OnDuplicatedTokensKnownByServerRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<OnDuplicatedTokensKnownByServerRequest> params(std::move(_request_buffer));
  BufferCollectionEvents::SetTransactionHeaderFor::OnDuplicatedTokensKnownByServerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollectionEvents::ResultOf::OnBuffersAllocated_Impl::OnBuffersAllocated_Impl(::zx::unowned_channel _client_end, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnBuffersAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_write_bytes);
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnBuffersAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::ResultOf::OnBuffersAllocated BufferCollectionEvents::SyncClient::OnBuffersAllocated(int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
    return ResultOf::OnBuffersAllocated(::zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_collection_info));
}

BufferCollectionEvents::ResultOf::OnBuffersAllocated BufferCollectionEvents::Call::OnBuffersAllocated(::zx::unowned_channel _client_end, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  return ResultOf::OnBuffersAllocated(std::move(_client_end), std::move(status), std::move(buffer_collection_info));
}


BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated_Impl::OnBuffersAllocated_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  if (_request_buffer.capacity() < OnBuffersAllocatedRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, OnBuffersAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnBuffersAllocatedRequest*>(_request_buffer.data());
  _request.status = std::move(status);
  _request.buffer_collection_info = std::move(buffer_collection_info);
  _request_buffer.set_actual(sizeof(OnBuffersAllocatedRequest));
  ::fidl::DecodedMessage<OnBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnBuffersAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated BufferCollectionEvents::SyncClient::OnBuffersAllocated(::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  return UnownedResultOf::OnBuffersAllocated(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_collection_info));
}

BufferCollectionEvents::UnownedResultOf::OnBuffersAllocated BufferCollectionEvents::Call::OnBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  return UnownedResultOf::OnBuffersAllocated(std::move(_client_end), std::move(_request_buffer), std::move(status), std::move(buffer_collection_info));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnBuffersAllocatedRequest> params) {
  BufferCollectionEvents::SetTransactionHeaderFor::OnBuffersAllocatedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone_Impl::OnAllocateSingleBufferDone_Impl(::zx::unowned_channel _client_end, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnAllocateSingleBufferDoneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OnAllocateSingleBufferDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_write_bytes);
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
    return ResultOf::OnAllocateSingleBufferDone(::zx::unowned_channel(this->channel_), std::move(status), std::move(buffer_info));
}

BufferCollectionEvents::ResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::Call::OnAllocateSingleBufferDone(::zx::unowned_channel _client_end, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  return ResultOf::OnAllocateSingleBufferDone(std::move(_client_end), std::move(status), std::move(buffer_info));
}


BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone_Impl::OnAllocateSingleBufferDone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  if (_request_buffer.capacity() < OnAllocateSingleBufferDoneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, OnAllocateSingleBufferDoneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OnAllocateSingleBufferDoneRequest*>(_request_buffer.data());
  _request.status = std::move(status);
  _request.buffer_info = std::move(buffer_info);
  _request_buffer.set_actual(sizeof(OnAllocateSingleBufferDoneRequest));
  ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::SyncClient::OnAllocateSingleBufferDone(::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  return UnownedResultOf::OnAllocateSingleBufferDone(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(status), std::move(buffer_info));
}

BufferCollectionEvents::UnownedResultOf::OnAllocateSingleBufferDone BufferCollectionEvents::Call::OnAllocateSingleBufferDone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  return UnownedResultOf::OnAllocateSingleBufferDone(std::move(_client_end), std::move(_request_buffer), std::move(status), std::move(buffer_info));
}

::fidl::internal::StatusAndError BufferCollectionEvents::InPlace::OnAllocateSingleBufferDone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnAllocateSingleBufferDoneRequest> params) {
  BufferCollectionEvents::SetTransactionHeaderFor::OnAllocateSingleBufferDoneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollectionEvents::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_Ordinal:
    case kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnDuplicatedTokensKnownByServerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->OnDuplicatedTokensKnownByServer(
          Interface::OnDuplicatedTokensKnownByServerCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnBuffersAllocated_Ordinal:
    case kBufferCollectionEvents_OnBuffersAllocated_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnBuffersAllocated(std::move(message->status), std::move(message->buffer_collection_info),
          Interface::OnBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollectionEvents_OnAllocateSingleBufferDone_Ordinal:
    case kBufferCollectionEvents_OnAllocateSingleBufferDone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnAllocateSingleBufferDoneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OnAllocateSingleBufferDone(std::move(message->status), std::move(message->buffer_info),
          Interface::OnAllocateSingleBufferDoneCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollectionEvents::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}



void BufferCollectionEvents::SetTransactionHeaderFor::OnDuplicatedTokensKnownByServerRequest(const ::fidl::DecodedMessage<BufferCollectionEvents::OnDuplicatedTokensKnownByServerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionEvents_OnDuplicatedTokensKnownByServer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollectionEvents::SetTransactionHeaderFor::OnBuffersAllocatedRequest(const ::fidl::DecodedMessage<BufferCollectionEvents::OnBuffersAllocatedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionEvents_OnBuffersAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollectionEvents::SetTransactionHeaderFor::OnAllocateSingleBufferDoneRequest(const ::fidl::DecodedMessage<BufferCollectionEvents::OnAllocateSingleBufferDoneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollectionEvents_OnAllocateSingleBufferDone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetEventSink_Ordinal = 0x154ba43000000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetEventSink_GenOrdinal = 0x7e48a6aac582e3c6lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSetEventSinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSetEventSinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Sync_Ordinal = 0x15ba322100000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Sync_GenOrdinal = 0x941fdbb6ec7f85elu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetConstraints_Ordinal = 0x541b637e00000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_SetConstraints_GenOrdinal = 0x4d9c3406c213227blu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSetConstraintsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionSetConstraintsResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForBuffersAllocated_Ordinal = 0x1b36cfa800000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForBuffersAllocated_GenOrdinal = 0x714667ea2a29a3a2lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionWaitForBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckBuffersAllocated_Ordinal = 0x95520ce00000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckBuffersAllocated_GenOrdinal = 0x245bb81f79189e9lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCheckBuffersAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CloseSingleBuffer_Ordinal = 0x1802fa4800000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CloseSingleBuffer_GenOrdinal = 0x3becedeb5959121alu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCloseSingleBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCloseSingleBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_AllocateSingleBuffer_Ordinal = 0x1ba0786400000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_AllocateSingleBuffer_GenOrdinal = 0x19cca74dfad8f2bflu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionAllocateSingleBufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionAllocateSingleBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForSingleBufferAllocated_Ordinal = 0x36e6672300000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_WaitForSingleBufferAllocated_GenOrdinal = 0x25ee1433c5fd1dclu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionWaitForSingleBufferAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckSingleBufferAllocated_Ordinal = 0x1301391c00000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_CheckSingleBufferAllocated_GenOrdinal = 0x5905702f25c60301lu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCheckSingleBufferAllocatedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCheckSingleBufferAllocatedResponseTable;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Close_Ordinal = 0x607c571800000000lu;
[[maybe_unused]]
constexpr uint64_t kBufferCollection_Close_GenOrdinal = 0x48ac4179438f99felu;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_sysmem_BufferCollectionCloseResponseTable;

}  // namespace

BufferCollection::ResultOf::SetEventSink_Impl::SetEventSink_Impl(::zx::unowned_channel _client_end, ::zx::channel events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetEventSinkRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetEventSinkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_write_bytes);
  _request.events = std::move(events);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::SetEventSink(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::SetEventSink BufferCollection::SyncClient::SetEventSink(::zx::channel events) {
    return ResultOf::SetEventSink(::zx::unowned_channel(this->channel_), std::move(events));
}

BufferCollection::ResultOf::SetEventSink BufferCollection::Call::SetEventSink(::zx::unowned_channel _client_end, ::zx::channel events) {
  return ResultOf::SetEventSink(std::move(_client_end), std::move(events));
}


BufferCollection::UnownedResultOf::SetEventSink_Impl::SetEventSink_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events) {
  if (_request_buffer.capacity() < SetEventSinkRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetEventSinkRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetEventSinkRequest*>(_request_buffer.data());
  _request.events = std::move(events);
  _request_buffer.set_actual(sizeof(SetEventSinkRequest));
  ::fidl::DecodedMessage<SetEventSinkRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::SetEventSink(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::SetEventSink BufferCollection::SyncClient::SetEventSink(::fidl::BytePart _request_buffer, ::zx::channel events) {
  return UnownedResultOf::SetEventSink(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(events));
}

BufferCollection::UnownedResultOf::SetEventSink BufferCollection::Call::SetEventSink(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel events) {
  return UnownedResultOf::SetEventSink(std::move(_client_end), std::move(_request_buffer), std::move(events));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::SetEventSink(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetEventSinkRequest> params) {
  BufferCollection::SetTransactionHeaderFor::SetEventSinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::Sync_Impl<BufferCollection::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::Sync BufferCollection::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::Sync BufferCollection::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

::fidl::DecodeResult<BufferCollection::SyncResponse> BufferCollection::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  BufferCollection::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::SetConstraints_Impl::SetConstraints_Impl(::zx::unowned_channel _client_end, bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetConstraintsRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_write_bytes);
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::SetConstraints(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::SetConstraints BufferCollection::SyncClient::SetConstraints(bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
    return ResultOf::SetConstraints(::zx::unowned_channel(this->channel_), std::move(has_constraints), std::move(constraints));
}

BufferCollection::ResultOf::SetConstraints BufferCollection::Call::SetConstraints(::zx::unowned_channel _client_end, bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
  return ResultOf::SetConstraints(std::move(_client_end), std::move(has_constraints), std::move(constraints));
}


BufferCollection::UnownedResultOf::SetConstraints_Impl::SetConstraints_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
  if (_request_buffer.capacity() < SetConstraintsRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetConstraintsRequest*>(_request_buffer.data());
  _request.has_constraints = std::move(has_constraints);
  _request.constraints = std::move(constraints);
  _request_buffer.set_actual(sizeof(SetConstraintsRequest));
  ::fidl::DecodedMessage<SetConstraintsRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::SetConstraints(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::SetConstraints BufferCollection::SyncClient::SetConstraints(::fidl::BytePart _request_buffer, bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
  return UnownedResultOf::SetConstraints(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(has_constraints), std::move(constraints));
}

BufferCollection::UnownedResultOf::SetConstraints BufferCollection::Call::SetConstraints(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool has_constraints, ::llcpp::fuchsia::sysmem::BufferCollectionConstraints constraints) {
  return UnownedResultOf::SetConstraints(std::move(_client_end), std::move(_request_buffer), std::move(has_constraints), std::move(constraints));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::SetConstraints(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConstraintsRequest> params) {
  BufferCollection::SetTransactionHeaderFor::SetConstraintsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::WaitForBuffersAllocated_Impl<BufferCollection::WaitForBuffersAllocatedResponse>::WaitForBuffersAllocated_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WaitForBuffersAllocatedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::WaitForBuffersAllocated(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::WaitForBuffersAllocated BufferCollection::SyncClient::WaitForBuffersAllocated() {
    return ResultOf::WaitForBuffersAllocated(::zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::WaitForBuffersAllocated BufferCollection::Call::WaitForBuffersAllocated(::zx::unowned_channel _client_end) {
  return ResultOf::WaitForBuffersAllocated(std::move(_client_end));
}

template <>
BufferCollection::UnownedResultOf::WaitForBuffersAllocated_Impl<BufferCollection::WaitForBuffersAllocatedResponse>::WaitForBuffersAllocated_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(WaitForBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, WaitForBuffersAllocatedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(WaitForBuffersAllocatedRequest));
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::WaitForBuffersAllocated(std::move(_client_end), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::WaitForBuffersAllocated BufferCollection::SyncClient::WaitForBuffersAllocated(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForBuffersAllocated(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::WaitForBuffersAllocated BufferCollection::Call::WaitForBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForBuffersAllocated(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse> BufferCollection::InPlace::WaitForBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(WaitForBuffersAllocatedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<WaitForBuffersAllocatedRequest> params(std::move(_request_buffer));
  BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WaitForBuffersAllocatedRequest, WaitForBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForBuffersAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
BufferCollection::ResultOf::CheckBuffersAllocated_Impl<BufferCollection::CheckBuffersAllocatedResponse>::CheckBuffersAllocated_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckBuffersAllocatedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::CheckBuffersAllocated(std::move(_client_end), Super::response_buffer()));
}

BufferCollection::ResultOf::CheckBuffersAllocated BufferCollection::SyncClient::CheckBuffersAllocated() {
    return ResultOf::CheckBuffersAllocated(::zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::CheckBuffersAllocated BufferCollection::Call::CheckBuffersAllocated(::zx::unowned_channel _client_end) {
  return ResultOf::CheckBuffersAllocated(std::move(_client_end));
}

template <>
BufferCollection::UnownedResultOf::CheckBuffersAllocated_Impl<BufferCollection::CheckBuffersAllocatedResponse>::CheckBuffersAllocated_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CheckBuffersAllocatedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CheckBuffersAllocatedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CheckBuffersAllocatedRequest));
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::CheckBuffersAllocated(std::move(_client_end), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::CheckBuffersAllocated BufferCollection::SyncClient::CheckBuffersAllocated(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckBuffersAllocated(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::CheckBuffersAllocated BufferCollection::Call::CheckBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckBuffersAllocated(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse> BufferCollection::InPlace::CheckBuffersAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CheckBuffersAllocatedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CheckBuffersAllocatedRequest> params(std::move(_request_buffer));
  BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CheckBuffersAllocatedRequest, CheckBuffersAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::CheckBuffersAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::CloseSingleBuffer_Impl::CloseSingleBuffer_Impl(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSingleBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::CloseSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::CloseSingleBuffer BufferCollection::SyncClient::CloseSingleBuffer(uint64_t buffer_index) {
    return ResultOf::CloseSingleBuffer(::zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::CloseSingleBuffer BufferCollection::Call::CloseSingleBuffer(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::CloseSingleBuffer(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::CloseSingleBuffer_Impl::CloseSingleBuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CloseSingleBufferRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloseSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSingleBufferRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CloseSingleBufferRequest));
  ::fidl::DecodedMessage<CloseSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::CloseSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::CloseSingleBuffer BufferCollection::SyncClient::CloseSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CloseSingleBuffer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::CloseSingleBuffer BufferCollection::Call::CloseSingleBuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CloseSingleBuffer(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::CloseSingleBuffer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSingleBufferRequest> params) {
  BufferCollection::SetTransactionHeaderFor::CloseSingleBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollection::ResultOf::AllocateSingleBuffer_Impl::AllocateSingleBuffer_Impl(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateSingleBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::AllocateSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::AllocateSingleBuffer BufferCollection::SyncClient::AllocateSingleBuffer(uint64_t buffer_index) {
    return ResultOf::AllocateSingleBuffer(::zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::AllocateSingleBuffer BufferCollection::Call::AllocateSingleBuffer(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::AllocateSingleBuffer(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::AllocateSingleBuffer_Impl::AllocateSingleBuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < AllocateSingleBufferRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, AllocateSingleBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateSingleBufferRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(AllocateSingleBufferRequest));
  ::fidl::DecodedMessage<AllocateSingleBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::AllocateSingleBuffer(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::AllocateSingleBuffer BufferCollection::SyncClient::AllocateSingleBuffer(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::AllocateSingleBuffer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::AllocateSingleBuffer BufferCollection::Call::AllocateSingleBuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::AllocateSingleBuffer(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::AllocateSingleBuffer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateSingleBufferRequest> params) {
  BufferCollection::SetTransactionHeaderFor::AllocateSingleBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
BufferCollection::ResultOf::WaitForSingleBufferAllocated_Impl<BufferCollection::WaitForSingleBufferAllocatedResponse>::WaitForSingleBufferAllocated_Impl(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WaitForSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      BufferCollection::InPlace::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

BufferCollection::ResultOf::WaitForSingleBufferAllocated BufferCollection::SyncClient::WaitForSingleBufferAllocated(uint64_t buffer_index) {
    return ResultOf::WaitForSingleBufferAllocated(::zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::WaitForSingleBufferAllocated BufferCollection::Call::WaitForSingleBufferAllocated(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::WaitForSingleBufferAllocated(std::move(_client_end), std::move(buffer_index));
}

template <>
BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated_Impl<BufferCollection::WaitForSingleBufferAllocatedResponse>::WaitForSingleBufferAllocated_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WaitForSingleBufferAllocatedRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WaitForSingleBufferAllocatedResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WaitForSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WaitForSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(WaitForSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      BufferCollection::InPlace::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated BufferCollection::SyncClient::WaitForSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForSingleBufferAllocated(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index), std::move(_response_buffer));
}

BufferCollection::UnownedResultOf::WaitForSingleBufferAllocated BufferCollection::Call::WaitForSingleBufferAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WaitForSingleBufferAllocated(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index), std::move(_response_buffer));
}

::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse> BufferCollection::InPlace::WaitForSingleBufferAllocated(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WaitForSingleBufferAllocatedRequest> params, ::fidl::BytePart response_buffer) {
  BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WaitForSingleBufferAllocatedRequest, WaitForSingleBufferAllocatedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<BufferCollection::WaitForSingleBufferAllocatedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


BufferCollection::ResultOf::CheckSingleBufferAllocated_Impl::CheckSingleBufferAllocated_Impl(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckSingleBufferAllocatedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_write_bytes);
  _request.buffer_index = std::move(buffer_index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::CheckSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::ResultOf::CheckSingleBufferAllocated BufferCollection::SyncClient::CheckSingleBufferAllocated(uint64_t buffer_index) {
    return ResultOf::CheckSingleBufferAllocated(::zx::unowned_channel(this->channel_), std::move(buffer_index));
}

BufferCollection::ResultOf::CheckSingleBufferAllocated BufferCollection::Call::CheckSingleBufferAllocated(::zx::unowned_channel _client_end, uint64_t buffer_index) {
  return ResultOf::CheckSingleBufferAllocated(std::move(_client_end), std::move(buffer_index));
}


BufferCollection::UnownedResultOf::CheckSingleBufferAllocated_Impl::CheckSingleBufferAllocated_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  if (_request_buffer.capacity() < CheckSingleBufferAllocatedRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CheckSingleBufferAllocatedRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckSingleBufferAllocatedRequest*>(_request_buffer.data());
  _request.buffer_index = std::move(buffer_index);
  _request_buffer.set_actual(sizeof(CheckSingleBufferAllocatedRequest));
  ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      BufferCollection::InPlace::CheckSingleBufferAllocated(std::move(_client_end), std::move(_decoded_request)));
}

BufferCollection::UnownedResultOf::CheckSingleBufferAllocated BufferCollection::SyncClient::CheckSingleBufferAllocated(::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CheckSingleBufferAllocated(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(buffer_index));
}

BufferCollection::UnownedResultOf::CheckSingleBufferAllocated BufferCollection::Call::CheckSingleBufferAllocated(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t buffer_index) {
  return UnownedResultOf::CheckSingleBufferAllocated(std::move(_client_end), std::move(_request_buffer), std::move(buffer_index));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::CheckSingleBufferAllocated(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckSingleBufferAllocatedRequest> params) {
  BufferCollection::SetTransactionHeaderFor::CheckSingleBufferAllocatedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


BufferCollection::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      BufferCollection::InPlace::Close(std::move(_client_end)));
}

BufferCollection::ResultOf::Close BufferCollection::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

BufferCollection::ResultOf::Close BufferCollection::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError BufferCollection::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  BufferCollection::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


bool BufferCollection::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kBufferCollection_SetEventSink_Ordinal:
    case kBufferCollection_SetEventSink_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetEventSinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetEventSink(std::move(message->events),
          Interface::SetEventSinkCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Sync_Ordinal:
    case kBufferCollection_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_SetConstraints_Ordinal:
    case kBufferCollection_SetConstraints_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetConstraintsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetConstraints(std::move(message->has_constraints), std::move(message->constraints),
          Interface::SetConstraintsCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForBuffersAllocated_Ordinal:
    case kBufferCollection_WaitForBuffersAllocated_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WaitForBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->WaitForBuffersAllocated(
          Interface::WaitForBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckBuffersAllocated_Ordinal:
    case kBufferCollection_CheckBuffersAllocated_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CheckBuffersAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->CheckBuffersAllocated(
          Interface::CheckBuffersAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CloseSingleBuffer_Ordinal:
    case kBufferCollection_CloseSingleBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CloseSingleBuffer(std::move(message->buffer_index),
          Interface::CloseSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_AllocateSingleBuffer_Ordinal:
    case kBufferCollection_AllocateSingleBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateSingleBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateSingleBuffer(std::move(message->buffer_index),
          Interface::AllocateSingleBufferCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_WaitForSingleBufferAllocated_Ordinal:
    case kBufferCollection_WaitForSingleBufferAllocated_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WaitForSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WaitForSingleBufferAllocated(std::move(message->buffer_index),
          Interface::WaitForSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_CheckSingleBufferAllocated_Ordinal:
    case kBufferCollection_CheckSingleBufferAllocated_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CheckSingleBufferAllocatedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CheckSingleBufferAllocated(std::move(message->buffer_index),
          Interface::CheckSingleBufferAllocatedCompleter::Sync(txn));
      return true;
    }
    case kBufferCollection_Close_Ordinal:
    case kBufferCollection_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool BufferCollection::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void BufferCollection::Interface::SyncCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  BufferCollection::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}


void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForBuffersAllocatedResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_write_bytes);
  BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedResponse(
      ::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WaitForBuffersAllocatedResponse::PrimarySize,
              WaitForBuffersAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::sysmem::BufferCollectionInfo_2 buffer_collection_info) {
  if (_buffer.capacity() < WaitForBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForBuffersAllocatedResponse*>(_buffer.data());
  BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedResponse(
      ::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WaitForBuffersAllocatedResponse::PrimarySize,
              WaitForBuffersAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.buffer_collection_info = std::move(buffer_collection_info);
  _buffer.set_actual(sizeof(WaitForBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForBuffersAllocatedResponse> params) {
  BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckBuffersAllocatedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_write_bytes);
  BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedResponse(
      ::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CheckBuffersAllocatedResponse::PrimarySize,
              CheckBuffersAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < CheckBuffersAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CheckBuffersAllocatedResponse*>(_buffer.data());
  BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedResponse(
      ::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CheckBuffersAllocatedResponse::PrimarySize,
              CheckBuffersAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(CheckBuffersAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::CheckBuffersAllocatedCompleterBase::Reply(::fidl::DecodedMessage<CheckBuffersAllocatedResponse> params) {
  BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WaitForSingleBufferAllocatedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_write_bytes);
  BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedResponse(
      ::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WaitForSingleBufferAllocatedResponse::PrimarySize,
              WaitForSingleBufferAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_response_bytes)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::sysmem::SingleBufferInfo buffer_info) {
  if (_buffer.capacity() < WaitForSingleBufferAllocatedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WaitForSingleBufferAllocatedResponse*>(_buffer.data());
  BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedResponse(
      ::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WaitForSingleBufferAllocatedResponse::PrimarySize,
              WaitForSingleBufferAllocatedResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.buffer_info = std::move(buffer_info);
  _buffer.set_actual(sizeof(WaitForSingleBufferAllocatedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse>(std::move(_buffer)));
}

void BufferCollection::Interface::WaitForSingleBufferAllocatedCompleterBase::Reply(::fidl::DecodedMessage<WaitForSingleBufferAllocatedResponse> params) {
  BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void BufferCollection::SetTransactionHeaderFor::SetEventSinkRequest(const ::fidl::DecodedMessage<BufferCollection::SetEventSinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_SetEventSink_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<BufferCollection::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void BufferCollection::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<BufferCollection::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::SetConstraintsRequest(const ::fidl::DecodedMessage<BufferCollection::SetConstraintsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_SetConstraints_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedRequest(const ::fidl::DecodedMessage<BufferCollection::WaitForBuffersAllocatedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_WaitForBuffersAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void BufferCollection::SetTransactionHeaderFor::WaitForBuffersAllocatedResponse(const ::fidl::DecodedMessage<BufferCollection::WaitForBuffersAllocatedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_WaitForBuffersAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedRequest(const ::fidl::DecodedMessage<BufferCollection::CheckBuffersAllocatedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_CheckBuffersAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void BufferCollection::SetTransactionHeaderFor::CheckBuffersAllocatedResponse(const ::fidl::DecodedMessage<BufferCollection::CheckBuffersAllocatedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_CheckBuffersAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::CloseSingleBufferRequest(const ::fidl::DecodedMessage<BufferCollection::CloseSingleBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_CloseSingleBuffer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::AllocateSingleBufferRequest(const ::fidl::DecodedMessage<BufferCollection::AllocateSingleBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_AllocateSingleBuffer_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedRequest(const ::fidl::DecodedMessage<BufferCollection::WaitForSingleBufferAllocatedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_WaitForSingleBufferAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void BufferCollection::SetTransactionHeaderFor::WaitForSingleBufferAllocatedResponse(const ::fidl::DecodedMessage<BufferCollection::WaitForSingleBufferAllocatedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_WaitForSingleBufferAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::CheckSingleBufferAllocatedRequest(const ::fidl::DecodedMessage<BufferCollection::CheckSingleBufferAllocatedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_CheckSingleBufferAllocated_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void BufferCollection::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<BufferCollection::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kBufferCollection_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace sysmem
}  // namespace fuchsia
}  // namespace llcpp

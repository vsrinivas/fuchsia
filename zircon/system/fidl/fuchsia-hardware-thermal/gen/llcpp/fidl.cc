// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/thermal/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace thermal {

namespace {

[[maybe_unused]]
constexpr uint64_t kDevice_GetInfo_Ordinal = 0x337747c500000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetDeviceInfo_Ordinal = 0x80abe5f00000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetDeviceInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetDvfsInfo_Ordinal = 0x6b72261200000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetDvfsInfoRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetDvfsInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetTemperatureCelsius_Ordinal = 0x1c4ce3b00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStateChangeEvent_Ordinal = 0x981447d00000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetStateChangeEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetStateChangePort_Ordinal = 0x626a7a1100000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetStateChangePortResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_SetTripCelsius_Ordinal = 0x1a338bd400000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceSetTripCelsiusResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetDvfsOperatingPoint_Ordinal = 0x2725cb4400000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_SetDvfsOperatingPoint_Ordinal = 0x553fac4700000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_GetFanLevel_Ordinal = 0xa3623b300000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_SetFanLevel_Ordinal = 0x344c3d2700000000lu;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceSetFanLevelRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_thermal_DeviceSetFanLevelResponseTable;

}  // namespace
template <>
Device::ResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetInfo Device::SyncClient::GetInfo() {
  return ResultOf::GetInfo(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetInfo Device::Call::GetInfo(zx::unowned_channel _client_end) {
  return ResultOf::GetInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetInfo_Impl<Device::GetInfoResponse>::GetInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetInfoRequest));
  ::fidl::DecodedMessage<GetInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetInfo Device::SyncClient::GetInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetInfo Device::Call::GetInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetInfoResponse> Device::InPlace::GetInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetInfoRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetInfoRequest, GetInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetDeviceInfo_Impl<Device::GetDeviceInfoResponse>::GetDeviceInfo_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDeviceInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDeviceInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDeviceInfoRequest));
  ::fidl::DecodedMessage<GetDeviceInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetDeviceInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetDeviceInfo Device::SyncClient::GetDeviceInfo() {
  return ResultOf::GetDeviceInfo(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetDeviceInfo Device::Call::GetDeviceInfo(zx::unowned_channel _client_end) {
  return ResultOf::GetDeviceInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetDeviceInfo_Impl<Device::GetDeviceInfoResponse>::GetDeviceInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetDeviceInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetDeviceInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetDeviceInfoRequest));
  ::fidl::DecodedMessage<GetDeviceInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetDeviceInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetDeviceInfo Device::SyncClient::GetDeviceInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDeviceInfo(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetDeviceInfo Device::Call::GetDeviceInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDeviceInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetDeviceInfoResponse> Device::InPlace::GetDeviceInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetDeviceInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetDeviceInfoRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDeviceInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDeviceInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetDeviceInfoRequest, GetDeviceInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDeviceInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetDvfsInfo_Impl<Device::GetDvfsInfoResponse>::GetDvfsInfo_Impl(zx::unowned_channel _client_end, PowerDomain power_domain) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDvfsInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDvfsInfoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDvfsInfoRequest*>(_write_bytes);
  _request.power_domain = std::move(power_domain);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDvfsInfoRequest));
  ::fidl::DecodedMessage<GetDvfsInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetDvfsInfo(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::GetDvfsInfo Device::SyncClient::GetDvfsInfo(PowerDomain power_domain) {
  return ResultOf::GetDvfsInfo(zx::unowned_channel(this->channel_), std::move(power_domain));
}

Device::ResultOf::GetDvfsInfo Device::Call::GetDvfsInfo(zx::unowned_channel _client_end, PowerDomain power_domain) {
  return ResultOf::GetDvfsInfo(std::move(_client_end), std::move(power_domain));
}

template <>
Device::UnownedResultOf::GetDvfsInfo_Impl<Device::GetDvfsInfoResponse>::GetDvfsInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetDvfsInfoRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetDvfsInfoResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetDvfsInfoRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDvfsInfoRequest*>(_request_buffer.data());
  _request.power_domain = std::move(power_domain);
  _request_buffer.set_actual(sizeof(GetDvfsInfoRequest));
  ::fidl::DecodedMessage<GetDvfsInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetDvfsInfo(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetDvfsInfo Device::SyncClient::GetDvfsInfo(::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDvfsInfo(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(power_domain), std::move(_response_buffer));
}

Device::UnownedResultOf::GetDvfsInfo Device::Call::GetDvfsInfo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDvfsInfo(std::move(_client_end), std::move(_request_buffer), std::move(power_domain), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetDvfsInfoResponse> Device::InPlace::GetDvfsInfo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDvfsInfoRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDvfsInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDvfsInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetDvfsInfoRequest, GetDvfsInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDvfsInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetTemperatureCelsius_Impl<Device::GetTemperatureCelsiusResponse>::GetTemperatureCelsius_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTemperatureCelsiusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTemperatureCelsiusRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTemperatureCelsiusRequest));
  ::fidl::DecodedMessage<GetTemperatureCelsiusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetTemperatureCelsius(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetTemperatureCelsius Device::SyncClient::GetTemperatureCelsius() {
  return ResultOf::GetTemperatureCelsius(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetTemperatureCelsius Device::Call::GetTemperatureCelsius(zx::unowned_channel _client_end) {
  return ResultOf::GetTemperatureCelsius(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetTemperatureCelsius_Impl<Device::GetTemperatureCelsiusResponse>::GetTemperatureCelsius_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTemperatureCelsiusRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTemperatureCelsiusRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTemperatureCelsiusRequest));
  ::fidl::DecodedMessage<GetTemperatureCelsiusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetTemperatureCelsius(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetTemperatureCelsius Device::SyncClient::GetTemperatureCelsius(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetTemperatureCelsius(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetTemperatureCelsius Device::Call::GetTemperatureCelsius(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetTemperatureCelsius(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetTemperatureCelsiusResponse> Device::InPlace::GetTemperatureCelsius(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTemperatureCelsiusRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTemperatureCelsiusRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetTemperatureCelsius_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetTemperatureCelsiusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTemperatureCelsiusRequest, GetTemperatureCelsiusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetTemperatureCelsiusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetStateChangeEvent_Impl<Device::GetStateChangeEventResponse>::GetStateChangeEvent_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStateChangeEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetStateChangeEventRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStateChangeEventRequest));
  ::fidl::DecodedMessage<GetStateChangeEventRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetStateChangeEvent(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetStateChangeEvent Device::SyncClient::GetStateChangeEvent() {
  return ResultOf::GetStateChangeEvent(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetStateChangeEvent Device::Call::GetStateChangeEvent(zx::unowned_channel _client_end) {
  return ResultOf::GetStateChangeEvent(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetStateChangeEvent_Impl<Device::GetStateChangeEventResponse>::GetStateChangeEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetStateChangeEventRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetStateChangeEventRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetStateChangeEventRequest));
  ::fidl::DecodedMessage<GetStateChangeEventRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetStateChangeEvent(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetStateChangeEvent Device::SyncClient::GetStateChangeEvent(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStateChangeEvent(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetStateChangeEvent Device::Call::GetStateChangeEvent(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStateChangeEvent(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetStateChangeEventResponse> Device::InPlace::GetStateChangeEvent(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetStateChangeEventRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetStateChangeEventRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetStateChangeEvent_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStateChangeEventResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetStateChangeEventRequest, GetStateChangeEventResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStateChangeEventResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetStateChangePort_Impl<Device::GetStateChangePortResponse>::GetStateChangePort_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStateChangePortRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetStateChangePortRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStateChangePortRequest));
  ::fidl::DecodedMessage<GetStateChangePortRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetStateChangePort(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetStateChangePort Device::SyncClient::GetStateChangePort() {
  return ResultOf::GetStateChangePort(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetStateChangePort Device::Call::GetStateChangePort(zx::unowned_channel _client_end) {
  return ResultOf::GetStateChangePort(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetStateChangePort_Impl<Device::GetStateChangePortResponse>::GetStateChangePort_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetStateChangePortRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetStateChangePortRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetStateChangePortRequest));
  ::fidl::DecodedMessage<GetStateChangePortRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetStateChangePort(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetStateChangePort Device::SyncClient::GetStateChangePort(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStateChangePort(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetStateChangePort Device::Call::GetStateChangePort(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetStateChangePort(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetStateChangePortResponse> Device::InPlace::GetStateChangePort(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetStateChangePortRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetStateChangePortRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetStateChangePort_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStateChangePortResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetStateChangePortRequest, GetStateChangePortResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetStateChangePortResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetTripCelsius_Impl<Device::SetTripCelsiusResponse>::SetTripCelsius_Impl(zx::unowned_channel _client_end, uint32_t id, float temp) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetTripCelsiusRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetTripCelsiusRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetTripCelsiusRequest*>(_write_bytes);
  _request.id = std::move(id);
  _request.temp = std::move(temp);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetTripCelsiusRequest));
  ::fidl::DecodedMessage<SetTripCelsiusRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::SetTripCelsius(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetTripCelsius Device::SyncClient::SetTripCelsius(uint32_t id, float temp) {
  return ResultOf::SetTripCelsius(zx::unowned_channel(this->channel_), std::move(id), std::move(temp));
}

Device::ResultOf::SetTripCelsius Device::Call::SetTripCelsius(zx::unowned_channel _client_end, uint32_t id, float temp) {
  return ResultOf::SetTripCelsius(std::move(_client_end), std::move(id), std::move(temp));
}

template <>
Device::UnownedResultOf::SetTripCelsius_Impl<Device::SetTripCelsiusResponse>::SetTripCelsius_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetTripCelsiusRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetTripCelsiusResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetTripCelsiusRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetTripCelsiusRequest*>(_request_buffer.data());
  _request.id = std::move(id);
  _request.temp = std::move(temp);
  _request_buffer.set_actual(sizeof(SetTripCelsiusRequest));
  ::fidl::DecodedMessage<SetTripCelsiusRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::SetTripCelsius(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetTripCelsius Device::SyncClient::SetTripCelsius(::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetTripCelsius(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id), std::move(temp), std::move(_response_buffer));
}

Device::UnownedResultOf::SetTripCelsius Device::Call::SetTripCelsius(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetTripCelsius(std::move(_client_end), std::move(_request_buffer), std::move(id), std::move(temp), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetTripCelsiusResponse> Device::InPlace::SetTripCelsius(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetTripCelsiusRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetTripCelsius_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetTripCelsiusResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetTripCelsiusRequest, SetTripCelsiusResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetTripCelsiusResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetDvfsOperatingPoint_Impl<Device::GetDvfsOperatingPointResponse>::GetDvfsOperatingPoint_Impl(zx::unowned_channel _client_end, PowerDomain power_domain) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDvfsOperatingPointRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetDvfsOperatingPointRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDvfsOperatingPointRequest*>(_write_bytes);
  _request.power_domain = std::move(power_domain);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDvfsOperatingPointRequest));
  ::fidl::DecodedMessage<GetDvfsOperatingPointRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetDvfsOperatingPoint(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::GetDvfsOperatingPoint Device::SyncClient::GetDvfsOperatingPoint(PowerDomain power_domain) {
  return ResultOf::GetDvfsOperatingPoint(zx::unowned_channel(this->channel_), std::move(power_domain));
}

Device::ResultOf::GetDvfsOperatingPoint Device::Call::GetDvfsOperatingPoint(zx::unowned_channel _client_end, PowerDomain power_domain) {
  return ResultOf::GetDvfsOperatingPoint(std::move(_client_end), std::move(power_domain));
}

template <>
Device::UnownedResultOf::GetDvfsOperatingPoint_Impl<Device::GetDvfsOperatingPointResponse>::GetDvfsOperatingPoint_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetDvfsOperatingPointRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetDvfsOperatingPointResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetDvfsOperatingPointRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetDvfsOperatingPointRequest*>(_request_buffer.data());
  _request.power_domain = std::move(power_domain);
  _request_buffer.set_actual(sizeof(GetDvfsOperatingPointRequest));
  ::fidl::DecodedMessage<GetDvfsOperatingPointRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetDvfsOperatingPoint(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetDvfsOperatingPoint Device::SyncClient::GetDvfsOperatingPoint(::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDvfsOperatingPoint(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(power_domain), std::move(_response_buffer));
}

Device::UnownedResultOf::GetDvfsOperatingPoint Device::Call::GetDvfsOperatingPoint(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetDvfsOperatingPoint(std::move(_client_end), std::move(_request_buffer), std::move(power_domain), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetDvfsOperatingPointResponse> Device::InPlace::GetDvfsOperatingPoint(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDvfsOperatingPointRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDvfsOperatingPoint_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDvfsOperatingPointResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetDvfsOperatingPointRequest, GetDvfsOperatingPointResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetDvfsOperatingPointResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetDvfsOperatingPoint_Impl<Device::SetDvfsOperatingPointResponse>::SetDvfsOperatingPoint_Impl(zx::unowned_channel _client_end, uint16_t op_idx, PowerDomain power_domain) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDvfsOperatingPointRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetDvfsOperatingPointRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDvfsOperatingPointRequest*>(_write_bytes);
  _request.op_idx = std::move(op_idx);
  _request.power_domain = std::move(power_domain);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDvfsOperatingPointRequest));
  ::fidl::DecodedMessage<SetDvfsOperatingPointRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::SetDvfsOperatingPoint(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetDvfsOperatingPoint Device::SyncClient::SetDvfsOperatingPoint(uint16_t op_idx, PowerDomain power_domain) {
  return ResultOf::SetDvfsOperatingPoint(zx::unowned_channel(this->channel_), std::move(op_idx), std::move(power_domain));
}

Device::ResultOf::SetDvfsOperatingPoint Device::Call::SetDvfsOperatingPoint(zx::unowned_channel _client_end, uint16_t op_idx, PowerDomain power_domain) {
  return ResultOf::SetDvfsOperatingPoint(std::move(_client_end), std::move(op_idx), std::move(power_domain));
}

template <>
Device::UnownedResultOf::SetDvfsOperatingPoint_Impl<Device::SetDvfsOperatingPointResponse>::SetDvfsOperatingPoint_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint16_t op_idx, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetDvfsOperatingPointRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetDvfsOperatingPointResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetDvfsOperatingPointRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDvfsOperatingPointRequest*>(_request_buffer.data());
  _request.op_idx = std::move(op_idx);
  _request.power_domain = std::move(power_domain);
  _request_buffer.set_actual(sizeof(SetDvfsOperatingPointRequest));
  ::fidl::DecodedMessage<SetDvfsOperatingPointRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::SetDvfsOperatingPoint(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetDvfsOperatingPoint Device::SyncClient::SetDvfsOperatingPoint(::fidl::BytePart _request_buffer, uint16_t op_idx, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetDvfsOperatingPoint(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(op_idx), std::move(power_domain), std::move(_response_buffer));
}

Device::UnownedResultOf::SetDvfsOperatingPoint Device::Call::SetDvfsOperatingPoint(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint16_t op_idx, PowerDomain power_domain, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetDvfsOperatingPoint(std::move(_client_end), std::move(_request_buffer), std::move(op_idx), std::move(power_domain), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetDvfsOperatingPointResponse> Device::InPlace::SetDvfsOperatingPoint(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDvfsOperatingPointRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetDvfsOperatingPoint_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetDvfsOperatingPointResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetDvfsOperatingPointRequest, SetDvfsOperatingPointResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetDvfsOperatingPointResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::GetFanLevel_Impl<Device::GetFanLevelResponse>::GetFanLevel_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFanLevelRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetFanLevelRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFanLevelRequest));
  ::fidl::DecodedMessage<GetFanLevelRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetFanLevel(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetFanLevel Device::SyncClient::GetFanLevel() {
  return ResultOf::GetFanLevel(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetFanLevel Device::Call::GetFanLevel(zx::unowned_channel _client_end) {
  return ResultOf::GetFanLevel(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetFanLevel_Impl<Device::GetFanLevelResponse>::GetFanLevel_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetFanLevelRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetFanLevelRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetFanLevelRequest));
  ::fidl::DecodedMessage<GetFanLevelRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetFanLevel(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetFanLevel Device::SyncClient::GetFanLevel(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFanLevel(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetFanLevel Device::Call::GetFanLevel(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetFanLevel(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetFanLevelResponse> Device::InPlace::GetFanLevel(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetFanLevelRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetFanLevelRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetFanLevel_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetFanLevelResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetFanLevelRequest, GetFanLevelResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetFanLevelResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::SetFanLevel_Impl<Device::SetFanLevelResponse>::SetFanLevel_Impl(zx::unowned_channel _client_end, uint32_t fan_level) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFanLevelRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetFanLevelRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetFanLevelRequest*>(_write_bytes);
  _request.fan_level = std::move(fan_level);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFanLevelRequest));
  ::fidl::DecodedMessage<SetFanLevelRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::SetFanLevel(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::SetFanLevel Device::SyncClient::SetFanLevel(uint32_t fan_level) {
  return ResultOf::SetFanLevel(zx::unowned_channel(this->channel_), std::move(fan_level));
}

Device::ResultOf::SetFanLevel Device::Call::SetFanLevel(zx::unowned_channel _client_end, uint32_t fan_level) {
  return ResultOf::SetFanLevel(std::move(_client_end), std::move(fan_level));
}

template <>
Device::UnownedResultOf::SetFanLevel_Impl<Device::SetFanLevelResponse>::SetFanLevel_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetFanLevelRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetFanLevelResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetFanLevelRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetFanLevelRequest*>(_request_buffer.data());
  _request.fan_level = std::move(fan_level);
  _request_buffer.set_actual(sizeof(SetFanLevelRequest));
  ::fidl::DecodedMessage<SetFanLevelRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::SetFanLevel(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::SetFanLevel Device::SyncClient::SetFanLevel(::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetFanLevel(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(fan_level), std::move(_response_buffer));
}

Device::UnownedResultOf::SetFanLevel Device::Call::SetFanLevel(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetFanLevel(std::move(_client_end), std::move(_request_buffer), std::move(fan_level), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::SetFanLevelResponse> Device::InPlace::SetFanLevel(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFanLevelRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetFanLevel_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetFanLevelResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetFanLevelRequest, SetFanLevelResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::SetFanLevelResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Device::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDevice_GetInfo_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetInfo(
        Interface::GetInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetDeviceInfo_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetDeviceInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetDeviceInfo(
        Interface::GetDeviceInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetDvfsInfo_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetDvfsInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetDvfsInfo(std::move(message->power_domain),
        Interface::GetDvfsInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetTemperatureCelsius_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetTemperatureCelsiusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetTemperatureCelsius(
        Interface::GetTemperatureCelsiusCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetStateChangeEvent_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetStateChangeEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetStateChangeEvent(
        Interface::GetStateChangeEventCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetStateChangePort_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetStateChangePortRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetStateChangePort(
        Interface::GetStateChangePortCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetTripCelsius_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetTripCelsiusRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetTripCelsius(std::move(message->id), std::move(message->temp),
        Interface::SetTripCelsiusCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetDvfsOperatingPoint_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetDvfsOperatingPointRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetDvfsOperatingPoint(std::move(message->power_domain),
        Interface::GetDvfsOperatingPointCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetDvfsOperatingPoint_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetDvfsOperatingPointRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDvfsOperatingPoint(std::move(message->op_idx), std::move(message->power_domain),
        Interface::SetDvfsOperatingPointCompleter::Sync(txn));
      return true;
    }
    case kDevice_GetFanLevel_Ordinal:
    {
      auto result = ::fidl::DecodeAs<GetFanLevelRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetFanLevel(
        Interface::GetFanLevelCompleter::Sync(txn));
      return true;
    }
    case kDevice_SetFanLevel_Ordinal:
    {
      auto result = ::fidl::DecodeAs<SetFanLevelRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetFanLevel(std::move(message->fan_level),
        Interface::SetFanLevelCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Device::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Device::Interface::GetInfoCompleterBase::Reply(int32_t status, ThermalInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ThermalInfo* info) {
  if (_buffer.capacity() < GetInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetInfoCompleterBase::Reply(::fidl::DecodedMessage<GetInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetDeviceInfoCompleterBase::Reply(int32_t status, ThermalDeviceInfo* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDeviceInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetDeviceInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetDeviceInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetDeviceInfoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ThermalDeviceInfo* info) {
  if (_buffer.capacity() < GetDeviceInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDeviceInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetDeviceInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetDeviceInfoCompleterBase::Reply(::fidl::DecodedMessage<GetDeviceInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDeviceInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetDvfsInfoCompleterBase::Reply(int32_t status, OperatingPoint* info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDvfsInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetDvfsInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetDvfsInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetDvfsInfoCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, OperatingPoint* info) {
  if (_buffer.capacity() < GetDvfsInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetDvfsInfoResponse _response = {};
  _response._hdr.ordinal = kDevice_GetDvfsInfo_Ordinal;
  _response.status = std::move(status);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Device::Interface::GetDvfsInfoCompleterBase::Reply(::fidl::DecodedMessage<GetDvfsInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDvfsInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetTemperatureCelsiusCompleterBase::Reply(int32_t status, float temp) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTemperatureCelsiusResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTemperatureCelsiusResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_GetTemperatureCelsius_Ordinal;
  _response.status = std::move(status);
  _response.temp = std::move(temp);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTemperatureCelsiusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTemperatureCelsiusResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetTemperatureCelsiusCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, float temp) {
  if (_buffer.capacity() < GetTemperatureCelsiusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTemperatureCelsiusResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_GetTemperatureCelsius_Ordinal;
  _response.status = std::move(status);
  _response.temp = std::move(temp);
  _buffer.set_actual(sizeof(GetTemperatureCelsiusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTemperatureCelsiusResponse>(std::move(_buffer)));
}

void Device::Interface::GetTemperatureCelsiusCompleterBase::Reply(::fidl::DecodedMessage<GetTemperatureCelsiusResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetTemperatureCelsius_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetStateChangeEventCompleterBase::Reply(int32_t status, ::zx::event handle) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStateChangeEventResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetStateChangeEventResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_GetStateChangeEvent_Ordinal;
  _response.status = std::move(status);
  _response.handle = std::move(handle);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStateChangeEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStateChangeEventResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetStateChangeEventCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::zx::event handle) {
  if (_buffer.capacity() < GetStateChangeEventResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetStateChangeEventResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_GetStateChangeEvent_Ordinal;
  _response.status = std::move(status);
  _response.handle = std::move(handle);
  _buffer.set_actual(sizeof(GetStateChangeEventResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStateChangeEventResponse>(std::move(_buffer)));
}

void Device::Interface::GetStateChangeEventCompleterBase::Reply(::fidl::DecodedMessage<GetStateChangeEventResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetStateChangeEvent_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetStateChangePortCompleterBase::Reply(int32_t status, ::zx::port handle) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetStateChangePortResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetStateChangePortResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_GetStateChangePort_Ordinal;
  _response.status = std::move(status);
  _response.handle = std::move(handle);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetStateChangePortResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStateChangePortResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetStateChangePortCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::zx::port handle) {
  if (_buffer.capacity() < GetStateChangePortResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetStateChangePortResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_GetStateChangePort_Ordinal;
  _response.status = std::move(status);
  _response.handle = std::move(handle);
  _buffer.set_actual(sizeof(GetStateChangePortResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetStateChangePortResponse>(std::move(_buffer)));
}

void Device::Interface::GetStateChangePortCompleterBase::Reply(::fidl::DecodedMessage<GetStateChangePortResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetStateChangePort_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::SetTripCelsiusCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetTripCelsiusResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetTripCelsiusResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_SetTripCelsius_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetTripCelsiusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetTripCelsiusResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetTripCelsiusCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetTripCelsiusResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetTripCelsiusResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_SetTripCelsius_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetTripCelsiusResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetTripCelsiusResponse>(std::move(_buffer)));
}

void Device::Interface::SetTripCelsiusCompleterBase::Reply(::fidl::DecodedMessage<SetTripCelsiusResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetTripCelsius_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetDvfsOperatingPointCompleterBase::Reply(int32_t status, uint16_t op_idx) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetDvfsOperatingPointResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetDvfsOperatingPointResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_GetDvfsOperatingPoint_Ordinal;
  _response.status = std::move(status);
  _response.op_idx = std::move(op_idx);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetDvfsOperatingPointResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetDvfsOperatingPointResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetDvfsOperatingPointCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint16_t op_idx) {
  if (_buffer.capacity() < GetDvfsOperatingPointResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetDvfsOperatingPointResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_GetDvfsOperatingPoint_Ordinal;
  _response.status = std::move(status);
  _response.op_idx = std::move(op_idx);
  _buffer.set_actual(sizeof(GetDvfsOperatingPointResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetDvfsOperatingPointResponse>(std::move(_buffer)));
}

void Device::Interface::GetDvfsOperatingPointCompleterBase::Reply(::fidl::DecodedMessage<GetDvfsOperatingPointResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetDvfsOperatingPoint_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::SetDvfsOperatingPointCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDvfsOperatingPointResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetDvfsOperatingPointResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_SetDvfsOperatingPoint_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDvfsOperatingPointResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetDvfsOperatingPointResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetDvfsOperatingPointCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetDvfsOperatingPointResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetDvfsOperatingPointResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_SetDvfsOperatingPoint_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetDvfsOperatingPointResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetDvfsOperatingPointResponse>(std::move(_buffer)));
}

void Device::Interface::SetDvfsOperatingPointCompleterBase::Reply(::fidl::DecodedMessage<SetDvfsOperatingPointResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetDvfsOperatingPoint_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::GetFanLevelCompleterBase::Reply(int32_t status, uint32_t fan_level) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetFanLevelResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetFanLevelResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_GetFanLevel_Ordinal;
  _response.status = std::move(status);
  _response.fan_level = std::move(fan_level);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetFanLevelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFanLevelResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetFanLevelCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint32_t fan_level) {
  if (_buffer.capacity() < GetFanLevelResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetFanLevelResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_GetFanLevel_Ordinal;
  _response.status = std::move(status);
  _response.fan_level = std::move(fan_level);
  _buffer.set_actual(sizeof(GetFanLevelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetFanLevelResponse>(std::move(_buffer)));
}

void Device::Interface::GetFanLevelCompleterBase::Reply(::fidl::DecodedMessage<GetFanLevelResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_GetFanLevel_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::SetFanLevelCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetFanLevelResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetFanLevelResponse*>(_write_bytes);
  _response._hdr.ordinal = kDevice_SetFanLevel_Ordinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetFanLevelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFanLevelResponse>(std::move(_response_bytes)));
}

void Device::Interface::SetFanLevelCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetFanLevelResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetFanLevelResponse*>(_buffer.data());
  _response._hdr.ordinal = kDevice_SetFanLevel_Ordinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetFanLevelResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetFanLevelResponse>(std::move(_buffer)));
}

void Device::Interface::SetFanLevelCompleterBase::Reply(::fidl::DecodedMessage<SetFanLevelResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kDevice_SetFanLevel_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace thermal
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/event.h>
#include <lib/zx/port.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace thermal {

struct ThermalTemperatureInfo;
struct ThermalInfo;
enum class PowerDomain : uint32_t {
  BIG_CLUSTER_POWER_DOMAIN = 0u,
  LITTLE_CLUSTER_POWER_DOMAIN = 1u,
};


class Device;
struct OperatingPointEntry;
struct OperatingPoint;
struct ThermalDeviceInfo;

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_ThermalTemperatureInfoTable;

// Temperature units are degrees Celsius.
struct ThermalTemperatureInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_ThermalTemperatureInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The temperature must rise to up_temp to get to this trip point.
  float up_temp_celsius = {};

  // The temperature must fall to down_temp to get to this trip point.
  float down_temp_celsius = {};

  // The fan level for this trip point.
  uint32_t fan_level = {};

  // The operating point index of the big cluster.
  uint16_t big_cluster_dvfs_opp = {};

  // The operating point index of the little cluster.
  uint16_t little_cluster_dvfs_opp = {};

  // The GPU clock source index.
  uint32_t gpu_clk_freq_source = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_ThermalInfoTable;

// Temperature units are degrees Celsius.
struct ThermalInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_ThermalInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // State is a bitmask of `THERMAL_STATE_`* values.
  uint32_t state = {};

  // The sensor temperature at which the system should activate passive cooling policy.
  float passive_temp_celsius = {};

  // The sensor temperature at which the system should perform critical shutdown.
  float critical_temp_celsius = {};

  // The number of trip points supported.
  uint32_t max_trip_count = {};

  // The currently active trip point.
  ::fidl::Array<float, 16> active_trip = {};
};

constexpr uint32_t THERMAL_STATE_TRIP_VIOLATION = 1u;

// Bitmask values for ThermalInfo.state.
constexpr uint32_t THERMAL_STATE_NORMAL = 0u;

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDeviceInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDeviceInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDvfsInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDvfsInfoResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetTemperatureCelsiusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetTemperatureCelsiusResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetStateChangeEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetStateChangeEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetStateChangePortRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetStateChangePortResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetTripCelsiusRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetTripCelsiusResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetFanLevelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceGetFanLevelResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetFanLevelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_DeviceSetFanLevelResponseTable;

class Device final {
  Device() = delete;
 public:

  struct GetInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::llcpp::fuchsia::hardware::thermal::ThermalInfo* info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 80;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetInfoRequest = ::fidl::AnyZeroArgMessage;

  struct GetDeviceInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo* info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetDeviceInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 608;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetDeviceInfoRequest = ::fidl::AnyZeroArgMessage;

  struct GetDvfsInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::llcpp::fuchsia::hardware::thermal::OperatingPoint* info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetDvfsInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 136;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetDvfsInfoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetDvfsInfoRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetDvfsInfoResponse;
  };

  struct GetTemperatureCelsiusResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    float temp;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetTemperatureCelsiusResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTemperatureCelsiusRequest = ::fidl::AnyZeroArgMessage;

  struct GetStateChangeEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::event handle;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetStateChangeEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetStateChangeEventRequest = ::fidl::AnyZeroArgMessage;

  struct GetStateChangePortResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::port handle;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetStateChangePortResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetStateChangePortRequest = ::fidl::AnyZeroArgMessage;

  struct SetTripCelsiusResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetTripCelsiusResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetTripCelsiusRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t id;
    float temp;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetTripCelsiusRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetTripCelsiusResponse;
  };

  struct GetDvfsOperatingPointResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint16_t op_idx;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetDvfsOperatingPointRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetDvfsOperatingPointRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetDvfsOperatingPointResponse;
  };

  struct SetDvfsOperatingPointResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetDvfsOperatingPointRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint16_t op_idx;
    ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetDvfsOperatingPointRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetDvfsOperatingPointResponse;
  };

  struct GetFanLevelResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint32_t fan_level;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceGetFanLevelResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetFanLevelRequest = ::fidl::AnyZeroArgMessage;

  struct SetFanLevelResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetFanLevelResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetFanLevelRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t fan_level;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_DeviceSetFanLevelRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetFanLevelResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDeviceInfo_Impl(::zx::unowned_channel _client_end);
      ~GetDeviceInfo_Impl() = default;
      GetDeviceInfo_Impl(GetDeviceInfo_Impl&& other) = default;
      GetDeviceInfo_Impl& operator=(GetDeviceInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDvfsInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDvfsInfo_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);
      ~GetDvfsInfo_Impl() = default;
      GetDvfsInfo_Impl(GetDvfsInfo_Impl&& other) = default;
      GetDvfsInfo_Impl& operator=(GetDvfsInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetTemperatureCelsius_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetTemperatureCelsius_Impl(::zx::unowned_channel _client_end);
      ~GetTemperatureCelsius_Impl() = default;
      GetTemperatureCelsius_Impl(GetTemperatureCelsius_Impl&& other) = default;
      GetTemperatureCelsius_Impl& operator=(GetTemperatureCelsius_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStateChangeEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetStateChangeEvent_Impl(::zx::unowned_channel _client_end);
      ~GetStateChangeEvent_Impl() = default;
      GetStateChangeEvent_Impl(GetStateChangeEvent_Impl&& other) = default;
      GetStateChangeEvent_Impl& operator=(GetStateChangeEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStateChangePort_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetStateChangePort_Impl(::zx::unowned_channel _client_end);
      ~GetStateChangePort_Impl() = default;
      GetStateChangePort_Impl(GetStateChangePort_Impl&& other) = default;
      GetStateChangePort_Impl& operator=(GetStateChangePort_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetTripCelsius_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetTripCelsius_Impl(::zx::unowned_channel _client_end, uint32_t id, float temp);
      ~SetTripCelsius_Impl() = default;
      SetTripCelsius_Impl(SetTripCelsius_Impl&& other) = default;
      SetTripCelsius_Impl& operator=(SetTripCelsius_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDvfsOperatingPoint_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDvfsOperatingPoint_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);
      ~GetDvfsOperatingPoint_Impl() = default;
      GetDvfsOperatingPoint_Impl(GetDvfsOperatingPoint_Impl&& other) = default;
      GetDvfsOperatingPoint_Impl& operator=(GetDvfsOperatingPoint_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetDvfsOperatingPoint_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetDvfsOperatingPoint_Impl(::zx::unowned_channel _client_end, uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);
      ~SetDvfsOperatingPoint_Impl() = default;
      SetDvfsOperatingPoint_Impl(SetDvfsOperatingPoint_Impl&& other) = default;
      SetDvfsOperatingPoint_Impl& operator=(SetDvfsOperatingPoint_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFanLevel_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetFanLevel_Impl(::zx::unowned_channel _client_end);
      ~GetFanLevel_Impl() = default;
      GetFanLevel_Impl(GetFanLevel_Impl&& other) = default;
      GetFanLevel_Impl& operator=(GetFanLevel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetFanLevel_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetFanLevel_Impl(::zx::unowned_channel _client_end, uint32_t fan_level);
      ~SetFanLevel_Impl() = default;
      SetFanLevel_Impl(SetFanLevel_Impl&& other) = default;
      SetFanLevel_Impl& operator=(SetFanLevel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetDeviceInfo = GetDeviceInfo_Impl<GetDeviceInfoResponse>;
    using GetDvfsInfo = GetDvfsInfo_Impl<GetDvfsInfoResponse>;
    using GetTemperatureCelsius = GetTemperatureCelsius_Impl<GetTemperatureCelsiusResponse>;
    using GetStateChangeEvent = GetStateChangeEvent_Impl<GetStateChangeEventResponse>;
    using GetStateChangePort = GetStateChangePort_Impl<GetStateChangePortResponse>;
    using SetTripCelsius = SetTripCelsius_Impl<SetTripCelsiusResponse>;
    using GetDvfsOperatingPoint = GetDvfsOperatingPoint_Impl<GetDvfsOperatingPointResponse>;
    using SetDvfsOperatingPoint = SetDvfsOperatingPoint_Impl<SetDvfsOperatingPointResponse>;
    using GetFanLevel = GetFanLevel_Impl<GetFanLevelResponse>;
    using SetFanLevel = SetFanLevel_Impl<SetFanLevelResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetInfo_Impl() = default;
      GetInfo_Impl(GetInfo_Impl&& other) = default;
      GetInfo_Impl& operator=(GetInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDeviceInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetDeviceInfo_Impl() = default;
      GetDeviceInfo_Impl(GetDeviceInfo_Impl&& other) = default;
      GetDeviceInfo_Impl& operator=(GetDeviceInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDvfsInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDvfsInfo_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);
      ~GetDvfsInfo_Impl() = default;
      GetDvfsInfo_Impl(GetDvfsInfo_Impl&& other) = default;
      GetDvfsInfo_Impl& operator=(GetDvfsInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetTemperatureCelsius_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetTemperatureCelsius_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetTemperatureCelsius_Impl() = default;
      GetTemperatureCelsius_Impl(GetTemperatureCelsius_Impl&& other) = default;
      GetTemperatureCelsius_Impl& operator=(GetTemperatureCelsius_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStateChangeEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetStateChangeEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetStateChangeEvent_Impl() = default;
      GetStateChangeEvent_Impl(GetStateChangeEvent_Impl&& other) = default;
      GetStateChangeEvent_Impl& operator=(GetStateChangeEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStateChangePort_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetStateChangePort_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetStateChangePort_Impl() = default;
      GetStateChangePort_Impl(GetStateChangePort_Impl&& other) = default;
      GetStateChangePort_Impl& operator=(GetStateChangePort_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetTripCelsius_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetTripCelsius_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer);
      ~SetTripCelsius_Impl() = default;
      SetTripCelsius_Impl(SetTripCelsius_Impl&& other) = default;
      SetTripCelsius_Impl& operator=(SetTripCelsius_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDvfsOperatingPoint_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDvfsOperatingPoint_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);
      ~GetDvfsOperatingPoint_Impl() = default;
      GetDvfsOperatingPoint_Impl(GetDvfsOperatingPoint_Impl&& other) = default;
      GetDvfsOperatingPoint_Impl& operator=(GetDvfsOperatingPoint_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetDvfsOperatingPoint_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetDvfsOperatingPoint_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);
      ~SetDvfsOperatingPoint_Impl() = default;
      SetDvfsOperatingPoint_Impl(SetDvfsOperatingPoint_Impl&& other) = default;
      SetDvfsOperatingPoint_Impl& operator=(SetDvfsOperatingPoint_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFanLevel_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetFanLevel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetFanLevel_Impl() = default;
      GetFanLevel_Impl(GetFanLevel_Impl&& other) = default;
      GetFanLevel_Impl& operator=(GetFanLevel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetFanLevel_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetFanLevel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer);
      ~SetFanLevel_Impl() = default;
      SetFanLevel_Impl(SetFanLevel_Impl&& other) = default;
      SetFanLevel_Impl& operator=(SetFanLevel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetInfo = GetInfo_Impl<GetInfoResponse>;
    using GetDeviceInfo = GetDeviceInfo_Impl<GetDeviceInfoResponse>;
    using GetDvfsInfo = GetDvfsInfo_Impl<GetDvfsInfoResponse>;
    using GetTemperatureCelsius = GetTemperatureCelsius_Impl<GetTemperatureCelsiusResponse>;
    using GetStateChangeEvent = GetStateChangeEvent_Impl<GetStateChangeEventResponse>;
    using GetStateChangePort = GetStateChangePort_Impl<GetStateChangePortResponse>;
    using SetTripCelsius = SetTripCelsius_Impl<SetTripCelsiusResponse>;
    using GetDvfsOperatingPoint = GetDvfsOperatingPoint_Impl<GetDvfsOperatingPointResponse>;
    using SetDvfsOperatingPoint = SetDvfsOperatingPoint_Impl<SetDvfsOperatingPointResponse>;
    using GetFanLevel = GetFanLevel_Impl<GetFanLevelResponse>;
    using SetFanLevel = SetFanLevel_Impl<SetFanLevelResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Get information about the device's current state.
    // Allocates 128 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetInfo GetInfo();

    // Get information about the device's current state.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetInfo GetInfo(::fidl::BytePart _response_buffer);

    // Get information about the device's thermal capabilities and trip points.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetDeviceInfo GetDeviceInfo();

    // Get information about the device's thermal capabilities and trip points.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDeviceInfo GetDeviceInfo(::fidl::BytePart _response_buffer);

    // Get the device's operating points.
    // TODO(bradenkell): Can this be removed? GetDeviceInfo() provides the same information.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDvfsInfo GetDvfsInfo(::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Get the device's operating points.
    // TODO(bradenkell): Can this be removed? GetDeviceInfo() provides the same information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDvfsInfo GetDvfsInfo(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Get the current temperature in degrees Celsius.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetTemperatureCelsius GetTemperatureCelsius();

    // Get the current temperature in degrees Celsius.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetTemperatureCelsius GetTemperatureCelsius(::fidl::BytePart _response_buffer);

    // Get an event to get trip point notifications on. `ZX_USER_SIGNAL_`0 is changed when either
    // trip point is reached. It is deasserted when the state is read via GetInfo.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetStateChangeEvent GetStateChangeEvent();

    // Get an event to get trip point notifications on. `ZX_USER_SIGNAL_`0 is changed when either
    // trip point is reached. It is deasserted when the state is read via GetInfo.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStateChangeEvent GetStateChangeEvent(::fidl::BytePart _response_buffer);

    // Get a port to get trip point notification packets.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetStateChangePort GetStateChangePort();

    // Get a port to get trip point notification packets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStateChangePort GetStateChangePort(::fidl::BytePart _response_buffer);

    // Sets a trip point in degrees Celsius. When the sensor reaches the trip point temperature the
    // device will notify on an event.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetTripCelsius SetTripCelsius(uint32_t id, float temp);

    // Sets a trip point in degrees Celsius. When the sensor reaches the trip point temperature the
    // device will notify on an event.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetTripCelsius SetTripCelsius(::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer);

    // Get the current operating point index.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDvfsOperatingPoint GetDvfsOperatingPoint(::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Get the current operating point index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDvfsOperatingPoint GetDvfsOperatingPoint(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Set the operating point index.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetDvfsOperatingPoint SetDvfsOperatingPoint(uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Set the operating point index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetDvfsOperatingPoint SetDvfsOperatingPoint(::fidl::BytePart _request_buffer, uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Get the current fan level.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetFanLevel GetFanLevel();

    // Get the current fan level.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetFanLevel GetFanLevel(::fidl::BytePart _response_buffer);

    // Set the fan level.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetFanLevel SetFanLevel(uint32_t fan_level);

    // Set the fan level.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetFanLevel SetFanLevel(::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Get information about the device's current state.
    // Allocates 128 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end);

    // Get information about the device's current state.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetInfo GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Get information about the device's thermal capabilities and trip points.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetDeviceInfo GetDeviceInfo(::zx::unowned_channel _client_end);

    // Get information about the device's thermal capabilities and trip points.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDeviceInfo GetDeviceInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Get the device's operating points.
    // TODO(bradenkell): Can this be removed? GetDeviceInfo() provides the same information.
    // Allocates 192 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDvfsInfo GetDvfsInfo(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Get the device's operating points.
    // TODO(bradenkell): Can this be removed? GetDeviceInfo() provides the same information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDvfsInfo GetDvfsInfo(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Get the current temperature in degrees Celsius.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetTemperatureCelsius GetTemperatureCelsius(::zx::unowned_channel _client_end);

    // Get the current temperature in degrees Celsius.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetTemperatureCelsius GetTemperatureCelsius(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Get an event to get trip point notifications on. `ZX_USER_SIGNAL_`0 is changed when either
    // trip point is reached. It is deasserted when the state is read via GetInfo.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetStateChangeEvent GetStateChangeEvent(::zx::unowned_channel _client_end);

    // Get an event to get trip point notifications on. `ZX_USER_SIGNAL_`0 is changed when either
    // trip point is reached. It is deasserted when the state is read via GetInfo.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStateChangeEvent GetStateChangeEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Get a port to get trip point notification packets.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetStateChangePort GetStateChangePort(::zx::unowned_channel _client_end);

    // Get a port to get trip point notification packets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStateChangePort GetStateChangePort(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets a trip point in degrees Celsius. When the sensor reaches the trip point temperature the
    // device will notify on an event.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetTripCelsius SetTripCelsius(::zx::unowned_channel _client_end, uint32_t id, float temp);

    // Sets a trip point in degrees Celsius. When the sensor reaches the trip point temperature the
    // device will notify on an event.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetTripCelsius SetTripCelsius(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, float temp, ::fidl::BytePart _response_buffer);

    // Get the current operating point index.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDvfsOperatingPoint GetDvfsOperatingPoint(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Get the current operating point index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDvfsOperatingPoint GetDvfsOperatingPoint(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Set the operating point index.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetDvfsOperatingPoint SetDvfsOperatingPoint(::zx::unowned_channel _client_end, uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain);

    // Set the operating point index.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetDvfsOperatingPoint SetDvfsOperatingPoint(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, ::fidl::BytePart _response_buffer);

    // Get the current fan level.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetFanLevel GetFanLevel(::zx::unowned_channel _client_end);

    // Get the current fan level.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetFanLevel GetFanLevel(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Set the fan level.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetFanLevel SetFanLevel(::zx::unowned_channel _client_end, uint32_t fan_level);

    // Set the fan level.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetFanLevel SetFanLevel(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t fan_level, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Get information about the device's current state.
    static ::fidl::DecodeResult<GetInfoResponse> GetInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Get information about the device's thermal capabilities and trip points.
    static ::fidl::DecodeResult<GetDeviceInfoResponse> GetDeviceInfo(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Get the device's operating points.
    // TODO(bradenkell): Can this be removed? GetDeviceInfo() provides the same information.
    static ::fidl::DecodeResult<GetDvfsInfoResponse> GetDvfsInfo(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDvfsInfoRequest> params, ::fidl::BytePart response_buffer);

    // Get the current temperature in degrees Celsius.
    static ::fidl::DecodeResult<GetTemperatureCelsiusResponse> GetTemperatureCelsius(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Get an event to get trip point notifications on. `ZX_USER_SIGNAL_`0 is changed when either
    // trip point is reached. It is deasserted when the state is read via GetInfo.
    static ::fidl::DecodeResult<GetStateChangeEventResponse> GetStateChangeEvent(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Get a port to get trip point notification packets.
    static ::fidl::DecodeResult<GetStateChangePortResponse> GetStateChangePort(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets a trip point in degrees Celsius. When the sensor reaches the trip point temperature the
    // device will notify on an event.
    static ::fidl::DecodeResult<SetTripCelsiusResponse> SetTripCelsius(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetTripCelsiusRequest> params, ::fidl::BytePart response_buffer);

    // Get the current operating point index.
    static ::fidl::DecodeResult<GetDvfsOperatingPointResponse> GetDvfsOperatingPoint(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetDvfsOperatingPointRequest> params, ::fidl::BytePart response_buffer);

    // Set the operating point index.
    static ::fidl::DecodeResult<SetDvfsOperatingPointResponse> SetDvfsOperatingPoint(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDvfsOperatingPointRequest> params, ::fidl::BytePart response_buffer);

    // Get the current fan level.
    static ::fidl::DecodeResult<GetFanLevelResponse> GetFanLevel(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Set the fan level.
    static ::fidl::DecodeResult<SetFanLevelResponse> SetFanLevel(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFanLevelRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    class GetInfoCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::llcpp::fuchsia::hardware::thermal::ThermalInfo* info);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::thermal::ThermalInfo* info);
      void Reply(::fidl::DecodedMessage<GetInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetInfoCompleter = ::fidl::Completer<GetInfoCompleterBase>;

    virtual void GetInfo(GetInfoCompleter::Sync _completer) = 0;

    class GetDeviceInfoCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo* info);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo* info);
      void Reply(::fidl::DecodedMessage<GetDeviceInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDeviceInfoCompleter = ::fidl::Completer<GetDeviceInfoCompleterBase>;

    virtual void GetDeviceInfo(GetDeviceInfoCompleter::Sync _completer) = 0;

    class GetDvfsInfoCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::llcpp::fuchsia::hardware::thermal::OperatingPoint* info);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::thermal::OperatingPoint* info);
      void Reply(::fidl::DecodedMessage<GetDvfsInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDvfsInfoCompleter = ::fidl::Completer<GetDvfsInfoCompleterBase>;

    virtual void GetDvfsInfo(::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, GetDvfsInfoCompleter::Sync _completer) = 0;

    class GetTemperatureCelsiusCompleterBase : public _Base {
     public:
      void Reply(int32_t status, float temp);
      void Reply(::fidl::BytePart _buffer, int32_t status, float temp);
      void Reply(::fidl::DecodedMessage<GetTemperatureCelsiusResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTemperatureCelsiusCompleter = ::fidl::Completer<GetTemperatureCelsiusCompleterBase>;

    virtual void GetTemperatureCelsius(GetTemperatureCelsiusCompleter::Sync _completer) = 0;

    class GetStateChangeEventCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::event handle);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::event handle);
      void Reply(::fidl::DecodedMessage<GetStateChangeEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetStateChangeEventCompleter = ::fidl::Completer<GetStateChangeEventCompleterBase>;

    virtual void GetStateChangeEvent(GetStateChangeEventCompleter::Sync _completer) = 0;

    class GetStateChangePortCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::port handle);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::port handle);
      void Reply(::fidl::DecodedMessage<GetStateChangePortResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetStateChangePortCompleter = ::fidl::Completer<GetStateChangePortCompleterBase>;

    virtual void GetStateChangePort(GetStateChangePortCompleter::Sync _completer) = 0;

    class SetTripCelsiusCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetTripCelsiusResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetTripCelsiusCompleter = ::fidl::Completer<SetTripCelsiusCompleterBase>;

    virtual void SetTripCelsius(uint32_t id, float temp, SetTripCelsiusCompleter::Sync _completer) = 0;

    class GetDvfsOperatingPointCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint16_t op_idx);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint16_t op_idx);
      void Reply(::fidl::DecodedMessage<GetDvfsOperatingPointResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDvfsOperatingPointCompleter = ::fidl::Completer<GetDvfsOperatingPointCompleterBase>;

    virtual void GetDvfsOperatingPoint(::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, GetDvfsOperatingPointCompleter::Sync _completer) = 0;

    class SetDvfsOperatingPointCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetDvfsOperatingPointResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetDvfsOperatingPointCompleter = ::fidl::Completer<SetDvfsOperatingPointCompleterBase>;

    virtual void SetDvfsOperatingPoint(uint16_t op_idx, ::llcpp::fuchsia::hardware::thermal::PowerDomain power_domain, SetDvfsOperatingPointCompleter::Sync _completer) = 0;

    class GetFanLevelCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint32_t fan_level);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint32_t fan_level);
      void Reply(::fidl::DecodedMessage<GetFanLevelResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetFanLevelCompleter = ::fidl::Completer<GetFanLevelCompleterBase>;

    virtual void GetFanLevel(GetFanLevelCompleter::Sync _completer) = 0;

    class SetFanLevelCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetFanLevelResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetFanLevelCompleter = ::fidl::Completer<SetFanLevelCompleterBase>;

    virtual void SetFanLevel(uint32_t fan_level, SetFanLevelCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetInfoRequest(const ::fidl::DecodedMessage<Device::GetInfoRequest>& _msg);
    static void GetInfoResponse(const ::fidl::DecodedMessage<Device::GetInfoResponse>& _msg);
    static void GetDeviceInfoRequest(const ::fidl::DecodedMessage<Device::GetDeviceInfoRequest>& _msg);
    static void GetDeviceInfoResponse(const ::fidl::DecodedMessage<Device::GetDeviceInfoResponse>& _msg);
    static void GetDvfsInfoRequest(const ::fidl::DecodedMessage<Device::GetDvfsInfoRequest>& _msg);
    static void GetDvfsInfoResponse(const ::fidl::DecodedMessage<Device::GetDvfsInfoResponse>& _msg);
    static void GetTemperatureCelsiusRequest(const ::fidl::DecodedMessage<Device::GetTemperatureCelsiusRequest>& _msg);
    static void GetTemperatureCelsiusResponse(const ::fidl::DecodedMessage<Device::GetTemperatureCelsiusResponse>& _msg);
    static void GetStateChangeEventRequest(const ::fidl::DecodedMessage<Device::GetStateChangeEventRequest>& _msg);
    static void GetStateChangeEventResponse(const ::fidl::DecodedMessage<Device::GetStateChangeEventResponse>& _msg);
    static void GetStateChangePortRequest(const ::fidl::DecodedMessage<Device::GetStateChangePortRequest>& _msg);
    static void GetStateChangePortResponse(const ::fidl::DecodedMessage<Device::GetStateChangePortResponse>& _msg);
    static void SetTripCelsiusRequest(const ::fidl::DecodedMessage<Device::SetTripCelsiusRequest>& _msg);
    static void SetTripCelsiusResponse(const ::fidl::DecodedMessage<Device::SetTripCelsiusResponse>& _msg);
    static void GetDvfsOperatingPointRequest(const ::fidl::DecodedMessage<Device::GetDvfsOperatingPointRequest>& _msg);
    static void GetDvfsOperatingPointResponse(const ::fidl::DecodedMessage<Device::GetDvfsOperatingPointResponse>& _msg);
    static void SetDvfsOperatingPointRequest(const ::fidl::DecodedMessage<Device::SetDvfsOperatingPointRequest>& _msg);
    static void SetDvfsOperatingPointResponse(const ::fidl::DecodedMessage<Device::SetDvfsOperatingPointResponse>& _msg);
    static void GetFanLevelRequest(const ::fidl::DecodedMessage<Device::GetFanLevelRequest>& _msg);
    static void GetFanLevelResponse(const ::fidl::DecodedMessage<Device::GetFanLevelResponse>& _msg);
    static void SetFanLevelRequest(const ::fidl::DecodedMessage<Device::SetFanLevelRequest>& _msg);
    static void SetFanLevelResponse(const ::fidl::DecodedMessage<Device::SetFanLevelResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_OperatingPointEntryTable;

// scpi_opp_entry_t is typedef'd to this.
struct OperatingPointEntry {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_OperatingPointEntryTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The operating point frequency in Hz.
  uint32_t freq_hz = {};

  // The operating point voltage in microvolts.
  uint32_t volt_uv = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_OperatingPointTable;

// scpi_opp_t is typedef'd to this.
struct OperatingPoint {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_OperatingPointTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 136;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The device's operating points.
  ::fidl::Array<::llcpp::fuchsia::hardware::thermal::OperatingPointEntry, 16> opp = {};

  // In microseconds.
  uint32_t latency = {};

  // The number of operating points in opp.
  uint32_t count = {};
};

extern "C" const fidl_type_t v1_fuchsia_hardware_thermal_ThermalDeviceInfoTable;

struct ThermalDeviceInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_thermal_ThermalDeviceInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 608;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // Active cooling support.
  bool active_cooling = {};

  // Passive cooling support.
  bool passive_cooling = {};

  // GPU throttling support.
  bool gpu_throttling = {};

  // Number of trip points.
  uint32_t num_trip_points = {};

  // Big-little architecture.
  bool big_little = {};

  // Critical temperature in degrees Celsius.
  float critical_temp_celsius = {};

  // Trip point information.
  ::fidl::Array<::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, 16> trip_point_info = {};

  // Operating point information.
  ::fidl::Array<::llcpp::fuchsia::hardware::thermal::OperatingPoint, 2> opps = {};
};

// The maximum number of trip points that can be used.
constexpr uint32_t MAX_TRIP_POINTS = 16u;

// The maximum number of operating points that can be used.
constexpr uint32_t MAX_DVFS_OPPS = 16u;

// The maximum number of DVFS domains a device can support (one for each cluster in a big-little
// architecture).
constexpr uint32_t MAX_DVFS_DOMAINS = 2u;

}  // namespace thermal
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, up_temp_celsius) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, down_temp_celsius) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, fan_level) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, big_cluster_dvfs_opp) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, little_cluster_dvfs_opp) == 14);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo, gpu_clk_freq_source) == 16);
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo) == ::llcpp::fuchsia::hardware::thermal::ThermalTemperatureInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::ThermalInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::thermal::ThermalInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalInfo, state) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalInfo, passive_temp_celsius) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalInfo, critical_temp_celsius) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalInfo, max_trip_count) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalInfo, active_trip) == 16);
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::ThermalInfo) == ::llcpp::fuchsia::hardware::thermal::ThermalInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetInfoResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDeviceInfoResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoRequest)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoRequest, power_domain) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsInfoResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetTemperatureCelsiusResponse, temp) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangeEventResponse, handle) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetStateChangePortResponse, handle) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest, id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusRequest, temp) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetTripCelsiusResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointRequest)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointRequest, power_domain) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetDvfsOperatingPointResponse, op_idx) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest, op_idx) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointRequest, power_domain) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetDvfsOperatingPointResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::GetFanLevelResponse, fan_level) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelRequest)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelRequest, fan_level) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelResponse)
    == ::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::Device::SetFanLevelResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::OperatingPointEntry> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::thermal::OperatingPointEntry>);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::OperatingPointEntry, freq_hz) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::OperatingPointEntry, volt_uv) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::OperatingPointEntry) == ::llcpp::fuchsia::hardware::thermal::OperatingPointEntry::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::OperatingPoint> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::thermal::OperatingPoint>);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::OperatingPoint, opp) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::OperatingPoint, latency) == 128);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::OperatingPoint, count) == 132);
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::OperatingPoint) == ::llcpp::fuchsia::hardware::thermal::OperatingPoint::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, active_cooling) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, passive_cooling) == 1);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, gpu_throttling) == 2);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, num_trip_points) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, big_little) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, critical_temp_celsius) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, trip_point_info) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo, opps) == 336);
static_assert(sizeof(::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo) == ::llcpp::fuchsia::hardware::thermal::ThermalDeviceInfo::PrimarySize);

}  // namespace fidl

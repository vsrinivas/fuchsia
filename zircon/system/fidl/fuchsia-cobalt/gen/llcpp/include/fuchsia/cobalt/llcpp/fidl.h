// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

#include <fuchsia/mem/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace cobalt {

struct Value;
struct CustomEventValue;
enum class Status : int32_t {
  OK = 0u,
  INVALID_ARGUMENTS = 1u,
  EVENT_TOO_BIG = 2u,
  BUFFER_FULL = 3u,
  INTERNAL_ERROR = -1,
};


class Controller;
class LoggerBase;
class LoggerSimple;
enum class ReleaseStage : int32_t {
  GA = 0u,
  DOGFOOD = 10u,
  FISHFOOD = 20u,
  DEBUG = 99u,
};


struct ProjectProfile;
class LoggerFactory;
struct HistogramBucket;
struct Experiment;
class SystemDataUpdater;
struct Event;
struct CountEvent;
struct EventPayload;
struct CobaltEvent;
class Logger;

extern "C" const fidl_type_t v1_fuchsia_cobalt_ValueTable;

struct Value {
  Value() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kStringValue = 1,  // 0x1
    kIntValue = 2,  // 0x2
    kDoubleValue = 3,  // 0x3
    kIndexValue = 4,  // 0x4
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_string_value() const { return ordinal() == Ordinal::kStringValue; }

  static Value WithStringValue(::fidl::StringView* val) {
    Value result;
    result.set_string_value(val);
    return result;
  }

  void set_string_value(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringValue;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_string_value() {
    ZX_ASSERT(ordinal() == Ordinal::kStringValue);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& string_value() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringValue);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_int_value() const { return ordinal() == Ordinal::kIntValue; }

  static Value WithIntValue(int64_t* val) {
    Value result;
    result.set_int_value(val);
    return result;
  }

  void set_int_value(int64_t* elem) {
    ordinal_ = Ordinal::kIntValue;
    envelope_.data = static_cast<void*>(elem);
  }

  int64_t& mutable_int_value() {
    ZX_ASSERT(ordinal() == Ordinal::kIntValue);
    return *static_cast<int64_t*>(envelope_.data);
  }
  const int64_t& int_value() const {
    ZX_ASSERT(ordinal() == Ordinal::kIntValue);
    return *static_cast<int64_t*>(envelope_.data);
  }

  bool is_double_value() const { return ordinal() == Ordinal::kDoubleValue; }

  static Value WithDoubleValue(double* val) {
    Value result;
    result.set_double_value(val);
    return result;
  }

  void set_double_value(double* elem) {
    ordinal_ = Ordinal::kDoubleValue;
    envelope_.data = static_cast<void*>(elem);
  }

  double& mutable_double_value() {
    ZX_ASSERT(ordinal() == Ordinal::kDoubleValue);
    return *static_cast<double*>(envelope_.data);
  }
  const double& double_value() const {
    ZX_ASSERT(ordinal() == Ordinal::kDoubleValue);
    return *static_cast<double*>(envelope_.data);
  }

  bool is_index_value() const { return ordinal() == Ordinal::kIndexValue; }

  static Value WithIndexValue(uint32_t* val) {
    Value result;
    result.set_index_value(val);
    return result;
  }

  void set_index_value(uint32_t* elem) {
    ordinal_ = Ordinal::kIndexValue;
    envelope_.data = static_cast<void*>(elem);
  }

  uint32_t& mutable_index_value() {
    ZX_ASSERT(ordinal() == Ordinal::kIndexValue);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  const uint32_t& index_value() const {
    ZX_ASSERT(ordinal() == Ordinal::kIndexValue);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ValueTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kStringValue = 1,  // 0x1
    kIntValue = 2,  // 0x2
    kDoubleValue = 3,  // 0x3
    kIndexValue = 4,  // 0x4
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_EventPayloadTable;

struct EventPayload {
  EventPayload() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kEvent = 1,  // 0x1
    kEventCount = 2,  // 0x2
    kElapsedMicros = 3,  // 0x3
    kFps = 4,  // 0x4
    kMemoryBytesUsed = 5,  // 0x5
    kIntHistogram = 7,  // 0x7
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_event() const { return ordinal() == Ordinal::kEvent; }

  static EventPayload WithEvent(::llcpp::fuchsia::cobalt::Event* val) {
    EventPayload result;
    result.set_event(val);
    return result;
  }

  void set_event(::llcpp::fuchsia::cobalt::Event* elem) {
    ordinal_ = Ordinal::kEvent;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::cobalt::Event& mutable_event() {
    ZX_ASSERT(ordinal() == Ordinal::kEvent);
    return *static_cast<::llcpp::fuchsia::cobalt::Event*>(envelope_.data);
  }
  const ::llcpp::fuchsia::cobalt::Event& event() const {
    ZX_ASSERT(ordinal() == Ordinal::kEvent);
    return *static_cast<::llcpp::fuchsia::cobalt::Event*>(envelope_.data);
  }

  bool is_event_count() const { return ordinal() == Ordinal::kEventCount; }

  static EventPayload WithEventCount(::llcpp::fuchsia::cobalt::CountEvent* val) {
    EventPayload result;
    result.set_event_count(val);
    return result;
  }

  void set_event_count(::llcpp::fuchsia::cobalt::CountEvent* elem) {
    ordinal_ = Ordinal::kEventCount;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::cobalt::CountEvent& mutable_event_count() {
    ZX_ASSERT(ordinal() == Ordinal::kEventCount);
    return *static_cast<::llcpp::fuchsia::cobalt::CountEvent*>(envelope_.data);
  }
  const ::llcpp::fuchsia::cobalt::CountEvent& event_count() const {
    ZX_ASSERT(ordinal() == Ordinal::kEventCount);
    return *static_cast<::llcpp::fuchsia::cobalt::CountEvent*>(envelope_.data);
  }

  bool is_elapsed_micros() const { return ordinal() == Ordinal::kElapsedMicros; }

  static EventPayload WithElapsedMicros(int64_t* val) {
    EventPayload result;
    result.set_elapsed_micros(val);
    return result;
  }

  void set_elapsed_micros(int64_t* elem) {
    ordinal_ = Ordinal::kElapsedMicros;
    envelope_.data = static_cast<void*>(elem);
  }

  int64_t& mutable_elapsed_micros() {
    ZX_ASSERT(ordinal() == Ordinal::kElapsedMicros);
    return *static_cast<int64_t*>(envelope_.data);
  }
  const int64_t& elapsed_micros() const {
    ZX_ASSERT(ordinal() == Ordinal::kElapsedMicros);
    return *static_cast<int64_t*>(envelope_.data);
  }

  bool is_fps() const { return ordinal() == Ordinal::kFps; }

  static EventPayload WithFps(float* val) {
    EventPayload result;
    result.set_fps(val);
    return result;
  }

  void set_fps(float* elem) {
    ordinal_ = Ordinal::kFps;
    envelope_.data = static_cast<void*>(elem);
  }

  float& mutable_fps() {
    ZX_ASSERT(ordinal() == Ordinal::kFps);
    return *static_cast<float*>(envelope_.data);
  }
  const float& fps() const {
    ZX_ASSERT(ordinal() == Ordinal::kFps);
    return *static_cast<float*>(envelope_.data);
  }

  bool is_memory_bytes_used() const { return ordinal() == Ordinal::kMemoryBytesUsed; }

  static EventPayload WithMemoryBytesUsed(int64_t* val) {
    EventPayload result;
    result.set_memory_bytes_used(val);
    return result;
  }

  void set_memory_bytes_used(int64_t* elem) {
    ordinal_ = Ordinal::kMemoryBytesUsed;
    envelope_.data = static_cast<void*>(elem);
  }

  int64_t& mutable_memory_bytes_used() {
    ZX_ASSERT(ordinal() == Ordinal::kMemoryBytesUsed);
    return *static_cast<int64_t*>(envelope_.data);
  }
  const int64_t& memory_bytes_used() const {
    ZX_ASSERT(ordinal() == Ordinal::kMemoryBytesUsed);
    return *static_cast<int64_t*>(envelope_.data);
  }

  bool is_int_histogram() const { return ordinal() == Ordinal::kIntHistogram; }

  static EventPayload WithIntHistogram(::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>* val) {
    EventPayload result;
    result.set_int_histogram(val);
    return result;
  }

  void set_int_histogram(::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>* elem) {
    ordinal_ = Ordinal::kIntHistogram;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>& mutable_int_histogram() {
    ZX_ASSERT(ordinal() == Ordinal::kIntHistogram);
    return *static_cast<::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>*>(envelope_.data);
  }
  const ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>& int_histogram() const {
    ZX_ASSERT(ordinal() == Ordinal::kIntHistogram);
    return *static_cast<::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket>*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_EventPayloadTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8016;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kEvent = 1,  // 0x1
    kEventCount = 2,  // 0x2
    kElapsedMicros = 3,  // 0x3
    kFps = 4,  // 0x4
    kMemoryBytesUsed = 5,  // 0x5
    kIntHistogram = 7,  // 0x7
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_CustomEventValueTable;

// Logger Interface
struct CustomEventValue {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_CustomEventValueTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  ::fidl::StringView dimension_name = {};

  ::llcpp::fuchsia::cobalt::Value value = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerRequestSendSoonRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerRequestSendSoonResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerBlockUntilEmptyRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerBlockUntilEmptyResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumSendAttemptsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumSendAttemptsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetFailedSendAttemptsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetFailedSendAttemptsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumObservationsAddedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGetNumObservationsAddedResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsResponseTable;

class Controller final {
  Controller() = delete;
 public:
  static constexpr char Name[] = "fuchsia.cobalt.Controller";

  struct RequestSendSoonResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool success;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerRequestSendSoonResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using RequestSendSoonRequest = ::fidl::AnyZeroArgMessage;

  using BlockUntilEmptyResponse = ::fidl::AnyZeroArgMessage;
  struct BlockUntilEmptyRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t max_wait_seconds;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerBlockUntilEmptyRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct GetNumSendAttemptsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t num;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerGetNumSendAttemptsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetNumSendAttemptsRequest = ::fidl::AnyZeroArgMessage;

  struct GetFailedSendAttemptsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t num;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerGetFailedSendAttemptsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetFailedSendAttemptsRequest = ::fidl::AnyZeroArgMessage;

  struct GetNumObservationsAddedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t num_obs;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerGetNumObservationsAddedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetNumObservationsAddedRequest = ::fidl::AnyZeroArgMessage;

  struct GenerateAggregatedObservationsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint64_t> num_obs;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GenerateAggregatedObservationsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t day_index;
    ::fidl::VectorView<uint32_t> report_ids;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ControllerGenerateAggregatedObservationsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GenerateAggregatedObservationsResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class RequestSendSoon_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      RequestSendSoon_Impl(::zx::unowned_channel _client_end);
      ~RequestSendSoon_Impl() = default;
      RequestSendSoon_Impl(RequestSendSoon_Impl&& other) = default;
      RequestSendSoon_Impl& operator=(RequestSendSoon_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class BlockUntilEmpty_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      BlockUntilEmpty_Impl(::zx::unowned_channel _client_end, uint32_t max_wait_seconds);
      ~BlockUntilEmpty_Impl() = default;
      BlockUntilEmpty_Impl(BlockUntilEmpty_Impl&& other) = default;
      BlockUntilEmpty_Impl& operator=(BlockUntilEmpty_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetNumSendAttempts_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetNumSendAttempts_Impl(::zx::unowned_channel _client_end);
      ~GetNumSendAttempts_Impl() = default;
      GetNumSendAttempts_Impl(GetNumSendAttempts_Impl&& other) = default;
      GetNumSendAttempts_Impl& operator=(GetNumSendAttempts_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFailedSendAttempts_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetFailedSendAttempts_Impl(::zx::unowned_channel _client_end);
      ~GetFailedSendAttempts_Impl() = default;
      GetFailedSendAttempts_Impl(GetFailedSendAttempts_Impl&& other) = default;
      GetFailedSendAttempts_Impl& operator=(GetFailedSendAttempts_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetNumObservationsAdded_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetNumObservationsAdded_Impl(::zx::unowned_channel _client_end);
      ~GetNumObservationsAdded_Impl() = default;
      GetNumObservationsAdded_Impl(GetNumObservationsAdded_Impl&& other) = default;
      GetNumObservationsAdded_Impl& operator=(GetNumObservationsAdded_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GenerateAggregatedObservations_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GenerateAggregatedObservations_Impl(::zx::unowned_channel _client_end, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids);
      ~GenerateAggregatedObservations_Impl() = default;
      GenerateAggregatedObservations_Impl(GenerateAggregatedObservations_Impl&& other) = default;
      GenerateAggregatedObservations_Impl& operator=(GenerateAggregatedObservations_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using RequestSendSoon = RequestSendSoon_Impl<RequestSendSoonResponse>;
    using BlockUntilEmpty = BlockUntilEmpty_Impl<BlockUntilEmptyResponse>;
    using GetNumSendAttempts = GetNumSendAttempts_Impl<GetNumSendAttemptsResponse>;
    using GetFailedSendAttempts = GetFailedSendAttempts_Impl<GetFailedSendAttemptsResponse>;
    using GetNumObservationsAdded = GetNumObservationsAdded_Impl<GetNumObservationsAddedResponse>;
    using GenerateAggregatedObservations = GenerateAggregatedObservations_Impl<GenerateAggregatedObservationsResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class RequestSendSoon_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      RequestSendSoon_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~RequestSendSoon_Impl() = default;
      RequestSendSoon_Impl(RequestSendSoon_Impl&& other) = default;
      RequestSendSoon_Impl& operator=(RequestSendSoon_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class BlockUntilEmpty_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      BlockUntilEmpty_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer);
      ~BlockUntilEmpty_Impl() = default;
      BlockUntilEmpty_Impl(BlockUntilEmpty_Impl&& other) = default;
      BlockUntilEmpty_Impl& operator=(BlockUntilEmpty_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetNumSendAttempts_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetNumSendAttempts_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetNumSendAttempts_Impl() = default;
      GetNumSendAttempts_Impl(GetNumSendAttempts_Impl&& other) = default;
      GetNumSendAttempts_Impl& operator=(GetNumSendAttempts_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFailedSendAttempts_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetFailedSendAttempts_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetFailedSendAttempts_Impl() = default;
      GetFailedSendAttempts_Impl(GetFailedSendAttempts_Impl&& other) = default;
      GetFailedSendAttempts_Impl& operator=(GetFailedSendAttempts_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetNumObservationsAdded_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetNumObservationsAdded_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetNumObservationsAdded_Impl() = default;
      GetNumObservationsAdded_Impl(GetNumObservationsAdded_Impl&& other) = default;
      GetNumObservationsAdded_Impl& operator=(GetNumObservationsAdded_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GenerateAggregatedObservations_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GenerateAggregatedObservations_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer);
      ~GenerateAggregatedObservations_Impl() = default;
      GenerateAggregatedObservations_Impl(GenerateAggregatedObservations_Impl&& other) = default;
      GenerateAggregatedObservations_Impl& operator=(GenerateAggregatedObservations_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using RequestSendSoon = RequestSendSoon_Impl<RequestSendSoonResponse>;
    using BlockUntilEmpty = BlockUntilEmpty_Impl<BlockUntilEmptyResponse>;
    using GetNumSendAttempts = GetNumSendAttempts_Impl<GetNumSendAttemptsResponse>;
    using GetFailedSendAttempts = GetFailedSendAttempts_Impl<GetFailedSendAttemptsResponse>;
    using GetNumObservationsAdded = GetNumObservationsAdded_Impl<GetNumObservationsAddedResponse>;
    using GenerateAggregatedObservations = GenerateAggregatedObservations_Impl<GenerateAggregatedObservationsResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::RequestSendSoon RequestSendSoon();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::RequestSendSoon RequestSendSoon(::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::BlockUntilEmpty BlockUntilEmpty(uint32_t max_wait_seconds);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::BlockUntilEmpty BlockUntilEmpty(::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetNumSendAttempts GetNumSendAttempts();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetNumSendAttempts GetNumSendAttempts(::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetFailedSendAttempts GetFailedSendAttempts();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetFailedSendAttempts GetFailedSendAttempts(::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetNumObservationsAdded GetNumObservationsAdded();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetNumObservationsAdded GetNumObservationsAdded(::fidl::BytePart _response_buffer);

    // Request is heap-allocated. Response is heap-allocated.
    ResultOf::GenerateAggregatedObservations GenerateAggregatedObservations(uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GenerateAggregatedObservations GenerateAggregatedObservations(::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::RequestSendSoon RequestSendSoon(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::RequestSendSoon RequestSendSoon(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::BlockUntilEmpty BlockUntilEmpty(::zx::unowned_channel _client_end, uint32_t max_wait_seconds);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::BlockUntilEmpty BlockUntilEmpty(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t max_wait_seconds, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetNumSendAttempts GetNumSendAttempts(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetNumSendAttempts GetNumSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetFailedSendAttempts GetFailedSendAttempts(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetFailedSendAttempts GetFailedSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetNumObservationsAdded GetNumObservationsAdded(::zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetNumObservationsAdded GetNumObservationsAdded(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Request is heap-allocated. Response is heap-allocated.
    static ResultOf::GenerateAggregatedObservations GenerateAggregatedObservations(::zx::unowned_channel _client_end, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GenerateAggregatedObservations GenerateAggregatedObservations(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<RequestSendSoonResponse> RequestSendSoon(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<BlockUntilEmptyResponse> BlockUntilEmpty(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BlockUntilEmptyRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetNumSendAttemptsResponse> GetNumSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetFailedSendAttemptsResponse> GetFailedSendAttempts(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetNumObservationsAddedResponse> GetNumObservationsAdded(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GenerateAggregatedObservationsResponse> GenerateAggregatedObservations(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GenerateAggregatedObservationsRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Controller;
    using _Base = ::fidl::CompleterBase;

    class RequestSendSoonCompleterBase : public _Base {
     public:
      void Reply(bool success);
      void Reply(::fidl::BytePart _buffer, bool success);
      void Reply(::fidl::DecodedMessage<RequestSendSoonResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RequestSendSoonCompleter = ::fidl::Completer<RequestSendSoonCompleterBase>;

    virtual void RequestSendSoon(RequestSendSoonCompleter::Sync _completer) = 0;

    class BlockUntilEmptyCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BlockUntilEmptyCompleter = ::fidl::Completer<BlockUntilEmptyCompleterBase>;

    virtual void BlockUntilEmpty(uint32_t max_wait_seconds, BlockUntilEmptyCompleter::Sync _completer) = 0;

    class GetNumSendAttemptsCompleterBase : public _Base {
     public:
      void Reply(uint32_t num);
      void Reply(::fidl::BytePart _buffer, uint32_t num);
      void Reply(::fidl::DecodedMessage<GetNumSendAttemptsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetNumSendAttemptsCompleter = ::fidl::Completer<GetNumSendAttemptsCompleterBase>;

    virtual void GetNumSendAttempts(GetNumSendAttemptsCompleter::Sync _completer) = 0;

    class GetFailedSendAttemptsCompleterBase : public _Base {
     public:
      void Reply(uint32_t num);
      void Reply(::fidl::BytePart _buffer, uint32_t num);
      void Reply(::fidl::DecodedMessage<GetFailedSendAttemptsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetFailedSendAttemptsCompleter = ::fidl::Completer<GetFailedSendAttemptsCompleterBase>;

    virtual void GetFailedSendAttempts(GetFailedSendAttemptsCompleter::Sync _completer) = 0;

    class GetNumObservationsAddedCompleterBase : public _Base {
     public:
      void Reply(uint64_t num_obs);
      void Reply(::fidl::BytePart _buffer, uint64_t num_obs);
      void Reply(::fidl::DecodedMessage<GetNumObservationsAddedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetNumObservationsAddedCompleter = ::fidl::Completer<GetNumObservationsAddedCompleterBase>;

    virtual void GetNumObservationsAdded(GetNumObservationsAddedCompleter::Sync _completer) = 0;

    class GenerateAggregatedObservationsCompleterBase : public _Base {
     public:
      void Reply(::fidl::VectorView<uint64_t> num_obs);
      void Reply(::fidl::BytePart _buffer, ::fidl::VectorView<uint64_t> num_obs);
      void Reply(::fidl::DecodedMessage<GenerateAggregatedObservationsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GenerateAggregatedObservationsCompleter = ::fidl::Completer<GenerateAggregatedObservationsCompleterBase>;

    virtual void GenerateAggregatedObservations(uint32_t day_index, ::fidl::VectorView<uint32_t> report_ids, GenerateAggregatedObservationsCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void RequestSendSoonRequest(const ::fidl::DecodedMessage<Controller::RequestSendSoonRequest>& _msg);
    static void RequestSendSoonResponse(const ::fidl::DecodedMessage<Controller::RequestSendSoonResponse>& _msg);
    static void BlockUntilEmptyRequest(const ::fidl::DecodedMessage<Controller::BlockUntilEmptyRequest>& _msg);
    static void BlockUntilEmptyResponse(const ::fidl::DecodedMessage<Controller::BlockUntilEmptyResponse>& _msg);
    static void GetNumSendAttemptsRequest(const ::fidl::DecodedMessage<Controller::GetNumSendAttemptsRequest>& _msg);
    static void GetNumSendAttemptsResponse(const ::fidl::DecodedMessage<Controller::GetNumSendAttemptsResponse>& _msg);
    static void GetFailedSendAttemptsRequest(const ::fidl::DecodedMessage<Controller::GetFailedSendAttemptsRequest>& _msg);
    static void GetFailedSendAttemptsResponse(const ::fidl::DecodedMessage<Controller::GetFailedSendAttemptsResponse>& _msg);
    static void GetNumObservationsAddedRequest(const ::fidl::DecodedMessage<Controller::GetNumObservationsAddedRequest>& _msg);
    static void GetNumObservationsAddedResponse(const ::fidl::DecodedMessage<Controller::GetNumObservationsAddedResponse>& _msg);
    static void GenerateAggregatedObservationsRequest(const ::fidl::DecodedMessage<Controller::GenerateAggregatedObservationsRequest>& _msg);
    static void GenerateAggregatedObservationsResponse(const ::fidl::DecodedMessage<Controller::GenerateAggregatedObservationsResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogEventCountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogFrameRateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseStartTimerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerBaseEndTimerResponseTable;

// LoggerBase Interface
class LoggerBase final {
  LoggerBase() = delete;
 public:

  struct LogEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventResponse;
  };

  struct LogEventCountResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogEventCountResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventCountRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t period_duration_micros;
    int64_t count;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogEventCountRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventCountResponse;
  };

  struct LogElapsedTimeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogElapsedTimeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t elapsed_micros;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogElapsedTimeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogElapsedTimeResponse;
  };

  struct LogFrameRateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogFrameRateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogFrameRateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    float fps;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogFrameRateRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogFrameRateResponse;
  };

  struct LogMemoryUsageResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogMemoryUsageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t bytes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseLogMemoryUsageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogMemoryUsageResponse;
  };

  struct StartTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseStartTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct StartTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseStartTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = StartTimerResponse;
  };

  struct EndTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseEndTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct EndTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerBaseEndTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = EndTimerResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEvent LogEvent(uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEvent LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEventCount LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEventCount LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogElapsedTime LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogElapsedTime LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogFrameRate LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogFrameRate LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogMemoryUsage LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogMemoryUsage LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::StartTimer StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::StartTimer StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::EndTimer EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::EndTimer EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<LogEventResponse> LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogEventCountResponse> LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogElapsedTimeResponse> LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogFrameRateResponse> LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogMemoryUsageResponse> LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<StartTimerResponse> StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<EndTimerResponse> EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = LoggerBase;
    using _Base = ::fidl::CompleterBase;

    class LogEventCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCompleter = ::fidl::Completer<LogEventCompleterBase>;

    virtual void LogEvent(uint32_t metric_id, uint32_t event_code, LogEventCompleter::Sync _completer) = 0;

    class LogEventCountCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventCountResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCountCompleter = ::fidl::Completer<LogEventCountCompleterBase>;

    virtual void LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, LogEventCountCompleter::Sync _completer) = 0;

    class LogElapsedTimeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogElapsedTimeCompleter = ::fidl::Completer<LogElapsedTimeCompleterBase>;

    virtual void LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, LogElapsedTimeCompleter::Sync _completer) = 0;

    class LogFrameRateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogFrameRateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogFrameRateCompleter = ::fidl::Completer<LogFrameRateCompleterBase>;

    virtual void LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, LogFrameRateCompleter::Sync _completer) = 0;

    class LogMemoryUsageCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogMemoryUsageCompleter = ::fidl::Completer<LogMemoryUsageCompleterBase>;

    virtual void LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, LogMemoryUsageCompleter::Sync _completer) = 0;

    class StartTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<StartTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartTimerCompleter = ::fidl::Completer<StartTimerCompleterBase>;

    virtual void StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, StartTimerCompleter::Sync _completer) = 0;

    class EndTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<EndTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using EndTimerCompleter = ::fidl::Completer<EndTimerCompleterBase>;

    virtual void EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, EndTimerCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void LogEventRequest(const ::fidl::DecodedMessage<LoggerBase::LogEventRequest>& _msg);
    static void LogEventResponse(const ::fidl::DecodedMessage<LoggerBase::LogEventResponse>& _msg);
    static void LogEventCountRequest(const ::fidl::DecodedMessage<LoggerBase::LogEventCountRequest>& _msg);
    static void LogEventCountResponse(const ::fidl::DecodedMessage<LoggerBase::LogEventCountResponse>& _msg);
    static void LogElapsedTimeRequest(const ::fidl::DecodedMessage<LoggerBase::LogElapsedTimeRequest>& _msg);
    static void LogElapsedTimeResponse(const ::fidl::DecodedMessage<LoggerBase::LogElapsedTimeResponse>& _msg);
    static void LogFrameRateRequest(const ::fidl::DecodedMessage<LoggerBase::LogFrameRateRequest>& _msg);
    static void LogFrameRateResponse(const ::fidl::DecodedMessage<LoggerBase::LogFrameRateResponse>& _msg);
    static void LogMemoryUsageRequest(const ::fidl::DecodedMessage<LoggerBase::LogMemoryUsageRequest>& _msg);
    static void LogMemoryUsageResponse(const ::fidl::DecodedMessage<LoggerBase::LogMemoryUsageResponse>& _msg);
    static void StartTimerRequest(const ::fidl::DecodedMessage<LoggerBase::StartTimerRequest>& _msg);
    static void StartTimerResponse(const ::fidl::DecodedMessage<LoggerBase::StartTimerResponse>& _msg);
    static void EndTimerRequest(const ::fidl::DecodedMessage<LoggerBase::EndTimerRequest>& _msg);
    static void EndTimerResponse(const ::fidl::DecodedMessage<LoggerBase::EndTimerResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogEventCountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogFrameRateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleStartTimerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleEndTimerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramResponseTable;

// LoggerSimple Interface
class LoggerSimple final {
  LoggerSimple() = delete;
 public:

  struct LogEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventResponse;
  };

  struct LogEventCountResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogEventCountResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventCountRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t period_duration_micros;
    int64_t count;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogEventCountRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventCountResponse;
  };

  struct LogElapsedTimeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogElapsedTimeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t elapsed_micros;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogElapsedTimeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogElapsedTimeResponse;
  };

  struct LogFrameRateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogFrameRateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogFrameRateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    float fps;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogFrameRateRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogFrameRateResponse;
  };

  struct LogMemoryUsageResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogMemoryUsageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t bytes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogMemoryUsageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogMemoryUsageResponse;
  };

  struct StartTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleStartTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct StartTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleStartTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = StartTimerResponse;
  };

  struct EndTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleEndTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct EndTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleEndTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = EndTimerResponse;
  };

  struct LogIntHistogramResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogIntHistogramRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    ::fidl::VectorView<uint32_t> bucket_indices;
    ::fidl::VectorView<uint64_t> bucket_counts;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerSimpleLogIntHistogramRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 6064;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 6064;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogIntHistogramResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogIntHistogram_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogIntHistogram_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts);
      ~LogIntHistogram_Impl() = default;
      LogIntHistogram_Impl(LogIntHistogram_Impl&& other) = default;
      LogIntHistogram_Impl& operator=(LogIntHistogram_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
    using LogIntHistogram = LogIntHistogram_Impl<LogIntHistogramResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogIntHistogram_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogIntHistogram_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer);
      ~LogIntHistogram_Impl() = default;
      LogIntHistogram_Impl(LogIntHistogram_Impl&& other) = default;
      LogIntHistogram_Impl& operator=(LogIntHistogram_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
    using LogIntHistogram = LogIntHistogram_Impl<LogIntHistogramResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEvent LogEvent(uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEvent LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEventCount LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEventCount LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogElapsedTime LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogElapsedTime LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogFrameRate LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogFrameRate LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogMemoryUsage LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogMemoryUsage LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::StartTimer StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::StartTimer StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::EndTimer EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::EndTimer EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::LogIntHistogram LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogIntHistogram LogIntHistogram(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::LogIntHistogram LogIntHistogram(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogIntHistogram LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<LogEventResponse> LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogEventCountResponse> LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogElapsedTimeResponse> LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogFrameRateResponse> LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogMemoryUsageResponse> LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<StartTimerResponse> StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<EndTimerResponse> EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogIntHistogramResponse> LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogIntHistogramRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = LoggerSimple;
    using _Base = ::fidl::CompleterBase;

    class LogEventCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCompleter = ::fidl::Completer<LogEventCompleterBase>;

    virtual void LogEvent(uint32_t metric_id, uint32_t event_code, LogEventCompleter::Sync _completer) = 0;

    class LogEventCountCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventCountResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCountCompleter = ::fidl::Completer<LogEventCountCompleterBase>;

    virtual void LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, LogEventCountCompleter::Sync _completer) = 0;

    class LogElapsedTimeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogElapsedTimeCompleter = ::fidl::Completer<LogElapsedTimeCompleterBase>;

    virtual void LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, LogElapsedTimeCompleter::Sync _completer) = 0;

    class LogFrameRateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogFrameRateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogFrameRateCompleter = ::fidl::Completer<LogFrameRateCompleterBase>;

    virtual void LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, LogFrameRateCompleter::Sync _completer) = 0;

    class LogMemoryUsageCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogMemoryUsageCompleter = ::fidl::Completer<LogMemoryUsageCompleterBase>;

    virtual void LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, LogMemoryUsageCompleter::Sync _completer) = 0;

    class StartTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<StartTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartTimerCompleter = ::fidl::Completer<StartTimerCompleterBase>;

    virtual void StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, StartTimerCompleter::Sync _completer) = 0;

    class EndTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<EndTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using EndTimerCompleter = ::fidl::Completer<EndTimerCompleterBase>;

    virtual void EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, EndTimerCompleter::Sync _completer) = 0;

    class LogIntHistogramCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogIntHistogramResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogIntHistogramCompleter = ::fidl::Completer<LogIntHistogramCompleterBase>;

    virtual void LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<uint32_t> bucket_indices, ::fidl::VectorView<uint64_t> bucket_counts, LogIntHistogramCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void LogEventRequest(const ::fidl::DecodedMessage<LoggerSimple::LogEventRequest>& _msg);
    static void LogEventResponse(const ::fidl::DecodedMessage<LoggerSimple::LogEventResponse>& _msg);
    static void LogEventCountRequest(const ::fidl::DecodedMessage<LoggerSimple::LogEventCountRequest>& _msg);
    static void LogEventCountResponse(const ::fidl::DecodedMessage<LoggerSimple::LogEventCountResponse>& _msg);
    static void LogElapsedTimeRequest(const ::fidl::DecodedMessage<LoggerSimple::LogElapsedTimeRequest>& _msg);
    static void LogElapsedTimeResponse(const ::fidl::DecodedMessage<LoggerSimple::LogElapsedTimeResponse>& _msg);
    static void LogFrameRateRequest(const ::fidl::DecodedMessage<LoggerSimple::LogFrameRateRequest>& _msg);
    static void LogFrameRateResponse(const ::fidl::DecodedMessage<LoggerSimple::LogFrameRateResponse>& _msg);
    static void LogMemoryUsageRequest(const ::fidl::DecodedMessage<LoggerSimple::LogMemoryUsageRequest>& _msg);
    static void LogMemoryUsageResponse(const ::fidl::DecodedMessage<LoggerSimple::LogMemoryUsageResponse>& _msg);
    static void StartTimerRequest(const ::fidl::DecodedMessage<LoggerSimple::StartTimerRequest>& _msg);
    static void StartTimerResponse(const ::fidl::DecodedMessage<LoggerSimple::StartTimerResponse>& _msg);
    static void EndTimerRequest(const ::fidl::DecodedMessage<LoggerSimple::EndTimerRequest>& _msg);
    static void EndTimerResponse(const ::fidl::DecodedMessage<LoggerSimple::EndTimerResponse>& _msg);
    static void LogIntHistogramRequest(const ::fidl::DecodedMessage<LoggerSimple::LogIntHistogramRequest>& _msg);
    static void LogIntHistogramResponse(const ::fidl::DecodedMessage<LoggerSimple::LogIntHistogramResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_ProjectProfileTable;

struct ProjectProfile {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ProjectProfileTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::llcpp::fuchsia::mem::Buffer config = {};

  ::llcpp::fuchsia::cobalt::ReleaseStage release_stage = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdResponseTable;

class LoggerFactory final {
  LoggerFactory() = delete;
 public:
  static constexpr char Name[] = "fuchsia.cobalt.LoggerFactory";

  struct CreateLoggerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CreateLoggerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::ProjectProfile profile;
    ::zx::channel logger;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CreateLoggerResponse;
  };

  struct CreateLoggerSimpleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CreateLoggerSimpleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::ProjectProfile profile;
    ::zx::channel logger;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CreateLoggerSimpleResponse;
  };

  struct CreateLoggerFromProjectIdResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CreateLoggerFromProjectIdRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t project_id;
    ::zx::channel logger;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerFromProjectIdRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CreateLoggerFromProjectIdResponse;
  };

  struct CreateLoggerSimpleFromProjectIdResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CreateLoggerSimpleFromProjectIdRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t project_id;
    ::zx::channel logger;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerFactoryCreateLoggerSimpleFromProjectIdRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CreateLoggerSimpleFromProjectIdResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class CreateLogger_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateLogger_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);
      ~CreateLogger_Impl() = default;
      CreateLogger_Impl(CreateLogger_Impl&& other) = default;
      CreateLogger_Impl& operator=(CreateLogger_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerSimple_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateLoggerSimple_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);
      ~CreateLoggerSimple_Impl() = default;
      CreateLoggerSimple_Impl(CreateLoggerSimple_Impl&& other) = default;
      CreateLoggerSimple_Impl& operator=(CreateLoggerSimple_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerFromProjectId_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateLoggerFromProjectId_Impl(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger);
      ~CreateLoggerFromProjectId_Impl() = default;
      CreateLoggerFromProjectId_Impl(CreateLoggerFromProjectId_Impl&& other) = default;
      CreateLoggerFromProjectId_Impl& operator=(CreateLoggerFromProjectId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerSimpleFromProjectId_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateLoggerSimpleFromProjectId_Impl(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger);
      ~CreateLoggerSimpleFromProjectId_Impl() = default;
      CreateLoggerSimpleFromProjectId_Impl(CreateLoggerSimpleFromProjectId_Impl&& other) = default;
      CreateLoggerSimpleFromProjectId_Impl& operator=(CreateLoggerSimpleFromProjectId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using CreateLogger = CreateLogger_Impl<CreateLoggerResponse>;
    using CreateLoggerSimple = CreateLoggerSimple_Impl<CreateLoggerSimpleResponse>;
    using CreateLoggerFromProjectId = CreateLoggerFromProjectId_Impl<CreateLoggerFromProjectIdResponse>;
    using CreateLoggerSimpleFromProjectId = CreateLoggerSimpleFromProjectId_Impl<CreateLoggerSimpleFromProjectIdResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class CreateLogger_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateLogger_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);
      ~CreateLogger_Impl() = default;
      CreateLogger_Impl(CreateLogger_Impl&& other) = default;
      CreateLogger_Impl& operator=(CreateLogger_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerSimple_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateLoggerSimple_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);
      ~CreateLoggerSimple_Impl() = default;
      CreateLoggerSimple_Impl(CreateLoggerSimple_Impl&& other) = default;
      CreateLoggerSimple_Impl& operator=(CreateLoggerSimple_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerFromProjectId_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateLoggerFromProjectId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);
      ~CreateLoggerFromProjectId_Impl() = default;
      CreateLoggerFromProjectId_Impl(CreateLoggerFromProjectId_Impl&& other) = default;
      CreateLoggerFromProjectId_Impl& operator=(CreateLoggerFromProjectId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateLoggerSimpleFromProjectId_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateLoggerSimpleFromProjectId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);
      ~CreateLoggerSimpleFromProjectId_Impl() = default;
      CreateLoggerSimpleFromProjectId_Impl(CreateLoggerSimpleFromProjectId_Impl&& other) = default;
      CreateLoggerSimpleFromProjectId_Impl& operator=(CreateLoggerSimpleFromProjectId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using CreateLogger = CreateLogger_Impl<CreateLoggerResponse>;
    using CreateLoggerSimple = CreateLoggerSimple_Impl<CreateLoggerSimpleResponse>;
    using CreateLoggerFromProjectId = CreateLoggerFromProjectId_Impl<CreateLoggerFromProjectIdResponse>;
    using CreateLoggerSimpleFromProjectId = CreateLoggerSimpleFromProjectId_Impl<CreateLoggerSimpleFromProjectIdResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateLogger CreateLogger(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateLogger CreateLogger(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateLoggerSimple CreateLoggerSimple(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateLoggerSimple CreateLoggerSimple(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateLoggerFromProjectId CreateLoggerFromProjectId(uint32_t project_id, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateLoggerFromProjectId CreateLoggerFromProjectId(::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateLoggerSimpleFromProjectId CreateLoggerSimpleFromProjectId(uint32_t project_id, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateLoggerSimpleFromProjectId CreateLoggerSimpleFromProjectId(::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateLogger CreateLogger(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateLogger CreateLogger(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateLoggerSimple CreateLoggerSimple(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateLoggerSimple CreateLoggerSimple(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateLoggerFromProjectId CreateLoggerFromProjectId(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateLoggerFromProjectId CreateLoggerFromProjectId(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateLoggerSimpleFromProjectId CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, uint32_t project_id, ::zx::channel logger);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateLoggerSimpleFromProjectId CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t project_id, ::zx::channel logger, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<CreateLoggerResponse> CreateLogger(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<CreateLoggerSimpleResponse> CreateLoggerSimple(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerSimpleRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<CreateLoggerFromProjectIdResponse> CreateLoggerFromProjectId(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerFromProjectIdRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<CreateLoggerSimpleFromProjectIdResponse> CreateLoggerSimpleFromProjectId(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = LoggerFactory;
    using _Base = ::fidl::CompleterBase;

    class CreateLoggerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<CreateLoggerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateLoggerCompleter = ::fidl::Completer<CreateLoggerCompleterBase>;

    virtual void CreateLogger(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, CreateLoggerCompleter::Sync _completer) = 0;

    class CreateLoggerSimpleCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<CreateLoggerSimpleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateLoggerSimpleCompleter = ::fidl::Completer<CreateLoggerSimpleCompleterBase>;

    virtual void CreateLoggerSimple(::llcpp::fuchsia::cobalt::ProjectProfile profile, ::zx::channel logger, CreateLoggerSimpleCompleter::Sync _completer) = 0;

    class CreateLoggerFromProjectIdCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<CreateLoggerFromProjectIdResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateLoggerFromProjectIdCompleter = ::fidl::Completer<CreateLoggerFromProjectIdCompleterBase>;

    virtual void CreateLoggerFromProjectId(uint32_t project_id, ::zx::channel logger, CreateLoggerFromProjectIdCompleter::Sync _completer) = 0;

    class CreateLoggerSimpleFromProjectIdCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<CreateLoggerSimpleFromProjectIdResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateLoggerSimpleFromProjectIdCompleter = ::fidl::Completer<CreateLoggerSimpleFromProjectIdCompleterBase>;

    virtual void CreateLoggerSimpleFromProjectId(uint32_t project_id, ::zx::channel logger, CreateLoggerSimpleFromProjectIdCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CreateLoggerRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerRequest>& _msg);
    static void CreateLoggerResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerResponse>& _msg);
    static void CreateLoggerSimpleRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleRequest>& _msg);
    static void CreateLoggerSimpleResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleResponse>& _msg);
    static void CreateLoggerFromProjectIdRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerFromProjectIdRequest>& _msg);
    static void CreateLoggerFromProjectIdResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerFromProjectIdResponse>& _msg);
    static void CreateLoggerSimpleFromProjectIdRequest(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleFromProjectIdRequest>& _msg);
    static void CreateLoggerSimpleFromProjectIdResponse(const ::fidl::DecodedMessage<LoggerFactory::CreateLoggerSimpleFromProjectIdResponse>& _msg);
  };
};

constexpr uint32_t MAX_TIMER_ID_LENGTH = 64u;

constexpr uint32_t MAX_HISTOGRAM_BUCKETS = 500u;

constexpr uint32_t MAX_EVENT_CODE_COUNT = 5u;

constexpr uint32_t MAX_COMPONENT_LENGTH = 64u;

constexpr uint32_t MAX_CHANNEL_NAME_LENGTH = 256u;

constexpr int64_t MAX_BYTES_PER_EVENT = 102400u;

constexpr uint32_t MAX_BATCHED_EVENTS = 64u;

extern "C" const fidl_type_t v1_fuchsia_cobalt_HistogramBucketTable;

struct HistogramBucket {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_HistogramBucketTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t index = {};

  uint64_t count = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_ExperimentTable;

// SystemProfileUpdater Interface
struct Experiment {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_ExperimentTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint64_t experiment_id = {};

  uint32_t arm_id = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetChannelRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_SystemDataUpdaterSetChannelResponseTable;

class SystemDataUpdater final {
  SystemDataUpdater() = delete;
 public:
  static constexpr char Name[] = "fuchsia.cobalt.SystemDataUpdater";

  struct SetExperimentStateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetExperimentStateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_SystemDataUpdaterSetExperimentStateRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetExperimentStateResponse;
  };

  struct SetChannelResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_SystemDataUpdaterSetChannelResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetChannelRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView current_channel;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_SystemDataUpdaterSetChannelRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 256;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 256;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetChannelResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class SetExperimentState_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetExperimentState_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments);
      ~SetExperimentState_Impl() = default;
      SetExperimentState_Impl(SetExperimentState_Impl&& other) = default;
      SetExperimentState_Impl& operator=(SetExperimentState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetChannel_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::StringView current_channel);
      ~SetChannel_Impl() = default;
      SetChannel_Impl(SetChannel_Impl&& other) = default;
      SetChannel_Impl& operator=(SetChannel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using SetExperimentState = SetExperimentState_Impl<SetExperimentStateResponse>;
    using SetChannel = SetChannel_Impl<SetChannelResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class SetExperimentState_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetExperimentState_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer);
      ~SetExperimentState_Impl() = default;
      SetExperimentState_Impl(SetExperimentState_Impl&& other) = default;
      SetExperimentState_Impl& operator=(SetExperimentState_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetChannel_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetChannel_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer);
      ~SetChannel_Impl() = default;
      SetChannel_Impl(SetChannel_Impl&& other) = default;
      SetChannel_Impl& operator=(SetChannel_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using SetExperimentState = SetExperimentState_Impl<SetExperimentStateResponse>;
    using SetChannel = SetChannel_Impl<SetChannelResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetExperimentState SetExperimentState(::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetExperimentState SetExperimentState(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer);

    // Allocates 312 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetChannel SetChannel(::fidl::StringView current_channel);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetChannel SetChannel(::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetExperimentState SetExperimentState(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetExperimentState SetExperimentState(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, ::fidl::BytePart _response_buffer);

    // Allocates 312 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetChannel SetChannel(::zx::unowned_channel _client_end, ::fidl::StringView current_channel);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetChannel SetChannel(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView current_channel, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<SetExperimentStateResponse> SetExperimentState(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetExperimentStateRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<SetChannelResponse> SetChannel(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetChannelRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = SystemDataUpdater;
    using _Base = ::fidl::CompleterBase;

    class SetExperimentStateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<SetExperimentStateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetExperimentStateCompleter = ::fidl::Completer<SetExperimentStateCompleterBase>;

    virtual void SetExperimentState(::fidl::VectorView<::llcpp::fuchsia::cobalt::Experiment> experiments, SetExperimentStateCompleter::Sync _completer) = 0;

    class SetChannelCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<SetChannelResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetChannelCompleter = ::fidl::Completer<SetChannelCompleterBase>;

    virtual void SetChannel(::fidl::StringView current_channel, SetChannelCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void SetExperimentStateRequest(const ::fidl::DecodedMessage<SystemDataUpdater::SetExperimentStateRequest>& _msg);
    static void SetExperimentStateResponse(const ::fidl::DecodedMessage<SystemDataUpdater::SetExperimentStateResponse>& _msg);
    static void SetChannelRequest(const ::fidl::DecodedMessage<SystemDataUpdater::SetChannelRequest>& _msg);
    static void SetChannelResponse(const ::fidl::DecodedMessage<SystemDataUpdater::SetChannelResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_EventTable;

struct Event {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_EventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_CountEventTable;

struct CountEvent {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_CountEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int64_t period_duration_micros = {};

  int64_t count = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_CobaltEventTable;

struct CobaltEvent {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_CobaltEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 64;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8104;

  uint32_t metric_id = {};

  ::fidl::VectorView<uint32_t> event_codes = {};

  ::fidl::StringView component = {};

  ::llcpp::fuchsia::cobalt::EventPayload payload = {};
};

extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventCountRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogEventCountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogElapsedTimeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogElapsedTimeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogFrameRateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogFrameRateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogMemoryUsageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogMemoryUsageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerStartTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerStartTimerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerEndTimerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerEndTimerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogIntHistogramRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogIntHistogramResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCustomEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCustomEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_cobalt_LoggerLogCobaltEventsResponseTable;

class Logger final {
  Logger() = delete;
 public:

  struct LogEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventResponse;
  };

  struct LogEventCountResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogEventCountResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogEventCountRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t period_duration_micros;
    int64_t count;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogEventCountRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogEventCountResponse;
  };

  struct LogElapsedTimeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogElapsedTimeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogElapsedTimeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t elapsed_micros;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogElapsedTimeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogElapsedTimeResponse;
  };

  struct LogFrameRateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogFrameRateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogFrameRateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    float fps;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogFrameRateRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogFrameRateResponse;
  };

  struct LogMemoryUsageResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogMemoryUsageResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogMemoryUsageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    int64_t bytes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogMemoryUsageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogMemoryUsageResponse;
  };

  struct StartTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerStartTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct StartTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerStartTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = StartTimerResponse;
  };

  struct EndTimerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerEndTimerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct EndTimerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView timer_id;
    uint64_t timestamp;
    uint32_t timeout_s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerEndTimerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 64;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 64;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = EndTimerResponse;
  };

  struct LogIntHistogramResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogIntHistogramResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogIntHistogramRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    uint32_t event_code;
    ::fidl::StringView component;
    ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogIntHistogramRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8064;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 8064;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogIntHistogramResponse;
  };

  struct LogCustomEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCustomEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogCustomEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t metric_id;
    ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCustomEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogCustomEventResponse;
  };

  struct LogCobaltEventResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCobaltEventResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogCobaltEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::CobaltEvent event;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCobaltEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 8104;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 8104;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogCobaltEventResponse;
  };

  struct LogCobaltEventsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::cobalt::Status status;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCobaltEventsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LogCobaltEventsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_cobalt_LoggerLogCobaltEventsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 522752;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 522752;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LogCobaltEventsResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogIntHistogram_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogIntHistogram_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram);
      ~LogIntHistogram_Impl() = default;
      LogIntHistogram_Impl(LogIntHistogram_Impl&& other) = default;
      LogIntHistogram_Impl& operator=(LogIntHistogram_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCustomEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogCustomEvent_Impl(::zx::unowned_channel _client_end, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values);
      ~LogCustomEvent_Impl() = default;
      LogCustomEvent_Impl(LogCustomEvent_Impl&& other) = default;
      LogCustomEvent_Impl& operator=(LogCustomEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCobaltEvent_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogCobaltEvent_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::CobaltEvent event);
      ~LogCobaltEvent_Impl() = default;
      LogCobaltEvent_Impl(LogCobaltEvent_Impl&& other) = default;
      LogCobaltEvent_Impl& operator=(LogCobaltEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCobaltEvents_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LogCobaltEvents_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events);
      ~LogCobaltEvents_Impl() = default;
      LogCobaltEvents_Impl(LogCobaltEvents_Impl&& other) = default;
      LogCobaltEvents_Impl& operator=(LogCobaltEvents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
    using LogIntHistogram = LogIntHistogram_Impl<LogIntHistogramResponse>;
    using LogCustomEvent = LogCustomEvent_Impl<LogCustomEventResponse>;
    using LogCobaltEvent = LogCobaltEvent_Impl<LogCobaltEventResponse>;
    using LogCobaltEvents = LogCobaltEvents_Impl<LogCobaltEventsResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class LogEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);
      ~LogEvent_Impl() = default;
      LogEvent_Impl(LogEvent_Impl&& other) = default;
      LogEvent_Impl& operator=(LogEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogEventCount_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogEventCount_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);
      ~LogEventCount_Impl() = default;
      LogEventCount_Impl(LogEventCount_Impl&& other) = default;
      LogEventCount_Impl& operator=(LogEventCount_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogElapsedTime_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogElapsedTime_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);
      ~LogElapsedTime_Impl() = default;
      LogElapsedTime_Impl(LogElapsedTime_Impl&& other) = default;
      LogElapsedTime_Impl& operator=(LogElapsedTime_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogFrameRate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogFrameRate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);
      ~LogFrameRate_Impl() = default;
      LogFrameRate_Impl(LogFrameRate_Impl&& other) = default;
      LogFrameRate_Impl& operator=(LogFrameRate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogMemoryUsage_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogMemoryUsage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);
      ~LogMemoryUsage_Impl() = default;
      LogMemoryUsage_Impl(LogMemoryUsage_Impl&& other) = default;
      LogMemoryUsage_Impl& operator=(LogMemoryUsage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      StartTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~StartTimer_Impl() = default;
      StartTimer_Impl(StartTimer_Impl&& other) = default;
      StartTimer_Impl& operator=(StartTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class EndTimer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      EndTimer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);
      ~EndTimer_Impl() = default;
      EndTimer_Impl(EndTimer_Impl&& other) = default;
      EndTimer_Impl& operator=(EndTimer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogIntHistogram_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogIntHistogram_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer);
      ~LogIntHistogram_Impl() = default;
      LogIntHistogram_Impl(LogIntHistogram_Impl&& other) = default;
      LogIntHistogram_Impl& operator=(LogIntHistogram_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCustomEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogCustomEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer);
      ~LogCustomEvent_Impl() = default;
      LogCustomEvent_Impl(LogCustomEvent_Impl&& other) = default;
      LogCustomEvent_Impl& operator=(LogCustomEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCobaltEvent_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogCobaltEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer);
      ~LogCobaltEvent_Impl() = default;
      LogCobaltEvent_Impl(LogCobaltEvent_Impl&& other) = default;
      LogCobaltEvent_Impl& operator=(LogCobaltEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LogCobaltEvents_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LogCobaltEvents_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer);
      ~LogCobaltEvents_Impl() = default;
      LogCobaltEvents_Impl(LogCobaltEvents_Impl&& other) = default;
      LogCobaltEvents_Impl& operator=(LogCobaltEvents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LogEvent = LogEvent_Impl<LogEventResponse>;
    using LogEventCount = LogEventCount_Impl<LogEventCountResponse>;
    using LogElapsedTime = LogElapsedTime_Impl<LogElapsedTimeResponse>;
    using LogFrameRate = LogFrameRate_Impl<LogFrameRateResponse>;
    using LogMemoryUsage = LogMemoryUsage_Impl<LogMemoryUsageResponse>;
    using StartTimer = StartTimer_Impl<StartTimerResponse>;
    using EndTimer = EndTimer_Impl<EndTimerResponse>;
    using LogIntHistogram = LogIntHistogram_Impl<LogIntHistogramResponse>;
    using LogCustomEvent = LogCustomEvent_Impl<LogCustomEventResponse>;
    using LogCobaltEvent = LogCobaltEvent_Impl<LogCobaltEventResponse>;
    using LogCobaltEvents = LogCobaltEvents_Impl<LogCobaltEventsResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEvent LogEvent(uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEvent LogEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogEventCount LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogEventCount LogEventCount(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogElapsedTime LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogElapsedTime LogElapsedTime(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogFrameRate LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogFrameRate LogFrameRate(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LogMemoryUsage LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogMemoryUsage LogMemoryUsage(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::StartTimer StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::StartTimer StartTimer(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::EndTimer EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::EndTimer EndTimer(::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::LogIntHistogram LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogIntHistogram LogIntHistogram(::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::LogCustomEvent LogCustomEvent(uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogCustomEvent LogCustomEvent(::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::LogCobaltEvent LogCobaltEvent(::llcpp::fuchsia::cobalt::CobaltEvent event);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogCobaltEvent LogCobaltEvent(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::LogCobaltEvents LogCobaltEvents(::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LogCobaltEvents LogCobaltEvents(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEvent LogEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::BytePart _response_buffer);

    // Allocates 144 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogEventCount LogEventCount(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogElapsedTime LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogFrameRate LogFrameRate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogMemoryUsage LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, ::fidl::BytePart _response_buffer);

    // Allocates 224 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::StartTimer StartTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 136 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::EndTimer EndTimer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::LogIntHistogram LogIntHistogram(::zx::unowned_channel _client_end, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogIntHistogram LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::LogCustomEvent LogCustomEvent(::zx::unowned_channel _client_end, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogCustomEvent LogCustomEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::LogCobaltEvent LogCobaltEvent(::zx::unowned_channel _client_end, ::llcpp::fuchsia::cobalt::CobaltEvent event);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogCobaltEvent LogCobaltEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::cobalt::CobaltEvent event, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::LogCobaltEvents LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LogCobaltEvents LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<LogEventResponse> LogEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogEventCountResponse> LogEventCount(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogEventCountRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogElapsedTimeResponse> LogElapsedTime(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogElapsedTimeRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogFrameRateResponse> LogFrameRate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogFrameRateRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogMemoryUsageResponse> LogMemoryUsage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogMemoryUsageRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<StartTimerResponse> StartTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartTimerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<EndTimerResponse> EndTimer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EndTimerRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogIntHistogramResponse> LogIntHistogram(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogIntHistogramRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogCustomEventResponse> LogCustomEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCustomEventRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogCobaltEventResponse> LogCobaltEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCobaltEventRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<LogCobaltEventsResponse> LogCobaltEvents(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LogCobaltEventsRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Logger;
    using _Base = ::fidl::CompleterBase;

    class LogEventCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCompleter = ::fidl::Completer<LogEventCompleterBase>;

    virtual void LogEvent(uint32_t metric_id, uint32_t event_code, LogEventCompleter::Sync _completer) = 0;

    class LogEventCountCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogEventCountResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogEventCountCompleter = ::fidl::Completer<LogEventCountCompleterBase>;

    virtual void LogEventCount(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t period_duration_micros, int64_t count, LogEventCountCompleter::Sync _completer) = 0;

    class LogElapsedTimeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogElapsedTimeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogElapsedTimeCompleter = ::fidl::Completer<LogElapsedTimeCompleterBase>;

    virtual void LogElapsedTime(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t elapsed_micros, LogElapsedTimeCompleter::Sync _completer) = 0;

    class LogFrameRateCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogFrameRateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogFrameRateCompleter = ::fidl::Completer<LogFrameRateCompleterBase>;

    virtual void LogFrameRate(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, float fps, LogFrameRateCompleter::Sync _completer) = 0;

    class LogMemoryUsageCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogMemoryUsageResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogMemoryUsageCompleter = ::fidl::Completer<LogMemoryUsageCompleterBase>;

    virtual void LogMemoryUsage(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, int64_t bytes, LogMemoryUsageCompleter::Sync _completer) = 0;

    class StartTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<StartTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartTimerCompleter = ::fidl::Completer<StartTimerCompleterBase>;

    virtual void StartTimer(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, StartTimerCompleter::Sync _completer) = 0;

    class EndTimerCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<EndTimerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using EndTimerCompleter = ::fidl::Completer<EndTimerCompleterBase>;

    virtual void EndTimer(::fidl::StringView timer_id, uint64_t timestamp, uint32_t timeout_s, EndTimerCompleter::Sync _completer) = 0;

    class LogIntHistogramCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogIntHistogramResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogIntHistogramCompleter = ::fidl::Completer<LogIntHistogramCompleterBase>;

    virtual void LogIntHistogram(uint32_t metric_id, uint32_t event_code, ::fidl::StringView component, ::fidl::VectorView<::llcpp::fuchsia::cobalt::HistogramBucket> histogram, LogIntHistogramCompleter::Sync _completer) = 0;

    class LogCustomEventCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogCustomEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogCustomEventCompleter = ::fidl::Completer<LogCustomEventCompleterBase>;

    virtual void LogCustomEvent(uint32_t metric_id, ::fidl::VectorView<::llcpp::fuchsia::cobalt::CustomEventValue> event_values, LogCustomEventCompleter::Sync _completer) = 0;

    class LogCobaltEventCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogCobaltEventResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogCobaltEventCompleter = ::fidl::Completer<LogCobaltEventCompleterBase>;

    virtual void LogCobaltEvent(::llcpp::fuchsia::cobalt::CobaltEvent event, LogCobaltEventCompleter::Sync _completer) = 0;

    class LogCobaltEventsCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::cobalt::Status status);
      void Reply(::fidl::DecodedMessage<LogCobaltEventsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LogCobaltEventsCompleter = ::fidl::Completer<LogCobaltEventsCompleterBase>;

    virtual void LogCobaltEvents(::fidl::VectorView<::llcpp::fuchsia::cobalt::CobaltEvent> events, LogCobaltEventsCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void LogEventRequest(const ::fidl::DecodedMessage<Logger::LogEventRequest>& _msg);
    static void LogEventResponse(const ::fidl::DecodedMessage<Logger::LogEventResponse>& _msg);
    static void LogEventCountRequest(const ::fidl::DecodedMessage<Logger::LogEventCountRequest>& _msg);
    static void LogEventCountResponse(const ::fidl::DecodedMessage<Logger::LogEventCountResponse>& _msg);
    static void LogElapsedTimeRequest(const ::fidl::DecodedMessage<Logger::LogElapsedTimeRequest>& _msg);
    static void LogElapsedTimeResponse(const ::fidl::DecodedMessage<Logger::LogElapsedTimeResponse>& _msg);
    static void LogFrameRateRequest(const ::fidl::DecodedMessage<Logger::LogFrameRateRequest>& _msg);
    static void LogFrameRateResponse(const ::fidl::DecodedMessage<Logger::LogFrameRateResponse>& _msg);
    static void LogMemoryUsageRequest(const ::fidl::DecodedMessage<Logger::LogMemoryUsageRequest>& _msg);
    static void LogMemoryUsageResponse(const ::fidl::DecodedMessage<Logger::LogMemoryUsageResponse>& _msg);
    static void StartTimerRequest(const ::fidl::DecodedMessage<Logger::StartTimerRequest>& _msg);
    static void StartTimerResponse(const ::fidl::DecodedMessage<Logger::StartTimerResponse>& _msg);
    static void EndTimerRequest(const ::fidl::DecodedMessage<Logger::EndTimerRequest>& _msg);
    static void EndTimerResponse(const ::fidl::DecodedMessage<Logger::EndTimerResponse>& _msg);
    static void LogIntHistogramRequest(const ::fidl::DecodedMessage<Logger::LogIntHistogramRequest>& _msg);
    static void LogIntHistogramResponse(const ::fidl::DecodedMessage<Logger::LogIntHistogramResponse>& _msg);
    static void LogCustomEventRequest(const ::fidl::DecodedMessage<Logger::LogCustomEventRequest>& _msg);
    static void LogCustomEventResponse(const ::fidl::DecodedMessage<Logger::LogCustomEventResponse>& _msg);
    static void LogCobaltEventRequest(const ::fidl::DecodedMessage<Logger::LogCobaltEventRequest>& _msg);
    static void LogCobaltEventResponse(const ::fidl::DecodedMessage<Logger::LogCobaltEventResponse>& _msg);
    static void LogCobaltEventsRequest(const ::fidl::DecodedMessage<Logger::LogCobaltEventsRequest>& _msg);
    static void LogCobaltEventsResponse(const ::fidl::DecodedMessage<Logger::LogCobaltEventsResponse>& _msg);
  };
};

}  // namespace cobalt
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Value> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::Value>);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::CustomEventValue> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::CustomEventValue>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CustomEventValue, dimension_name) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CustomEventValue, value) == 16);
static_assert(sizeof(::llcpp::fuchsia::cobalt::CustomEventValue) == ::llcpp::fuchsia::cobalt::CustomEventValue::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::RequestSendSoonResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::RequestSendSoonResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::RequestSendSoonResponse)
    == ::llcpp::fuchsia::cobalt::Controller::RequestSendSoonResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::RequestSendSoonResponse, success) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::BlockUntilEmptyRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::BlockUntilEmptyRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::BlockUntilEmptyRequest)
    == ::llcpp::fuchsia::cobalt::Controller::BlockUntilEmptyRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::BlockUntilEmptyRequest, max_wait_seconds) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::GetNumSendAttemptsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::GetNumSendAttemptsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::GetNumSendAttemptsResponse)
    == ::llcpp::fuchsia::cobalt::Controller::GetNumSendAttemptsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GetNumSendAttemptsResponse, num) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::GetFailedSendAttemptsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::GetFailedSendAttemptsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::GetFailedSendAttemptsResponse)
    == ::llcpp::fuchsia::cobalt::Controller::GetFailedSendAttemptsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GetFailedSendAttemptsResponse, num) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::GetNumObservationsAddedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::GetNumObservationsAddedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::GetNumObservationsAddedResponse)
    == ::llcpp::fuchsia::cobalt::Controller::GetNumObservationsAddedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GetNumObservationsAddedResponse, num_obs) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest)
    == ::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest, day_index) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsRequest, report_ids) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsResponse)
    == ::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Controller::GenerateAggregatedObservationsResponse, num_obs) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventRequest, event_code) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest, period_duration_micros) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountRequest, count) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogEventCountResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeRequest, elapsed_micros) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogElapsedTimeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateRequest, fps) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogFrameRateResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageRequest, bytes) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::LogMemoryUsageResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, timer_id) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, timestamp) == 56);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerRequest, timeout_s) == 64);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::StartTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::StartTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::StartTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::StartTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest)
    == ::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest, timer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest, timestamp) == 32);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerRequest, timeout_s) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerBase::EndTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerBase::EndTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerResponse)
    == ::llcpp::fuchsia::cobalt::LoggerBase::EndTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerBase::EndTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventRequest, event_code) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest, period_duration_micros) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountRequest, count) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogEventCountResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeRequest, elapsed_micros) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogElapsedTimeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateRequest, fps) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogFrameRateResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageRequest, bytes) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogMemoryUsageResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, timer_id) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, timestamp) == 56);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerRequest, timeout_s) == 64);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::StartTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest, timer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest, timestamp) == 32);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerRequest, timeout_s) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::EndTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest, bucket_indices) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramRequest, bucket_counts) == 56);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramResponse)
    == ::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerSimple::LogIntHistogramResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::ProjectProfile> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::ProjectProfile>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::ProjectProfile, config) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::ProjectProfile, release_stage) == 16);
static_assert(sizeof(::llcpp::fuchsia::cobalt::ProjectProfile) == ::llcpp::fuchsia::cobalt::ProjectProfile::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest, profile) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerRequest, logger) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerResponse)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest, profile) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleRequest, logger) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleResponse)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest, project_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdRequest, logger) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdResponse)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerFromProjectIdResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest, project_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdRequest, logger) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdResponse)
    == ::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::LoggerFactory::CreateLoggerSimpleFromProjectIdResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::HistogramBucket> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::HistogramBucket>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::HistogramBucket, index) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::HistogramBucket, count) == 8);
static_assert(sizeof(::llcpp::fuchsia::cobalt::HistogramBucket) == ::llcpp::fuchsia::cobalt::HistogramBucket::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Experiment> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::Experiment>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Experiment, experiment_id) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Experiment, arm_id) == 8);
static_assert(sizeof(::llcpp::fuchsia::cobalt::Experiment) == ::llcpp::fuchsia::cobalt::Experiment::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateRequest)
    == ::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateRequest, experiments) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateResponse)
    == ::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetExperimentStateResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelRequest)
    == ::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelRequest, current_channel) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelResponse)
    == ::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::SystemDataUpdater::SetChannelResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Event> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::Event>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Event, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::cobalt::Event) == ::llcpp::fuchsia::cobalt::Event::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::CountEvent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::CountEvent>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CountEvent, period_duration_micros) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CountEvent, count) == 8);
static_assert(sizeof(::llcpp::fuchsia::cobalt::CountEvent) == ::llcpp::fuchsia::cobalt::CountEvent::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::EventPayload> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::EventPayload>);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::CobaltEvent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::cobalt::CobaltEvent>);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CobaltEvent, metric_id) == 0);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CobaltEvent, event_codes) == 8);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CobaltEvent, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::CobaltEvent, payload) == 40);
static_assert(sizeof(::llcpp::fuchsia::cobalt::CobaltEvent) == ::llcpp::fuchsia::cobalt::CobaltEvent::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogEventRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventRequest, event_code) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogEventResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest, period_duration_micros) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountRequest, count) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogEventCountResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogEventCountResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogEventCountResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogEventCountResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogEventCountResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeRequest, elapsed_micros) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogElapsedTimeResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateRequest, fps) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogFrameRateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogFrameRateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogFrameRateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogFrameRateResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageRequest, bytes) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogMemoryUsageResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::StartTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::StartTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest)
    == ::llcpp::fuchsia::cobalt::Logger::StartTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, timer_id) == 40);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, timestamp) == 56);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerRequest, timeout_s) == 64);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::StartTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::StartTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::StartTimerResponse)
    == ::llcpp::fuchsia::cobalt::Logger::StartTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::StartTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::EndTimerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::EndTimerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::EndTimerRequest)
    == ::llcpp::fuchsia::cobalt::Logger::EndTimerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::EndTimerRequest, timer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::EndTimerRequest, timestamp) == 32);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::EndTimerRequest, timeout_s) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::EndTimerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::EndTimerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::EndTimerResponse)
    == ::llcpp::fuchsia::cobalt::Logger::EndTimerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::EndTimerResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest, event_code) == 20);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest, component) == 24);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramRequest, histogram) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogIntHistogramResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogIntHistogramResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogIntHistogramResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogIntHistogramResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest, metric_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCustomEventRequest, event_values) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCustomEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCustomEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCustomEventResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogCustomEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCustomEventResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogCobaltEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventRequest, event) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogCobaltEventResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsRequest)
    == ::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsRequest, events) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsResponse)
    == ::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::cobalt::Logger::LogCobaltEventsResponse, status) == 16);

}  // namespace fidl

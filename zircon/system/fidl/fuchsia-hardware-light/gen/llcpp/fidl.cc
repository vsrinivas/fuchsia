// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/light/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace light {

namespace {

[[maybe_unused]]
constexpr uint64_t kLight_GetName_Ordinal = 0x9d4dbd800000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_GetName_GenOrdinal = 0x14a083e18eeca03dlu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetNameRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightGetNameResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetCount_Ordinal = 0x4e441b4600000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_GetCount_GenOrdinal = 0x3f141dbdbcb1f0felu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetCountRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetCountResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightGetCountResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_HasCapability_Ordinal = 0x703098f200000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_HasCapability_GenOrdinal = 0x6fb1d40c2effffc9lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightHasCapabilityRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightHasCapabilityResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightHasCapabilityResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetSimpleValue_Ordinal = 0x634b636200000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_GetSimpleValue_GenOrdinal = 0x30826e9255b5a9e3lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetSimpleValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetSimpleValueResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightGetSimpleValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_SetSimpleValue_Ordinal = 0x56deecd500000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_SetSimpleValue_GenOrdinal = 0x4fb33d84c1aad81dlu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetSimpleValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetSimpleValueResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightSetSimpleValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetRgbValue_Ordinal = 0xf37a4e00000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_GetRgbValue_GenOrdinal = 0x57f15472f735669dlu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetRgbValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetRgbValueResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightGetRgbValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_SetRgbValue_Ordinal = 0x81b4c9b00000000lu;
[[maybe_unused]]
constexpr uint64_t kLight_SetRgbValue_GenOrdinal = 0x2b354d18be0b70a4lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetRgbValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetRgbValueResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_light_LightSetRgbValueResponseTable;

}  // namespace
template <>
Light::ResultOf::GetName_Impl<Light::GetNameResponse>::GetName_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNameRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNameRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetNameRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNameRequest));
  ::fidl::DecodedMessage<GetNameRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetName(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetName Light::SyncClient::GetName(uint32_t index) {
  return ResultOf::GetName(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetName Light::Call::GetName(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetName(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetName_Impl<Light::GetNameResponse>::GetName_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetNameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetNameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetNameRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetNameRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetNameRequest));
  ::fidl::DecodedMessage<GetNameRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetName(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetName Light::SyncClient::GetName(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetName(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetName Light::Call::GetName(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetName(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::GetNameResponse> Light::InPlace::GetName(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetNameRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::GetNameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetNameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNameRequest, GetNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetNameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetCount_Impl<Light::GetCountResponse>::GetCount_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetCountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetCountRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetCount(std::move(_client_end), Super::response_buffer()));
}

Light::ResultOf::GetCount Light::SyncClient::GetCount() {
  return ResultOf::GetCount(zx::unowned_channel(this->channel_));
}

Light::ResultOf::GetCount Light::Call::GetCount(zx::unowned_channel _client_end) {
  return ResultOf::GetCount(std::move(_client_end));
}

template <>
Light::UnownedResultOf::GetCount_Impl<Light::GetCountResponse>::GetCount_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetCountRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetCountRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetCount(std::move(_client_end), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetCount Light::SyncClient::GetCount(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetCount(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Light::UnownedResultOf::GetCount Light::Call::GetCount(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetCount(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::GetCountResponse> Light::InPlace::GetCount(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetCountRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetCountRequest> params(std::move(_request_buffer));
  Light::SetTransactionHeaderFor::GetCountRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetCountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetCountRequest, GetCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetCountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::HasCapability_Impl<Light::HasCapabilityResponse>::HasCapability_Impl(zx::unowned_channel _client_end, uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, HasCapabilityRequest::PrimarySize);
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::HasCapability(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::HasCapability Light::SyncClient::HasCapability(uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability) {
  return ResultOf::HasCapability(zx::unowned_channel(this->channel_), std::move(index), std::move(capability));
}

Light::ResultOf::HasCapability Light::Call::HasCapability(zx::unowned_channel _client_end, uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability) {
  return ResultOf::HasCapability(std::move(_client_end), std::move(index), std::move(capability));
}

template <>
Light::UnownedResultOf::HasCapability_Impl<Light::HasCapabilityResponse>::HasCapability_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < HasCapabilityRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<HasCapabilityResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, HasCapabilityRequest::PrimarySize);
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  _request_buffer.set_actual(sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::HasCapability(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::HasCapability Light::SyncClient::HasCapability(::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::HasCapability(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(capability), std::move(_response_buffer));
}

Light::UnownedResultOf::HasCapability Light::Call::HasCapability(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Capability capability, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::HasCapability(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(capability), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::HasCapabilityResponse> Light::InPlace::HasCapability(zx::unowned_channel _client_end, ::fidl::DecodedMessage<HasCapabilityRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::HasCapabilityRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::HasCapabilityResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<HasCapabilityRequest, HasCapabilityResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::HasCapabilityResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetSimpleValue_Impl<Light::GetSimpleValueResponse>::GetSimpleValue_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetSimpleValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetSimpleValue Light::SyncClient::GetSimpleValue(uint32_t index) {
  return ResultOf::GetSimpleValue(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetSimpleValue Light::Call::GetSimpleValue(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetSimpleValue(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetSimpleValue_Impl<Light::GetSimpleValueResponse>::GetSimpleValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetSimpleValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetSimpleValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetSimpleValue Light::SyncClient::GetSimpleValue(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSimpleValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetSimpleValue Light::Call::GetSimpleValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSimpleValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::GetSimpleValueResponse> Light::InPlace::GetSimpleValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSimpleValueRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::GetSimpleValueRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetSimpleValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetSimpleValueRequest, GetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetSimpleValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::SetSimpleValue_Impl<Light::SetSimpleValueResponse>::SetSimpleValue_Impl(zx::unowned_channel _client_end, uint32_t index, uint8_t value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::SetSimpleValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::SetSimpleValue Light::SyncClient::SetSimpleValue(uint32_t index, uint8_t value) {
  return ResultOf::SetSimpleValue(zx::unowned_channel(this->channel_), std::move(index), std::move(value));
}

Light::ResultOf::SetSimpleValue Light::Call::SetSimpleValue(zx::unowned_channel _client_end, uint32_t index, uint8_t value) {
  return ResultOf::SetSimpleValue(std::move(_client_end), std::move(index), std::move(value));
}

template <>
Light::UnownedResultOf::SetSimpleValue_Impl<Light::SetSimpleValueResponse>::SetSimpleValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetSimpleValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::SetSimpleValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::SetSimpleValue Light::SyncClient::SetSimpleValue(::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetSimpleValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

Light::UnownedResultOf::SetSimpleValue Light::Call::SetSimpleValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetSimpleValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::SetSimpleValueResponse> Light::InPlace::SetSimpleValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSimpleValueRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::SetSimpleValueRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetSimpleValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetSimpleValueRequest, SetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetSimpleValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetRgbValue_Impl<Light::GetRgbValueResponse>::GetRgbValue_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetRgbValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetRgbValue Light::SyncClient::GetRgbValue(uint32_t index) {
  return ResultOf::GetRgbValue(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetRgbValue Light::Call::GetRgbValue(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetRgbValue(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetRgbValue_Impl<Light::GetRgbValueResponse>::GetRgbValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetRgbValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetRgbValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetRgbValue Light::SyncClient::GetRgbValue(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetRgbValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetRgbValue Light::Call::GetRgbValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetRgbValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::GetRgbValueResponse> Light::InPlace::GetRgbValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetRgbValueRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::GetRgbValueRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetRgbValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetRgbValueRequest, GetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetRgbValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::SetRgbValue_Impl<Light::SetRgbValueResponse>::SetRgbValue_Impl(zx::unowned_channel _client_end, uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::SetRgbValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::SetRgbValue Light::SyncClient::SetRgbValue(uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value) {
  return ResultOf::SetRgbValue(zx::unowned_channel(this->channel_), std::move(index), std::move(value));
}

Light::ResultOf::SetRgbValue Light::Call::SetRgbValue(zx::unowned_channel _client_end, uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value) {
  return ResultOf::SetRgbValue(std::move(_client_end), std::move(index), std::move(value));
}

template <>
Light::UnownedResultOf::SetRgbValue_Impl<Light::SetRgbValueResponse>::SetRgbValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetRgbValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::SetRgbValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::SetRgbValue Light::SyncClient::SetRgbValue(::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetRgbValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

Light::UnownedResultOf::SetRgbValue Light::Call::SetRgbValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::llcpp::fuchsia::hardware::light::Rgb value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetRgbValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::SetRgbValueResponse> Light::InPlace::SetRgbValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetRgbValueRequest> params, ::fidl::BytePart response_buffer) {
  Light::SetTransactionHeaderFor::SetRgbValueRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetRgbValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetRgbValueRequest, SetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetRgbValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Light::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kLight_GetName_Ordinal:
    case kLight_GetName_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetName(std::move(message->index),
          Interface::GetNameCompleter::Sync(txn));
      return true;
    }
    case kLight_GetCount_Ordinal:
    case kLight_GetCount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetCountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetCount(
          Interface::GetCountCompleter::Sync(txn));
      return true;
    }
    case kLight_HasCapability_Ordinal:
    case kLight_HasCapability_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<HasCapabilityRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->HasCapability(std::move(message->index), std::move(message->capability),
          Interface::HasCapabilityCompleter::Sync(txn));
      return true;
    }
    case kLight_GetSimpleValue_Ordinal:
    case kLight_GetSimpleValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetSimpleValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetSimpleValue(std::move(message->index),
          Interface::GetSimpleValueCompleter::Sync(txn));
      return true;
    }
    case kLight_SetSimpleValue_Ordinal:
    case kLight_SetSimpleValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetSimpleValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetSimpleValue(std::move(message->index), std::move(message->value),
          Interface::SetSimpleValueCompleter::Sync(txn));
      return true;
    }
    case kLight_GetRgbValue_Ordinal:
    case kLight_GetRgbValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetRgbValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetRgbValue(std::move(message->index),
          Interface::GetRgbValueCompleter::Sync(txn));
      return true;
    }
    case kLight_SetRgbValue_Ordinal:
    case kLight_SetRgbValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetRgbValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetRgbValue(std::move(message->index), std::move(message->value),
          Interface::SetRgbValueCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Light::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Light::Interface::GetNameCompleterBase::Reply(int32_t status, ::fidl::StringView name) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetNameResponse _response = {};
  Light::SetTransactionHeaderFor::GetNameResponse(
      ::fidl::DecodedMessage<GetNameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNameResponse::PrimarySize,
              GetNameResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Light::Interface::GetNameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::StringView name) {
  if (_buffer.capacity() < GetNameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetNameResponse _response = {};
  Light::SetTransactionHeaderFor::GetNameResponse(
      ::fidl::DecodedMessage<GetNameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNameResponse::PrimarySize,
              GetNameResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Light::Interface::GetNameCompleterBase::Reply(::fidl::DecodedMessage<GetNameResponse> params) {
  Light::SetTransactionHeaderFor::GetNameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetCountCompleterBase::Reply(uint32_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetCountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetCountResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::GetCountResponse(
      ::fidl::DecodedMessage<GetCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetCountResponse::PrimarySize,
              GetCountResponse::PrimarySize)));
  _response.count = std::move(count);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetCountResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetCountCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t count) {
  if (_buffer.capacity() < GetCountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetCountResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::GetCountResponse(
      ::fidl::DecodedMessage<GetCountResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetCountResponse::PrimarySize,
              GetCountResponse::PrimarySize)));
  _response.count = std::move(count);
  _buffer.set_actual(sizeof(GetCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetCountResponse>(std::move(_buffer)));
}

void Light::Interface::GetCountCompleterBase::Reply(::fidl::DecodedMessage<GetCountResponse> params) {
  Light::SetTransactionHeaderFor::GetCountResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::HasCapabilityCompleterBase::Reply(int32_t status, bool has) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<HasCapabilityResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::HasCapabilityResponse(
      ::fidl::DecodedMessage<HasCapabilityResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              HasCapabilityResponse::PrimarySize,
              HasCapabilityResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.has = std::move(has);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(HasCapabilityResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<HasCapabilityResponse>(std::move(_response_bytes)));
}

void Light::Interface::HasCapabilityCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, bool has) {
  if (_buffer.capacity() < HasCapabilityResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<HasCapabilityResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::HasCapabilityResponse(
      ::fidl::DecodedMessage<HasCapabilityResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              HasCapabilityResponse::PrimarySize,
              HasCapabilityResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.has = std::move(has);
  _buffer.set_actual(sizeof(HasCapabilityResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<HasCapabilityResponse>(std::move(_buffer)));
}

void Light::Interface::HasCapabilityCompleterBase::Reply(::fidl::DecodedMessage<HasCapabilityResponse> params) {
  Light::SetTransactionHeaderFor::HasCapabilityResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetSimpleValueCompleterBase::Reply(int32_t status, uint8_t value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetSimpleValueResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::GetSimpleValueResponse(
      ::fidl::DecodedMessage<GetSimpleValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSimpleValueResponse::PrimarySize,
              GetSimpleValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.value = std::move(value);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSimpleValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetSimpleValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint8_t value) {
  if (_buffer.capacity() < GetSimpleValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetSimpleValueResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::GetSimpleValueResponse(
      ::fidl::DecodedMessage<GetSimpleValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSimpleValueResponse::PrimarySize,
              GetSimpleValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.value = std::move(value);
  _buffer.set_actual(sizeof(GetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSimpleValueResponse>(std::move(_buffer)));
}

void Light::Interface::GetSimpleValueCompleterBase::Reply(::fidl::DecodedMessage<GetSimpleValueResponse> params) {
  Light::SetTransactionHeaderFor::GetSimpleValueResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::SetSimpleValueCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetSimpleValueResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::SetSimpleValueResponse(
      ::fidl::DecodedMessage<SetSimpleValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetSimpleValueResponse::PrimarySize,
              SetSimpleValueResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetSimpleValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::SetSimpleValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetSimpleValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetSimpleValueResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::SetSimpleValueResponse(
      ::fidl::DecodedMessage<SetSimpleValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetSimpleValueResponse::PrimarySize,
              SetSimpleValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetSimpleValueResponse>(std::move(_buffer)));
}

void Light::Interface::SetSimpleValueCompleterBase::Reply(::fidl::DecodedMessage<SetSimpleValueResponse> params) {
  Light::SetTransactionHeaderFor::SetSimpleValueResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetRgbValueCompleterBase::Reply(int32_t status, ::llcpp::fuchsia::hardware::light::Rgb value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetRgbValueResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::GetRgbValueResponse(
      ::fidl::DecodedMessage<GetRgbValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetRgbValueResponse::PrimarySize,
              GetRgbValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.value = std::move(value);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetRgbValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetRgbValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::hardware::light::Rgb value) {
  if (_buffer.capacity() < GetRgbValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetRgbValueResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::GetRgbValueResponse(
      ::fidl::DecodedMessage<GetRgbValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetRgbValueResponse::PrimarySize,
              GetRgbValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _response.value = std::move(value);
  _buffer.set_actual(sizeof(GetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetRgbValueResponse>(std::move(_buffer)));
}

void Light::Interface::GetRgbValueCompleterBase::Reply(::fidl::DecodedMessage<GetRgbValueResponse> params) {
  Light::SetTransactionHeaderFor::GetRgbValueResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::SetRgbValueCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetRgbValueResponse*>(_write_bytes);
  Light::SetTransactionHeaderFor::SetRgbValueResponse(
      ::fidl::DecodedMessage<SetRgbValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetRgbValueResponse::PrimarySize,
              SetRgbValueResponse::PrimarySize)));
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetRgbValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::SetRgbValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetRgbValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetRgbValueResponse*>(_buffer.data());
  Light::SetTransactionHeaderFor::SetRgbValueResponse(
      ::fidl::DecodedMessage<SetRgbValueResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetRgbValueResponse::PrimarySize,
              SetRgbValueResponse::PrimarySize)));
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetRgbValueResponse>(std::move(_buffer)));
}

void Light::Interface::SetRgbValueCompleterBase::Reply(::fidl::DecodedMessage<SetRgbValueResponse> params) {
  Light::SetTransactionHeaderFor::SetRgbValueResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Light::SetTransactionHeaderFor::GetNameRequest(const ::fidl::DecodedMessage<Light::GetNameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetName_GenOrdinal);
}
void Light::SetTransactionHeaderFor::GetNameResponse(const ::fidl::DecodedMessage<Light::GetNameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetName_GenOrdinal);
}

void Light::SetTransactionHeaderFor::GetCountRequest(const ::fidl::DecodedMessage<Light::GetCountRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetCount_GenOrdinal);
}
void Light::SetTransactionHeaderFor::GetCountResponse(const ::fidl::DecodedMessage<Light::GetCountResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetCount_GenOrdinal);
}

void Light::SetTransactionHeaderFor::HasCapabilityRequest(const ::fidl::DecodedMessage<Light::HasCapabilityRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_HasCapability_GenOrdinal);
}
void Light::SetTransactionHeaderFor::HasCapabilityResponse(const ::fidl::DecodedMessage<Light::HasCapabilityResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_HasCapability_GenOrdinal);
}

void Light::SetTransactionHeaderFor::GetSimpleValueRequest(const ::fidl::DecodedMessage<Light::GetSimpleValueRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetSimpleValue_GenOrdinal);
}
void Light::SetTransactionHeaderFor::GetSimpleValueResponse(const ::fidl::DecodedMessage<Light::GetSimpleValueResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetSimpleValue_GenOrdinal);
}

void Light::SetTransactionHeaderFor::SetSimpleValueRequest(const ::fidl::DecodedMessage<Light::SetSimpleValueRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_SetSimpleValue_GenOrdinal);
}
void Light::SetTransactionHeaderFor::SetSimpleValueResponse(const ::fidl::DecodedMessage<Light::SetSimpleValueResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_SetSimpleValue_GenOrdinal);
}

void Light::SetTransactionHeaderFor::GetRgbValueRequest(const ::fidl::DecodedMessage<Light::GetRgbValueRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetRgbValue_GenOrdinal);
}
void Light::SetTransactionHeaderFor::GetRgbValueResponse(const ::fidl::DecodedMessage<Light::GetRgbValueResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_GetRgbValue_GenOrdinal);
}

void Light::SetTransactionHeaderFor::SetRgbValueRequest(const ::fidl::DecodedMessage<Light::SetRgbValueRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_SetRgbValue_GenOrdinal);
}
void Light::SetTransactionHeaderFor::SetRgbValueResponse(const ::fidl::DecodedMessage<Light::SetRgbValueResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kLight_SetRgbValue_GenOrdinal);
}

}  // namespace light
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

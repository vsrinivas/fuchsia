// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/event.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

#include <fuchsia/sysmem/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace display {

enum class VirtconMode : uint8_t {
  INACTIVE = 0u,
  FALLBACK = 1u,
  FORCED = 2u,
};


enum class Transform : uint8_t {
  IDENTITY = 0u,
  REFLECT_X = 1u,
  REFLECT_Y = 2u,
  ROT_90 = 3u,
  ROT_180 = 4u,
  ROT_270 = 5u,
  ROT_90_REFLECT_X = 6u,
  ROT_90_REFLECT_Y = 7u,
};


class Provider;
struct Mode;
struct ImagePlane;
struct ImageConfig;
struct Frame;
struct CursorInfo;
struct Info;
struct Controller_StartCapture_Response;
struct Controller_StartCapture_Result;
struct Controller_ReleaseCapture_Response;
struct Controller_ReleaseCapture_Result;
struct Controller_IsCaptureSupported_Response;
struct Controller_IsCaptureSupported_Result;
struct Controller_ImportImageForCapture_Response;
struct Controller_ImportImageForCapture_Result;
enum class ConfigResult : uint32_t {
  OK = 0u,
  INVALID_CONFIG = 1u,
  UNSUPPORTED_CONFIG = 2u,
  TOO_MANY_DISPLAYS = 3u,
  UNSUPPORTED_DISPLAY_MODES = 4u,
};


enum class ClientCompositionOpcode : uint8_t {
  CLIENT_USE_PRIMARY = 0u,
  CLIENT_MERGE_BASE = 1u,
  CLIENT_MERGE_SRC = 2u,
  CLIENT_FRAME_SCALE = 3u,
  CLIENT_SRC_FRAME = 4u,
  CLIENT_TRANSFORM = 5u,
  CLIENT_COLOR_CONVERSION = 6u,
  CLIENT_ALPHA = 7u,
};


struct ClientCompositionOp;
enum class AlphaMode : uint8_t {
  DISABLE = 0u,
  PREMULTIPLIED = 1u,
  HW_MULTIPLY = 2u,
};


class Controller;

constexpr uint32_t typeSimple = 0u;

constexpr uint32_t typeCapture = 10u;

constexpr int32_t modeInterlaced = 1u;

constexpr uint64_t invalidId = 0u;

constexpr uint32_t identifierMaxLen = 128u;

extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenControllerResponseTable;

// Provider for display controllers.
//
// The driver supports two simultaneous clients - a primary client and a virtcon
// client.
class Provider final {
  Provider() = delete;
 public:

  struct OpenVirtconControllerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct OpenVirtconControllerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel device;
    ::zx::channel controller;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = OpenVirtconControllerResponse;
  };

  struct OpenControllerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ProviderOpenControllerResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ProviderOpenControllerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct OpenControllerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel device;
    ::zx::channel controller;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ProviderOpenControllerRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ProviderOpenControllerRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = OpenControllerResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class OpenVirtconController_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      OpenVirtconController_Impl(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller);
      ~OpenVirtconController_Impl() = default;
      OpenVirtconController_Impl(OpenVirtconController_Impl&& other) = default;
      OpenVirtconController_Impl& operator=(OpenVirtconController_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class OpenController_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      OpenController_Impl(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller);
      ~OpenController_Impl() = default;
      OpenController_Impl(OpenController_Impl&& other) = default;
      OpenController_Impl& operator=(OpenController_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using OpenVirtconController = OpenVirtconController_Impl<OpenVirtconControllerResponse>;
    using OpenController = OpenController_Impl<OpenControllerResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class OpenVirtconController_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      OpenVirtconController_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);
      ~OpenVirtconController_Impl() = default;
      OpenVirtconController_Impl(OpenVirtconController_Impl&& other) = default;
      OpenVirtconController_Impl& operator=(OpenVirtconController_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class OpenController_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      OpenController_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);
      ~OpenController_Impl() = default;
      OpenController_Impl(OpenController_Impl&& other) = default;
      OpenController_Impl& operator=(OpenController_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using OpenVirtconController = OpenVirtconController_Impl<OpenVirtconControllerResponse>;
    using OpenController = OpenController_Impl<OpenControllerResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Open a virtcon client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a virtcon controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::OpenVirtconController OpenVirtconController(::zx::channel device, ::zx::channel controller);

    // Open a virtcon client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a virtcon controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::OpenVirtconController OpenVirtconController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);

    // Open a primary client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a primary controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::OpenController OpenController(::zx::channel device, ::zx::channel controller);

    // Open a primary client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a primary controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::OpenController OpenController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Open a virtcon client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a virtcon controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::OpenVirtconController OpenVirtconController(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller);

    // Open a virtcon client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a virtcon controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::OpenVirtconController OpenVirtconController(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);

    // Open a primary client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a primary controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::OpenController OpenController(zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller);

    // Open a primary client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a primary controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::OpenController OpenController(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Open a virtcon client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a virtcon controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    static ::fidl::DecodeResult<OpenVirtconControllerResponse> OpenVirtconController(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenVirtconControllerRequest> params, ::fidl::BytePart response_buffer);

    // Open a primary client. `device` should be a handle to one endpoint of a
    // channel that (on success) will become an open connection to a new
    // instance of a display client device. A protocol request `controller`
    // provides an interface to the Controller for the new device. Closing the
    // connection to `device` will also close the `controller` interface. If
    // the display device already has a primary controller then this method
    // will return `ZX_ERR_ALREADY_BOUND`.
    static ::fidl::DecodeResult<OpenControllerResponse> OpenController(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenControllerRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Provider;
    using _Base = ::fidl::CompleterBase;

    class OpenVirtconControllerCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<OpenVirtconControllerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using OpenVirtconControllerCompleter = ::fidl::Completer<OpenVirtconControllerCompleterBase>;

    virtual void OpenVirtconController(::zx::channel device, ::zx::channel controller, OpenVirtconControllerCompleter::Sync _completer) = 0;

    class OpenControllerCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<OpenControllerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using OpenControllerCompleter = ::fidl::Completer<OpenControllerCompleterBase>;

    virtual void OpenController(::zx::channel device, ::zx::channel controller, OpenControllerCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void OpenVirtconControllerRequest(const ::fidl::DecodedMessage<Provider::OpenVirtconControllerRequest>& _msg);
    static void OpenVirtconControllerResponse(const ::fidl::DecodedMessage<Provider::OpenVirtconControllerResponse>& _msg);
    static void OpenControllerRequest(const ::fidl::DecodedMessage<Provider::OpenControllerRequest>& _msg);
    static void OpenControllerResponse(const ::fidl::DecodedMessage<Provider::OpenControllerResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_hardware_display_ModeTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ModeTable;

struct Mode {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ModeTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ModeTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t horizontal_resolution = {};

  uint32_t vertical_resolution = {};

  uint32_t refresh_rate_e2 = {};

  uint32_t flags = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_ImagePlaneTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ImagePlaneTable;

struct ImagePlane {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ImagePlaneTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ImagePlaneTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t byte_offset = {};

  uint32_t bytes_per_row = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_ImageConfigTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ImageConfigTable;

struct ImageConfig {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ImageConfigTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ImageConfigTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t width = {};

  uint32_t height = {};

  uint32_t pixel_format = {};

  uint32_t type = {};

  ::fidl::Array<::llcpp::fuchsia::hardware::display::ImagePlane, 4> planes = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_FrameTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_FrameTable;

struct Frame {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_FrameTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_FrameTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t x_pos = {};

  uint32_t y_pos = {};

  uint32_t width = {};

  uint32_t height = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_CursorInfoTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_CursorInfoTable;

struct CursorInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_CursorInfoTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_CursorInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint32_t width = {};

  uint32_t height = {};

  uint32_t pixel_format = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_InfoTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_InfoTable;

struct Info {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_InfoTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_InfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 104;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t AltPrimarySize = 104;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 4294967295;

  uint64_t id = {};

  ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Mode> modes = {};

  ::fidl::VectorView<uint32_t> pixel_format = {};

  ::fidl::VectorView<::llcpp::fuchsia::hardware::display::CursorInfo> cursor_configs = {};

  ::fidl::StringView manufacturer_name = {};

  ::fidl::StringView monitor_name = {};

  ::fidl::StringView monitor_serial = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_StartCapture_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_StartCapture_ResponseTable;

struct Controller_StartCapture_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_StartCapture_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_StartCapture_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_StartCapture_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_StartCapture_ResultTable;

struct Controller_StartCapture_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_StartCapture_Result();
  ~Controller_StartCapture_Result();

  Controller_StartCapture_Result(Controller_StartCapture_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_StartCapture_Result& operator=(Controller_StartCapture_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_StartCapture_Result WithResponse(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response* val) {
    Controller_StartCapture_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_StartCapture_Result WithErr(int32_t* val) {
    Controller_StartCapture_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_StartCapture_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_StartCapture_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_StartCapture_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_ReleaseCapture_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_ReleaseCapture_ResponseTable;

struct Controller_ReleaseCapture_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_ReleaseCapture_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_ReleaseCapture_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_ReleaseCapture_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_ReleaseCapture_ResultTable;

struct Controller_ReleaseCapture_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_ReleaseCapture_Result();
  ~Controller_ReleaseCapture_Result();

  Controller_ReleaseCapture_Result(Controller_ReleaseCapture_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_ReleaseCapture_Result& operator=(Controller_ReleaseCapture_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_ReleaseCapture_Result WithResponse(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response* val) {
    Controller_ReleaseCapture_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_ReleaseCapture_Result WithErr(int32_t* val) {
    Controller_ReleaseCapture_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_ReleaseCapture_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_ReleaseCapture_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_ReleaseCapture_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_IsCaptureSupported_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_IsCaptureSupported_ResponseTable;

struct Controller_IsCaptureSupported_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_IsCaptureSupported_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_IsCaptureSupported_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  bool supported = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_IsCaptureSupported_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_IsCaptureSupported_ResultTable;

struct Controller_IsCaptureSupported_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_IsCaptureSupported_Result();
  ~Controller_IsCaptureSupported_Result();

  Controller_IsCaptureSupported_Result(Controller_IsCaptureSupported_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_IsCaptureSupported_Result& operator=(Controller_IsCaptureSupported_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_IsCaptureSupported_Result WithResponse(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response* val) {
    Controller_IsCaptureSupported_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_IsCaptureSupported_Result WithErr(int32_t* val) {
    Controller_IsCaptureSupported_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_IsCaptureSupported_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_IsCaptureSupported_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_IsCaptureSupported_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_ImportImageForCapture_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_ImportImageForCapture_ResponseTable;

struct Controller_ImportImageForCapture_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_ImportImageForCapture_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_ImportImageForCapture_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint64_t image_id = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_Controller_ImportImageForCapture_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_Controller_ImportImageForCapture_ResultTable;

struct Controller_ImportImageForCapture_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_ImportImageForCapture_Result();
  ~Controller_ImportImageForCapture_Result();

  Controller_ImportImageForCapture_Result(Controller_ImportImageForCapture_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_ImportImageForCapture_Result& operator=(Controller_ImportImageForCapture_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_ImportImageForCapture_Result WithResponse(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response* val) {
    Controller_ImportImageForCapture_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_ImportImageForCapture_Result WithErr(int32_t* val) {
    Controller_ImportImageForCapture_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_Controller_ImportImageForCapture_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_Controller_ImportImageForCapture_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_ImportImageForCapture_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_hardware_display_ClientCompositionOpTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ClientCompositionOpTable;

struct ClientCompositionOp {
  static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ClientCompositionOpTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ClientCompositionOpTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint64_t display_id = {};

  uint64_t layer_id = {};

  ::llcpp::fuchsia::hardware::display::ClientCompositionOpcode opcode = {};
};

extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDisplaysChangedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDisplaysChangedRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseImageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseImageResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportEventRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportEventResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseEventRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseEventRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseEventResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCreateLayerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCreateLayerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCreateLayerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCreateLayerResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDestroyLayerRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDestroyLayerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDestroyLayerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDestroyLayerResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayModeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayModeResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayColorConversionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayColorConversionResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayLayersResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayLayersResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryPositionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryPositionResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorPositionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorPositionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorPositionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorPositionResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerColorConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerColorConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerImageRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerImageResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCheckConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCheckConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerApplyConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerApplyConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerApplyConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerApplyConfigResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerEnableVsyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerEnableVsyncResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerVsyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerVsyncRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerVsyncEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerVsyncEventTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetVirtconModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetVirtconModeResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerClientOwnershipChangeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerClientOwnershipChangeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseBufferCollectionRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseBufferCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseBufferCollectionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseBufferCollectionResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerGetSingleBufferFramebufferRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerGetSingleBufferFramebufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerIsCaptureSupportedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerIsCaptureSupportedRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerStartCaptureRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerStartCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerStartCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerStartCaptureResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseCaptureRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;

// Interface for accessing the display hardware.
//
// A display configuration can be separated into two parts: the layer layout and
// the layer contents. The layout includes all parts of a configuration other
// than the image handles. The active configuration is composed of the most
// recently applied layout and an active image from each layer - see
// SetLayerImage for details on how the active image is defined. Note the
// requirement that each layer has an active image. Whenever a new active
// configuration is available, it is immediately given to the hardware. This
// allows the layout and each layer's contents to advance independently when
// possible.
//
// Performing illegal actions on the interface will result in the interface
// being closed.
class Controller final {
  Controller() = delete;
 public:

  struct DisplaysChangedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added;
    ::fidl::VectorView<uint64_t> removed;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportVmoImageResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;
    uint64_t image_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportVmoImageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::ImageConfig image_config;
    ::zx::vmo vmo;
    int32_t offset;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ImportVmoImageResponse;
  };

  struct ImportImageResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;
    uint64_t image_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportImageResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportImageResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportImageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::ImageConfig image_config;
    uint64_t collection_id;
    uint32_t index;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportImageRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportImageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ImportImageResponse;
  };

  struct ReleaseImageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t image_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerReleaseImageRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerReleaseImageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct ImportEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::event event;
    uint64_t id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportEventRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct ReleaseEventRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerReleaseEventRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerReleaseEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CreateLayerResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;
    uint64_t layer_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerCreateLayerResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerCreateLayerResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CreateLayerRequest = ::fidl::AnyZeroArgMessage;

  struct DestroyLayerRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerDestroyLayerRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerDestroyLayerRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetDisplayModeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t display_id;
    ::llcpp::fuchsia::hardware::display::Mode mode;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetDisplayModeRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetDisplayModeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetDisplayColorConversionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t display_id;
    ::fidl::Array<float, 3> preoffsets;
    ::fidl::Array<float, 9> coefficients;
    ::fidl::Array<float, 3> postoffsets;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 88;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 88;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetDisplayLayersRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t display_id;
    ::fidl::VectorView<uint64_t> layer_ids;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerPrimaryConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    ::llcpp::fuchsia::hardware::display::ImageConfig image_config;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerPrimaryConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerPrimaryConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerPrimaryPositionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    ::llcpp::fuchsia::hardware::display::Transform transform;
    ::llcpp::fuchsia::hardware::display::Frame src_frame;
    ::llcpp::fuchsia::hardware::display::Frame dest_frame;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 64;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerPrimaryAlphaRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    ::llcpp::fuchsia::hardware::display::AlphaMode mode;
    float val;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerCursorConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    ::llcpp::fuchsia::hardware::display::ImageConfig image_config;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerCursorConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerCursorConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerCursorPositionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    int32_t x;
    int32_t y;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerCursorPositionRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerCursorPositionRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerColorConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    uint32_t pixel_format;
    ::fidl::VectorView<uint8_t> color_bytes;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetLayerImageRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t layer_id;
    uint64_t image_id;
    uint64_t wait_event_id;
    uint64_t signal_event_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetLayerImageRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetLayerImageRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CheckConfigResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::ConfigResult res;
    ::fidl::VectorView<::llcpp::fuchsia::hardware::display::ClientCompositionOp> ops;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerCheckConfigResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerCheckConfigResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CheckConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool discard;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerCheckConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerCheckConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CheckConfigResponse;
  };

  using ApplyConfigRequest = ::fidl::AnyZeroArgMessage;

  struct EnableVsyncRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool enable;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct VsyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t display_id;
    uint64_t timestamp;
    ::fidl::VectorView<uint64_t> images;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerVsyncEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerVsyncEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetVirtconModeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t mode;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct ClientOwnershipChangeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool has_ownership;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportBufferCollectionResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportBufferCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t collection_id;
    ::zx::channel collection_token;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ImportBufferCollectionResponse;
  };

  struct ReleaseBufferCollectionRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t collection_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerReleaseBufferCollectionRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerReleaseBufferCollectionRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct SetBufferCollectionConstraintsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetBufferCollectionConstraintsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t collection_id;
    ::llcpp::fuchsia::hardware::display::ImageConfig config;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 72;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetBufferCollectionConstraintsResponse;
  };

  struct GetSingleBufferFramebufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t res;
    ::zx::vmo vmo;
    uint32_t stride;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSingleBufferFramebufferRequest = ::fidl::AnyZeroArgMessage;

  struct IsCaptureSupportedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using IsCaptureSupportedRequest = ::fidl::AnyZeroArgMessage;

  struct ImportImageForCaptureResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ImportImageForCaptureRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::ImageConfig image_config;
    uint64_t collection_id;
    uint32_t index;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ImportImageForCaptureResponse;
  };

  struct StartCaptureResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerStartCaptureResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerStartCaptureResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct StartCaptureRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t signal_event_id;
    uint64_t image_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerStartCaptureRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerStartCaptureRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = StartCaptureResponse;
  };

  struct ReleaseCaptureResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReleaseCaptureRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t image_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_display_ControllerReleaseCaptureRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_hardware_display_ControllerReleaseCaptureRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReleaseCaptureResponse;
  };


  struct EventHandlers {
    fit::callback<zx_status_t(::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added, ::fidl::VectorView<uint64_t> removed)> displays_changed;

    fit::callback<zx_status_t(uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images)> vsync;

    fit::callback<zx_status_t(bool has_ownership)> client_ownership_change;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class ImportVmoImage_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ImportVmoImage_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset);
      ~ImportVmoImage_Impl() = default;
      ImportVmoImage_Impl(ImportVmoImage_Impl&& other) = default;
      ImportVmoImage_Impl& operator=(ImportVmoImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ImportImage_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ImportImage_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);
      ~ImportImage_Impl() = default;
      ImportImage_Impl(ImportImage_Impl&& other) = default;
      ImportImage_Impl& operator=(ImportImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ReleaseImage_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseImage_Impl(zx::unowned_channel _client_end, uint64_t image_id);
      ~ReleaseImage_Impl() = default;
      ReleaseImage_Impl(ReleaseImage_Impl&& other) = default;
      ReleaseImage_Impl& operator=(ReleaseImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class ImportEvent_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ImportEvent_Impl(zx::unowned_channel _client_end, ::zx::event event, uint64_t id);
      ~ImportEvent_Impl() = default;
      ImportEvent_Impl(ImportEvent_Impl&& other) = default;
      ImportEvent_Impl& operator=(ImportEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class ReleaseEvent_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseEvent_Impl(zx::unowned_channel _client_end, uint64_t id);
      ~ReleaseEvent_Impl() = default;
      ReleaseEvent_Impl(ReleaseEvent_Impl&& other) = default;
      ReleaseEvent_Impl& operator=(ReleaseEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class CreateLayer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateLayer_Impl(zx::unowned_channel _client_end);
      ~CreateLayer_Impl() = default;
      CreateLayer_Impl(CreateLayer_Impl&& other) = default;
      CreateLayer_Impl& operator=(CreateLayer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class DestroyLayer_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      DestroyLayer_Impl(zx::unowned_channel _client_end, uint64_t layer_id);
      ~DestroyLayer_Impl() = default;
      DestroyLayer_Impl(DestroyLayer_Impl&& other) = default;
      DestroyLayer_Impl& operator=(DestroyLayer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayMode_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayMode_Impl(zx::unowned_channel _client_end, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);
      ~SetDisplayMode_Impl() = default;
      SetDisplayMode_Impl(SetDisplayMode_Impl&& other) = default;
      SetDisplayMode_Impl& operator=(SetDisplayMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayColorConversion_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayColorConversion_Impl(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);
      ~SetDisplayColorConversion_Impl() = default;
      SetDisplayColorConversion_Impl(SetDisplayColorConversion_Impl&& other) = default;
      SetDisplayColorConversion_Impl& operator=(SetDisplayColorConversion_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayLayers_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayLayers_Impl(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);
      ~SetDisplayLayers_Impl() = default;
      SetDisplayLayers_Impl(SetDisplayLayers_Impl&& other) = default;
      SetDisplayLayers_Impl& operator=(SetDisplayLayers_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);
      ~SetLayerPrimaryConfig_Impl() = default;
      SetLayerPrimaryConfig_Impl(SetLayerPrimaryConfig_Impl&& other) = default;
      SetLayerPrimaryConfig_Impl& operator=(SetLayerPrimaryConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryPosition_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryPosition_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);
      ~SetLayerPrimaryPosition_Impl() = default;
      SetLayerPrimaryPosition_Impl(SetLayerPrimaryPosition_Impl&& other) = default;
      SetLayerPrimaryPosition_Impl& operator=(SetLayerPrimaryPosition_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryAlpha_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryAlpha_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);
      ~SetLayerPrimaryAlpha_Impl() = default;
      SetLayerPrimaryAlpha_Impl(SetLayerPrimaryAlpha_Impl&& other) = default;
      SetLayerPrimaryAlpha_Impl& operator=(SetLayerPrimaryAlpha_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerCursorConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerCursorConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);
      ~SetLayerCursorConfig_Impl() = default;
      SetLayerCursorConfig_Impl(SetLayerCursorConfig_Impl&& other) = default;
      SetLayerCursorConfig_Impl& operator=(SetLayerCursorConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerCursorPosition_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerCursorPosition_Impl(zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y);
      ~SetLayerCursorPosition_Impl() = default;
      SetLayerCursorPosition_Impl(SetLayerCursorPosition_Impl&& other) = default;
      SetLayerCursorPosition_Impl& operator=(SetLayerCursorPosition_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerColorConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerColorConfig_Impl(zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);
      ~SetLayerColorConfig_Impl() = default;
      SetLayerColorConfig_Impl(SetLayerColorConfig_Impl&& other) = default;
      SetLayerColorConfig_Impl& operator=(SetLayerColorConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerImage_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerImage_Impl(zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);
      ~SetLayerImage_Impl() = default;
      SetLayerImage_Impl(SetLayerImage_Impl&& other) = default;
      SetLayerImage_Impl& operator=(SetLayerImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class CheckConfig_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CheckConfig_Impl(zx::unowned_channel _client_end, bool discard);
      ~CheckConfig_Impl() = default;
      CheckConfig_Impl(CheckConfig_Impl&& other) = default;
      CheckConfig_Impl& operator=(CheckConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ApplyConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ApplyConfig_Impl(zx::unowned_channel _client_end);
      ~ApplyConfig_Impl() = default;
      ApplyConfig_Impl(ApplyConfig_Impl&& other) = default;
      ApplyConfig_Impl& operator=(ApplyConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class EnableVsync_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      EnableVsync_Impl(zx::unowned_channel _client_end, bool enable);
      ~EnableVsync_Impl() = default;
      EnableVsync_Impl(EnableVsync_Impl&& other) = default;
      EnableVsync_Impl& operator=(EnableVsync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetVirtconMode_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetVirtconMode_Impl(zx::unowned_channel _client_end, uint8_t mode);
      ~SetVirtconMode_Impl() = default;
      SetVirtconMode_Impl(SetVirtconMode_Impl&& other) = default;
      SetVirtconMode_Impl& operator=(SetVirtconMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class ImportBufferCollection_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ImportBufferCollection_Impl(zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token);
      ~ImportBufferCollection_Impl() = default;
      ImportBufferCollection_Impl(ImportBufferCollection_Impl&& other) = default;
      ImportBufferCollection_Impl& operator=(ImportBufferCollection_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ReleaseBufferCollection_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseBufferCollection_Impl(zx::unowned_channel _client_end, uint64_t collection_id);
      ~ReleaseBufferCollection_Impl() = default;
      ReleaseBufferCollection_Impl(ReleaseBufferCollection_Impl&& other) = default;
      ReleaseBufferCollection_Impl& operator=(ReleaseBufferCollection_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class SetBufferCollectionConstraints_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetBufferCollectionConstraints_Impl(zx::unowned_channel _client_end, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config);
      ~SetBufferCollectionConstraints_Impl() = default;
      SetBufferCollectionConstraints_Impl(SetBufferCollectionConstraints_Impl&& other) = default;
      SetBufferCollectionConstraints_Impl& operator=(SetBufferCollectionConstraints_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSingleBufferFramebuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSingleBufferFramebuffer_Impl(zx::unowned_channel _client_end);
      ~GetSingleBufferFramebuffer_Impl() = default;
      GetSingleBufferFramebuffer_Impl(GetSingleBufferFramebuffer_Impl&& other) = default;
      GetSingleBufferFramebuffer_Impl& operator=(GetSingleBufferFramebuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class IsCaptureSupported_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      IsCaptureSupported_Impl(zx::unowned_channel _client_end);
      ~IsCaptureSupported_Impl() = default;
      IsCaptureSupported_Impl(IsCaptureSupported_Impl&& other) = default;
      IsCaptureSupported_Impl& operator=(IsCaptureSupported_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ImportImageForCapture_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ImportImageForCapture_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);
      ~ImportImageForCapture_Impl() = default;
      ImportImageForCapture_Impl(ImportImageForCapture_Impl&& other) = default;
      ImportImageForCapture_Impl& operator=(ImportImageForCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartCapture_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      StartCapture_Impl(zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id);
      ~StartCapture_Impl() = default;
      StartCapture_Impl(StartCapture_Impl&& other) = default;
      StartCapture_Impl& operator=(StartCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReleaseCapture_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReleaseCapture_Impl(zx::unowned_channel _client_end, uint64_t image_id);
      ~ReleaseCapture_Impl() = default;
      ReleaseCapture_Impl(ReleaseCapture_Impl&& other) = default;
      ReleaseCapture_Impl& operator=(ReleaseCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using ImportVmoImage = ImportVmoImage_Impl<ImportVmoImageResponse>;
    using ImportImage = ImportImage_Impl<ImportImageResponse>;
    using ReleaseImage = ReleaseImage_Impl;
    using ImportEvent = ImportEvent_Impl;
    using ReleaseEvent = ReleaseEvent_Impl;
    using CreateLayer = CreateLayer_Impl<CreateLayerResponse>;
    using DestroyLayer = DestroyLayer_Impl;
    using SetDisplayMode = SetDisplayMode_Impl;
    using SetDisplayColorConversion = SetDisplayColorConversion_Impl;
    using SetDisplayLayers = SetDisplayLayers_Impl;
    using SetLayerPrimaryConfig = SetLayerPrimaryConfig_Impl;
    using SetLayerPrimaryPosition = SetLayerPrimaryPosition_Impl;
    using SetLayerPrimaryAlpha = SetLayerPrimaryAlpha_Impl;
    using SetLayerCursorConfig = SetLayerCursorConfig_Impl;
    using SetLayerCursorPosition = SetLayerCursorPosition_Impl;
    using SetLayerColorConfig = SetLayerColorConfig_Impl;
    using SetLayerImage = SetLayerImage_Impl;
    using CheckConfig = CheckConfig_Impl<CheckConfigResponse>;
    using ApplyConfig = ApplyConfig_Impl;
    using EnableVsync = EnableVsync_Impl;
    using SetVirtconMode = SetVirtconMode_Impl;
    using ImportBufferCollection = ImportBufferCollection_Impl<ImportBufferCollectionResponse>;
    using ReleaseBufferCollection = ReleaseBufferCollection_Impl;
    using SetBufferCollectionConstraints = SetBufferCollectionConstraints_Impl<SetBufferCollectionConstraintsResponse>;
    using GetSingleBufferFramebuffer = GetSingleBufferFramebuffer_Impl<GetSingleBufferFramebufferResponse>;
    using IsCaptureSupported = IsCaptureSupported_Impl<IsCaptureSupportedResponse>;
    using ImportImageForCapture = ImportImageForCapture_Impl<ImportImageForCaptureResponse>;
    using StartCapture = StartCapture_Impl<StartCaptureResponse>;
    using ReleaseCapture = ReleaseCapture_Impl<ReleaseCaptureResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class ImportVmoImage_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ImportVmoImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer);
      ~ImportVmoImage_Impl() = default;
      ImportVmoImage_Impl(ImportVmoImage_Impl&& other) = default;
      ImportVmoImage_Impl& operator=(ImportVmoImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ImportImage_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ImportImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);
      ~ImportImage_Impl() = default;
      ImportImage_Impl(ImportImage_Impl&& other) = default;
      ImportImage_Impl& operator=(ImportImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ReleaseImage_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id);
      ~ReleaseImage_Impl() = default;
      ReleaseImage_Impl(ReleaseImage_Impl&& other) = default;
      ReleaseImage_Impl& operator=(ReleaseImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class ImportEvent_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ImportEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id);
      ~ImportEvent_Impl() = default;
      ImportEvent_Impl(ImportEvent_Impl&& other) = default;
      ImportEvent_Impl& operator=(ImportEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class ReleaseEvent_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseEvent_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id);
      ~ReleaseEvent_Impl() = default;
      ReleaseEvent_Impl(ReleaseEvent_Impl&& other) = default;
      ReleaseEvent_Impl& operator=(ReleaseEvent_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class CreateLayer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateLayer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~CreateLayer_Impl() = default;
      CreateLayer_Impl(CreateLayer_Impl&& other) = default;
      CreateLayer_Impl& operator=(CreateLayer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class DestroyLayer_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      DestroyLayer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id);
      ~DestroyLayer_Impl() = default;
      DestroyLayer_Impl(DestroyLayer_Impl&& other) = default;
      DestroyLayer_Impl& operator=(DestroyLayer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayMode_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayMode_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);
      ~SetDisplayMode_Impl() = default;
      SetDisplayMode_Impl(SetDisplayMode_Impl&& other) = default;
      SetDisplayMode_Impl& operator=(SetDisplayMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayColorConversion_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayColorConversion_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);
      ~SetDisplayColorConversion_Impl() = default;
      SetDisplayColorConversion_Impl(SetDisplayColorConversion_Impl&& other) = default;
      SetDisplayColorConversion_Impl& operator=(SetDisplayColorConversion_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetDisplayLayers_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetDisplayLayers_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);
      ~SetDisplayLayers_Impl() = default;
      SetDisplayLayers_Impl(SetDisplayLayers_Impl&& other) = default;
      SetDisplayLayers_Impl& operator=(SetDisplayLayers_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);
      ~SetLayerPrimaryConfig_Impl() = default;
      SetLayerPrimaryConfig_Impl(SetLayerPrimaryConfig_Impl&& other) = default;
      SetLayerPrimaryConfig_Impl& operator=(SetLayerPrimaryConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryPosition_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryPosition_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);
      ~SetLayerPrimaryPosition_Impl() = default;
      SetLayerPrimaryPosition_Impl(SetLayerPrimaryPosition_Impl&& other) = default;
      SetLayerPrimaryPosition_Impl& operator=(SetLayerPrimaryPosition_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerPrimaryAlpha_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerPrimaryAlpha_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);
      ~SetLayerPrimaryAlpha_Impl() = default;
      SetLayerPrimaryAlpha_Impl(SetLayerPrimaryAlpha_Impl&& other) = default;
      SetLayerPrimaryAlpha_Impl& operator=(SetLayerPrimaryAlpha_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerCursorConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerCursorConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);
      ~SetLayerCursorConfig_Impl() = default;
      SetLayerCursorConfig_Impl(SetLayerCursorConfig_Impl&& other) = default;
      SetLayerCursorConfig_Impl& operator=(SetLayerCursorConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerCursorPosition_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerCursorPosition_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y);
      ~SetLayerCursorPosition_Impl() = default;
      SetLayerCursorPosition_Impl(SetLayerCursorPosition_Impl&& other) = default;
      SetLayerCursorPosition_Impl& operator=(SetLayerCursorPosition_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerColorConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerColorConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);
      ~SetLayerColorConfig_Impl() = default;
      SetLayerColorConfig_Impl(SetLayerColorConfig_Impl&& other) = default;
      SetLayerColorConfig_Impl& operator=(SetLayerColorConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetLayerImage_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetLayerImage_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);
      ~SetLayerImage_Impl() = default;
      SetLayerImage_Impl(SetLayerImage_Impl&& other) = default;
      SetLayerImage_Impl& operator=(SetLayerImage_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class CheckConfig_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CheckConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer);
      ~CheckConfig_Impl() = default;
      CheckConfig_Impl(CheckConfig_Impl&& other) = default;
      CheckConfig_Impl& operator=(CheckConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ApplyConfig_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ApplyConfig_Impl(zx::unowned_channel _client_end);
      ~ApplyConfig_Impl() = default;
      ApplyConfig_Impl(ApplyConfig_Impl&& other) = default;
      ApplyConfig_Impl& operator=(ApplyConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class EnableVsync_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      EnableVsync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable);
      ~EnableVsync_Impl() = default;
      EnableVsync_Impl(EnableVsync_Impl&& other) = default;
      EnableVsync_Impl& operator=(EnableVsync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class SetVirtconMode_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      SetVirtconMode_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode);
      ~SetVirtconMode_Impl() = default;
      SetVirtconMode_Impl(SetVirtconMode_Impl&& other) = default;
      SetVirtconMode_Impl& operator=(SetVirtconMode_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class ImportBufferCollection_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ImportBufferCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer);
      ~ImportBufferCollection_Impl() = default;
      ImportBufferCollection_Impl(ImportBufferCollection_Impl&& other) = default;
      ImportBufferCollection_Impl& operator=(ImportBufferCollection_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class ReleaseBufferCollection_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      ReleaseBufferCollection_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id);
      ~ReleaseBufferCollection_Impl() = default;
      ReleaseBufferCollection_Impl(ReleaseBufferCollection_Impl&& other) = default;
      ReleaseBufferCollection_Impl& operator=(ReleaseBufferCollection_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class SetBufferCollectionConstraints_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetBufferCollectionConstraints_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer);
      ~SetBufferCollectionConstraints_Impl() = default;
      SetBufferCollectionConstraints_Impl(SetBufferCollectionConstraints_Impl&& other) = default;
      SetBufferCollectionConstraints_Impl& operator=(SetBufferCollectionConstraints_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSingleBufferFramebuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSingleBufferFramebuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSingleBufferFramebuffer_Impl() = default;
      GetSingleBufferFramebuffer_Impl(GetSingleBufferFramebuffer_Impl&& other) = default;
      GetSingleBufferFramebuffer_Impl& operator=(GetSingleBufferFramebuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class IsCaptureSupported_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      IsCaptureSupported_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~IsCaptureSupported_Impl() = default;
      IsCaptureSupported_Impl(IsCaptureSupported_Impl&& other) = default;
      IsCaptureSupported_Impl& operator=(IsCaptureSupported_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ImportImageForCapture_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ImportImageForCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);
      ~ImportImageForCapture_Impl() = default;
      ImportImageForCapture_Impl(ImportImageForCapture_Impl&& other) = default;
      ImportImageForCapture_Impl& operator=(ImportImageForCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StartCapture_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      StartCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer);
      ~StartCapture_Impl() = default;
      StartCapture_Impl(StartCapture_Impl&& other) = default;
      StartCapture_Impl& operator=(StartCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReleaseCapture_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReleaseCapture_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer);
      ~ReleaseCapture_Impl() = default;
      ReleaseCapture_Impl(ReleaseCapture_Impl&& other) = default;
      ReleaseCapture_Impl& operator=(ReleaseCapture_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using ImportVmoImage = ImportVmoImage_Impl<ImportVmoImageResponse>;
    using ImportImage = ImportImage_Impl<ImportImageResponse>;
    using ReleaseImage = ReleaseImage_Impl;
    using ImportEvent = ImportEvent_Impl;
    using ReleaseEvent = ReleaseEvent_Impl;
    using CreateLayer = CreateLayer_Impl<CreateLayerResponse>;
    using DestroyLayer = DestroyLayer_Impl;
    using SetDisplayMode = SetDisplayMode_Impl;
    using SetDisplayColorConversion = SetDisplayColorConversion_Impl;
    using SetDisplayLayers = SetDisplayLayers_Impl;
    using SetLayerPrimaryConfig = SetLayerPrimaryConfig_Impl;
    using SetLayerPrimaryPosition = SetLayerPrimaryPosition_Impl;
    using SetLayerPrimaryAlpha = SetLayerPrimaryAlpha_Impl;
    using SetLayerCursorConfig = SetLayerCursorConfig_Impl;
    using SetLayerCursorPosition = SetLayerCursorPosition_Impl;
    using SetLayerColorConfig = SetLayerColorConfig_Impl;
    using SetLayerImage = SetLayerImage_Impl;
    using CheckConfig = CheckConfig_Impl<CheckConfigResponse>;
    using ApplyConfig = ApplyConfig_Impl;
    using EnableVsync = EnableVsync_Impl;
    using SetVirtconMode = SetVirtconMode_Impl;
    using ImportBufferCollection = ImportBufferCollection_Impl<ImportBufferCollectionResponse>;
    using ReleaseBufferCollection = ReleaseBufferCollection_Impl;
    using SetBufferCollectionConstraints = SetBufferCollectionConstraints_Impl<SetBufferCollectionConstraintsResponse>;
    using GetSingleBufferFramebuffer = GetSingleBufferFramebuffer_Impl<GetSingleBufferFramebufferResponse>;
    using IsCaptureSupported = IsCaptureSupported_Impl<IsCaptureSupportedResponse>;
    using ImportImageForCapture = ImportImageForCapture_Impl<ImportImageForCaptureResponse>;
    using StartCapture = StartCapture_Impl<StartCaptureResponse>;
    using ReleaseCapture = ReleaseCapture_Impl<ReleaseCaptureResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ImportVmoImage ImportVmoImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ImportVmoImage ImportVmoImage(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer);

    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ImportImage ImportImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ImportImage ImportImage(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReleaseImage ReleaseImage(uint64_t image_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReleaseImage ReleaseImage(::fidl::BytePart _request_buffer, uint64_t image_id);

    // Imports an event into the driver and associates it with the given id.
    //
    // It is illegal for id to be equal to invalidId, and it is undefined to
    // import one event with two different ids or to import two different events
    // with the same id (note that ids map well to koids).
    //
    // If a client is reusing events, they must clear the signal
    // before referencing the id again.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ImportEvent ImportEvent(::zx::event event, uint64_t id);

    // Imports an event into the driver and associates it with the given id.
    //
    // It is illegal for id to be equal to invalidId, and it is undefined to
    // import one event with two different ids or to import two different events
    // with the same id (note that ids map well to koids).
    //
    // If a client is reusing events, they must clear the signal
    // before referencing the id again.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ImportEvent ImportEvent(::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id);

    // Releases the event imported with the given id.
    //
    // If any images are currently using the given event, the event
    // will still be waited up or signaled as appropriate before its
    // resources are released. It is an error to reuse an ID while the
    // active config has references to it.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReleaseEvent ReleaseEvent(uint64_t id);

    // Releases the event imported with the given id.
    //
    // If any images are currently using the given event, the event
    // will still be waited up or signaled as appropriate before its
    // resources are released. It is an error to reuse an ID while the
    // active config has references to it.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReleaseEvent ReleaseEvent(::fidl::BytePart _request_buffer, uint64_t id);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateLayer CreateLayer();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateLayer CreateLayer(::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::DestroyLayer DestroyLayer(uint64_t layer_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::DestroyLayer DestroyLayer(::fidl::BytePart _request_buffer, uint64_t layer_id);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetDisplayMode SetDisplayMode(uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetDisplayMode SetDisplayMode(::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);

    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetDisplayColorConversion SetDisplayColorConversion(uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetDisplayColorConversion SetDisplayColorConversion(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);

    // Request is heap-allocated.
    ResultOf::SetDisplayLayers SetDisplayLayers(uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetDisplayLayers SetDisplayLayers(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerPrimaryConfig SetLayerPrimaryConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerPrimaryConfig SetLayerPrimaryConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerPrimaryPosition SetLayerPrimaryPosition(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerPrimaryPosition SetLayerPrimaryPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerPrimaryAlpha SetLayerPrimaryAlpha(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerPrimaryAlpha SetLayerPrimaryAlpha(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerCursorConfig SetLayerCursorConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerCursorConfig SetLayerCursorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerCursorPosition SetLayerCursorPosition(uint64_t layer_id, int32_t x, int32_t y);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerCursorPosition SetLayerCursorPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y);

    // Request is heap-allocated.
    ResultOf::SetLayerColorConfig SetLayerColorConfig(uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerColorConfig SetLayerColorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetLayerImage SetLayerImage(uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetLayerImage SetLayerImage(::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);

    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::CheckConfig CheckConfig(bool discard);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CheckConfig CheckConfig(::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer);

    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ApplyConfig ApplyConfig();


    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::EnableVsync EnableVsync(bool enable);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::EnableVsync EnableVsync(::fidl::BytePart _request_buffer, bool enable);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetVirtconMode SetVirtconMode(uint8_t mode);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetVirtconMode SetVirtconMode(::fidl::BytePart _request_buffer, uint8_t mode);

    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ImportBufferCollection ImportBufferCollection(uint64_t collection_id, ::zx::channel collection_token);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ImportBufferCollection ImportBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReleaseBufferCollection ReleaseBufferCollection(uint64_t collection_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReleaseBufferCollection ReleaseBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id);

    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetBufferCollectionConstraints SetBufferCollectionConstraints(uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetBufferCollectionConstraints SetBufferCollectionConstraints(::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSingleBufferFramebuffer GetSingleBufferFramebuffer();

    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSingleBufferFramebuffer GetSingleBufferFramebuffer(::fidl::BytePart _response_buffer);

    // Returns true if Capture is supported on the platform.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::IsCaptureSupported IsCaptureSupported();

    // Returns true if Capture is supported on the platform.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::IsCaptureSupported IsCaptureSupported(::fidl::BytePart _response_buffer);

    // Imports a buffer collection backed VMO into the display controller. The VMO
    // will be used by display controller to capture the image being displayed.
    // Returns ZX_OK along with an image_id.
    // image_id must be used by the client to start capture and/or release
    // resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ImportImageForCapture ImportImageForCapture(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);

    // Imports a buffer collection backed VMO into the display controller. The VMO
    // will be used by display controller to capture the image being displayed.
    // Returns ZX_OK along with an image_id.
    // image_id must be used by the client to start capture and/or release
    // resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ImportImageForCapture ImportImageForCapture(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);

    // Starts capture. Client must provide a valid signal_event_id and
    // image_id. signal_event_id must have been imported into the driver
    // using ImportEvent FIDL API. Image_id is the id from ImportImageForCapture.
    // The client will get notified once capture is complete via signal_event_id.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::StartCapture StartCapture(uint64_t signal_event_id, uint64_t image_id);

    // Starts capture. Client must provide a valid signal_event_id and
    // image_id. signal_event_id must have been imported into the driver
    // using ImportEvent FIDL API. Image_id is the id from ImportImageForCapture.
    // The client will get notified once capture is complete via signal_event_id.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::StartCapture StartCapture(::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer);

    // Releases resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReleaseCapture ReleaseCapture(uint64_t image_id);

    // Releases resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReleaseCapture ReleaseCapture(::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ImportVmoImage ImportVmoImage(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ImportVmoImage ImportVmoImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer);

    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ImportImage ImportImage(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ImportImage ImportImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReleaseImage ReleaseImage(zx::unowned_channel _client_end, uint64_t image_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReleaseImage ReleaseImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id);

    // Imports an event into the driver and associates it with the given id.
    //
    // It is illegal for id to be equal to invalidId, and it is undefined to
    // import one event with two different ids or to import two different events
    // with the same id (note that ids map well to koids).
    //
    // If a client is reusing events, they must clear the signal
    // before referencing the id again.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ImportEvent ImportEvent(zx::unowned_channel _client_end, ::zx::event event, uint64_t id);

    // Imports an event into the driver and associates it with the given id.
    //
    // It is illegal for id to be equal to invalidId, and it is undefined to
    // import one event with two different ids or to import two different events
    // with the same id (note that ids map well to koids).
    //
    // If a client is reusing events, they must clear the signal
    // before referencing the id again.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ImportEvent ImportEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id);

    // Releases the event imported with the given id.
    //
    // If any images are currently using the given event, the event
    // will still be waited up or signaled as appropriate before its
    // resources are released. It is an error to reuse an ID while the
    // active config has references to it.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReleaseEvent ReleaseEvent(zx::unowned_channel _client_end, uint64_t id);

    // Releases the event imported with the given id.
    //
    // If any images are currently using the given event, the event
    // will still be waited up or signaled as appropriate before its
    // resources are released. It is an error to reuse an ID while the
    // active config has references to it.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReleaseEvent ReleaseEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateLayer CreateLayer(zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateLayer CreateLayer(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::DestroyLayer DestroyLayer(zx::unowned_channel _client_end, uint64_t layer_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::DestroyLayer DestroyLayer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id);

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetDisplayMode SetDisplayMode(zx::unowned_channel _client_end, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetDisplayMode SetDisplayMode(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode);

    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetDisplayColorConversion SetDisplayColorConversion(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetDisplayColorConversion SetDisplayColorConversion(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets);

    // Request is heap-allocated.
    static ResultOf::SetDisplayLayers SetDisplayLayers(zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetDisplayLayers SetDisplayLayers(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerPrimaryConfig SetLayerPrimaryConfig(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerPrimaryConfig SetLayerPrimaryConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerPrimaryPosition SetLayerPrimaryPosition(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerPrimaryPosition SetLayerPrimaryPosition(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerPrimaryAlpha SetLayerPrimaryAlpha(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerPrimaryAlpha SetLayerPrimaryAlpha(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val);

    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerCursorConfig SetLayerCursorConfig(zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerCursorConfig SetLayerCursorConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config);

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerCursorPosition SetLayerCursorPosition(zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerCursorPosition SetLayerCursorPosition(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y);

    // Request is heap-allocated.
    static ResultOf::SetLayerColorConfig SetLayerColorConfig(zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerColorConfig SetLayerColorConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetLayerImage SetLayerImage(zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetLayerImage SetLayerImage(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id);

    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::CheckConfig CheckConfig(zx::unowned_channel _client_end, bool discard);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CheckConfig CheckConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer);

    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ApplyConfig ApplyConfig(zx::unowned_channel _client_end);


    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::EnableVsync EnableVsync(zx::unowned_channel _client_end, bool enable);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::EnableVsync EnableVsync(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetVirtconMode SetVirtconMode(zx::unowned_channel _client_end, uint8_t mode);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetVirtconMode SetVirtconMode(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode);

    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ImportBufferCollection ImportBufferCollection(zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ImportBufferCollection ImportBufferCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer);

    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReleaseBufferCollection ReleaseBufferCollection(zx::unowned_channel _client_end, uint64_t collection_id);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReleaseBufferCollection ReleaseBufferCollection(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id);

    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetBufferCollectionConstraints SetBufferCollectionConstraints(zx::unowned_channel _client_end, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetBufferCollectionConstraints SetBufferCollectionConstraints(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer);

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSingleBufferFramebuffer GetSingleBufferFramebuffer(zx::unowned_channel _client_end);

    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSingleBufferFramebuffer GetSingleBufferFramebuffer(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns true if Capture is supported on the platform.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::IsCaptureSupported IsCaptureSupported(zx::unowned_channel _client_end);

    // Returns true if Capture is supported on the platform.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::IsCaptureSupported IsCaptureSupported(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Imports a buffer collection backed VMO into the display controller. The VMO
    // will be used by display controller to capture the image being displayed.
    // Returns ZX_OK along with an image_id.
    // image_id must be used by the client to start capture and/or release
    // resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ImportImageForCapture ImportImageForCapture(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index);

    // Imports a buffer collection backed VMO into the display controller. The VMO
    // will be used by display controller to capture the image being displayed.
    // Returns ZX_OK along with an image_id.
    // image_id must be used by the client to start capture and/or release
    // resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ImportImageForCapture ImportImageForCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer);

    // Starts capture. Client must provide a valid signal_event_id and
    // image_id. signal_event_id must have been imported into the driver
    // using ImportEvent FIDL API. Image_id is the id from ImportImageForCapture.
    // The client will get notified once capture is complete via signal_event_id.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::StartCapture StartCapture(zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id);

    // Starts capture. Client must provide a valid signal_event_id and
    // image_id. signal_event_id must have been imported into the driver
    // using ImportEvent FIDL API. Image_id is the id from ImportImageForCapture.
    // The client will get notified once capture is complete via signal_event_id.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::StartCapture StartCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer);

    // Releases resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReleaseCapture ReleaseCapture(zx::unowned_channel _client_end, uint64_t image_id);

    // Releases resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReleaseCapture ReleaseCapture(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    static ::fidl::DecodeResult<ImportVmoImageResponse> ImportVmoImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportVmoImageRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<ImportImageResponse> ImportImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::internal::StatusAndError ReleaseImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseImageRequest> params);

    // Imports an event into the driver and associates it with the given id.
    //
    // It is illegal for id to be equal to invalidId, and it is undefined to
    // import one event with two different ids or to import two different events
    // with the same id (note that ids map well to koids).
    //
    // If a client is reusing events, they must clear the signal
    // before referencing the id again.
    static ::fidl::internal::StatusAndError ImportEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportEventRequest> params);

    // Releases the event imported with the given id.
    //
    // If any images are currently using the given event, the event
    // will still be waited up or signaled as appropriate before its
    // resources are released. It is an error to reuse an ID while the
    // active config has references to it.
    static ::fidl::internal::StatusAndError ReleaseEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseEventRequest> params);

    static ::fidl::DecodeResult<CreateLayerResponse> CreateLayer(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    static ::fidl::internal::StatusAndError DestroyLayer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyLayerRequest> params);

    static ::fidl::internal::StatusAndError SetDisplayMode(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayModeRequest> params);

    static ::fidl::internal::StatusAndError SetDisplayColorConversion(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayColorConversionRequest> params);

    static ::fidl::internal::StatusAndError SetDisplayLayers(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayLayersRequest> params);

    static ::fidl::internal::StatusAndError SetLayerPrimaryConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> params);

    static ::fidl::internal::StatusAndError SetLayerPrimaryPosition(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> params);

    static ::fidl::internal::StatusAndError SetLayerPrimaryAlpha(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> params);

    static ::fidl::internal::StatusAndError SetLayerCursorConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorConfigRequest> params);

    static ::fidl::internal::StatusAndError SetLayerCursorPosition(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorPositionRequest> params);

    static ::fidl::internal::StatusAndError SetLayerColorConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerColorConfigRequest> params);

    static ::fidl::internal::StatusAndError SetLayerImage(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerImageRequest> params);

    static ::fidl::DecodeResult<CheckConfigResponse> CheckConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckConfigRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::internal::StatusAndError ApplyConfig(zx::unowned_channel _client_end);

    static ::fidl::internal::StatusAndError EnableVsync(zx::unowned_channel _client_end, ::fidl::DecodedMessage<EnableVsyncRequest> params);

    static ::fidl::internal::StatusAndError SetVirtconMode(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetVirtconModeRequest> params);

    static ::fidl::DecodeResult<ImportBufferCollectionResponse> ImportBufferCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportBufferCollectionRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::internal::StatusAndError ReleaseBufferCollection(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> params);

    static ::fidl::DecodeResult<SetBufferCollectionConstraintsResponse> SetBufferCollectionConstraints(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> params, ::fidl::BytePart response_buffer);

    static ::fidl::DecodeResult<GetSingleBufferFramebufferResponse> GetSingleBufferFramebuffer(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns true if Capture is supported on the platform.
    static ::fidl::DecodeResult<IsCaptureSupportedResponse> IsCaptureSupported(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Imports a buffer collection backed VMO into the display controller. The VMO
    // will be used by display controller to capture the image being displayed.
    // Returns ZX_OK along with an image_id.
    // image_id must be used by the client to start capture and/or release
    // resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    static ::fidl::DecodeResult<ImportImageForCaptureResponse> ImportImageForCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageForCaptureRequest> params, ::fidl::BytePart response_buffer);

    // Starts capture. Client must provide a valid signal_event_id and
    // image_id. signal_event_id must have been imported into the driver
    // using ImportEvent FIDL API. Image_id is the id from ImportImageForCapture.
    // The client will get notified once capture is complete via signal_event_id.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    static ::fidl::DecodeResult<StartCaptureResponse> StartCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartCaptureRequest> params, ::fidl::BytePart response_buffer);

    // Releases resources allocated for capture.
    // Returns ZX_ERR_NOT_SUPPORTED if controller does not support capture
    static ::fidl::DecodeResult<ReleaseCaptureResponse> ReleaseCapture(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseCaptureRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Controller;
    using _Base = ::fidl::CompleterBase;

    class ImportVmoImageCompleterBase : public _Base {
     public:
      void Reply(int32_t res, uint64_t image_id);
      void Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id);
      void Reply(::fidl::DecodedMessage<ImportVmoImageResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ImportVmoImageCompleter = ::fidl::Completer<ImportVmoImageCompleterBase>;

    virtual void ImportVmoImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ImportVmoImageCompleter::Sync _completer) = 0;

    class ImportImageCompleterBase : public _Base {
     public:
      void Reply(int32_t res, uint64_t image_id);
      void Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id);
      void Reply(::fidl::DecodedMessage<ImportImageResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ImportImageCompleter = ::fidl::Completer<ImportImageCompleterBase>;

    virtual void ImportImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ImportImageCompleter::Sync _completer) = 0;

    using ReleaseImageCompleter = ::fidl::Completer<>;

    virtual void ReleaseImage(uint64_t image_id, ReleaseImageCompleter::Sync _completer) = 0;

    using ImportEventCompleter = ::fidl::Completer<>;

    virtual void ImportEvent(::zx::event event, uint64_t id, ImportEventCompleter::Sync _completer) = 0;

    using ReleaseEventCompleter = ::fidl::Completer<>;

    virtual void ReleaseEvent(uint64_t id, ReleaseEventCompleter::Sync _completer) = 0;

    class CreateLayerCompleterBase : public _Base {
     public:
      void Reply(int32_t res, uint64_t layer_id);
      void Reply(::fidl::BytePart _buffer, int32_t res, uint64_t layer_id);
      void Reply(::fidl::DecodedMessage<CreateLayerResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateLayerCompleter = ::fidl::Completer<CreateLayerCompleterBase>;

    virtual void CreateLayer(CreateLayerCompleter::Sync _completer) = 0;

    using DestroyLayerCompleter = ::fidl::Completer<>;

    virtual void DestroyLayer(uint64_t layer_id, DestroyLayerCompleter::Sync _completer) = 0;

    using SetDisplayModeCompleter = ::fidl::Completer<>;

    virtual void SetDisplayMode(uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode, SetDisplayModeCompleter::Sync _completer) = 0;

    using SetDisplayColorConversionCompleter = ::fidl::Completer<>;

    virtual void SetDisplayColorConversion(uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets, SetDisplayColorConversionCompleter::Sync _completer) = 0;

    using SetDisplayLayersCompleter = ::fidl::Completer<>;

    virtual void SetDisplayLayers(uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids, SetDisplayLayersCompleter::Sync _completer) = 0;

    using SetLayerPrimaryConfigCompleter = ::fidl::Completer<>;

    virtual void SetLayerPrimaryConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, SetLayerPrimaryConfigCompleter::Sync _completer) = 0;

    using SetLayerPrimaryPositionCompleter = ::fidl::Completer<>;

    virtual void SetLayerPrimaryPosition(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame, SetLayerPrimaryPositionCompleter::Sync _completer) = 0;

    using SetLayerPrimaryAlphaCompleter = ::fidl::Completer<>;

    virtual void SetLayerPrimaryAlpha(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val, SetLayerPrimaryAlphaCompleter::Sync _completer) = 0;

    using SetLayerCursorConfigCompleter = ::fidl::Completer<>;

    virtual void SetLayerCursorConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, SetLayerCursorConfigCompleter::Sync _completer) = 0;

    using SetLayerCursorPositionCompleter = ::fidl::Completer<>;

    virtual void SetLayerCursorPosition(uint64_t layer_id, int32_t x, int32_t y, SetLayerCursorPositionCompleter::Sync _completer) = 0;

    using SetLayerColorConfigCompleter = ::fidl::Completer<>;

    virtual void SetLayerColorConfig(uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes, SetLayerColorConfigCompleter::Sync _completer) = 0;

    using SetLayerImageCompleter = ::fidl::Completer<>;

    virtual void SetLayerImage(uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id, SetLayerImageCompleter::Sync _completer) = 0;

    class CheckConfigCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::display::ConfigResult res, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::ClientCompositionOp> ops);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::ConfigResult res, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::ClientCompositionOp> ops);
      void Reply(::fidl::DecodedMessage<CheckConfigResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CheckConfigCompleter = ::fidl::Completer<CheckConfigCompleterBase>;

    virtual void CheckConfig(bool discard, CheckConfigCompleter::Sync _completer) = 0;

    using ApplyConfigCompleter = ::fidl::Completer<>;

    virtual void ApplyConfig(ApplyConfigCompleter::Sync _completer) = 0;

    using EnableVsyncCompleter = ::fidl::Completer<>;

    virtual void EnableVsync(bool enable, EnableVsyncCompleter::Sync _completer) = 0;

    using SetVirtconModeCompleter = ::fidl::Completer<>;

    virtual void SetVirtconMode(uint8_t mode, SetVirtconModeCompleter::Sync _completer) = 0;

    class ImportBufferCollectionCompleterBase : public _Base {
     public:
      void Reply(int32_t res);
      void Reply(::fidl::BytePart _buffer, int32_t res);
      void Reply(::fidl::DecodedMessage<ImportBufferCollectionResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ImportBufferCollectionCompleter = ::fidl::Completer<ImportBufferCollectionCompleterBase>;

    virtual void ImportBufferCollection(uint64_t collection_id, ::zx::channel collection_token, ImportBufferCollectionCompleter::Sync _completer) = 0;

    using ReleaseBufferCollectionCompleter = ::fidl::Completer<>;

    virtual void ReleaseBufferCollection(uint64_t collection_id, ReleaseBufferCollectionCompleter::Sync _completer) = 0;

    class SetBufferCollectionConstraintsCompleterBase : public _Base {
     public:
      void Reply(int32_t res);
      void Reply(::fidl::BytePart _buffer, int32_t res);
      void Reply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetBufferCollectionConstraintsCompleter = ::fidl::Completer<SetBufferCollectionConstraintsCompleterBase>;

    virtual void SetBufferCollectionConstraints(uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, SetBufferCollectionConstraintsCompleter::Sync _completer) = 0;

    class GetSingleBufferFramebufferCompleterBase : public _Base {
     public:
      void Reply(int32_t res, ::zx::vmo vmo, uint32_t stride);
      void Reply(::fidl::BytePart _buffer, int32_t res, ::zx::vmo vmo, uint32_t stride);
      void Reply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSingleBufferFramebufferCompleter = ::fidl::Completer<GetSingleBufferFramebufferCompleterBase>;

    virtual void GetSingleBufferFramebuffer(GetSingleBufferFramebufferCompleter::Sync _completer) = 0;

    class IsCaptureSupportedCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result result);
      void ReplySuccess(bool supported);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, bool supported);
      void Reply(::fidl::DecodedMessage<IsCaptureSupportedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IsCaptureSupportedCompleter = ::fidl::Completer<IsCaptureSupportedCompleterBase>;

    virtual void IsCaptureSupported(IsCaptureSupportedCompleter::Sync _completer) = 0;

    class ImportImageForCaptureCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result result);
      void ReplySuccess(uint64_t image_id);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t image_id);
      void Reply(::fidl::DecodedMessage<ImportImageForCaptureResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ImportImageForCaptureCompleter = ::fidl::Completer<ImportImageForCaptureCompleterBase>;

    virtual void ImportImageForCapture(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ImportImageForCaptureCompleter::Sync _completer) = 0;

    class StartCaptureCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<StartCaptureResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartCaptureCompleter = ::fidl::Completer<StartCaptureCompleterBase>;

    virtual void StartCapture(uint64_t signal_event_id, uint64_t image_id, StartCaptureCompleter::Sync _completer) = 0;

    class ReleaseCaptureCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ReleaseCaptureResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReleaseCaptureCompleter = ::fidl::Completer<ReleaseCaptureCompleterBase>;

    virtual void ReleaseCapture(uint64_t image_id, ReleaseCaptureCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  static zx_status_t SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added, ::fidl::VectorView<uint64_t> removed);

  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added, ::fidl::VectorView<uint64_t> removed);

  // Messages are encoded in-place.
  static zx_status_t SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<DisplaysChangedResponse> params);

  static zx_status_t SendVsyncEvent(::zx::unowned_channel _chan, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images);

  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images);

  // Messages are encoded in-place.
  static zx_status_t SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<VsyncResponse> params);

  static zx_status_t SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, bool has_ownership);

  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool has_ownership);

  // Messages are encoded in-place.
  static zx_status_t SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<ClientOwnershipChangeResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void DisplaysChangedResponse(const ::fidl::DecodedMessage<Controller::DisplaysChangedResponse>& _msg);
    static void ImportVmoImageRequest(const ::fidl::DecodedMessage<Controller::ImportVmoImageRequest>& _msg);
    static void ImportVmoImageResponse(const ::fidl::DecodedMessage<Controller::ImportVmoImageResponse>& _msg);
    static void ImportImageRequest(const ::fidl::DecodedMessage<Controller::ImportImageRequest>& _msg);
    static void ImportImageResponse(const ::fidl::DecodedMessage<Controller::ImportImageResponse>& _msg);
    static void ReleaseImageRequest(const ::fidl::DecodedMessage<Controller::ReleaseImageRequest>& _msg);
    static void ImportEventRequest(const ::fidl::DecodedMessage<Controller::ImportEventRequest>& _msg);
    static void ReleaseEventRequest(const ::fidl::DecodedMessage<Controller::ReleaseEventRequest>& _msg);
    static void CreateLayerRequest(const ::fidl::DecodedMessage<Controller::CreateLayerRequest>& _msg);
    static void CreateLayerResponse(const ::fidl::DecodedMessage<Controller::CreateLayerResponse>& _msg);
    static void DestroyLayerRequest(const ::fidl::DecodedMessage<Controller::DestroyLayerRequest>& _msg);
    static void SetDisplayModeRequest(const ::fidl::DecodedMessage<Controller::SetDisplayModeRequest>& _msg);
    static void SetDisplayColorConversionRequest(const ::fidl::DecodedMessage<Controller::SetDisplayColorConversionRequest>& _msg);
    static void SetDisplayLayersRequest(const ::fidl::DecodedMessage<Controller::SetDisplayLayersRequest>& _msg);
    static void SetLayerPrimaryConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryConfigRequest>& _msg);
    static void SetLayerPrimaryPositionRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryPositionRequest>& _msg);
    static void SetLayerPrimaryAlphaRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryAlphaRequest>& _msg);
    static void SetLayerCursorConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerCursorConfigRequest>& _msg);
    static void SetLayerCursorPositionRequest(const ::fidl::DecodedMessage<Controller::SetLayerCursorPositionRequest>& _msg);
    static void SetLayerColorConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerColorConfigRequest>& _msg);
    static void SetLayerImageRequest(const ::fidl::DecodedMessage<Controller::SetLayerImageRequest>& _msg);
    static void CheckConfigRequest(const ::fidl::DecodedMessage<Controller::CheckConfigRequest>& _msg);
    static void CheckConfigResponse(const ::fidl::DecodedMessage<Controller::CheckConfigResponse>& _msg);
    static void ApplyConfigRequest(const ::fidl::DecodedMessage<Controller::ApplyConfigRequest>& _msg);
    static void EnableVsyncRequest(const ::fidl::DecodedMessage<Controller::EnableVsyncRequest>& _msg);
    static void VsyncResponse(const ::fidl::DecodedMessage<Controller::VsyncResponse>& _msg);
    static void SetVirtconModeRequest(const ::fidl::DecodedMessage<Controller::SetVirtconModeRequest>& _msg);
    static void ClientOwnershipChangeResponse(const ::fidl::DecodedMessage<Controller::ClientOwnershipChangeResponse>& _msg);
    static void ImportBufferCollectionRequest(const ::fidl::DecodedMessage<Controller::ImportBufferCollectionRequest>& _msg);
    static void ImportBufferCollectionResponse(const ::fidl::DecodedMessage<Controller::ImportBufferCollectionResponse>& _msg);
    static void ReleaseBufferCollectionRequest(const ::fidl::DecodedMessage<Controller::ReleaseBufferCollectionRequest>& _msg);
    static void SetBufferCollectionConstraintsRequest(const ::fidl::DecodedMessage<Controller::SetBufferCollectionConstraintsRequest>& _msg);
    static void SetBufferCollectionConstraintsResponse(const ::fidl::DecodedMessage<Controller::SetBufferCollectionConstraintsResponse>& _msg);
    static void GetSingleBufferFramebufferRequest(const ::fidl::DecodedMessage<Controller::GetSingleBufferFramebufferRequest>& _msg);
    static void GetSingleBufferFramebufferResponse(const ::fidl::DecodedMessage<Controller::GetSingleBufferFramebufferResponse>& _msg);
    static void IsCaptureSupportedRequest(const ::fidl::DecodedMessage<Controller::IsCaptureSupportedRequest>& _msg);
    static void IsCaptureSupportedResponse(const ::fidl::DecodedMessage<Controller::IsCaptureSupportedResponse>& _msg);
    static void ImportImageForCaptureRequest(const ::fidl::DecodedMessage<Controller::ImportImageForCaptureRequest>& _msg);
    static void ImportImageForCaptureResponse(const ::fidl::DecodedMessage<Controller::ImportImageForCaptureResponse>& _msg);
    static void StartCaptureRequest(const ::fidl::DecodedMessage<Controller::StartCaptureRequest>& _msg);
    static void StartCaptureResponse(const ::fidl::DecodedMessage<Controller::StartCaptureResponse>& _msg);
    static void ReleaseCaptureRequest(const ::fidl::DecodedMessage<Controller::ReleaseCaptureRequest>& _msg);
    static void ReleaseCaptureResponse(const ::fidl::DecodedMessage<Controller::ReleaseCaptureResponse>& _msg);
  };
};

}  // namespace display
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest)
    == ::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest, device) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerRequest, controller) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerResponse)
    == ::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenVirtconControllerResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest)
    == ::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest, device) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenControllerRequest, controller) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Provider::OpenControllerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Provider::OpenControllerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Provider::OpenControllerResponse)
    == ::llcpp::fuchsia::hardware::display::Provider::OpenControllerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Provider::OpenControllerResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Mode> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Mode>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Mode, horizontal_resolution) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Mode, vertical_resolution) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Mode, refresh_rate_e2) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Mode, flags) == 12);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Mode) == ::llcpp::fuchsia::hardware::display::Mode::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::ImagePlane> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::ImagePlane>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImagePlane, byte_offset) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImagePlane, bytes_per_row) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::ImagePlane) == ::llcpp::fuchsia::hardware::display::ImagePlane::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::ImageConfig> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::ImageConfig>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImageConfig, width) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImageConfig, height) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImageConfig, pixel_format) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImageConfig, type) == 12);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ImageConfig, planes) == 16);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::ImageConfig) == ::llcpp::fuchsia::hardware::display::ImageConfig::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Frame> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Frame>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Frame, x_pos) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Frame, y_pos) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Frame, width) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Frame, height) == 12);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Frame) == ::llcpp::fuchsia::hardware::display::Frame::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::CursorInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::CursorInfo>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::CursorInfo, width) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::CursorInfo, height) == 4);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::CursorInfo, pixel_format) == 8);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::CursorInfo) == ::llcpp::fuchsia::hardware::display::CursorInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Info> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Info>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, id) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, modes) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, pixel_format) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, cursor_configs) == 40);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, manufacturer_name) == 56);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, monitor_name) == 72);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Info, monitor_serial) == 88);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Info) == ::llcpp::fuchsia::hardware::display::Info::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response) == ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response) == ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response, supported) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response) == ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response, image_id) == 0);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response) == ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::ClientCompositionOp> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::display::ClientCompositionOp>);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ClientCompositionOp, display_id) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ClientCompositionOp, layer_id) == 8);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::ClientCompositionOp, opcode) == 16);
static_assert(sizeof(::llcpp::fuchsia::hardware::display::ClientCompositionOp) == ::llcpp::fuchsia::hardware::display::ClientCompositionOp::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse, added) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::DisplaysChangedResponse, removed) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest, image_config) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest, vmo) == 64);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageRequest, offset) == 68);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse, res) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportVmoImageResponse, image_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest, image_config) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest, collection_id) == 64);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageRequest, index) == 72);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse, res) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageResponse, image_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ReleaseImageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ReleaseImageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ReleaseImageRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ReleaseImageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ReleaseImageRequest, image_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest, event) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportEventRequest, id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ReleaseEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ReleaseEventRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ReleaseEventRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ReleaseEventRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ReleaseEventRequest, id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse, res) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::CreateLayerResponse, layer_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::DestroyLayerRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::DestroyLayerRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::DestroyLayerRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::DestroyLayerRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::DestroyLayerRequest, layer_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest, display_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayModeRequest, mode) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest, display_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest, preoffsets) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest, coefficients) == 36);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayColorConversionRequest, postoffsets) == 72);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest, display_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetDisplayLayersRequest, layer_ids) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryConfigRequest, image_config) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest, transform) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest, src_frame) == 28);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryPositionRequest, dest_frame) == 44);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest, mode) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerPrimaryAlphaRequest, val) == 28);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorConfigRequest, image_config) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest, x) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerCursorPositionRequest, y) == 28);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest, pixel_format) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerColorConfigRequest, color_bytes) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest, layer_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest, image_id) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest, wait_event_id) == 32);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetLayerImageRequest, signal_event_id) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::CheckConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::CheckConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::CheckConfigRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::CheckConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::CheckConfigRequest, discard) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse, res) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::CheckConfigResponse, ops) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::EnableVsyncRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::EnableVsyncRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::EnableVsyncRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::EnableVsyncRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::EnableVsyncRequest, enable) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::VsyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::VsyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::VsyncResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::VsyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::VsyncResponse, display_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::VsyncResponse, timestamp) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::VsyncResponse, images) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetVirtconModeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetVirtconModeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetVirtconModeRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetVirtconModeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetVirtconModeRequest, mode) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ClientOwnershipChangeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ClientOwnershipChangeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ClientOwnershipChangeResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ClientOwnershipChangeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ClientOwnershipChangeResponse, has_ownership) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest, collection_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionRequest, collection_token) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportBufferCollectionResponse, res) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ReleaseBufferCollectionRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ReleaseBufferCollectionRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ReleaseBufferCollectionRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ReleaseBufferCollectionRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ReleaseBufferCollectionRequest, collection_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest, collection_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsRequest, config) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::SetBufferCollectionConstraintsResponse, res) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse, res) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse, vmo) == 20);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::GetSingleBufferFramebufferResponse, stride) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::IsCaptureSupportedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::IsCaptureSupportedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::IsCaptureSupportedResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::IsCaptureSupportedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::IsCaptureSupportedResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest, image_config) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest, collection_id) == 64);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureRequest, index) == 72);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ImportImageForCaptureResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest, signal_event_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::StartCaptureRequest, image_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::StartCaptureResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::StartCaptureResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::StartCaptureResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::StartCaptureResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::StartCaptureResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureRequest)
    == ::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureRequest, image_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureResponse)
    == ::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller::ReleaseCaptureResponse, result) == 16);

}  // namespace fidl

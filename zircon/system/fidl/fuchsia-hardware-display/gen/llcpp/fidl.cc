// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/display/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace display {

namespace {

[[maybe_unused]]
constexpr uint64_t kProvider_OpenVirtconController_Ordinal = 0x7522c7b300000000lu;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenVirtconController_GenOrdinal = 0x7163a23d838e6fb6lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenVirtconControllerResponseTable;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenController_Ordinal = 0x69d407d00000000lu;
[[maybe_unused]]
constexpr uint64_t kProvider_OpenController_GenOrdinal = 0x54b5aa00a47ab0b3lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ProviderOpenControllerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ProviderOpenControllerResponseTable;

}  // namespace
template <>
Provider::ResultOf::OpenVirtconController_Impl<Provider::OpenVirtconControllerResponse>::OpenVirtconController_Impl(::zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenVirtconControllerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenVirtconControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenVirtconControllerRequest*>(_write_bytes);
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenVirtconControllerRequest));
  ::fidl::DecodedMessage<OpenVirtconControllerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Provider::InPlace::OpenVirtconController(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Provider::ResultOf::OpenVirtconController Provider::SyncClient::OpenVirtconController(::zx::channel device, ::zx::channel controller) {
    return ResultOf::OpenVirtconController(::zx::unowned_channel(this->channel_), std::move(device), std::move(controller));
}

Provider::ResultOf::OpenVirtconController Provider::Call::OpenVirtconController(::zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenVirtconController(std::move(_client_end), std::move(device), std::move(controller));
}

template <>
Provider::UnownedResultOf::OpenVirtconController_Impl<Provider::OpenVirtconControllerResponse>::OpenVirtconController_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenVirtconControllerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenVirtconControllerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenVirtconControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenVirtconControllerRequest*>(_request_buffer.data());
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  _request_buffer.set_actual(sizeof(OpenVirtconControllerRequest));
  ::fidl::DecodedMessage<OpenVirtconControllerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Provider::InPlace::OpenVirtconController(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Provider::UnownedResultOf::OpenVirtconController Provider::SyncClient::OpenVirtconController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenVirtconController(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

Provider::UnownedResultOf::OpenVirtconController Provider::Call::OpenVirtconController(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenVirtconController(std::move(_client_end), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

::fidl::DecodeResult<Provider::OpenVirtconControllerResponse> Provider::InPlace::OpenVirtconController(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenVirtconControllerRequest> params, ::fidl::BytePart response_buffer) {
  Provider::SetTransactionHeaderFor::OpenVirtconControllerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenVirtconControllerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenVirtconControllerRequest, OpenVirtconControllerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenVirtconControllerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Provider::ResultOf::OpenController_Impl<Provider::OpenControllerResponse>::OpenController_Impl(::zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenControllerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenControllerRequest*>(_write_bytes);
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenControllerRequest));
  ::fidl::DecodedMessage<OpenControllerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Provider::InPlace::OpenController(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Provider::ResultOf::OpenController Provider::SyncClient::OpenController(::zx::channel device, ::zx::channel controller) {
    return ResultOf::OpenController(::zx::unowned_channel(this->channel_), std::move(device), std::move(controller));
}

Provider::ResultOf::OpenController Provider::Call::OpenController(::zx::unowned_channel _client_end, ::zx::channel device, ::zx::channel controller) {
  return ResultOf::OpenController(std::move(_client_end), std::move(device), std::move(controller));
}

template <>
Provider::UnownedResultOf::OpenController_Impl<Provider::OpenControllerResponse>::OpenController_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenControllerRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenControllerResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenControllerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenControllerRequest*>(_request_buffer.data());
  _request.device = std::move(device);
  _request.controller = std::move(controller);
  _request_buffer.set_actual(sizeof(OpenControllerRequest));
  ::fidl::DecodedMessage<OpenControllerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Provider::InPlace::OpenController(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Provider::UnownedResultOf::OpenController Provider::SyncClient::OpenController(::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenController(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

Provider::UnownedResultOf::OpenController Provider::Call::OpenController(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel device, ::zx::channel controller, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenController(std::move(_client_end), std::move(_request_buffer), std::move(device), std::move(controller), std::move(_response_buffer));
}

::fidl::DecodeResult<Provider::OpenControllerResponse> Provider::InPlace::OpenController(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenControllerRequest> params, ::fidl::BytePart response_buffer) {
  Provider::SetTransactionHeaderFor::OpenControllerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenControllerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenControllerRequest, OpenControllerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Provider::OpenControllerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Provider::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kProvider_OpenVirtconController_Ordinal:
    case kProvider_OpenVirtconController_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenVirtconControllerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenVirtconController(std::move(message->device), std::move(message->controller),
          Interface::OpenVirtconControllerCompleter::Sync(txn));
      return true;
    }
    case kProvider_OpenController_Ordinal:
    case kProvider_OpenController_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenControllerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenController(std::move(message->device), std::move(message->controller),
          Interface::OpenControllerCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Provider::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenVirtconControllerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OpenVirtconControllerResponse*>(_write_bytes);
  Provider::SetTransactionHeaderFor::OpenVirtconControllerResponse(
      ::fidl::DecodedMessage<OpenVirtconControllerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenVirtconControllerResponse::PrimarySize,
              OpenVirtconControllerResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenVirtconControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenVirtconControllerResponse>(std::move(_response_bytes)));
}

void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < OpenVirtconControllerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<OpenVirtconControllerResponse*>(_buffer.data());
  Provider::SetTransactionHeaderFor::OpenVirtconControllerResponse(
      ::fidl::DecodedMessage<OpenVirtconControllerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenVirtconControllerResponse::PrimarySize,
              OpenVirtconControllerResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(OpenVirtconControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenVirtconControllerResponse>(std::move(_buffer)));
}

void Provider::Interface::OpenVirtconControllerCompleterBase::Reply(::fidl::DecodedMessage<OpenVirtconControllerResponse> params) {
  Provider::SetTransactionHeaderFor::OpenVirtconControllerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Provider::Interface::OpenControllerCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenControllerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OpenControllerResponse*>(_write_bytes);
  Provider::SetTransactionHeaderFor::OpenControllerResponse(
      ::fidl::DecodedMessage<OpenControllerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenControllerResponse::PrimarySize,
              OpenControllerResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenControllerResponse>(std::move(_response_bytes)));
}

void Provider::Interface::OpenControllerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < OpenControllerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<OpenControllerResponse*>(_buffer.data());
  Provider::SetTransactionHeaderFor::OpenControllerResponse(
      ::fidl::DecodedMessage<OpenControllerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OpenControllerResponse::PrimarySize,
              OpenControllerResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(OpenControllerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenControllerResponse>(std::move(_buffer)));
}

void Provider::Interface::OpenControllerCompleterBase::Reply(::fidl::DecodedMessage<OpenControllerResponse> params) {
  Provider::SetTransactionHeaderFor::OpenControllerResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Provider::SetTransactionHeaderFor::OpenVirtconControllerRequest(const ::fidl::DecodedMessage<Provider::OpenVirtconControllerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kProvider_OpenVirtconController_GenOrdinal);
}
void Provider::SetTransactionHeaderFor::OpenVirtconControllerResponse(const ::fidl::DecodedMessage<Provider::OpenVirtconControllerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kProvider_OpenVirtconController_GenOrdinal);
}

void Provider::SetTransactionHeaderFor::OpenControllerRequest(const ::fidl::DecodedMessage<Provider::OpenControllerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kProvider_OpenController_GenOrdinal);
}
void Provider::SetTransactionHeaderFor::OpenControllerResponse(const ::fidl::DecodedMessage<Provider::OpenControllerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kProvider_OpenController_GenOrdinal);
}

::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::Controller_StartCapture_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::~Controller_StartCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_StartCapture_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::MoveImpl_(Controller_StartCapture_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::Controller_ReleaseCapture_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::~Controller_ReleaseCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_ReleaseCapture_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::MoveImpl_(Controller_ReleaseCapture_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::Controller_IsCaptureSupported_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::~Controller_IsCaptureSupported_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_IsCaptureSupported_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::MoveImpl_(Controller_IsCaptureSupported_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result) == ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response& ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::Controller_ImportImageForCapture_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::~Controller_ImportImageForCapture_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_ImportImageForCapture_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::MoveImpl_(Controller_ImportImageForCapture_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result, response_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result, err_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result) == ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response& ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kController_DisplaysChanged_Ordinal = 0x30f5452200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_DisplaysChanged_GenOrdinal = 0x848efe931ddb1c6lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDisplaysChangedRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDisplaysChangedEventTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportVmoImage_Ordinal = 0x420a4b7000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportVmoImage_GenOrdinal = 0x7cab4d73f9f1893clu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportVmoImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportImage_Ordinal = 0x18d6e53b00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportImage_GenOrdinal = 0x1be9cd6562de6db5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseImage_Ordinal = 0x3abc075800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseImage_GenOrdinal = 0x63a7d0a6b107bd11lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportEvent_Ordinal = 0x7d2447aa00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportEvent_GenOrdinal = 0x402289f13944e6d7lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportEventRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseEvent_Ordinal = 0x4379630400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseEvent_GenOrdinal = 0x657e4eab9a8e23a1lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseEventRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseEventResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseEventResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_CreateLayer_Ordinal = 0x7f56932400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_CreateLayer_GenOrdinal = 0x468d06aadd139295lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCreateLayerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCreateLayerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCreateLayerResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_DestroyLayer_Ordinal = 0x2abc04b100000000lu;
[[maybe_unused]]
constexpr uint64_t kController_DestroyLayer_GenOrdinal = 0x6b42dce004859fe5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDestroyLayerRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerDestroyLayerResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerDestroyLayerResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayMode_Ordinal = 0x584c92ab00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayMode_GenOrdinal = 0x55a035e7a881c48dlu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayModeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayModeResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayColorConversion_Ordinal = 0x71cb370500000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayColorConversion_GenOrdinal = 0x3d3548d04caf79b7lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayColorConversionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayColorConversionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayColorConversionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayLayers_Ordinal = 0x9bebf8600000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetDisplayLayers_GenOrdinal = 0x47e92da1f9702675lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayLayersRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetDisplayLayersResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetDisplayLayersResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryConfig_Ordinal = 0x3673de6000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryConfig_GenOrdinal = 0x10bc9fc5d61f5c94lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryPosition_Ordinal = 0x6bd4fbc600000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryPosition_GenOrdinal = 0x735faf29ee889cdclu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryPositionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryPositionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryPositionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryAlpha_Ordinal = 0x5a79ec9200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerPrimaryAlpha_GenOrdinal = 0x1b81604b1a9b6576lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerPrimaryAlphaResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorConfig_Ordinal = 0x74020b200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorConfig_GenOrdinal = 0x2fddfd240f9e7764lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorPosition_Ordinal = 0x2f36e7b000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerCursorPosition_GenOrdinal = 0x147c1526ac3ad9c5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorPositionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerCursorPositionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerCursorPositionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerColorConfig_Ordinal = 0x21cc7c8800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerColorConfig_GenOrdinal = 0x19cb6da071d515calu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerColorConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerColorConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerColorConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerImage_Ordinal = 0x1ecab8800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetLayerImage_GenOrdinal = 0x7c71f66253182fb9lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerImageRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetLayerImageResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetLayerImageResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_CheckConfig_Ordinal = 0x160ce58b00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_CheckConfig_GenOrdinal = 0x586ca589eaf66e11lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerCheckConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerCheckConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ApplyConfig_Ordinal = 0x572081a200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ApplyConfig_GenOrdinal = 0x65b30a10604984f7lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerApplyConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerApplyConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerApplyConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_EnableVsync_Ordinal = 0x2be2db1300000000lu;
[[maybe_unused]]
constexpr uint64_t kController_EnableVsync_GenOrdinal = 0x5d517bdbc05d434elu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerEnableVsyncRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerEnableVsyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerEnableVsyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Vsync_Ordinal = 0x71fcce9000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Vsync_GenOrdinal = 0x5813c85bf6f9d5f5lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerVsyncRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerVsyncEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerVsyncEventTable;
[[maybe_unused]]
constexpr uint64_t kController_SetVirtconMode_Ordinal = 0x49c4520700000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetVirtconMode_GenOrdinal = 0x7c8d1b102e72182clu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetVirtconModeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetVirtconModeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetVirtconModeResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ClientOwnershipChange_Ordinal = 0x4360b92e00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ClientOwnershipChange_GenOrdinal = 0x41b1af32fb2f7362lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerClientOwnershipChangeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerClientOwnershipChangeEventTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportBufferCollection_Ordinal = 0x605b9d0d00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportBufferCollection_GenOrdinal = 0x1cdf9cc2e60832d1lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportBufferCollectionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseBufferCollection_Ordinal = 0x52f8b58400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseBufferCollection_GenOrdinal = 0x4527c480391b6c83lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseBufferCollectionRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseBufferCollectionResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseBufferCollectionResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_SetBufferCollectionConstraints_Ordinal = 0x78b51dd00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_SetBufferCollectionConstraints_GenOrdinal = 0x3b78d75d2d21b451lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerSetBufferCollectionConstraintsResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetSingleBufferFramebuffer_Ordinal = 0x2ecce54500000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetSingleBufferFramebuffer_GenOrdinal = 0x65cd908c2c03b49dlu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerGetSingleBufferFramebufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerGetSingleBufferFramebufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_IsCaptureSupported_Ordinal = 0x6dfc193a00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_IsCaptureSupported_GenOrdinal = 0x1cd2541e93a17760lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerIsCaptureSupportedRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerIsCaptureSupportedResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ImportImageForCapture_Ordinal = 0x3150d1a200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ImportImageForCapture_GenOrdinal = 0x2a595fbc2df7f9eblu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerImportImageForCaptureResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_StartCapture_Ordinal = 0x5436d93300000000lu;
[[maybe_unused]]
constexpr uint64_t kController_StartCapture_GenOrdinal = 0x7d4ccf55f0259266lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerStartCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerStartCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerStartCaptureResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseCapture_Ordinal = 0x7f1785f000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseCapture_GenOrdinal = 0x3c5dbe1d114a5752lu;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseCaptureRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_display_ControllerReleaseCaptureResponseTable;

}  // namespace
template <>
Controller::ResultOf::ImportVmoImage_Impl<Controller::ImportVmoImageResponse>::ImportVmoImage_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportVmoImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportVmoImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportVmoImageRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.vmo = std::move(vmo);
  _request.offset = std::move(offset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportVmoImageRequest));
  ::fidl::DecodedMessage<ImportVmoImageRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportVmoImage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportVmoImage Controller::SyncClient::ImportVmoImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
    return ResultOf::ImportVmoImage(::zx::unowned_channel(this->channel_), std::move(image_config), std::move(vmo), std::move(offset));
}

Controller::ResultOf::ImportVmoImage Controller::Call::ImportVmoImage(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset) {
  return ResultOf::ImportVmoImage(std::move(_client_end), std::move(image_config), std::move(vmo), std::move(offset));
}

template <>
Controller::UnownedResultOf::ImportVmoImage_Impl<Controller::ImportVmoImageResponse>::ImportVmoImage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportVmoImageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportVmoImageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportVmoImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportVmoImageRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.vmo = std::move(vmo);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(ImportVmoImageRequest));
  ::fidl::DecodedMessage<ImportVmoImageRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportVmoImage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportVmoImage Controller::SyncClient::ImportVmoImage(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportVmoImage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(vmo), std::move(offset), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportVmoImage Controller::Call::ImportVmoImage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, ::zx::vmo vmo, int32_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportVmoImage(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(vmo), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportVmoImageResponse> Controller::InPlace::ImportVmoImage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportVmoImageRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ImportVmoImageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportVmoImageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportVmoImageRequest, ImportVmoImageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportVmoImageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ImportImage_Impl<Controller::ImportImageResponse>::ImportImage_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageRequest));
  ::fidl::DecodedMessage<ImportImageRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportImage(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportImage Controller::SyncClient::ImportImage(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
    return ResultOf::ImportImage(::zx::unowned_channel(this->channel_), std::move(image_config), std::move(collection_id), std::move(index));
}

Controller::ResultOf::ImportImage Controller::Call::ImportImage(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImage(std::move(_client_end), std::move(image_config), std::move(collection_id), std::move(index));
}

template <>
Controller::UnownedResultOf::ImportImage_Impl<Controller::ImportImageResponse>::ImportImage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportImageRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportImageResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(ImportImageRequest));
  ::fidl::DecodedMessage<ImportImageRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportImage(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportImage Controller::SyncClient::ImportImage(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportImage Controller::Call::ImportImage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImage(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportImageResponse> Controller::InPlace::ImportImage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ImportImageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportImageRequest, ImportImageResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ReleaseImage_Impl::ReleaseImage_Impl(::zx::unowned_channel _client_end, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseImageRequest*>(_write_bytes);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseImageRequest));
  ::fidl::DecodedMessage<ReleaseImageRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseImage Controller::SyncClient::ReleaseImage(uint64_t image_id) {
    return ResultOf::ReleaseImage(::zx::unowned_channel(this->channel_), std::move(image_id));
}

Controller::ResultOf::ReleaseImage Controller::Call::ReleaseImage(::zx::unowned_channel _client_end, uint64_t image_id) {
  return ResultOf::ReleaseImage(std::move(_client_end), std::move(image_id));
}


Controller::UnownedResultOf::ReleaseImage_Impl::ReleaseImage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id) {
  if (_request_buffer.capacity() < ReleaseImageRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseImageRequest*>(_request_buffer.data());
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(ReleaseImageRequest));
  ::fidl::DecodedMessage<ReleaseImageRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseImage Controller::SyncClient::ReleaseImage(::fidl::BytePart _request_buffer, uint64_t image_id) {
  return UnownedResultOf::ReleaseImage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_id));
}

Controller::UnownedResultOf::ReleaseImage Controller::Call::ReleaseImage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id) {
  return UnownedResultOf::ReleaseImage(std::move(_client_end), std::move(_request_buffer), std::move(image_id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseImage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseImageRequest> params) {
  Controller::SetTransactionHeaderFor::ReleaseImageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::ImportEvent_Impl::ImportEvent_Impl(::zx::unowned_channel _client_end, ::zx::event event, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportEventRequest*>(_write_bytes);
  _request.event = std::move(event);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportEventRequest));
  ::fidl::DecodedMessage<ImportEventRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ImportEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ImportEvent Controller::SyncClient::ImportEvent(::zx::event event, uint64_t id) {
    return ResultOf::ImportEvent(::zx::unowned_channel(this->channel_), std::move(event), std::move(id));
}

Controller::ResultOf::ImportEvent Controller::Call::ImportEvent(::zx::unowned_channel _client_end, ::zx::event event, uint64_t id) {
  return ResultOf::ImportEvent(std::move(_client_end), std::move(event), std::move(id));
}


Controller::UnownedResultOf::ImportEvent_Impl::ImportEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  if (_request_buffer.capacity() < ImportEventRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ImportEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportEventRequest*>(_request_buffer.data());
  _request.event = std::move(event);
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(ImportEventRequest));
  ::fidl::DecodedMessage<ImportEventRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ImportEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ImportEvent Controller::SyncClient::ImportEvent(::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  return UnownedResultOf::ImportEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(event), std::move(id));
}

Controller::UnownedResultOf::ImportEvent Controller::Call::ImportEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::event event, uint64_t id) {
  return UnownedResultOf::ImportEvent(std::move(_client_end), std::move(_request_buffer), std::move(event), std::move(id));
}

::fidl::internal::StatusAndError Controller::InPlace::ImportEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportEventRequest> params) {
  Controller::SetTransactionHeaderFor::ImportEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::ReleaseEvent_Impl::ReleaseEvent_Impl(::zx::unowned_channel _client_end, uint64_t id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseEventRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseEventRequest*>(_write_bytes);
  _request.id = std::move(id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseEventRequest));
  ::fidl::DecodedMessage<ReleaseEventRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseEvent Controller::SyncClient::ReleaseEvent(uint64_t id) {
    return ResultOf::ReleaseEvent(::zx::unowned_channel(this->channel_), std::move(id));
}

Controller::ResultOf::ReleaseEvent Controller::Call::ReleaseEvent(::zx::unowned_channel _client_end, uint64_t id) {
  return ResultOf::ReleaseEvent(std::move(_client_end), std::move(id));
}


Controller::UnownedResultOf::ReleaseEvent_Impl::ReleaseEvent_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id) {
  if (_request_buffer.capacity() < ReleaseEventRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseEventRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseEventRequest*>(_request_buffer.data());
  _request.id = std::move(id);
  _request_buffer.set_actual(sizeof(ReleaseEventRequest));
  ::fidl::DecodedMessage<ReleaseEventRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseEvent(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseEvent Controller::SyncClient::ReleaseEvent(::fidl::BytePart _request_buffer, uint64_t id) {
  return UnownedResultOf::ReleaseEvent(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(id));
}

Controller::UnownedResultOf::ReleaseEvent Controller::Call::ReleaseEvent(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t id) {
  return UnownedResultOf::ReleaseEvent(std::move(_client_end), std::move(_request_buffer), std::move(id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseEvent(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseEventRequest> params) {
  Controller::SetTransactionHeaderFor::ReleaseEventRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::CreateLayer_Impl<Controller::CreateLayerResponse>::CreateLayer_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLayerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CreateLayerRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLayerRequest));
  ::fidl::DecodedMessage<CreateLayerRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::CreateLayer(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::CreateLayer Controller::SyncClient::CreateLayer() {
    return ResultOf::CreateLayer(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::CreateLayer Controller::Call::CreateLayer(::zx::unowned_channel _client_end) {
  return ResultOf::CreateLayer(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::CreateLayer_Impl<Controller::CreateLayerResponse>::CreateLayer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CreateLayerRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CreateLayerRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CreateLayerRequest));
  ::fidl::DecodedMessage<CreateLayerRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::CreateLayer(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::CreateLayer Controller::SyncClient::CreateLayer(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLayer(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::CreateLayer Controller::Call::CreateLayer(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CreateLayer(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::CreateLayerResponse> Controller::InPlace::CreateLayer(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CreateLayerRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CreateLayerRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::CreateLayerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CreateLayerResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CreateLayerRequest, CreateLayerResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CreateLayerResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::DestroyLayer_Impl::DestroyLayer_Impl(::zx::unowned_channel _client_end, uint64_t layer_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DestroyLayerRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DestroyLayerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyLayerRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DestroyLayerRequest));
  ::fidl::DecodedMessage<DestroyLayerRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::DestroyLayer(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::DestroyLayer Controller::SyncClient::DestroyLayer(uint64_t layer_id) {
    return ResultOf::DestroyLayer(::zx::unowned_channel(this->channel_), std::move(layer_id));
}

Controller::ResultOf::DestroyLayer Controller::Call::DestroyLayer(::zx::unowned_channel _client_end, uint64_t layer_id) {
  return ResultOf::DestroyLayer(std::move(_client_end), std::move(layer_id));
}


Controller::UnownedResultOf::DestroyLayer_Impl::DestroyLayer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id) {
  if (_request_buffer.capacity() < DestroyLayerRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, DestroyLayerRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DestroyLayerRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request_buffer.set_actual(sizeof(DestroyLayerRequest));
  ::fidl::DecodedMessage<DestroyLayerRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::DestroyLayer(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::DestroyLayer Controller::SyncClient::DestroyLayer(::fidl::BytePart _request_buffer, uint64_t layer_id) {
  return UnownedResultOf::DestroyLayer(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id));
}

Controller::UnownedResultOf::DestroyLayer Controller::Call::DestroyLayer(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id) {
  return UnownedResultOf::DestroyLayer(std::move(_client_end), std::move(_request_buffer), std::move(layer_id));
}

::fidl::internal::StatusAndError Controller::InPlace::DestroyLayer(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DestroyLayerRequest> params) {
  Controller::SetTransactionHeaderFor::DestroyLayerRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayMode_Impl::SetDisplayMode_Impl(::zx::unowned_channel _client_end, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetDisplayModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayModeRequest*>(_write_bytes);
  _request.display_id = std::move(display_id);
  _request.mode = std::move(mode);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDisplayModeRequest));
  ::fidl::DecodedMessage<SetDisplayModeRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetDisplayMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayMode Controller::SyncClient::SetDisplayMode(uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
    return ResultOf::SetDisplayMode(::zx::unowned_channel(this->channel_), std::move(display_id), std::move(mode));
}

Controller::ResultOf::SetDisplayMode Controller::Call::SetDisplayMode(::zx::unowned_channel _client_end, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
  return ResultOf::SetDisplayMode(std::move(_client_end), std::move(display_id), std::move(mode));
}


Controller::UnownedResultOf::SetDisplayMode_Impl::SetDisplayMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
  if (_request_buffer.capacity() < SetDisplayModeRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetDisplayModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayModeRequest*>(_request_buffer.data());
  _request.display_id = std::move(display_id);
  _request.mode = std::move(mode);
  _request_buffer.set_actual(sizeof(SetDisplayModeRequest));
  ::fidl::DecodedMessage<SetDisplayModeRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetDisplayMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayMode Controller::SyncClient::SetDisplayMode(::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
  return UnownedResultOf::SetDisplayMode(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(mode));
}

Controller::UnownedResultOf::SetDisplayMode Controller::Call::SetDisplayMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::llcpp::fuchsia::hardware::display::Mode mode) {
  return UnownedResultOf::SetDisplayMode(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(mode));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayModeRequest> params) {
  Controller::SetTransactionHeaderFor::SetDisplayModeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayColorConversion_Impl::SetDisplayColorConversion_Impl(::zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayColorConversionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetDisplayColorConversionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayColorConversionRequest*>(_write_bytes);
  _request.display_id = std::move(display_id);
  _request.preoffsets = std::move(preoffsets);
  _request.coefficients = std::move(coefficients);
  _request.postoffsets = std::move(postoffsets);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetDisplayColorConversionRequest));
  ::fidl::DecodedMessage<SetDisplayColorConversionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetDisplayColorConversion(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayColorConversion Controller::SyncClient::SetDisplayColorConversion(uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
    return ResultOf::SetDisplayColorConversion(::zx::unowned_channel(this->channel_), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

Controller::ResultOf::SetDisplayColorConversion Controller::Call::SetDisplayColorConversion(::zx::unowned_channel _client_end, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return ResultOf::SetDisplayColorConversion(std::move(_client_end), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}


Controller::UnownedResultOf::SetDisplayColorConversion_Impl::SetDisplayColorConversion_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  if (_request_buffer.capacity() < SetDisplayColorConversionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetDisplayColorConversionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetDisplayColorConversionRequest*>(_request_buffer.data());
  _request.display_id = std::move(display_id);
  _request.preoffsets = std::move(preoffsets);
  _request.coefficients = std::move(coefficients);
  _request.postoffsets = std::move(postoffsets);
  _request_buffer.set_actual(sizeof(SetDisplayColorConversionRequest));
  ::fidl::DecodedMessage<SetDisplayColorConversionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetDisplayColorConversion(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayColorConversion Controller::SyncClient::SetDisplayColorConversion(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return UnownedResultOf::SetDisplayColorConversion(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

Controller::UnownedResultOf::SetDisplayColorConversion Controller::Call::SetDisplayColorConversion(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::Array<float, 3> preoffsets, ::fidl::Array<float, 9> coefficients, ::fidl::Array<float, 3> postoffsets) {
  return UnownedResultOf::SetDisplayColorConversion(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(preoffsets), std::move(coefficients), std::move(postoffsets));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayColorConversion(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayColorConversionRequest> params) {
  Controller::SetTransactionHeaderFor::SetDisplayColorConversionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetDisplayLayers_Impl::SetDisplayLayers_Impl(::zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetDisplayLayersRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  SetDisplayLayersRequest _request = {};
  _request.display_id = std::move(display_id);
  _request.layer_ids = std::move(layer_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetDisplayLayersRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetDisplayLayers(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetDisplayLayers Controller::SyncClient::SetDisplayLayers(uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
    return ResultOf::SetDisplayLayers(::zx::unowned_channel(this->channel_), std::move(display_id), std::move(layer_ids));
}

Controller::ResultOf::SetDisplayLayers Controller::Call::SetDisplayLayers(::zx::unowned_channel _client_end, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return ResultOf::SetDisplayLayers(std::move(_client_end), std::move(display_id), std::move(layer_ids));
}


Controller::UnownedResultOf::SetDisplayLayers_Impl::SetDisplayLayers_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  if (_request_buffer.capacity() < SetDisplayLayersRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  SetDisplayLayersRequest _request = {};
  _request.display_id = std::move(display_id);
  _request.layer_ids = std::move(layer_ids);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetDisplayLayersRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetDisplayLayers(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetDisplayLayers Controller::SyncClient::SetDisplayLayers(::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return UnownedResultOf::SetDisplayLayers(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(display_id), std::move(layer_ids));
}

Controller::UnownedResultOf::SetDisplayLayers Controller::Call::SetDisplayLayers(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t display_id, ::fidl::VectorView<uint64_t> layer_ids) {
  return UnownedResultOf::SetDisplayLayers(std::move(_client_end), std::move(_request_buffer), std::move(display_id), std::move(layer_ids));
}

::fidl::internal::StatusAndError Controller::InPlace::SetDisplayLayers(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetDisplayLayersRequest> params) {
  Controller::SetTransactionHeaderFor::SetDisplayLayersRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryConfig_Impl::SetLayerPrimaryConfig_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryConfigRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryConfigRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryConfig Controller::SyncClient::SetLayerPrimaryConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
    return ResultOf::SetLayerPrimaryConfig(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_config));
}

Controller::ResultOf::SetLayerPrimaryConfig Controller::Call::SetLayerPrimaryConfig(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return ResultOf::SetLayerPrimaryConfig(std::move(_client_end), std::move(layer_id), std::move(image_config));
}


Controller::UnownedResultOf::SetLayerPrimaryConfig_Impl::SetLayerPrimaryConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  if (_request_buffer.capacity() < SetLayerPrimaryConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryConfigRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryConfigRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryConfig Controller::SyncClient::SetLayerPrimaryConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return UnownedResultOf::SetLayerPrimaryConfig(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

Controller::UnownedResultOf::SetLayerPrimaryConfig Controller::Call::SetLayerPrimaryConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return UnownedResultOf::SetLayerPrimaryConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryConfigRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerPrimaryConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryPosition_Impl::SetLayerPrimaryPosition_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryPositionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryPositionRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.transform = std::move(transform);
  _request.src_frame = std::move(src_frame);
  _request.dest_frame = std::move(dest_frame);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryPositionRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryPosition Controller::SyncClient::SetLayerPrimaryPosition(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
    return ResultOf::SetLayerPrimaryPosition(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

Controller::ResultOf::SetLayerPrimaryPosition Controller::Call::SetLayerPrimaryPosition(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
  return ResultOf::SetLayerPrimaryPosition(std::move(_client_end), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}


Controller::UnownedResultOf::SetLayerPrimaryPosition_Impl::SetLayerPrimaryPosition_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
  if (_request_buffer.capacity() < SetLayerPrimaryPositionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryPositionRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.transform = std::move(transform);
  _request.src_frame = std::move(src_frame);
  _request.dest_frame = std::move(dest_frame);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryPositionRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryPosition Controller::SyncClient::SetLayerPrimaryPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
  return UnownedResultOf::SetLayerPrimaryPosition(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

Controller::UnownedResultOf::SetLayerPrimaryPosition Controller::Call::SetLayerPrimaryPosition(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::Transform transform, ::llcpp::fuchsia::hardware::display::Frame src_frame, ::llcpp::fuchsia::hardware::display::Frame dest_frame) {
  return UnownedResultOf::SetLayerPrimaryPosition(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(transform), std::move(src_frame), std::move(dest_frame));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryPosition(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryPositionRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerPrimaryPositionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerPrimaryAlpha_Impl::SetLayerPrimaryAlpha_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerPrimaryAlphaRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerPrimaryAlphaRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryAlphaRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.mode = std::move(mode);
  _request.val = std::move(val);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerPrimaryAlphaRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerPrimaryAlpha Controller::SyncClient::SetLayerPrimaryAlpha(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
    return ResultOf::SetLayerPrimaryAlpha(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(mode), std::move(val));
}

Controller::ResultOf::SetLayerPrimaryAlpha Controller::Call::SetLayerPrimaryAlpha(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
  return ResultOf::SetLayerPrimaryAlpha(std::move(_client_end), std::move(layer_id), std::move(mode), std::move(val));
}


Controller::UnownedResultOf::SetLayerPrimaryAlpha_Impl::SetLayerPrimaryAlpha_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
  if (_request_buffer.capacity() < SetLayerPrimaryAlphaRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerPrimaryAlphaRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerPrimaryAlphaRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.mode = std::move(mode);
  _request.val = std::move(val);
  _request_buffer.set_actual(sizeof(SetLayerPrimaryAlphaRequest));
  ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerPrimaryAlpha Controller::SyncClient::SetLayerPrimaryAlpha(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
  return UnownedResultOf::SetLayerPrimaryAlpha(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(mode), std::move(val));
}

Controller::UnownedResultOf::SetLayerPrimaryAlpha Controller::Call::SetLayerPrimaryAlpha(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::AlphaMode mode, float val) {
  return UnownedResultOf::SetLayerPrimaryAlpha(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(mode), std::move(val));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerPrimaryAlpha(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerPrimaryAlphaRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerPrimaryAlphaRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerCursorConfig_Impl::SetLayerCursorConfig_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerCursorConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerCursorConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorConfigRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerCursorConfigRequest));
  ::fidl::DecodedMessage<SetLayerCursorConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerCursorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerCursorConfig Controller::SyncClient::SetLayerCursorConfig(uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
    return ResultOf::SetLayerCursorConfig(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_config));
}

Controller::ResultOf::SetLayerCursorConfig Controller::Call::SetLayerCursorConfig(::zx::unowned_channel _client_end, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return ResultOf::SetLayerCursorConfig(std::move(_client_end), std::move(layer_id), std::move(image_config));
}


Controller::UnownedResultOf::SetLayerCursorConfig_Impl::SetLayerCursorConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  if (_request_buffer.capacity() < SetLayerCursorConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerCursorConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorConfigRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_config = std::move(image_config);
  _request_buffer.set_actual(sizeof(SetLayerCursorConfigRequest));
  ::fidl::DecodedMessage<SetLayerCursorConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerCursorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerCursorConfig Controller::SyncClient::SetLayerCursorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return UnownedResultOf::SetLayerCursorConfig(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

Controller::UnownedResultOf::SetLayerCursorConfig Controller::Call::SetLayerCursorConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, ::llcpp::fuchsia::hardware::display::ImageConfig image_config) {
  return UnownedResultOf::SetLayerCursorConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_config));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerCursorConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorConfigRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerCursorConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerCursorPosition_Impl::SetLayerCursorPosition_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerCursorPositionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerCursorPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorPositionRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.x = std::move(x);
  _request.y = std::move(y);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerCursorPositionRequest));
  ::fidl::DecodedMessage<SetLayerCursorPositionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerCursorPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerCursorPosition Controller::SyncClient::SetLayerCursorPosition(uint64_t layer_id, int32_t x, int32_t y) {
    return ResultOf::SetLayerCursorPosition(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(x), std::move(y));
}

Controller::ResultOf::SetLayerCursorPosition Controller::Call::SetLayerCursorPosition(::zx::unowned_channel _client_end, uint64_t layer_id, int32_t x, int32_t y) {
  return ResultOf::SetLayerCursorPosition(std::move(_client_end), std::move(layer_id), std::move(x), std::move(y));
}


Controller::UnownedResultOf::SetLayerCursorPosition_Impl::SetLayerCursorPosition_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  if (_request_buffer.capacity() < SetLayerCursorPositionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerCursorPositionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerCursorPositionRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.x = std::move(x);
  _request.y = std::move(y);
  _request_buffer.set_actual(sizeof(SetLayerCursorPositionRequest));
  ::fidl::DecodedMessage<SetLayerCursorPositionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerCursorPosition(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerCursorPosition Controller::SyncClient::SetLayerCursorPosition(::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  return UnownedResultOf::SetLayerCursorPosition(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(x), std::move(y));
}

Controller::UnownedResultOf::SetLayerCursorPosition Controller::Call::SetLayerCursorPosition(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, int32_t x, int32_t y) {
  return UnownedResultOf::SetLayerCursorPosition(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(x), std::move(y));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerCursorPosition(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerCursorPositionRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerCursorPositionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerColorConfig_Impl::SetLayerColorConfig_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerColorConfigRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  SetLayerColorConfigRequest _request = {};
  _request.layer_id = std::move(layer_id);
  _request.pixel_format = std::move(pixel_format);
  _request.color_bytes = std::move(color_bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetLayerColorConfigRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetLayerColorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerColorConfig Controller::SyncClient::SetLayerColorConfig(uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
    return ResultOf::SetLayerColorConfig(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

Controller::ResultOf::SetLayerColorConfig Controller::Call::SetLayerColorConfig(::zx::unowned_channel _client_end, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return ResultOf::SetLayerColorConfig(std::move(_client_end), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}


Controller::UnownedResultOf::SetLayerColorConfig_Impl::SetLayerColorConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  if (_request_buffer.capacity() < SetLayerColorConfigRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  SetLayerColorConfigRequest _request = {};
  _request.layer_id = std::move(layer_id);
  _request.pixel_format = std::move(pixel_format);
  _request.color_bytes = std::move(color_bytes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<SetLayerColorConfigRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Controller::InPlace::SetLayerColorConfig(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerColorConfig Controller::SyncClient::SetLayerColorConfig(::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return UnownedResultOf::SetLayerColorConfig(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

Controller::UnownedResultOf::SetLayerColorConfig Controller::Call::SetLayerColorConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint32_t pixel_format, ::fidl::VectorView<uint8_t> color_bytes) {
  return UnownedResultOf::SetLayerColorConfig(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(pixel_format), std::move(color_bytes));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerColorConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerColorConfigRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerColorConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetLayerImage_Impl::SetLayerImage_Impl(::zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetLayerImageRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetLayerImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerImageRequest*>(_write_bytes);
  _request.layer_id = std::move(layer_id);
  _request.image_id = std::move(image_id);
  _request.wait_event_id = std::move(wait_event_id);
  _request.signal_event_id = std::move(signal_event_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetLayerImageRequest));
  ::fidl::DecodedMessage<SetLayerImageRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetLayerImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetLayerImage Controller::SyncClient::SetLayerImage(uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
    return ResultOf::SetLayerImage(::zx::unowned_channel(this->channel_), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

Controller::ResultOf::SetLayerImage Controller::Call::SetLayerImage(::zx::unowned_channel _client_end, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return ResultOf::SetLayerImage(std::move(_client_end), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}


Controller::UnownedResultOf::SetLayerImage_Impl::SetLayerImage_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  if (_request_buffer.capacity() < SetLayerImageRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetLayerImageRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetLayerImageRequest*>(_request_buffer.data());
  _request.layer_id = std::move(layer_id);
  _request.image_id = std::move(image_id);
  _request.wait_event_id = std::move(wait_event_id);
  _request.signal_event_id = std::move(signal_event_id);
  _request_buffer.set_actual(sizeof(SetLayerImageRequest));
  ::fidl::DecodedMessage<SetLayerImageRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetLayerImage(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetLayerImage Controller::SyncClient::SetLayerImage(::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return UnownedResultOf::SetLayerImage(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

Controller::UnownedResultOf::SetLayerImage Controller::Call::SetLayerImage(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t layer_id, uint64_t image_id, uint64_t wait_event_id, uint64_t signal_event_id) {
  return UnownedResultOf::SetLayerImage(std::move(_client_end), std::move(_request_buffer), std::move(layer_id), std::move(image_id), std::move(wait_event_id), std::move(signal_event_id));
}

::fidl::internal::StatusAndError Controller::InPlace::SetLayerImage(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetLayerImageRequest> params) {
  Controller::SetTransactionHeaderFor::SetLayerImageRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::CheckConfig_Impl<Controller::CheckConfigResponse>::CheckConfig_Impl(::zx::unowned_channel _client_end, bool discard) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CheckConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckConfigRequest*>(_write_bytes);
  _request.discard = std::move(discard);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CheckConfigRequest));
  ::fidl::DecodedMessage<CheckConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::CheckConfig(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::CheckConfig Controller::SyncClient::CheckConfig(bool discard) {
    return ResultOf::CheckConfig(::zx::unowned_channel(this->channel_), std::move(discard));
}

Controller::ResultOf::CheckConfig Controller::Call::CheckConfig(::zx::unowned_channel _client_end, bool discard) {
  return ResultOf::CheckConfig(std::move(_client_end), std::move(discard));
}

template <>
Controller::UnownedResultOf::CheckConfig_Impl<Controller::CheckConfigResponse>::CheckConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CheckConfigRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CheckConfigResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CheckConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CheckConfigRequest*>(_request_buffer.data());
  _request.discard = std::move(discard);
  _request_buffer.set_actual(sizeof(CheckConfigRequest));
  ::fidl::DecodedMessage<CheckConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::CheckConfig(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::CheckConfig Controller::SyncClient::CheckConfig(::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckConfig(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(discard), std::move(_response_buffer));
}

Controller::UnownedResultOf::CheckConfig Controller::Call::CheckConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool discard, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CheckConfig(std::move(_client_end), std::move(_request_buffer), std::move(discard), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::CheckConfigResponse> Controller::InPlace::CheckConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CheckConfigRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::CheckConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CheckConfigResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CheckConfigRequest, CheckConfigResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::CheckConfigResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ApplyConfig_Impl::ApplyConfig_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ApplyConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ApplyConfigRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ApplyConfigRequest));
  ::fidl::DecodedMessage<ApplyConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ApplyConfig(std::move(_client_end)));
}

Controller::ResultOf::ApplyConfig Controller::SyncClient::ApplyConfig() {
    return ResultOf::ApplyConfig(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::ApplyConfig Controller::Call::ApplyConfig(::zx::unowned_channel _client_end) {
  return ResultOf::ApplyConfig(std::move(_client_end));
}

::fidl::internal::StatusAndError Controller::InPlace::ApplyConfig(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(ApplyConfigRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ApplyConfigRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::ApplyConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::EnableVsync_Impl::EnableVsync_Impl(::zx::unowned_channel _client_end, bool enable) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EnableVsyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, EnableVsyncRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnableVsyncRequest*>(_write_bytes);
  _request.enable = std::move(enable);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(EnableVsyncRequest));
  ::fidl::DecodedMessage<EnableVsyncRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::EnableVsync(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::EnableVsync Controller::SyncClient::EnableVsync(bool enable) {
    return ResultOf::EnableVsync(::zx::unowned_channel(this->channel_), std::move(enable));
}

Controller::ResultOf::EnableVsync Controller::Call::EnableVsync(::zx::unowned_channel _client_end, bool enable) {
  return ResultOf::EnableVsync(std::move(_client_end), std::move(enable));
}


Controller::UnownedResultOf::EnableVsync_Impl::EnableVsync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable) {
  if (_request_buffer.capacity() < EnableVsyncRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, EnableVsyncRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnableVsyncRequest*>(_request_buffer.data());
  _request.enable = std::move(enable);
  _request_buffer.set_actual(sizeof(EnableVsyncRequest));
  ::fidl::DecodedMessage<EnableVsyncRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::EnableVsync(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::EnableVsync Controller::SyncClient::EnableVsync(::fidl::BytePart _request_buffer, bool enable) {
  return UnownedResultOf::EnableVsync(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(enable));
}

Controller::UnownedResultOf::EnableVsync Controller::Call::EnableVsync(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, bool enable) {
  return UnownedResultOf::EnableVsync(std::move(_client_end), std::move(_request_buffer), std::move(enable));
}

::fidl::internal::StatusAndError Controller::InPlace::EnableVsync(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EnableVsyncRequest> params) {
  Controller::SetTransactionHeaderFor::EnableVsyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Controller::ResultOf::SetVirtconMode_Impl::SetVirtconMode_Impl(::zx::unowned_channel _client_end, uint8_t mode) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetVirtconModeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetVirtconModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetVirtconModeRequest*>(_write_bytes);
  _request.mode = std::move(mode);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetVirtconModeRequest));
  ::fidl::DecodedMessage<SetVirtconModeRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::SetVirtconMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::SetVirtconMode Controller::SyncClient::SetVirtconMode(uint8_t mode) {
    return ResultOf::SetVirtconMode(::zx::unowned_channel(this->channel_), std::move(mode));
}

Controller::ResultOf::SetVirtconMode Controller::Call::SetVirtconMode(::zx::unowned_channel _client_end, uint8_t mode) {
  return ResultOf::SetVirtconMode(std::move(_client_end), std::move(mode));
}


Controller::UnownedResultOf::SetVirtconMode_Impl::SetVirtconMode_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode) {
  if (_request_buffer.capacity() < SetVirtconModeRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, SetVirtconModeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetVirtconModeRequest*>(_request_buffer.data());
  _request.mode = std::move(mode);
  _request_buffer.set_actual(sizeof(SetVirtconModeRequest));
  ::fidl::DecodedMessage<SetVirtconModeRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::SetVirtconMode(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::SetVirtconMode Controller::SyncClient::SetVirtconMode(::fidl::BytePart _request_buffer, uint8_t mode) {
  return UnownedResultOf::SetVirtconMode(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mode));
}

Controller::UnownedResultOf::SetVirtconMode Controller::Call::SetVirtconMode(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t mode) {
  return UnownedResultOf::SetVirtconMode(std::move(_client_end), std::move(_request_buffer), std::move(mode));
}

::fidl::internal::StatusAndError Controller::InPlace::SetVirtconMode(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetVirtconModeRequest> params) {
  Controller::SetTransactionHeaderFor::SetVirtconModeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::ImportBufferCollection_Impl<Controller::ImportBufferCollectionResponse>::ImportBufferCollection_Impl(::zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportBufferCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportBufferCollectionRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  _request.collection_token = std::move(collection_token);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportBufferCollectionRequest));
  ::fidl::DecodedMessage<ImportBufferCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportBufferCollection(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportBufferCollection Controller::SyncClient::ImportBufferCollection(uint64_t collection_id, ::zx::channel collection_token) {
    return ResultOf::ImportBufferCollection(::zx::unowned_channel(this->channel_), std::move(collection_id), std::move(collection_token));
}

Controller::ResultOf::ImportBufferCollection Controller::Call::ImportBufferCollection(::zx::unowned_channel _client_end, uint64_t collection_id, ::zx::channel collection_token) {
  return ResultOf::ImportBufferCollection(std::move(_client_end), std::move(collection_id), std::move(collection_token));
}

template <>
Controller::UnownedResultOf::ImportBufferCollection_Impl<Controller::ImportBufferCollectionResponse>::ImportBufferCollection_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportBufferCollectionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportBufferCollectionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportBufferCollectionRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request.collection_token = std::move(collection_token);
  _request_buffer.set_actual(sizeof(ImportBufferCollectionRequest));
  ::fidl::DecodedMessage<ImportBufferCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportBufferCollection(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportBufferCollection Controller::SyncClient::ImportBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportBufferCollection(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id), std::move(collection_token), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportBufferCollection Controller::Call::ImportBufferCollection(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::zx::channel collection_token, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportBufferCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection_id), std::move(collection_token), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportBufferCollectionResponse> Controller::InPlace::ImportBufferCollection(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportBufferCollectionRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ImportBufferCollectionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportBufferCollectionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportBufferCollectionRequest, ImportBufferCollectionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportBufferCollectionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Controller::ResultOf::ReleaseBufferCollection_Impl::ReleaseBufferCollection_Impl(::zx::unowned_channel _client_end, uint64_t collection_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseBufferCollectionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseBufferCollectionRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseBufferCollectionRequest));
  ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Controller::InPlace::ReleaseBufferCollection(std::move(_client_end), std::move(_decoded_request)));
}

Controller::ResultOf::ReleaseBufferCollection Controller::SyncClient::ReleaseBufferCollection(uint64_t collection_id) {
    return ResultOf::ReleaseBufferCollection(::zx::unowned_channel(this->channel_), std::move(collection_id));
}

Controller::ResultOf::ReleaseBufferCollection Controller::Call::ReleaseBufferCollection(::zx::unowned_channel _client_end, uint64_t collection_id) {
  return ResultOf::ReleaseBufferCollection(std::move(_client_end), std::move(collection_id));
}


Controller::UnownedResultOf::ReleaseBufferCollection_Impl::ReleaseBufferCollection_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id) {
  if (_request_buffer.capacity() < ReleaseBufferCollectionRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseBufferCollectionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseBufferCollectionRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request_buffer.set_actual(sizeof(ReleaseBufferCollectionRequest));
  ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Controller::InPlace::ReleaseBufferCollection(std::move(_client_end), std::move(_decoded_request)));
}

Controller::UnownedResultOf::ReleaseBufferCollection Controller::SyncClient::ReleaseBufferCollection(::fidl::BytePart _request_buffer, uint64_t collection_id) {
  return UnownedResultOf::ReleaseBufferCollection(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id));
}

Controller::UnownedResultOf::ReleaseBufferCollection Controller::Call::ReleaseBufferCollection(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id) {
  return UnownedResultOf::ReleaseBufferCollection(std::move(_client_end), std::move(_request_buffer), std::move(collection_id));
}

::fidl::internal::StatusAndError Controller::InPlace::ReleaseBufferCollection(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseBufferCollectionRequest> params) {
  Controller::SetTransactionHeaderFor::ReleaseBufferCollectionRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Controller::ResultOf::SetBufferCollectionConstraints_Impl<Controller::SetBufferCollectionConstraintsResponse>::SetBufferCollectionConstraints_Impl(::zx::unowned_channel _client_end, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetBufferCollectionConstraintsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetBufferCollectionConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetBufferCollectionConstraintsRequest*>(_write_bytes);
  _request.collection_id = std::move(collection_id);
  _request.config = std::move(config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetBufferCollectionConstraintsRequest));
  ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::SetBufferCollectionConstraints(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::SetBufferCollectionConstraints Controller::SyncClient::SetBufferCollectionConstraints(uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config) {
    return ResultOf::SetBufferCollectionConstraints(::zx::unowned_channel(this->channel_), std::move(collection_id), std::move(config));
}

Controller::ResultOf::SetBufferCollectionConstraints Controller::Call::SetBufferCollectionConstraints(::zx::unowned_channel _client_end, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config) {
  return ResultOf::SetBufferCollectionConstraints(std::move(_client_end), std::move(collection_id), std::move(config));
}

template <>
Controller::UnownedResultOf::SetBufferCollectionConstraints_Impl<Controller::SetBufferCollectionConstraintsResponse>::SetBufferCollectionConstraints_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetBufferCollectionConstraintsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetBufferCollectionConstraintsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetBufferCollectionConstraintsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetBufferCollectionConstraintsRequest*>(_request_buffer.data());
  _request.collection_id = std::move(collection_id);
  _request.config = std::move(config);
  _request_buffer.set_actual(sizeof(SetBufferCollectionConstraintsRequest));
  ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::SetBufferCollectionConstraints(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::SetBufferCollectionConstraints Controller::SyncClient::SetBufferCollectionConstraints(::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetBufferCollectionConstraints(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(collection_id), std::move(config), std::move(_response_buffer));
}

Controller::UnownedResultOf::SetBufferCollectionConstraints Controller::Call::SetBufferCollectionConstraints(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t collection_id, ::llcpp::fuchsia::hardware::display::ImageConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetBufferCollectionConstraints(std::move(_client_end), std::move(_request_buffer), std::move(collection_id), std::move(config), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse> Controller::InPlace::SetBufferCollectionConstraints(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetBufferCollectionConstraintsRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetBufferCollectionConstraintsRequest, SetBufferCollectionConstraintsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::SetBufferCollectionConstraintsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetSingleBufferFramebuffer_Impl<Controller::GetSingleBufferFramebufferResponse>::GetSingleBufferFramebuffer_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSingleBufferFramebufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetSingleBufferFramebufferRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSingleBufferFramebufferRequest));
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetSingleBufferFramebuffer(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetSingleBufferFramebuffer Controller::SyncClient::GetSingleBufferFramebuffer() {
    return ResultOf::GetSingleBufferFramebuffer(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetSingleBufferFramebuffer Controller::Call::GetSingleBufferFramebuffer(::zx::unowned_channel _client_end) {
  return ResultOf::GetSingleBufferFramebuffer(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetSingleBufferFramebuffer_Impl<Controller::GetSingleBufferFramebufferResponse>::GetSingleBufferFramebuffer_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetSingleBufferFramebufferRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetSingleBufferFramebufferRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetSingleBufferFramebufferRequest));
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetSingleBufferFramebuffer(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetSingleBufferFramebuffer Controller::SyncClient::GetSingleBufferFramebuffer(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSingleBufferFramebuffer(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetSingleBufferFramebuffer Controller::Call::GetSingleBufferFramebuffer(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSingleBufferFramebuffer(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse> Controller::InPlace::GetSingleBufferFramebuffer(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetSingleBufferFramebufferRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetSingleBufferFramebufferRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetSingleBufferFramebufferRequest, GetSingleBufferFramebufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetSingleBufferFramebufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::IsCaptureSupported_Impl<Controller::IsCaptureSupportedResponse>::IsCaptureSupported_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IsCaptureSupportedRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, IsCaptureSupportedRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(IsCaptureSupportedRequest));
  ::fidl::DecodedMessage<IsCaptureSupportedRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::IsCaptureSupported(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::IsCaptureSupported Controller::SyncClient::IsCaptureSupported() {
    return ResultOf::IsCaptureSupported(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::IsCaptureSupported Controller::Call::IsCaptureSupported(::zx::unowned_channel _client_end) {
  return ResultOf::IsCaptureSupported(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::IsCaptureSupported_Impl<Controller::IsCaptureSupportedResponse>::IsCaptureSupported_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(IsCaptureSupportedRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, IsCaptureSupportedRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(IsCaptureSupportedRequest));
  ::fidl::DecodedMessage<IsCaptureSupportedRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::IsCaptureSupported(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::IsCaptureSupported Controller::SyncClient::IsCaptureSupported(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::IsCaptureSupported(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::IsCaptureSupported Controller::Call::IsCaptureSupported(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::IsCaptureSupported(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::IsCaptureSupportedResponse> Controller::InPlace::IsCaptureSupported(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(IsCaptureSupportedRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<IsCaptureSupportedRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::IsCaptureSupportedRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::IsCaptureSupportedResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<IsCaptureSupportedRequest, IsCaptureSupportedResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::IsCaptureSupportedResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ImportImageForCapture_Impl<Controller::ImportImageForCaptureResponse>::ImportImageForCapture_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageForCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ImportImageForCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageForCaptureRequest*>(_write_bytes);
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageForCaptureRequest));
  ::fidl::DecodedMessage<ImportImageForCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ImportImageForCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ImportImageForCapture Controller::SyncClient::ImportImageForCapture(::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
    return ResultOf::ImportImageForCapture(::zx::unowned_channel(this->channel_), std::move(image_config), std::move(collection_id), std::move(index));
}

Controller::ResultOf::ImportImageForCapture Controller::Call::ImportImageForCapture(::zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index) {
  return ResultOf::ImportImageForCapture(std::move(_client_end), std::move(image_config), std::move(collection_id), std::move(index));
}

template <>
Controller::UnownedResultOf::ImportImageForCapture_Impl<Controller::ImportImageForCaptureResponse>::ImportImageForCapture_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ImportImageForCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ImportImageForCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ImportImageForCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ImportImageForCaptureRequest*>(_request_buffer.data());
  _request.image_config = std::move(image_config);
  _request.collection_id = std::move(collection_id);
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(ImportImageForCaptureRequest));
  ::fidl::DecodedMessage<ImportImageForCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ImportImageForCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ImportImageForCapture Controller::SyncClient::ImportImageForCapture(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImageForCapture(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

Controller::UnownedResultOf::ImportImageForCapture Controller::Call::ImportImageForCapture(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::display::ImageConfig image_config, uint64_t collection_id, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ImportImageForCapture(std::move(_client_end), std::move(_request_buffer), std::move(image_config), std::move(collection_id), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ImportImageForCaptureResponse> Controller::InPlace::ImportImageForCapture(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ImportImageForCaptureRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ImportImageForCaptureRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageForCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ImportImageForCaptureRequest, ImportImageForCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ImportImageForCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::StartCapture_Impl<Controller::StartCaptureResponse>::StartCapture_Impl(::zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StartCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StartCaptureRequest*>(_write_bytes);
  _request.signal_event_id = std::move(signal_event_id);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartCaptureRequest));
  ::fidl::DecodedMessage<StartCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::StartCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::StartCapture Controller::SyncClient::StartCapture(uint64_t signal_event_id, uint64_t image_id) {
    return ResultOf::StartCapture(::zx::unowned_channel(this->channel_), std::move(signal_event_id), std::move(image_id));
}

Controller::ResultOf::StartCapture Controller::Call::StartCapture(::zx::unowned_channel _client_end, uint64_t signal_event_id, uint64_t image_id) {
  return ResultOf::StartCapture(std::move(_client_end), std::move(signal_event_id), std::move(image_id));
}

template <>
Controller::UnownedResultOf::StartCapture_Impl<Controller::StartCaptureResponse>::StartCapture_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StartCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StartCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, StartCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StartCaptureRequest*>(_request_buffer.data());
  _request.signal_event_id = std::move(signal_event_id);
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(StartCaptureRequest));
  ::fidl::DecodedMessage<StartCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::StartCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::StartCapture Controller::SyncClient::StartCapture(::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartCapture(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(signal_event_id), std::move(image_id), std::move(_response_buffer));
}

Controller::UnownedResultOf::StartCapture Controller::Call::StartCapture(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t signal_event_id, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StartCapture(std::move(_client_end), std::move(_request_buffer), std::move(signal_event_id), std::move(image_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::StartCaptureResponse> Controller::InPlace::StartCapture(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StartCaptureRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::StartCaptureRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartCaptureRequest, StartCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ReleaseCapture_Impl<Controller::ReleaseCaptureResponse>::ReleaseCapture_Impl(::zx::unowned_channel _client_end, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseCaptureRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseCaptureRequest*>(_write_bytes);
  _request.image_id = std::move(image_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseCaptureRequest));
  ::fidl::DecodedMessage<ReleaseCaptureRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ReleaseCapture(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ReleaseCapture Controller::SyncClient::ReleaseCapture(uint64_t image_id) {
    return ResultOf::ReleaseCapture(::zx::unowned_channel(this->channel_), std::move(image_id));
}

Controller::ResultOf::ReleaseCapture Controller::Call::ReleaseCapture(::zx::unowned_channel _client_end, uint64_t image_id) {
  return ResultOf::ReleaseCapture(std::move(_client_end), std::move(image_id));
}

template <>
Controller::UnownedResultOf::ReleaseCapture_Impl<Controller::ReleaseCaptureResponse>::ReleaseCapture_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReleaseCaptureRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReleaseCaptureResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseCaptureRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseCaptureRequest*>(_request_buffer.data());
  _request.image_id = std::move(image_id);
  _request_buffer.set_actual(sizeof(ReleaseCaptureRequest));
  ::fidl::DecodedMessage<ReleaseCaptureRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ReleaseCapture(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ReleaseCapture Controller::SyncClient::ReleaseCapture(::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseCapture(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(image_id), std::move(_response_buffer));
}

Controller::UnownedResultOf::ReleaseCapture Controller::Call::ReleaseCapture(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t image_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseCapture(std::move(_client_end), std::move(_request_buffer), std::move(image_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ReleaseCaptureResponse> Controller::InPlace::ReleaseCapture(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseCaptureRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ReleaseCaptureRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseCaptureResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReleaseCaptureRequest, ReleaseCaptureResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseCaptureResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Controller::SyncClient::HandleEvents(Controller::EventHandlers handlers) {
  return Controller::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Controller::Call::HandleEvents(::zx::unowned_channel client_end, Controller::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (DisplaysChangedResponse::MaxNumHandles >= x) {
      x = DisplaysChangedResponse::MaxNumHandles;
    }
    if (VsyncResponse::MaxNumHandles >= x) {
      x = VsyncResponse::MaxNumHandles;
    }
    if (ClientOwnershipChangeResponse::MaxNumHandles >= x) {
      x = ClientOwnershipChangeResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kController_DisplaysChanged_Ordinal:
    case kController_DisplaysChanged_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DisplaysChangedResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.displays_changed(std::move(message->added), std::move(message->removed));
    }
    case kController_Vsync_Ordinal:
    case kController_Vsync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<VsyncResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.vsync(std::move(message->display_id), std::move(message->timestamp), std::move(message->images));
    }
    case kController_ClientOwnershipChange_Ordinal:
    case kController_ClientOwnershipChange_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ClientOwnershipChangeResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.client_ownership_change(std::move(message->has_ownership));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kController_ImportVmoImage_Ordinal:
    case kController_ImportVmoImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportVmoImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportVmoImage(std::move(message->image_config), std::move(message->vmo), std::move(message->offset),
          Interface::ImportVmoImageCompleter::Sync(txn));
      return true;
    }
    case kController_ImportImage_Ordinal:
    case kController_ImportImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportImage(std::move(message->image_config), std::move(message->collection_id), std::move(message->index),
          Interface::ImportImageCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseImage_Ordinal:
    case kController_ReleaseImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseImage(std::move(message->image_id),
          Interface::ReleaseImageCompleter::Sync(txn));
      return true;
    }
    case kController_ImportEvent_Ordinal:
    case kController_ImportEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportEvent(std::move(message->event), std::move(message->id),
          Interface::ImportEventCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseEvent_Ordinal:
    case kController_ReleaseEvent_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseEventRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseEvent(std::move(message->id),
          Interface::ReleaseEventCompleter::Sync(txn));
      return true;
    }
    case kController_CreateLayer_Ordinal:
    case kController_CreateLayer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CreateLayerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->CreateLayer(
          Interface::CreateLayerCompleter::Sync(txn));
      return true;
    }
    case kController_DestroyLayer_Ordinal:
    case kController_DestroyLayer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DestroyLayerRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->DestroyLayer(std::move(message->layer_id),
          Interface::DestroyLayerCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayMode_Ordinal:
    case kController_SetDisplayMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayMode(std::move(message->display_id), std::move(message->mode),
          Interface::SetDisplayModeCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayColorConversion_Ordinal:
    case kController_SetDisplayColorConversion_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayColorConversionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayColorConversion(std::move(message->display_id), std::move(message->preoffsets), std::move(message->coefficients), std::move(message->postoffsets),
          Interface::SetDisplayColorConversionCompleter::Sync(txn));
      return true;
    }
    case kController_SetDisplayLayers_Ordinal:
    case kController_SetDisplayLayers_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetDisplayLayersRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetDisplayLayers(std::move(message->display_id), std::move(message->layer_ids),
          Interface::SetDisplayLayersCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryConfig_Ordinal:
    case kController_SetLayerPrimaryConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryConfig(std::move(message->layer_id), std::move(message->image_config),
          Interface::SetLayerPrimaryConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryPosition_Ordinal:
    case kController_SetLayerPrimaryPosition_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryPositionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryPosition(std::move(message->layer_id), std::move(message->transform), std::move(message->src_frame), std::move(message->dest_frame),
          Interface::SetLayerPrimaryPositionCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerPrimaryAlpha_Ordinal:
    case kController_SetLayerPrimaryAlpha_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerPrimaryAlphaRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerPrimaryAlpha(std::move(message->layer_id), std::move(message->mode), std::move(message->val),
          Interface::SetLayerPrimaryAlphaCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerCursorConfig_Ordinal:
    case kController_SetLayerCursorConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerCursorConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerCursorConfig(std::move(message->layer_id), std::move(message->image_config),
          Interface::SetLayerCursorConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerCursorPosition_Ordinal:
    case kController_SetLayerCursorPosition_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerCursorPositionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerCursorPosition(std::move(message->layer_id), std::move(message->x), std::move(message->y),
          Interface::SetLayerCursorPositionCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerColorConfig_Ordinal:
    case kController_SetLayerColorConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerColorConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerColorConfig(std::move(message->layer_id), std::move(message->pixel_format), std::move(message->color_bytes),
          Interface::SetLayerColorConfigCompleter::Sync(txn));
      return true;
    }
    case kController_SetLayerImage_Ordinal:
    case kController_SetLayerImage_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetLayerImageRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetLayerImage(std::move(message->layer_id), std::move(message->image_id), std::move(message->wait_event_id), std::move(message->signal_event_id),
          Interface::SetLayerImageCompleter::Sync(txn));
      return true;
    }
    case kController_CheckConfig_Ordinal:
    case kController_CheckConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CheckConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CheckConfig(std::move(message->discard),
          Interface::CheckConfigCompleter::Sync(txn));
      return true;
    }
    case kController_ApplyConfig_Ordinal:
    case kController_ApplyConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ApplyConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ApplyConfig(
          Interface::ApplyConfigCompleter::Sync(txn));
      return true;
    }
    case kController_EnableVsync_Ordinal:
    case kController_EnableVsync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EnableVsyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->EnableVsync(std::move(message->enable),
          Interface::EnableVsyncCompleter::Sync(txn));
      return true;
    }
    case kController_SetVirtconMode_Ordinal:
    case kController_SetVirtconMode_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetVirtconModeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetVirtconMode(std::move(message->mode),
          Interface::SetVirtconModeCompleter::Sync(txn));
      return true;
    }
    case kController_ImportBufferCollection_Ordinal:
    case kController_ImportBufferCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportBufferCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportBufferCollection(std::move(message->collection_id), std::move(message->collection_token),
          Interface::ImportBufferCollectionCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseBufferCollection_Ordinal:
    case kController_ReleaseBufferCollection_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseBufferCollectionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseBufferCollection(std::move(message->collection_id),
          Interface::ReleaseBufferCollectionCompleter::Sync(txn));
      return true;
    }
    case kController_SetBufferCollectionConstraints_Ordinal:
    case kController_SetBufferCollectionConstraints_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetBufferCollectionConstraintsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetBufferCollectionConstraints(std::move(message->collection_id), std::move(message->config),
          Interface::SetBufferCollectionConstraintsCompleter::Sync(txn));
      return true;
    }
    case kController_GetSingleBufferFramebuffer_Ordinal:
    case kController_GetSingleBufferFramebuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetSingleBufferFramebufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetSingleBufferFramebuffer(
          Interface::GetSingleBufferFramebufferCompleter::Sync(txn));
      return true;
    }
    case kController_IsCaptureSupported_Ordinal:
    case kController_IsCaptureSupported_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<IsCaptureSupportedRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->IsCaptureSupported(
          Interface::IsCaptureSupportedCompleter::Sync(txn));
      return true;
    }
    case kController_ImportImageForCapture_Ordinal:
    case kController_ImportImageForCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ImportImageForCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ImportImageForCapture(std::move(message->image_config), std::move(message->collection_id), std::move(message->index),
          Interface::ImportImageForCaptureCompleter::Sync(txn));
      return true;
    }
    case kController_StartCapture_Ordinal:
    case kController_StartCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StartCapture(std::move(message->signal_event_id), std::move(message->image_id),
          Interface::StartCaptureCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseCapture_Ordinal:
    case kController_ReleaseCapture_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseCaptureRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseCapture(std::move(message->image_id),
          Interface::ReleaseCaptureCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added, ::fidl::VectorView<uint64_t> removed) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DisplaysChangedResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DisplaysChangedResponse _response = {};
  Controller::SetTransactionHeaderFor::DisplaysChangedResponse(
      ::fidl::DecodedMessage<DisplaysChangedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DisplaysChangedResponse::PrimarySize,
              DisplaysChangedResponse::PrimarySize)));
  _response.added = std::move(added);
  _response.removed = std::move(removed);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::Info> added, ::fidl::VectorView<uint64_t> removed) {
  if (_buffer.capacity() < DisplaysChangedResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  DisplaysChangedResponse _response = {};
  Controller::SetTransactionHeaderFor::DisplaysChangedResponse(
      ::fidl::DecodedMessage<DisplaysChangedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DisplaysChangedResponse::PrimarySize,
              DisplaysChangedResponse::PrimarySize)));
  _response.added = std::move(added);
  _response.removed = std::move(removed);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendDisplaysChangedEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<DisplaysChangedResponse> params) {
  Controller::SetTransactionHeaderFor::DisplaysChangedResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Controller::Interface::ImportVmoImageCompleterBase::Reply(int32_t res, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportVmoImageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportVmoImageResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ImportVmoImageResponse(
      ::fidl::DecodedMessage<ImportVmoImageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportVmoImageResponse::PrimarySize,
              ImportVmoImageResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportVmoImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportVmoImageResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportVmoImageCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id) {
  if (_buffer.capacity() < ImportVmoImageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportVmoImageResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ImportVmoImageResponse(
      ::fidl::DecodedMessage<ImportVmoImageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportVmoImageResponse::PrimarySize,
              ImportVmoImageResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  _buffer.set_actual(sizeof(ImportVmoImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportVmoImageResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportVmoImageCompleterBase::Reply(::fidl::DecodedMessage<ImportVmoImageResponse> params) {
  Controller::SetTransactionHeaderFor::ImportVmoImageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ImportImageCompleterBase::Reply(int32_t res, uint64_t image_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportImageResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ImportImageResponse(
      ::fidl::DecodedMessage<ImportImageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportImageResponse::PrimarySize,
              ImportImageResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportImageCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t image_id) {
  if (_buffer.capacity() < ImportImageResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportImageResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ImportImageResponse(
      ::fidl::DecodedMessage<ImportImageResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportImageResponse::PrimarySize,
              ImportImageResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.image_id = std::move(image_id);
  _buffer.set_actual(sizeof(ImportImageResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportImageCompleterBase::Reply(::fidl::DecodedMessage<ImportImageResponse> params) {
  Controller::SetTransactionHeaderFor::ImportImageResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::CreateLayerCompleterBase::Reply(int32_t res, uint64_t layer_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CreateLayerResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CreateLayerResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::CreateLayerResponse(
      ::fidl::DecodedMessage<CreateLayerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLayerResponse::PrimarySize,
              CreateLayerResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.layer_id = std::move(layer_id);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CreateLayerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLayerResponse>(std::move(_response_bytes)));
}

void Controller::Interface::CreateLayerCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, uint64_t layer_id) {
  if (_buffer.capacity() < CreateLayerResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CreateLayerResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::CreateLayerResponse(
      ::fidl::DecodedMessage<CreateLayerResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CreateLayerResponse::PrimarySize,
              CreateLayerResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.layer_id = std::move(layer_id);
  _buffer.set_actual(sizeof(CreateLayerResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CreateLayerResponse>(std::move(_buffer)));
}

void Controller::Interface::CreateLayerCompleterBase::Reply(::fidl::DecodedMessage<CreateLayerResponse> params) {
  Controller::SetTransactionHeaderFor::CreateLayerResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::CheckConfigCompleterBase::Reply(::llcpp::fuchsia::hardware::display::ConfigResult res, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::ClientCompositionOp> ops) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CheckConfigResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  CheckConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::CheckConfigResponse(
      ::fidl::DecodedMessage<CheckConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CheckConfigResponse::PrimarySize,
              CheckConfigResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.ops = std::move(ops);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::CheckConfigCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::ConfigResult res, ::fidl::VectorView<::llcpp::fuchsia::hardware::display::ClientCompositionOp> ops) {
  if (_buffer.capacity() < CheckConfigResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CheckConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::CheckConfigResponse(
      ::fidl::DecodedMessage<CheckConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CheckConfigResponse::PrimarySize,
              CheckConfigResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.ops = std::move(ops);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::CheckConfigCompleterBase::Reply(::fidl::DecodedMessage<CheckConfigResponse> params) {
  Controller::SetTransactionHeaderFor::CheckConfigResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<VsyncResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  VsyncResponse _response = {};
  Controller::SetTransactionHeaderFor::VsyncResponse(
      ::fidl::DecodedMessage<VsyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              VsyncResponse::PrimarySize,
              VsyncResponse::PrimarySize)));
  _response.display_id = std::move(display_id);
  _response.timestamp = std::move(timestamp);
  _response.images = std::move(images);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, uint64_t display_id, uint64_t timestamp, ::fidl::VectorView<uint64_t> images) {
  if (_buffer.capacity() < VsyncResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  VsyncResponse _response = {};
  Controller::SetTransactionHeaderFor::VsyncResponse(
      ::fidl::DecodedMessage<VsyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              VsyncResponse::PrimarySize,
              VsyncResponse::PrimarySize)));
  _response.display_id = std::move(display_id);
  _response.timestamp = std::move(timestamp);
  _response.images = std::move(images);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Controller::SendVsyncEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<VsyncResponse> params) {
  Controller::SetTransactionHeaderFor::VsyncResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, bool has_ownership) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ClientOwnershipChangeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ClientOwnershipChangeResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ClientOwnershipChangeResponse(
      ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ClientOwnershipChangeResponse::PrimarySize,
              ClientOwnershipChangeResponse::PrimarySize)));
  _response.has_ownership = std::move(has_ownership);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ClientOwnershipChangeResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(std::move(_response_bytes)));
}

zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool has_ownership) {
  if (_buffer.capacity() < ClientOwnershipChangeResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<ClientOwnershipChangeResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ClientOwnershipChangeResponse(
      ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ClientOwnershipChangeResponse::PrimarySize,
              ClientOwnershipChangeResponse::PrimarySize)));
  _response.has_ownership = std::move(has_ownership);
  _buffer.set_actual(sizeof(ClientOwnershipChangeResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<ClientOwnershipChangeResponse>(std::move(_buffer)));
}

zx_status_t Controller::SendClientOwnershipChangeEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<ClientOwnershipChangeResponse> params) {
  Controller::SetTransactionHeaderFor::ClientOwnershipChangeResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(int32_t res) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportBufferCollectionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportBufferCollectionResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ImportBufferCollectionResponse(
      ::fidl::DecodedMessage<ImportBufferCollectionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportBufferCollectionResponse::PrimarySize,
              ImportBufferCollectionResponse::PrimarySize)));
  _response.res = std::move(res);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportBufferCollectionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportBufferCollectionResponse>(std::move(_response_bytes)));
}

void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res) {
  if (_buffer.capacity() < ImportBufferCollectionResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportBufferCollectionResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ImportBufferCollectionResponse(
      ::fidl::DecodedMessage<ImportBufferCollectionResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportBufferCollectionResponse::PrimarySize,
              ImportBufferCollectionResponse::PrimarySize)));
  _response.res = std::move(res);
  _buffer.set_actual(sizeof(ImportBufferCollectionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportBufferCollectionResponse>(std::move(_buffer)));
}

void Controller::Interface::ImportBufferCollectionCompleterBase::Reply(::fidl::DecodedMessage<ImportBufferCollectionResponse> params) {
  Controller::SetTransactionHeaderFor::ImportBufferCollectionResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(int32_t res) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetBufferCollectionConstraintsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetBufferCollectionConstraintsResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsResponse(
      ::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetBufferCollectionConstraintsResponse::PrimarySize,
              SetBufferCollectionConstraintsResponse::PrimarySize)));
  _response.res = std::move(res);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetBufferCollectionConstraintsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(std::move(_response_bytes)));
}

void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res) {
  if (_buffer.capacity() < SetBufferCollectionConstraintsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetBufferCollectionConstraintsResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsResponse(
      ::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetBufferCollectionConstraintsResponse::PrimarySize,
              SetBufferCollectionConstraintsResponse::PrimarySize)));
  _response.res = std::move(res);
  _buffer.set_actual(sizeof(SetBufferCollectionConstraintsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse>(std::move(_buffer)));
}

void Controller::Interface::SetBufferCollectionConstraintsCompleterBase::Reply(::fidl::DecodedMessage<SetBufferCollectionConstraintsResponse> params) {
  Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(int32_t res, ::zx::vmo vmo, uint32_t stride) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSingleBufferFramebufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetSingleBufferFramebufferResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferResponse(
      ::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSingleBufferFramebufferResponse::PrimarySize,
              GetSingleBufferFramebufferResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  _response.stride = std::move(stride);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSingleBufferFramebufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(::fidl::BytePart _buffer, int32_t res, ::zx::vmo vmo, uint32_t stride) {
  if (_buffer.capacity() < GetSingleBufferFramebufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetSingleBufferFramebufferResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferResponse(
      ::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetSingleBufferFramebufferResponse::PrimarySize,
              GetSingleBufferFramebufferResponse::PrimarySize)));
  _response.res = std::move(res);
  _response.vmo = std::move(vmo);
  _response.stride = std::move(stride);
  _buffer.set_actual(sizeof(GetSingleBufferFramebufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse>(std::move(_buffer)));
}

void Controller::Interface::GetSingleBufferFramebufferCompleterBase::Reply(::fidl::DecodedMessage<GetSingleBufferFramebufferResponse> params) {
  Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::IsCaptureSupportedCompleterBase::Reply(::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<IsCaptureSupportedResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<IsCaptureSupportedResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::IsCaptureSupportedResponse(
      ::fidl::DecodedMessage<IsCaptureSupportedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              IsCaptureSupportedResponse::PrimarySize,
              IsCaptureSupportedResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(IsCaptureSupportedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<IsCaptureSupportedResponse>(std::move(_response_bytes)));
}
void Controller::Interface::IsCaptureSupportedCompleterBase::ReplySuccess(bool supported) {
  Controller_IsCaptureSupported_Response response;
  response.supported = std::move(supported);

  Reply(Controller_IsCaptureSupported_Result::WithResponse(&response));
}
void Controller::Interface::IsCaptureSupportedCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_IsCaptureSupported_Result::WithErr(&error));
}

void Controller::Interface::IsCaptureSupportedCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_IsCaptureSupported_Result result) {
  if (_buffer.capacity() < IsCaptureSupportedResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<IsCaptureSupportedResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::IsCaptureSupportedResponse(
      ::fidl::DecodedMessage<IsCaptureSupportedResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              IsCaptureSupportedResponse::PrimarySize,
              IsCaptureSupportedResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(IsCaptureSupportedResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<IsCaptureSupportedResponse>(std::move(_buffer)));
}
void Controller::Interface::IsCaptureSupportedCompleterBase::ReplySuccess(::fidl::BytePart _buffer, bool supported) {
  Controller_IsCaptureSupported_Response response;
  response.supported = std::move(supported);

  Reply(std::move(_buffer), Controller_IsCaptureSupported_Result::WithResponse(&response));
}

void Controller::Interface::IsCaptureSupportedCompleterBase::Reply(::fidl::DecodedMessage<IsCaptureSupportedResponse> params) {
  Controller::SetTransactionHeaderFor::IsCaptureSupportedResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ImportImageForCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ImportImageForCaptureResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ImportImageForCaptureResponse(
      ::fidl::DecodedMessage<ImportImageForCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportImageForCaptureResponse::PrimarySize,
              ImportImageForCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ImportImageForCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageForCaptureResponse>(std::move(_response_bytes)));
}
void Controller::Interface::ImportImageForCaptureCompleterBase::ReplySuccess(uint64_t image_id) {
  Controller_ImportImageForCapture_Response response;
  response.image_id = std::move(image_id);

  Reply(Controller_ImportImageForCapture_Result::WithResponse(&response));
}
void Controller::Interface::ImportImageForCaptureCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_ImportImageForCapture_Result::WithErr(&error));
}

void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_ImportImageForCapture_Result result) {
  if (_buffer.capacity() < ImportImageForCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ImportImageForCaptureResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ImportImageForCaptureResponse(
      ::fidl::DecodedMessage<ImportImageForCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ImportImageForCaptureResponse::PrimarySize,
              ImportImageForCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ImportImageForCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ImportImageForCaptureResponse>(std::move(_buffer)));
}
void Controller::Interface::ImportImageForCaptureCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint64_t image_id) {
  Controller_ImportImageForCapture_Response response;
  response.image_id = std::move(image_id);

  Reply(std::move(_buffer), Controller_ImportImageForCapture_Result::WithResponse(&response));
}

void Controller::Interface::ImportImageForCaptureCompleterBase::Reply(::fidl::DecodedMessage<ImportImageForCaptureResponse> params) {
  Controller::SetTransactionHeaderFor::ImportImageForCaptureResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::StartCaptureCompleterBase::Reply(::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartCaptureResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::StartCaptureResponse(
      ::fidl::DecodedMessage<StartCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartCaptureResponse::PrimarySize,
              StartCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartCaptureResponse>(std::move(_response_bytes)));
}
void Controller::Interface::StartCaptureCompleterBase::ReplySuccess() {
  Controller_StartCapture_Response response;

  Reply(Controller_StartCapture_Result::WithResponse(&response));
}
void Controller::Interface::StartCaptureCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_StartCapture_Result::WithErr(&error));
}

void Controller::Interface::StartCaptureCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_StartCapture_Result result) {
  if (_buffer.capacity() < StartCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<StartCaptureResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::StartCaptureResponse(
      ::fidl::DecodedMessage<StartCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartCaptureResponse::PrimarySize,
              StartCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(StartCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartCaptureResponse>(std::move(_buffer)));
}
void Controller::Interface::StartCaptureCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_StartCapture_Response response;

  Reply(std::move(_buffer), Controller_StartCapture_Result::WithResponse(&response));
}

void Controller::Interface::StartCaptureCompleterBase::Reply(::fidl::DecodedMessage<StartCaptureResponse> params) {
  Controller::SetTransactionHeaderFor::StartCaptureResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ReleaseCaptureCompleterBase::Reply(::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseCaptureResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ReleaseCaptureResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ReleaseCaptureResponse(
      ::fidl::DecodedMessage<ReleaseCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReleaseCaptureResponse::PrimarySize,
              ReleaseCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseCaptureResponse>(std::move(_response_bytes)));
}
void Controller::Interface::ReleaseCaptureCompleterBase::ReplySuccess() {
  Controller_ReleaseCapture_Response response;

  Reply(Controller_ReleaseCapture_Result::WithResponse(&response));
}
void Controller::Interface::ReleaseCaptureCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_ReleaseCapture_Result::WithErr(&error));
}

void Controller::Interface::ReleaseCaptureCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::display::Controller_ReleaseCapture_Result result) {
  if (_buffer.capacity() < ReleaseCaptureResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ReleaseCaptureResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ReleaseCaptureResponse(
      ::fidl::DecodedMessage<ReleaseCaptureResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReleaseCaptureResponse::PrimarySize,
              ReleaseCaptureResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ReleaseCaptureResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseCaptureResponse>(std::move(_buffer)));
}
void Controller::Interface::ReleaseCaptureCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_ReleaseCapture_Response response;

  Reply(std::move(_buffer), Controller_ReleaseCapture_Result::WithResponse(&response));
}

void Controller::Interface::ReleaseCaptureCompleterBase::Reply(::fidl::DecodedMessage<ReleaseCaptureResponse> params) {
  Controller::SetTransactionHeaderFor::ReleaseCaptureResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Controller::SetTransactionHeaderFor::DisplaysChangedResponse(const ::fidl::DecodedMessage<Controller::DisplaysChangedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_DisplaysChanged_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ImportVmoImageRequest(const ::fidl::DecodedMessage<Controller::ImportVmoImageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportVmoImage_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ImportVmoImageResponse(const ::fidl::DecodedMessage<Controller::ImportVmoImageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportVmoImage_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ImportImageRequest(const ::fidl::DecodedMessage<Controller::ImportImageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportImage_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ImportImageResponse(const ::fidl::DecodedMessage<Controller::ImportImageResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportImage_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ReleaseImageRequest(const ::fidl::DecodedMessage<Controller::ReleaseImageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseImage_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ImportEventRequest(const ::fidl::DecodedMessage<Controller::ImportEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportEvent_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ReleaseEventRequest(const ::fidl::DecodedMessage<Controller::ReleaseEventRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseEvent_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::CreateLayerRequest(const ::fidl::DecodedMessage<Controller::CreateLayerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_CreateLayer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::CreateLayerResponse(const ::fidl::DecodedMessage<Controller::CreateLayerResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_CreateLayer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::DestroyLayerRequest(const ::fidl::DecodedMessage<Controller::DestroyLayerRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_DestroyLayer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetDisplayModeRequest(const ::fidl::DecodedMessage<Controller::SetDisplayModeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetDisplayMode_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetDisplayColorConversionRequest(const ::fidl::DecodedMessage<Controller::SetDisplayColorConversionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetDisplayColorConversion_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetDisplayLayersRequest(const ::fidl::DecodedMessage<Controller::SetDisplayLayersRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetDisplayLayers_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerPrimaryConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerPrimaryConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerPrimaryPositionRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryPositionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerPrimaryPosition_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerPrimaryAlphaRequest(const ::fidl::DecodedMessage<Controller::SetLayerPrimaryAlphaRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerPrimaryAlpha_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerCursorConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerCursorConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerCursorConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerCursorPositionRequest(const ::fidl::DecodedMessage<Controller::SetLayerCursorPositionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerCursorPosition_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerColorConfigRequest(const ::fidl::DecodedMessage<Controller::SetLayerColorConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerColorConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetLayerImageRequest(const ::fidl::DecodedMessage<Controller::SetLayerImageRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetLayerImage_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::CheckConfigRequest(const ::fidl::DecodedMessage<Controller::CheckConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_CheckConfig_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::CheckConfigResponse(const ::fidl::DecodedMessage<Controller::CheckConfigResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_CheckConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ApplyConfigRequest(const ::fidl::DecodedMessage<Controller::ApplyConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ApplyConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::EnableVsyncRequest(const ::fidl::DecodedMessage<Controller::EnableVsyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_EnableVsync_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::VsyncResponse(const ::fidl::DecodedMessage<Controller::VsyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Vsync_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetVirtconModeRequest(const ::fidl::DecodedMessage<Controller::SetVirtconModeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetVirtconMode_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ClientOwnershipChangeResponse(const ::fidl::DecodedMessage<Controller::ClientOwnershipChangeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ClientOwnershipChange_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ImportBufferCollectionRequest(const ::fidl::DecodedMessage<Controller::ImportBufferCollectionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportBufferCollection_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ImportBufferCollectionResponse(const ::fidl::DecodedMessage<Controller::ImportBufferCollectionResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportBufferCollection_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ReleaseBufferCollectionRequest(const ::fidl::DecodedMessage<Controller::ReleaseBufferCollectionRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseBufferCollection_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsRequest(const ::fidl::DecodedMessage<Controller::SetBufferCollectionConstraintsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetBufferCollectionConstraints_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::SetBufferCollectionConstraintsResponse(const ::fidl::DecodedMessage<Controller::SetBufferCollectionConstraintsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_SetBufferCollectionConstraints_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferRequest(const ::fidl::DecodedMessage<Controller::GetSingleBufferFramebufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetSingleBufferFramebuffer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::GetSingleBufferFramebufferResponse(const ::fidl::DecodedMessage<Controller::GetSingleBufferFramebufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetSingleBufferFramebuffer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::IsCaptureSupportedRequest(const ::fidl::DecodedMessage<Controller::IsCaptureSupportedRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_IsCaptureSupported_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::IsCaptureSupportedResponse(const ::fidl::DecodedMessage<Controller::IsCaptureSupportedResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_IsCaptureSupported_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ImportImageForCaptureRequest(const ::fidl::DecodedMessage<Controller::ImportImageForCaptureRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportImageForCapture_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ImportImageForCaptureResponse(const ::fidl::DecodedMessage<Controller::ImportImageForCaptureResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ImportImageForCapture_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::StartCaptureRequest(const ::fidl::DecodedMessage<Controller::StartCaptureRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_StartCapture_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::StartCaptureResponse(const ::fidl::DecodedMessage<Controller::StartCaptureResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_StartCapture_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ReleaseCaptureRequest(const ::fidl::DecodedMessage<Controller::ReleaseCaptureRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseCapture_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ReleaseCaptureResponse(const ::fidl::DecodedMessage<Controller::ReleaseCaptureResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseCapture_GenOrdinal);
}

}  // namespace display
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

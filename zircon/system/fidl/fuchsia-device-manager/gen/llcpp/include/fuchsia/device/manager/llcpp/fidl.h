// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace device {
namespace manager {

class DebugDumper;
class Administrator;
class DevhostController;
enum class CompatibilityTestStatus : uint32_t {
  OK = 1u,
  ERR_BIND_NO_DDKADD = 2u,
  ERR_BIND_TIMEOUT = 3u,
  ERR_UNBIND_NO_DDKREMOVE = 4u,
  ERR_UNBIND_TIMEOUT = 5u,
  ERR_SUSPEND_DDKREMOVE = 6u,
  ERR_INTERNAL = 7u,
};


class DeviceController;
struct DeviceComponentPart;
struct DeviceComponent;
class AddDeviceConfig final {
public:
  constexpr AddDeviceConfig() : value_(0u) {}
  explicit constexpr AddDeviceConfig(uint32_t value) : value_(value) {}
  const static AddDeviceConfig ALLOW_MULTI_COMPOSITE;
  const static AddDeviceConfig mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  constexpr inline operator bool() const { return value_; }
  constexpr inline AddDeviceConfig operator~() const;
  constexpr inline AddDeviceConfig operator|(const AddDeviceConfig& other) const;
  constexpr inline AddDeviceConfig operator&(const AddDeviceConfig& other) const;
  constexpr inline AddDeviceConfig operator^(const AddDeviceConfig& other) const;
  constexpr inline void operator|=(const AddDeviceConfig& other);
  constexpr inline void operator&=(const AddDeviceConfig& other);
  constexpr inline void operator^=(const AddDeviceConfig& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::ALLOW_MULTI_COMPOSITE = ::llcpp::fuchsia::device::manager::AddDeviceConfig(1u);
constexpr const ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::mask = ::llcpp::fuchsia::device::manager::AddDeviceConfig(1u);

constexpr inline ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::operator~() const {
  return ::llcpp::fuchsia::device::manager::AddDeviceConfig(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::operator|(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) const {
  return ::llcpp::fuchsia::device::manager::AddDeviceConfig(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::operator&(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) const {
  return ::llcpp::fuchsia::device::manager::AddDeviceConfig(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::device::manager::AddDeviceConfig AddDeviceConfig::operator^(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) const {
  return ::llcpp::fuchsia::device::manager::AddDeviceConfig(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void AddDeviceConfig::operator|=(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) {
  this->value_ |= other.value_;
}

constexpr inline void AddDeviceConfig::operator&=(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) {
  this->value_ &= other.value_;
}

constexpr inline void AddDeviceConfig::operator^=(
    const ::llcpp::fuchsia::device::manager::AddDeviceConfig& other) {
  this->value_ ^= other.value_;
}

class Coordinator;

extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpTreeRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpTreeResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpDriversRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpDriversResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpBindingPropertiesRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DebugDumperDumpBindingPropertiesResponseTable;

// Dumps text debug information.
//
// All methods dump ascii text into a VMO, this allows the caller the flexibility to decide
// how much data they want. Use the returned `written` value to read the data, no string
// termination is guaranteed.
class DebugDumper final {
 public:
  static constexpr char Name_[] = "fuchsia.device.manager.DebugDumper";

  struct DumpTreeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t written;
    uint64_t available;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpTreeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct DumpTreeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo output;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpTreeRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = DumpTreeResponse;
  };

  struct DumpDriversResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t written;
    uint64_t available;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpDriversResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct DumpDriversRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo output;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpDriversRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = DumpDriversResponse;
  };

  struct DumpBindingPropertiesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t written;
    uint64_t available;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpBindingPropertiesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct DumpBindingPropertiesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo output;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DebugDumperDumpBindingPropertiesRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = DumpBindingPropertiesResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    zx_status_t DumpTree(::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DumpTreeResponse> DumpTree(::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DumpTreeResponse> DumpTree(::fidl::DecodedMessage<DumpTreeRequest> params, ::fidl::BytePart response_buffer);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    zx_status_t DumpDrivers(::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DumpDriversResponse> DumpDrivers(::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DumpDriversResponse> DumpDrivers(::fidl::DecodedMessage<DumpDriversRequest> params, ::fidl::BytePart response_buffer);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    zx_status_t DumpBindingProperties(::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DumpBindingPropertiesResponse> DumpBindingProperties(::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DumpBindingPropertiesResponse> DumpBindingProperties(::fidl::DecodedMessage<DumpBindingPropertiesRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    static zx_status_t DumpTree(zx::unowned_channel _client_end, ::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DumpTreeResponse> DumpTree(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print device tree into `output`, returns bytes `written` and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DumpTreeResponse> DumpTree(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DumpTreeRequest> params, ::fidl::BytePart response_buffer);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    static zx_status_t DumpDrivers(zx::unowned_channel _client_end, ::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DumpDriversResponse> DumpDrivers(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print information about all drivers into `output`, returns bytes `written` and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DumpDriversResponse> DumpDrivers(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DumpDriversRequest> params, ::fidl::BytePart response_buffer);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    static zx_status_t DumpBindingProperties(zx::unowned_channel _client_end, ::zx::vmo output, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DumpBindingPropertiesResponse> DumpBindingProperties(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::vmo output, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_written, uint64_t* out_available);

    // Print all devices and their binding properties into `output`, returns bytes `written`
    // and bytes `available` to write.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DumpBindingPropertiesResponse> DumpBindingProperties(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DumpBindingPropertiesRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DebugDumper;
    using _Base = ::fidl::CompleterBase;

    class DumpTreeCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::DecodedMessage<DumpTreeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DumpTreeCompleter = ::fidl::Completer<DumpTreeCompleterBase>;

    virtual void DumpTree(::zx::vmo output, DumpTreeCompleter::Sync _completer) = 0;

    class DumpDriversCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::DecodedMessage<DumpDriversResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DumpDriversCompleter = ::fidl::Completer<DumpDriversCompleterBase>;

    virtual void DumpDrivers(::zx::vmo output, DumpDriversCompleter::Sync _completer) = 0;

    class DumpBindingPropertiesCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t written, uint64_t available);
      void Reply(::fidl::DecodedMessage<DumpBindingPropertiesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DumpBindingPropertiesCompleter = ::fidl::Completer<DumpBindingPropertiesCompleterBase>;

    virtual void DumpBindingProperties(::zx::vmo output, DumpBindingPropertiesCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_device_manager_AdministratorSuspendRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_AdministratorSuspendResponseTable;

// Provides administration services for the device manager service and the device tree it controls.
class Administrator final {
 public:
  static constexpr char Name_[] = "fuchsia.device.manager.Administrator";

  struct SuspendResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_AdministratorSuspendResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SuspendRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_AdministratorSuspendRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SuspendResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    zx_status_t Suspend(uint32_t flags, int32_t* out_status);

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SuspendResponse> Suspend(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SuspendResponse> Suspend(::fidl::DecodedMessage<SuspendRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    static zx_status_t Suspend(zx::unowned_channel _client_end, uint32_t flags, int32_t* out_status);

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SuspendResponse> Suspend(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Ask all devices to enter the suspend state indicated by `flags`. Flags should be some
    // combination of DEVICE_SUSPEND_FLAG_* from the DDK.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SuspendResponse> Suspend(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SuspendRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Administrator;
    using _Base = ::fidl::CompleterBase;

    class SuspendCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SuspendResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SuspendCompleter = ::fidl::Completer<SuspendCompleterBase>;

    virtual void Suspend(uint32_t flags, SuspendCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

// Check the DDK for all available flags.
constexpr uint32_t SUSPEND_FLAG_REBOOT = 3705405696u;

constexpr uint32_t SUSPEND_FLAG_POWEROFF = 3705405952u;

// Maximum number of properties that can be attached to a device
constexpr uint32_t PROPERTIES_MAX = 256u;

// Maximum number of bytes in a metadata payload
constexpr uint32_t METADATA_MAX = 4096u;

extern "C" const fidl_type_t fuchsia_device_manager_DevhostControllerCreateDeviceStubRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DevhostControllerCreateDeviceRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DevhostControllerCreateCompositeDeviceRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DevhostControllerCreateCompositeDeviceResponseTable;

// Protocol for controlling a devhost process from the devcoordinator
class DevhostController final {
 public:

  struct CreateDeviceStubRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel rpc;
    uint32_t protocol_id;
    uint64_t local_device_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DevhostControllerCreateDeviceStubRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CreateDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel rpc;
    ::fidl::StringView driver_path;
    ::zx::vmo driver;
    ::zx::handle parent_proxy;
    ::fidl::StringView proxy_args;
    uint64_t local_device_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DevhostControllerCreateDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 3;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 2048;
  };

  struct CreateCompositeDeviceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DevhostControllerCreateCompositeDeviceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct CreateCompositeDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel rpc;
    ::fidl::VectorView<uint64_t> components;
    ::fidl::StringView name;
    uint64_t local_device_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DevhostControllerCreateCompositeDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 96;
    using ResponseType = CreateCompositeDeviceResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    zx_status_t CreateDeviceStub(::zx::channel rpc, uint32_t protocol_id, uint64_t local_device_id);

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CreateDeviceStub(::fidl::BytePart _request_buffer, ::zx::channel rpc, uint32_t protocol_id, uint64_t local_device_id);

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    // Messages are encoded and decoded in-place.
    zx_status_t CreateDeviceStub(::fidl::DecodedMessage<CreateDeviceStubRequest> params);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    zx_status_t CreateDevice(::zx::channel rpc, ::fidl::StringView driver_path, ::zx::vmo driver, ::zx::handle parent_proxy, ::fidl::StringView proxy_args, uint64_t local_device_id);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CreateDevice(::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::StringView driver_path, ::zx::vmo driver, ::zx::handle parent_proxy, ::fidl::StringView proxy_args, uint64_t local_device_id);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    // Messages are encoded and decoded in-place.
    zx_status_t CreateDevice(::fidl::DecodedMessage<CreateDeviceRequest> params);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    zx_status_t CreateCompositeDevice(::zx::channel rpc, ::fidl::VectorView<uint64_t> components, ::fidl::StringView name, uint64_t local_device_id, int32_t* out_status);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CreateCompositeDeviceResponse> CreateCompositeDevice(::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> components, ::fidl::StringView name, uint64_t local_device_id, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CreateCompositeDeviceResponse> CreateCompositeDevice(::fidl::DecodedMessage<CreateCompositeDeviceRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    static zx_status_t CreateDeviceStub(zx::unowned_channel _client_end, ::zx::channel rpc, uint32_t protocol_id, uint64_t local_device_id);

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CreateDeviceStub(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel rpc, uint32_t protocol_id, uint64_t local_device_id);

    // Create a device in the devhost that only implements the device protocol
    // and claims to support the given `protocol_id`.  This device will communicate
    // with the devcoordinator via `rpc`.
    // Messages are encoded and decoded in-place.
    static zx_status_t CreateDeviceStub(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateDeviceStubRequest> params);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    static zx_status_t CreateDevice(zx::unowned_channel _client_end, ::zx::channel rpc, ::fidl::StringView driver_path, ::zx::vmo driver, ::zx::handle parent_proxy, ::fidl::StringView proxy_args, uint64_t local_device_id);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CreateDevice(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::StringView driver_path, ::zx::vmo driver, ::zx::handle parent_proxy, ::fidl::StringView proxy_args, uint64_t local_device_id);

    // Create a device in the devhost representing the shadowed half of device
    // in another devhost.  This new device will communicate with the devcoordinator
    // via `rpc`, and with its other half via `parent_proxy`.
    //
    // The new device will have the given driver responsible for running its half
    // of the driver's cross-process protocol.  It's create() method will be invoked,
    // giving it access to `parent_proxy` and `proxy_args`.
    //
    // parent_proxy, if present, will usually be a channel to the upper half of
    // a shadowed device.  The one exception is when this method is used
    // to create the Platform Bus, in which case it will be a channel to a
    // fuchsia.boot.Items protocol.
    //
    // `local_device_id` will be a unique value within the device's devhost
    // Messages are encoded and decoded in-place.
    static zx_status_t CreateDevice(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateDeviceRequest> params);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    static zx_status_t CreateCompositeDevice(zx::unowned_channel _client_end, ::zx::channel rpc, ::fidl::VectorView<uint64_t> components, ::fidl::StringView name, uint64_t local_device_id, int32_t* out_status);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CreateCompositeDeviceResponse> CreateCompositeDevice(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> components, ::fidl::StringView name, uint64_t local_device_id, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Introduce a composite device that has the given name and properties.
    // `components` will be a list of all of the composite's components,
    // described using devhost local device ids.  The order of the components
    // will match the original composite creation request.  The new device will
    // communicate with devcoordinator via `rpc`.
    //
    // `local_device_id` will be a unique value within the device's devhost, identifying
    // the resulting composite device.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CreateCompositeDeviceResponse> CreateCompositeDevice(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateCompositeDeviceRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DevhostController;
    using _Base = ::fidl::CompleterBase;

    using CreateDeviceStubCompleter = ::fidl::Completer<>;

    virtual void CreateDeviceStub(::zx::channel rpc, uint32_t protocol_id, uint64_t local_device_id, CreateDeviceStubCompleter::Sync _completer) = 0;

    using CreateDeviceCompleter = ::fidl::Completer<>;

    virtual void CreateDevice(::zx::channel rpc, ::fidl::StringView driver_path, ::zx::vmo driver, ::zx::handle parent_proxy, ::fidl::StringView proxy_args, uint64_t local_device_id, CreateDeviceCompleter::Sync _completer) = 0;

    class CreateCompositeDeviceCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<CreateCompositeDeviceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateCompositeDeviceCompleter = ::fidl::Completer<CreateCompositeDeviceCompleterBase>;

    virtual void CreateCompositeDevice(::zx::channel rpc, ::fidl::VectorView<uint64_t> components, ::fidl::StringView name, uint64_t local_device_id, CreateCompositeDeviceCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

// Maximum number of bytes in a path
constexpr uint32_t DEVICE_PATH_MAX = 1024u;

// This definition must match ZX_DEVICE_NAME_MAX and is checked by a static assert.
constexpr uint32_t DEVICE_NAME_MAX = 31u;

// Maximum instructions in a match program
constexpr uint32_t DEVICE_COMPONENT_PART_INSTRUCTIONS_MAX = 32u;

// Maximum number of parts that a composite device component can have
constexpr uint32_t DEVICE_COMPONENT_PARTS_MAX = 16u;

// Maximum number of bytes in a device arguments string.
constexpr uint32_t DEVICE_ARGS_MAX = 1024u;

extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerBindDriverRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerBindDriverResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerConnectProxyRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerSuspendRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerSuspendResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_DeviceControllerCompleteCompatibilityTestsRequestTable;

// Protocol for controlling devices in a devhost process from the devcoordinator
class DeviceController final {
 public:

  struct BindDriverResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::channel test_output;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerBindDriverResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct BindDriverRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView driver_path;
    ::zx::vmo driver;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerBindDriverRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 1024;
    using ResponseType = BindDriverResponse;
  };

  struct ConnectProxyRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel shadow;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerConnectProxyRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  using UnbindRequest = ::fidl::AnyZeroArgMessage;

  using CompleteRemovalRequest = ::fidl::AnyZeroArgMessage;

  using RemoveDeviceRequest = ::fidl::AnyZeroArgMessage;

  struct SuspendResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerSuspendResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SuspendRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerSuspendRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SuspendResponse;
  };

  struct CompleteCompatibilityTestsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    CompatibilityTestStatus status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceControllerCompleteCompatibilityTestsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    zx_status_t BindDriver(::fidl::StringView driver_path, ::zx::vmo driver, int32_t* out_status, ::zx::channel* out_test_output);

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<BindDriverResponse> BindDriver(::fidl::BytePart _request_buffer, ::fidl::StringView driver_path, ::zx::vmo driver, ::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::channel* out_test_output);

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<BindDriverResponse> BindDriver(::fidl::DecodedMessage<BindDriverRequest> params, ::fidl::BytePart response_buffer);

    // Give this device a channel to its shadow in another process.
    zx_status_t ConnectProxy(::zx::channel shadow);

    // Give this device a channel to its shadow in another process.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t ConnectProxy(::fidl::BytePart _request_buffer, ::zx::channel shadow);

    // Give this device a channel to its shadow in another process.
    // Messages are encoded and decoded in-place.
    zx_status_t ConnectProxy(::fidl::DecodedMessage<ConnectProxyRequest> params);

    // Ask devhost to unbind this device. On success, the remote end of this
    // interface channel will close instead of returning a result.
    zx_status_t Unbind();

    // Ask the devhost to complete the removal of this device, which previously had
    // invoked |ScheduleRemove|. This is a special case that can be removed
    // once |device_remove| invokes |unbind|.
    zx_status_t CompleteRemoval();

    // Ask the devhost to remove this device.  On success, the remote end of
    // this interface channel will close instead of returning a result.
    zx_status_t RemoveDevice();

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    zx_status_t Suspend(uint32_t flags, int32_t* out_status);

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SuspendResponse> Suspend(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SuspendResponse> Suspend(::fidl::DecodedMessage<SuspendRequest> params, ::fidl::BytePart response_buffer);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    zx_status_t CompleteCompatibilityTests(CompatibilityTestStatus status);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t CompleteCompatibilityTests(::fidl::BytePart _request_buffer, CompatibilityTestStatus status);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    // Messages are encoded and decoded in-place.
    zx_status_t CompleteCompatibilityTests(::fidl::DecodedMessage<CompleteCompatibilityTestsRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    static zx_status_t BindDriver(zx::unowned_channel _client_end, ::fidl::StringView driver_path, ::zx::vmo driver, int32_t* out_status, ::zx::channel* out_test_output);

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<BindDriverResponse> BindDriver(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView driver_path, ::zx::vmo driver, ::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::channel* out_test_output);

    // Bind the requested driver to this device.  `driver_path` is informational,
    // but all calls to BindDriver/CreateDevice should use the same `driver_path`
    // each time they use a `driver` VMO with the same contents. Returns a `status`
    // and optionally a channel to the driver's test output. `test_output` will be
    // not present unless the driver is configured to run its run_unit_tests hook, in
    // which case the other end of the channel will have been passed to the driver.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<BindDriverResponse> BindDriver(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindDriverRequest> params, ::fidl::BytePart response_buffer);

    // Give this device a channel to its shadow in another process.
    static zx_status_t ConnectProxy(zx::unowned_channel _client_end, ::zx::channel shadow);

    // Give this device a channel to its shadow in another process.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t ConnectProxy(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel shadow);

    // Give this device a channel to its shadow in another process.
    // Messages are encoded and decoded in-place.
    static zx_status_t ConnectProxy(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectProxyRequest> params);

    // Ask devhost to unbind this device. On success, the remote end of this
    // interface channel will close instead of returning a result.
    static zx_status_t Unbind(zx::unowned_channel _client_end);

    // Ask the devhost to complete the removal of this device, which previously had
    // invoked |ScheduleRemove|. This is a special case that can be removed
    // once |device_remove| invokes |unbind|.
    static zx_status_t CompleteRemoval(zx::unowned_channel _client_end);

    // Ask the devhost to remove this device.  On success, the remote end of
    // this interface channel will close instead of returning a result.
    static zx_status_t RemoveDevice(zx::unowned_channel _client_end);

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    static zx_status_t Suspend(zx::unowned_channel _client_end, uint32_t flags, int32_t* out_status);

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SuspendResponse> Suspend(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Ask devhost to suspend this device, using the target state indicated by `flags`.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SuspendResponse> Suspend(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SuspendRequest> params, ::fidl::BytePart response_buffer);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    static zx_status_t CompleteCompatibilityTests(zx::unowned_channel _client_end, CompatibilityTestStatus status);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t CompleteCompatibilityTests(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, CompatibilityTestStatus status);

    // Inform devhost about the compatibility test status when compatibility tests
    // fail or complete successfully.
    // Messages are encoded and decoded in-place.
    static zx_status_t CompleteCompatibilityTests(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CompleteCompatibilityTestsRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DeviceController;
    using _Base = ::fidl::CompleterBase;

    class BindDriverCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::channel test_output);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::channel test_output);
      void Reply(::fidl::DecodedMessage<BindDriverResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindDriverCompleter = ::fidl::Completer<BindDriverCompleterBase>;

    virtual void BindDriver(::fidl::StringView driver_path, ::zx::vmo driver, BindDriverCompleter::Sync _completer) = 0;

    using ConnectProxyCompleter = ::fidl::Completer<>;

    virtual void ConnectProxy(::zx::channel shadow, ConnectProxyCompleter::Sync _completer) = 0;

    using UnbindCompleter = ::fidl::Completer<>;

    virtual void Unbind(UnbindCompleter::Sync _completer) = 0;

    using CompleteRemovalCompleter = ::fidl::Completer<>;

    virtual void CompleteRemoval(CompleteRemovalCompleter::Sync _completer) = 0;

    using RemoveDeviceCompleter = ::fidl::Completer<>;

    virtual void RemoveDevice(RemoveDeviceCompleter::Sync _completer) = 0;

    class SuspendCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SuspendResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SuspendCompleter = ::fidl::Completer<SuspendCompleterBase>;

    virtual void Suspend(uint32_t flags, SuspendCompleter::Sync _completer) = 0;

    using CompleteCompatibilityTestsCompleter = ::fidl::Completer<>;

    virtual void CompleteCompatibilityTests(CompatibilityTestStatus status, CompleteCompatibilityTestsCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

// Maximum number of components that a composite device can have
constexpr uint32_t COMPONENTS_MAX = 8u;

extern "C" const fidl_type_t fuchsia_device_manager_DeviceComponentPartTable;

// A part of a description of a DeviceComponent
struct DeviceComponentPart {
  static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceComponentPartTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 264;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t match_program_count{};

  ::fidl::Array<uint64_t, 32> match_program{};
};

extern "C" const fidl_type_t fuchsia_device_manager_DeviceComponentTable;

// A piece of a composite device
struct DeviceComponent {
  static constexpr const fidl_type_t* Type = &fuchsia_device_manager_DeviceComponentTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4232;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t parts_count{};

  ::fidl::Array<DeviceComponentPart, 16> parts{};
};

extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddDeviceRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddDeviceResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddDeviceInvisibleRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddDeviceInvisibleResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorRemoveDeviceResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorMakeVisibleResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorBindDeviceRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorBindDeviceResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorGetTopologicalPathResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorLoadFirmwareRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorLoadFirmwareResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorGetMetadataRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorGetMetadataResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorGetMetadataSizeRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorGetMetadataSizeResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddMetadataRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddMetadataResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorPublishMetadataRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorPublishMetadataResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddCompositeDeviceRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorAddCompositeDeviceResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorDirectoryWatchRequestTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorDirectoryWatchResponseTable;
extern "C" const fidl_type_t fuchsia_device_manager_CoordinatorRunCompatibilityTestsResponseTable;

// Interface for the devices in devhosts to coordinate with the devcoordinator.
class Coordinator final {
 public:

  struct AddDeviceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t local_device_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddDeviceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AddDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel rpc;
    ::fidl::VectorView<uint64_t> props;
    ::fidl::StringView name;
    uint32_t protocol_id;
    ::fidl::StringView driver_path;
    ::fidl::StringView args;
    AddDeviceConfig device_add_config;
    ::zx::channel client_remote;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 104;
    static constexpr uint32_t MaxOutOfLine = 4128;
    using ResponseType = AddDeviceResponse;
  };

  struct AddDeviceInvisibleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t local_device_id;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddDeviceInvisibleResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AddDeviceInvisibleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel rpc;
    ::fidl::VectorView<uint64_t> props;
    ::fidl::StringView name;
    uint32_t protocol_id;
    ::fidl::StringView driver_path;
    ::fidl::StringView args;
    ::zx::channel client_remote;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddDeviceInvisibleRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 104;
    static constexpr uint32_t MaxOutOfLine = 4128;
    using ResponseType = AddDeviceInvisibleResponse;
  };

  using ScheduleRemoveRequest = ::fidl::AnyZeroArgMessage;

  using UnbindDoneRequest = ::fidl::AnyZeroArgMessage;

  struct RemoveDeviceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorRemoveDeviceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using RemoveDeviceRequest = ::fidl::AnyZeroArgMessage;

  struct MakeVisibleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorMakeVisibleResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using MakeVisibleRequest = ::fidl::AnyZeroArgMessage;

  struct BindDeviceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorBindDeviceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct BindDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView driver_path;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorBindDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 1024;
    using ResponseType = BindDeviceResponse;
  };

  struct GetTopologicalPathResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorGetTopologicalPathResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 1024;
  };
  using GetTopologicalPathRequest = ::fidl::AnyZeroArgMessage;

  struct LoadFirmwareResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::vmo vmo;
    uint64_t size;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorLoadFirmwareResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct LoadFirmwareRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView fw_path;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorLoadFirmwareRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 1024;
    using ResponseType = LoadFirmwareResponse;
  };

  struct GetMetadataResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorGetMetadataResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4096;
  };
  struct GetMetadataRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t key;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorGetMetadataRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = GetMetadataResponse;
  };

  struct GetMetadataSizeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint64_t size;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorGetMetadataSizeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct GetMetadataSizeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t key;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorGetMetadataSizeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = GetMetadataSizeResponse;
  };

  struct AddMetadataResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddMetadataResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AddMetadataRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t key;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddMetadataRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4096;
    using ResponseType = AddMetadataResponse;
  };

  struct PublishMetadataResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorPublishMetadataResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct PublishMetadataRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView device_path;
    uint32_t key;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorPublishMetadataRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 5120;
    using ResponseType = PublishMetadataResponse;
  };

  struct AddCompositeDeviceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddCompositeDeviceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct AddCompositeDeviceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView name;
    ::fidl::VectorView<uint64_t> props;
    ::fidl::Array<DeviceComponent, 8> components;
    uint32_t components_count;
    uint32_t coresident_device_index;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorAddCompositeDeviceRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 33912;
    static constexpr uint32_t MaxOutOfLine = 2080;
    using ResponseType = AddCompositeDeviceResponse;
  };

  struct DirectoryWatchResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorDirectoryWatchResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct DirectoryWatchRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t mask;
    uint32_t options;
    ::zx::channel watcher;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorDirectoryWatchRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = DirectoryWatchResponse;
  };

  struct RunCompatibilityTestsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_device_manager_CoordinatorRunCompatibilityTestsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct RunCompatibilityTestsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int64_t hook_wait_time;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = RunCompatibilityTestsResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    SyncClient(SyncClient&&) = default;

    SyncClient& operator=(SyncClient&&) = default;

    ~SyncClient() {}

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    zx_status_t AddDevice(::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, AddDeviceConfig device_add_config, ::zx::channel client_remote, int32_t* out_status, uint64_t* out_local_device_id);

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AddDeviceResponse> AddDevice(::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, AddDeviceConfig device_add_config, ::zx::channel client_remote, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_local_device_id);

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AddDeviceResponse> AddDevice(::fidl::DecodedMessage<AddDeviceRequest> params, ::fidl::BytePart response_buffer);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    zx_status_t AddDeviceInvisible(::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, ::zx::channel client_remote, int32_t* out_status, uint64_t* out_local_device_id);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AddDeviceInvisibleResponse> AddDeviceInvisible(::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, ::zx::channel client_remote, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_local_device_id);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AddDeviceInvisibleResponse> AddDeviceInvisible(::fidl::DecodedMessage<AddDeviceInvisibleRequest> params, ::fidl::BytePart response_buffer);

    // Requests the devcoordinator schedule the removal of this device,
    // and the unbinding of its children.
    zx_status_t ScheduleRemove();

    // Sent as the response to |Unbind| or |CompleteRemoval|.
    zx_status_t UnbindDone();

    // Record the removal of this device.
    zx_status_t RemoveDevice(int32_t* out_status);

    // Record the removal of this device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<RemoveDeviceResponse> RemoveDevice(::fidl::BytePart _response_buffer, int32_t* out_status);

    // Record the removal of this device.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RemoveDeviceResponse> RemoveDevice(::fidl::BytePart response_buffer);

    // Mark this device as visible.
    zx_status_t MakeVisible(int32_t* out_status);

    // Mark this device as visible.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<MakeVisibleResponse> MakeVisible(::fidl::BytePart _response_buffer, int32_t* out_status);

    // Mark this device as visible.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<MakeVisibleResponse> MakeVisible(::fidl::BytePart response_buffer);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    zx_status_t BindDevice(::fidl::StringView driver_path, int32_t* out_status);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<BindDeviceResponse> BindDevice(::fidl::BytePart _request_buffer, ::fidl::StringView driver_path, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<BindDeviceResponse> BindDevice(::fidl::DecodedMessage<BindDeviceRequest> params, ::fidl::BytePart response_buffer);


    // Returns the topological path of this device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetTopologicalPathResponse> GetTopologicalPath(::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_path);

    // Returns the topological path of this device.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetTopologicalPathResponse> GetTopologicalPath(::fidl::BytePart response_buffer);

    // Requests that the firmware at the given path be loaded and returned.
    zx_status_t LoadFirmware(::fidl::StringView fw_path, int32_t* out_status, ::zx::vmo* out_vmo, uint64_t* out_size);

    // Requests that the firmware at the given path be loaded and returned.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<LoadFirmwareResponse> LoadFirmware(::fidl::BytePart _request_buffer, ::fidl::StringView fw_path, ::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::vmo* out_vmo, uint64_t* out_size);

    // Requests that the firmware at the given path be loaded and returned.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<LoadFirmwareResponse> LoadFirmware(::fidl::DecodedMessage<LoadFirmwareRequest> params, ::fidl::BytePart response_buffer);


    // Retrieve the metadata blob associated with this device and the given key.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetMetadataResponse> GetMetadata(::fidl::BytePart _request_buffer, uint32_t key, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::VectorView<uint8_t>* out_data);

    // Retrieve the metadata blob associated with this device and the given key.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetMetadataResponse> GetMetadata(::fidl::DecodedMessage<GetMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Retrieve the metadata size associated with this device and the given key.
    zx_status_t GetMetadataSize(uint32_t key, int32_t* out_status, uint64_t* out_size);

    // Retrieve the metadata size associated with this device and the given key.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetMetadataSizeResponse> GetMetadataSize(::fidl::BytePart _request_buffer, uint32_t key, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_size);

    // Retrieve the metadata size associated with this device and the given key.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetMetadataSizeResponse> GetMetadataSize(::fidl::DecodedMessage<GetMetadataSizeRequest> params, ::fidl::BytePart response_buffer);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    zx_status_t AddMetadata(uint32_t key, ::fidl::VectorView<uint8_t> data, int32_t* out_status);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AddMetadataResponse> AddMetadata(::fidl::BytePart _request_buffer, uint32_t key, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AddMetadataResponse> AddMetadata(::fidl::DecodedMessage<AddMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    zx_status_t PublishMetadata(::fidl::StringView device_path, uint32_t key, ::fidl::VectorView<uint8_t> data, int32_t* out_status);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<PublishMetadataResponse> PublishMetadata(::fidl::BytePart _request_buffer, ::fidl::StringView device_path, uint32_t key, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<PublishMetadataResponse> PublishMetadata(::fidl::DecodedMessage<PublishMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    zx_status_t AddCompositeDevice(::fidl::StringView name, ::fidl::VectorView<uint64_t> props, ::fidl::Array<DeviceComponent, 8> components, uint32_t components_count, uint32_t coresident_device_index, int32_t* out_status);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AddCompositeDeviceResponse> AddCompositeDevice(::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::VectorView<uint64_t> props, ::fidl::Array<DeviceComponent, 8> components, uint32_t components_count, uint32_t coresident_device_index, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<AddCompositeDeviceResponse> AddCompositeDevice(::fidl::DecodedMessage<AddCompositeDeviceRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    zx_status_t DirectoryWatch(uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DirectoryWatchResponse> DirectoryWatch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DirectoryWatchResponse> DirectoryWatch(::fidl::DecodedMessage<DirectoryWatchRequest> params, ::fidl::BytePart response_buffer);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    zx_status_t RunCompatibilityTests(int64_t hook_wait_time, int32_t* out_status);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<RunCompatibilityTestsResponse> RunCompatibilityTests(::fidl::BytePart _request_buffer, int64_t hook_wait_time, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RunCompatibilityTestsResponse> RunCompatibilityTests(::fidl::DecodedMessage<RunCompatibilityTestsRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    static zx_status_t AddDevice(zx::unowned_channel _client_end, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, AddDeviceConfig device_add_config, ::zx::channel client_remote, int32_t* out_status, uint64_t* out_local_device_id);

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AddDeviceResponse> AddDevice(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, AddDeviceConfig device_add_config, ::zx::channel client_remote, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_local_device_id);

    // Record the addition of a new device that can be communicated with via `rpc`.
    // For binding purposes, it is has properties `props`. `name` and `driver_path`
    // are informational and used for debugging.  The device will have `protocol_id`
    // as its primary protocol id.  `args` should only be used for shadowed devices,
    // and will be forwarded to the shadow device. `client_remote`, if present,
    // will be passed to the device as an open connection for the client.
    // On success, the returned `local_device_id` is the identifier assigned by devmgr.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AddDeviceResponse> AddDevice(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddDeviceRequest> params, ::fidl::BytePart response_buffer);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    static zx_status_t AddDeviceInvisible(zx::unowned_channel _client_end, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, ::zx::channel client_remote, int32_t* out_status, uint64_t* out_local_device_id);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AddDeviceInvisibleResponse> AddDeviceInvisible(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, ::zx::channel client_remote, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_local_device_id);

    // Behaves as AddDevice, but marks the device as initially invisible.  This means
    // that it will not be visible to other devices or the devfs until it is later marked
    // visible (via MakeVisible).
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AddDeviceInvisibleResponse> AddDeviceInvisible(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddDeviceInvisibleRequest> params, ::fidl::BytePart response_buffer);

    // Requests the devcoordinator schedule the removal of this device,
    // and the unbinding of its children.
    static zx_status_t ScheduleRemove(zx::unowned_channel _client_end);

    // Sent as the response to |Unbind| or |CompleteRemoval|.
    static zx_status_t UnbindDone(zx::unowned_channel _client_end);

    // Record the removal of this device.
    static zx_status_t RemoveDevice(zx::unowned_channel _client_end, int32_t* out_status);

    // Record the removal of this device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<RemoveDeviceResponse> RemoveDevice(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Record the removal of this device.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RemoveDeviceResponse> RemoveDevice(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Mark this device as visible.
    static zx_status_t MakeVisible(zx::unowned_channel _client_end, int32_t* out_status);

    // Mark this device as visible.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<MakeVisibleResponse> MakeVisible(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Mark this device as visible.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<MakeVisibleResponse> MakeVisible(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    static zx_status_t BindDevice(zx::unowned_channel _client_end, ::fidl::StringView driver_path, int32_t* out_status);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<BindDeviceResponse> BindDevice(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView driver_path, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Attempt to bind a driver against this device.  If `driver_path` is null,
    // this will initiate the driver matching algorithm.
    // TODO(teisenbe): Specify the behavior of invoking this multiple times.  I believe
    // the current behavior is a bug.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<BindDeviceResponse> BindDevice(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindDeviceRequest> params, ::fidl::BytePart response_buffer);


    // Returns the topological path of this device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetTopologicalPathResponse> GetTopologicalPath(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_path);

    // Returns the topological path of this device.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetTopologicalPathResponse> GetTopologicalPath(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Requests that the firmware at the given path be loaded and returned.
    static zx_status_t LoadFirmware(zx::unowned_channel _client_end, ::fidl::StringView fw_path, int32_t* out_status, ::zx::vmo* out_vmo, uint64_t* out_size);

    // Requests that the firmware at the given path be loaded and returned.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<LoadFirmwareResponse> LoadFirmware(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView fw_path, ::fidl::BytePart _response_buffer, int32_t* out_status, ::zx::vmo* out_vmo, uint64_t* out_size);

    // Requests that the firmware at the given path be loaded and returned.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<LoadFirmwareResponse> LoadFirmware(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LoadFirmwareRequest> params, ::fidl::BytePart response_buffer);


    // Retrieve the metadata blob associated with this device and the given key.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetMetadataResponse> GetMetadata(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t key, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::VectorView<uint8_t>* out_data);

    // Retrieve the metadata blob associated with this device and the given key.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetMetadataResponse> GetMetadata(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Retrieve the metadata size associated with this device and the given key.
    static zx_status_t GetMetadataSize(zx::unowned_channel _client_end, uint32_t key, int32_t* out_status, uint64_t* out_size);

    // Retrieve the metadata size associated with this device and the given key.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetMetadataSizeResponse> GetMetadataSize(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t key, ::fidl::BytePart _response_buffer, int32_t* out_status, uint64_t* out_size);

    // Retrieve the metadata size associated with this device and the given key.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetMetadataSizeResponse> GetMetadataSize(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMetadataSizeRequest> params, ::fidl::BytePart response_buffer);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    static zx_status_t AddMetadata(zx::unowned_channel _client_end, uint32_t key, ::fidl::VectorView<uint8_t> data, int32_t* out_status);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AddMetadataResponse> AddMetadata(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t key, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Add metadata blob associated with this device and the given key.
    // TODO(teisenbe): Document the behavior of calling this twice with the same
    // key.  I believe the current behavior results in inaccessible data that is
    // kept around for the lifetime of the device.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AddMetadataResponse> AddMetadata(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    static zx_status_t PublishMetadata(zx::unowned_channel _client_end, ::fidl::StringView device_path, uint32_t key, ::fidl::VectorView<uint8_t> data, int32_t* out_status);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<PublishMetadataResponse> PublishMetadata(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView device_path, uint32_t key, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Behaves like AddMetadata, but instead of associating it with the
    // requesting device, associates it with the device at `device_path`.  If
    // the device at `device_path` is not a child of the requesting device AND
    // the requesting device is not running in the sys devhost, then this will
    // fail.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<PublishMetadataResponse> PublishMetadata(zx::unowned_channel _client_end, ::fidl::DecodedMessage<PublishMetadataRequest> params, ::fidl::BytePart response_buffer);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    static zx_status_t AddCompositeDevice(zx::unowned_channel _client_end, ::fidl::StringView name, ::fidl::VectorView<uint64_t> props, ::fidl::Array<DeviceComponent, 8> components, uint32_t components_count, uint32_t coresident_device_index, int32_t* out_status);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AddCompositeDeviceResponse> AddCompositeDevice(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::VectorView<uint64_t> props, ::fidl::Array<DeviceComponent, 8> components, uint32_t components_count, uint32_t coresident_device_index, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Adds the given composite device.  This causes the devcoordinator to try to match the
    // components against the existing device tree, and to monitor all new device additions
    // in order to find the components as they are created.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<AddCompositeDeviceResponse> AddCompositeDevice(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddCompositeDeviceRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    static zx_status_t DirectoryWatch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DirectoryWatchResponse> DirectoryWatch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    // See fuchsia.io.Directory for more information.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DirectoryWatchResponse> DirectoryWatch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<DirectoryWatchRequest> params, ::fidl::BytePart response_buffer);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    static zx_status_t RunCompatibilityTests(zx::unowned_channel _client_end, int64_t hook_wait_time, int32_t* out_status);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<RunCompatibilityTestsResponse> RunCompatibilityTests(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t hook_wait_time, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Run Compatibility tests for the driver that binds to this device.
    // The hook_wait_time is the time that the driver expects to take for
    // each device hook in nanoseconds.
    // Returns whether the compatibility tests started, and does not convey
    // anything about the status of the test.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RunCompatibilityTestsResponse> RunCompatibilityTests(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RunCompatibilityTestsRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Coordinator;
    using _Base = ::fidl::CompleterBase;

    class AddDeviceCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t local_device_id);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t local_device_id);
      void Reply(::fidl::DecodedMessage<AddDeviceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddDeviceCompleter = ::fidl::Completer<AddDeviceCompleterBase>;

    virtual void AddDevice(::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, AddDeviceConfig device_add_config, ::zx::channel client_remote, AddDeviceCompleter::Sync _completer) = 0;

    class AddDeviceInvisibleCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t local_device_id);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t local_device_id);
      void Reply(::fidl::DecodedMessage<AddDeviceInvisibleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddDeviceInvisibleCompleter = ::fidl::Completer<AddDeviceInvisibleCompleterBase>;

    virtual void AddDeviceInvisible(::zx::channel rpc, ::fidl::VectorView<uint64_t> props, ::fidl::StringView name, uint32_t protocol_id, ::fidl::StringView driver_path, ::fidl::StringView args, ::zx::channel client_remote, AddDeviceInvisibleCompleter::Sync _completer) = 0;

    using ScheduleRemoveCompleter = ::fidl::Completer<>;

    virtual void ScheduleRemove(ScheduleRemoveCompleter::Sync _completer) = 0;

    using UnbindDoneCompleter = ::fidl::Completer<>;

    virtual void UnbindDone(UnbindDoneCompleter::Sync _completer) = 0;

    class RemoveDeviceCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<RemoveDeviceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RemoveDeviceCompleter = ::fidl::Completer<RemoveDeviceCompleterBase>;

    virtual void RemoveDevice(RemoveDeviceCompleter::Sync _completer) = 0;

    class MakeVisibleCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<MakeVisibleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using MakeVisibleCompleter = ::fidl::Completer<MakeVisibleCompleterBase>;

    virtual void MakeVisible(MakeVisibleCompleter::Sync _completer) = 0;

    class BindDeviceCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<BindDeviceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindDeviceCompleter = ::fidl::Completer<BindDeviceCompleterBase>;

    virtual void BindDevice(::fidl::StringView driver_path, BindDeviceCompleter::Sync _completer) = 0;

    class GetTopologicalPathCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::fidl::StringView path);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::StringView path);
      void Reply(::fidl::DecodedMessage<GetTopologicalPathResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTopologicalPathCompleter = ::fidl::Completer<GetTopologicalPathCompleterBase>;

    virtual void GetTopologicalPath(GetTopologicalPathCompleter::Sync _completer) = 0;

    class LoadFirmwareCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::vmo vmo, uint64_t size);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::vmo vmo, uint64_t size);
      void Reply(::fidl::DecodedMessage<LoadFirmwareResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LoadFirmwareCompleter = ::fidl::Completer<LoadFirmwareCompleterBase>;

    virtual void LoadFirmware(::fidl::StringView fw_path, LoadFirmwareCompleter::Sync _completer) = 0;

    class GetMetadataCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<GetMetadataResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetMetadataCompleter = ::fidl::Completer<GetMetadataCompleterBase>;

    virtual void GetMetadata(uint32_t key, GetMetadataCompleter::Sync _completer) = 0;

    class GetMetadataSizeCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint64_t size);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint64_t size);
      void Reply(::fidl::DecodedMessage<GetMetadataSizeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetMetadataSizeCompleter = ::fidl::Completer<GetMetadataSizeCompleterBase>;

    virtual void GetMetadataSize(uint32_t key, GetMetadataSizeCompleter::Sync _completer) = 0;

    class AddMetadataCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<AddMetadataResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddMetadataCompleter = ::fidl::Completer<AddMetadataCompleterBase>;

    virtual void AddMetadata(uint32_t key, ::fidl::VectorView<uint8_t> data, AddMetadataCompleter::Sync _completer) = 0;

    class PublishMetadataCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<PublishMetadataResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using PublishMetadataCompleter = ::fidl::Completer<PublishMetadataCompleterBase>;

    virtual void PublishMetadata(::fidl::StringView device_path, uint32_t key, ::fidl::VectorView<uint8_t> data, PublishMetadataCompleter::Sync _completer) = 0;

    class AddCompositeDeviceCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<AddCompositeDeviceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AddCompositeDeviceCompleter = ::fidl::Completer<AddCompositeDeviceCompleterBase>;

    virtual void AddCompositeDevice(::fidl::StringView name, ::fidl::VectorView<uint64_t> props, ::fidl::Array<DeviceComponent, 8> components, uint32_t components_count, uint32_t coresident_device_index, AddCompositeDeviceCompleter::Sync _completer) = 0;

    class DirectoryWatchCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<DirectoryWatchResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DirectoryWatchCompleter = ::fidl::Completer<DirectoryWatchCompleterBase>;

    virtual void DirectoryWatch(uint32_t mask, uint32_t options, ::zx::channel watcher, DirectoryWatchCompleter::Sync _completer) = 0;

    class RunCompatibilityTestsCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<RunCompatibilityTestsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RunCompatibilityTestsCompleter = ::fidl::Completer<RunCompatibilityTestsCompleterBase>;

    virtual void RunCompatibilityTests(int64_t hook_wait_time, RunCompatibilityTestsCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

}  // namespace manager
}  // namespace device
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeRequest)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeRequest, output) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse, written) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpTreeResponse, available) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversRequest)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversRequest, output) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse, written) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpDriversResponse, available) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesRequest)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesRequest, output) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse)
    == ::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse, written) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DebugDumper::DumpBindingPropertiesResponse, available) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Administrator::SuspendRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Administrator::SuspendRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Administrator::SuspendRequest)
    == ::llcpp::fuchsia::device::manager::Administrator::SuspendRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Administrator::SuspendRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Administrator::SuspendResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Administrator::SuspendResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Administrator::SuspendResponse)
    == ::llcpp::fuchsia::device::manager::Administrator::SuspendResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Administrator::SuspendResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest)
    == ::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest, rpc) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest, protocol_id) == 20);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceStubRequest, local_device_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest)
    == ::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, rpc) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, driver_path) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, driver) == 40);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, parent_proxy) == 44);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, proxy_args) == 48);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateDeviceRequest, local_device_id) == 64);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest)
    == ::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest, rpc) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest, components) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest, name) == 40);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceRequest, local_device_id) == 56);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceResponse)
    == ::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DevhostController::CreateCompositeDeviceResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest)
    == ::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest, driver_path) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverRequest, driver) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse)
    == ::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::BindDriverResponse, test_output) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::ConnectProxyRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::ConnectProxyRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::ConnectProxyRequest)
    == ::llcpp::fuchsia::device::manager::DeviceController::ConnectProxyRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::ConnectProxyRequest, shadow) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::SuspendRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::SuspendRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::SuspendRequest)
    == ::llcpp::fuchsia::device::manager::DeviceController::SuspendRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::SuspendRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::SuspendResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::SuspendResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::SuspendResponse)
    == ::llcpp::fuchsia::device::manager::DeviceController::SuspendResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::SuspendResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceController::CompleteCompatibilityTestsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::DeviceController::CompleteCompatibilityTestsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceController::CompleteCompatibilityTestsRequest)
    == ::llcpp::fuchsia::device::manager::DeviceController::CompleteCompatibilityTestsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceController::CompleteCompatibilityTestsRequest, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceComponentPart> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::manager::DeviceComponentPart>);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceComponentPart, match_program_count) == 0);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceComponentPart, match_program) == 8);
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceComponentPart) == ::llcpp::fuchsia::device::manager::DeviceComponentPart::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::DeviceComponent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::manager::DeviceComponent>);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceComponent, parts_count) == 0);
static_assert(offsetof(::llcpp::fuchsia::device::manager::DeviceComponent, parts) == 8);
static_assert(sizeof(::llcpp::fuchsia::device::manager::DeviceComponent) == ::llcpp::fuchsia::device::manager::DeviceComponent::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::AddDeviceConfig> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::device::manager::AddDeviceConfig>);
static_assert(sizeof(::llcpp::fuchsia::device::manager::AddDeviceConfig) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, rpc) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, props) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, name) == 40);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, protocol_id) == 56);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, driver_path) == 64);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, args) == 80);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, device_add_config) == 96);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceRequest, client_remote) == 100);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceResponse, local_device_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, rpc) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, props) == 24);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, name) == 40);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, protocol_id) == 56);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, driver_path) == 64);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, args) == 80);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleRequest, client_remote) == 96);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddDeviceInvisibleResponse, local_device_id) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::RemoveDeviceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::RemoveDeviceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::RemoveDeviceResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::RemoveDeviceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::RemoveDeviceResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::MakeVisibleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::MakeVisibleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::MakeVisibleResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::MakeVisibleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::MakeVisibleResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::BindDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::BindDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::BindDeviceRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::BindDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::BindDeviceRequest, driver_path) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::BindDeviceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::BindDeviceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::BindDeviceResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::BindDeviceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::BindDeviceResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetTopologicalPathResponse, path) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareRequest, fw_path) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse, vmo) == 20);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::LoadFirmwareResponse, size) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::GetMetadataRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataRequest, key) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataResponse, data) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeRequest, key) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::GetMetadataSizeResponse, size) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest, key) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddMetadataRequest, data) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddMetadataResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddMetadataResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddMetadataResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddMetadataResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddMetadataResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest, device_path) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest, key) == 32);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataRequest, data) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::PublishMetadataResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest, name) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest, props) == 32);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest, components) == 48);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest, components_count) == 33904);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceRequest, coresident_device_index) == 33908);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::AddCompositeDeviceResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest, mask) == 16);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest, options) == 20);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchRequest, watcher) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::DirectoryWatchResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsRequest)
    == ::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsRequest, hook_wait_time) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsResponse)
    == ::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::device::manager::Coordinator::RunCompatibilityTestsResponse, status) == 16);

}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/cpu/insntrace/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace cpu {
namespace insntrace {

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::Controller_Terminate_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::~Controller_Terminate_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_Terminate_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::MoveImpl_(Controller_Terminate_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::Controller_ReleaseThreadBuffer_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::~Controller_ReleaseThreadBuffer_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_ReleaseThreadBuffer_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::MoveImpl_(Controller_ReleaseThreadBuffer_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::Controller_Initialize_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::~Controller_Initialize_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_Initialize_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::MoveImpl_(Controller_Initialize_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::Controller_AssignThreadBuffer_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::~Controller_AssignThreadBuffer_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_AssignThreadBuffer_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::MoveImpl_(Controller_AssignThreadBuffer_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::Controller_AllocateBuffer_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::~Controller_AllocateBuffer_Result() {
  Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~Controller_AllocateBuffer_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::MoveImpl_(Controller_AllocateBuffer_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result, response_) == 4);
  static_assert(offsetof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result, err_) == 4);
  static_assert(sizeof(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result) == ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::PrimarySize);
}


::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

int32_t& ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) int32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kController_Initialize_Ordinal = 0x59b0d03400000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Initialize_GenOrdinal = 0x1ca155857f30468lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerInitializeRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerInitializeResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Terminate_Ordinal = 0x720fc32b00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Terminate_GenOrdinal = 0x6115092acef4d497lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerTerminateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerTerminateResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetAllocation_Ordinal = 0x1226c5d000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetAllocation_GenOrdinal = 0xabef26cf562354flu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetAllocationResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_AllocateBuffer_Ordinal = 0x6e2611dd00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_AllocateBuffer_GenOrdinal = 0x5a0c3fcdcca20055lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAllocateBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_AssignThreadBuffer_Ordinal = 0x39f7e62f00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_AssignThreadBuffer_GenOrdinal = 0x5d699c2d22aafef2lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerAssignThreadBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseThreadBuffer_Ordinal = 0x50b6cf000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_ReleaseThreadBuffer_GenOrdinal = 0x5dd0a7fe5a69bb8lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerReleaseThreadBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferConfig_Ordinal = 0x283603b800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferConfig_GenOrdinal = 0x3e2bb907fc1c195dlu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferState_Ordinal = 0x1ae1ae5f00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferState_GenOrdinal = 0x6069af45b952f39flu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetBufferStateResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetChunkHandle_Ordinal = 0x27fbff0900000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetChunkHandle_GenOrdinal = 0x11b8b37d81869ea4lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerGetChunkHandleResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_FreeBuffer_Ordinal = 0x3f86f0d000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_FreeBuffer_GenOrdinal = 0x6909636959de71c7lu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerFreeBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerFreeBufferResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerFreeBufferResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Start_Ordinal = 0x58e0bb6900000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Start_GenOrdinal = 0x3c92516dbfd4d43blu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStartRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStartResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Stop_Ordinal = 0x1cb723ab00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Stop_GenOrdinal = 0x7e33aef68733c1fclu;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStopRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_cpu_insntrace_ControllerStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_cpu_insntrace_ControllerStopResponseTable;

}  // namespace
template <>
Controller::ResultOf::Initialize_Impl<Controller::InitializeResponse>::Initialize_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, InitializeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializeRequest*>(_write_bytes);
  _request.allocation = std::move(allocation);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializeRequest));
  ::fidl::DecodedMessage<InitializeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Initialize(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::Initialize Controller::SyncClient::Initialize(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation) {
  return ResultOf::Initialize(zx::unowned_channel(this->channel_), std::move(allocation));
}

Controller::ResultOf::Initialize Controller::Call::Initialize(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation) {
  return ResultOf::Initialize(std::move(_client_end), std::move(allocation));
}

template <>
Controller::UnownedResultOf::Initialize_Impl<Controller::InitializeResponse>::Initialize_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < InitializeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<InitializeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, InitializeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializeRequest*>(_request_buffer.data());
  _request.allocation = std::move(allocation);
  _request_buffer.set_actual(sizeof(InitializeRequest));
  ::fidl::DecodedMessage<InitializeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::Initialize(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::Initialize Controller::SyncClient::Initialize(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Initialize(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(allocation), std::move(_response_buffer));
}

Controller::UnownedResultOf::Initialize Controller::Call::Initialize(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation allocation, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Initialize(std::move(_client_end), std::move(_request_buffer), std::move(allocation), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::InitializeResponse> Controller::InPlace::Initialize(zx::unowned_channel _client_end, ::fidl::DecodedMessage<InitializeRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::InitializeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::InitializeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InitializeRequest, InitializeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::InitializeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Terminate_Impl<Controller::TerminateResponse>::Terminate_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TerminateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, TerminateRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(TerminateRequest));
  ::fidl::DecodedMessage<TerminateRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Terminate(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Terminate Controller::SyncClient::Terminate() {
  return ResultOf::Terminate(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Terminate Controller::Call::Terminate(zx::unowned_channel _client_end) {
  return ResultOf::Terminate(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::Terminate_Impl<Controller::TerminateResponse>::Terminate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(TerminateRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, TerminateRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(TerminateRequest));
  ::fidl::DecodedMessage<TerminateRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::Terminate(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::Terminate Controller::SyncClient::Terminate(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Terminate(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::Terminate Controller::Call::Terminate(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Terminate(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::TerminateResponse> Controller::InPlace::Terminate(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(TerminateRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<TerminateRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::TerminateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::TerminateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<TerminateRequest, TerminateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::TerminateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetAllocation_Impl<Controller::GetAllocationResponse>::GetAllocation_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAllocationRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAllocationRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAllocationRequest));
  ::fidl::DecodedMessage<GetAllocationRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetAllocation(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetAllocation Controller::SyncClient::GetAllocation() {
  return ResultOf::GetAllocation(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetAllocation Controller::Call::GetAllocation(zx::unowned_channel _client_end) {
  return ResultOf::GetAllocation(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetAllocation_Impl<Controller::GetAllocationResponse>::GetAllocation_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAllocationRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAllocationRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAllocationRequest));
  ::fidl::DecodedMessage<GetAllocationRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetAllocation(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetAllocation Controller::SyncClient::GetAllocation(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAllocation(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetAllocation Controller::Call::GetAllocation(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAllocation(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetAllocationResponse> Controller::InPlace::GetAllocation(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAllocationRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAllocationRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetAllocationRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetAllocationResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAllocationRequest, GetAllocationResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetAllocationResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::AllocateBuffer_Impl<Controller::AllocateBufferResponse>::AllocateBuffer_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AllocateBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateBufferRequest*>(_write_bytes);
  _request.config = std::move(config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateBufferRequest));
  ::fidl::DecodedMessage<AllocateBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::AllocateBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::AllocateBuffer Controller::SyncClient::AllocateBuffer(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config) {
  return ResultOf::AllocateBuffer(zx::unowned_channel(this->channel_), std::move(config));
}

Controller::ResultOf::AllocateBuffer Controller::Call::AllocateBuffer(zx::unowned_channel _client_end, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config) {
  return ResultOf::AllocateBuffer(std::move(_client_end), std::move(config));
}

template <>
Controller::UnownedResultOf::AllocateBuffer_Impl<Controller::AllocateBufferResponse>::AllocateBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AllocateBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AllocateBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AllocateBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AllocateBufferRequest*>(_request_buffer.data());
  _request.config = std::move(config);
  _request_buffer.set_actual(sizeof(AllocateBufferRequest));
  ::fidl::DecodedMessage<AllocateBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::AllocateBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::AllocateBuffer Controller::SyncClient::AllocateBuffer(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(config), std::move(_response_buffer));
}

Controller::UnownedResultOf::AllocateBuffer Controller::Call::AllocateBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AllocateBuffer(std::move(_client_end), std::move(_request_buffer), std::move(config), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::AllocateBufferResponse> Controller::InPlace::AllocateBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AllocateBufferRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::AllocateBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AllocateBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AllocateBufferRequest, AllocateBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AllocateBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::AssignThreadBuffer_Impl<Controller::AssignThreadBufferResponse>::AssignThreadBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AssignThreadBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, AssignThreadBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AssignThreadBufferRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  _request.thread = std::move(thread);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(AssignThreadBufferRequest));
  ::fidl::DecodedMessage<AssignThreadBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::AssignThreadBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::AssignThreadBuffer Controller::SyncClient::AssignThreadBuffer(uint32_t descriptor, ::zx::thread thread) {
  return ResultOf::AssignThreadBuffer(zx::unowned_channel(this->channel_), std::move(descriptor), std::move(thread));
}

Controller::ResultOf::AssignThreadBuffer Controller::Call::AssignThreadBuffer(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread) {
  return ResultOf::AssignThreadBuffer(std::move(_client_end), std::move(descriptor), std::move(thread));
}

template <>
Controller::UnownedResultOf::AssignThreadBuffer_Impl<Controller::AssignThreadBufferResponse>::AssignThreadBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < AssignThreadBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<AssignThreadBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, AssignThreadBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<AssignThreadBufferRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request.thread = std::move(thread);
  _request_buffer.set_actual(sizeof(AssignThreadBufferRequest));
  ::fidl::DecodedMessage<AssignThreadBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::AssignThreadBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::AssignThreadBuffer Controller::SyncClient::AssignThreadBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AssignThreadBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(thread), std::move(_response_buffer));
}

Controller::UnownedResultOf::AssignThreadBuffer Controller::Call::AssignThreadBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::AssignThreadBuffer(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(thread), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::AssignThreadBufferResponse> Controller::InPlace::AssignThreadBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AssignThreadBufferRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::AssignThreadBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AssignThreadBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<AssignThreadBufferRequest, AssignThreadBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::AssignThreadBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::ReleaseThreadBuffer_Impl<Controller::ReleaseThreadBufferResponse>::ReleaseThreadBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseThreadBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReleaseThreadBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseThreadBufferRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  _request.thread = std::move(thread);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseThreadBufferRequest));
  ::fidl::DecodedMessage<ReleaseThreadBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::ReleaseThreadBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::ReleaseThreadBuffer Controller::SyncClient::ReleaseThreadBuffer(uint32_t descriptor, ::zx::thread thread) {
  return ResultOf::ReleaseThreadBuffer(zx::unowned_channel(this->channel_), std::move(descriptor), std::move(thread));
}

Controller::ResultOf::ReleaseThreadBuffer Controller::Call::ReleaseThreadBuffer(zx::unowned_channel _client_end, uint32_t descriptor, ::zx::thread thread) {
  return ResultOf::ReleaseThreadBuffer(std::move(_client_end), std::move(descriptor), std::move(thread));
}

template <>
Controller::UnownedResultOf::ReleaseThreadBuffer_Impl<Controller::ReleaseThreadBufferResponse>::ReleaseThreadBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReleaseThreadBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReleaseThreadBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReleaseThreadBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReleaseThreadBufferRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request.thread = std::move(thread);
  _request_buffer.set_actual(sizeof(ReleaseThreadBufferRequest));
  ::fidl::DecodedMessage<ReleaseThreadBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::ReleaseThreadBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::ReleaseThreadBuffer Controller::SyncClient::ReleaseThreadBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseThreadBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(thread), std::move(_response_buffer));
}

Controller::UnownedResultOf::ReleaseThreadBuffer Controller::Call::ReleaseThreadBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::zx::thread thread, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReleaseThreadBuffer(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(thread), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::ReleaseThreadBufferResponse> Controller::InPlace::ReleaseThreadBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReleaseThreadBufferRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::ReleaseThreadBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseThreadBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReleaseThreadBufferRequest, ReleaseThreadBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::ReleaseThreadBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetBufferConfig_Impl<Controller::GetBufferConfigResponse>::GetBufferConfig_Impl(zx::unowned_channel _client_end, uint32_t descriptor) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetBufferConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferConfigRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetBufferConfigRequest));
  ::fidl::DecodedMessage<GetBufferConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetBufferConfig(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::GetBufferConfig Controller::SyncClient::GetBufferConfig(uint32_t descriptor) {
  return ResultOf::GetBufferConfig(zx::unowned_channel(this->channel_), std::move(descriptor));
}

Controller::ResultOf::GetBufferConfig Controller::Call::GetBufferConfig(zx::unowned_channel _client_end, uint32_t descriptor) {
  return ResultOf::GetBufferConfig(std::move(_client_end), std::move(descriptor));
}

template <>
Controller::UnownedResultOf::GetBufferConfig_Impl<Controller::GetBufferConfigResponse>::GetBufferConfig_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetBufferConfigRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetBufferConfigResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetBufferConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferConfigRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request_buffer.set_actual(sizeof(GetBufferConfigRequest));
  ::fidl::DecodedMessage<GetBufferConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetBufferConfig(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetBufferConfig Controller::SyncClient::GetBufferConfig(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferConfig(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetBufferConfig Controller::Call::GetBufferConfig(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferConfig(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetBufferConfigResponse> Controller::InPlace::GetBufferConfig(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferConfigRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::GetBufferConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferConfigResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetBufferConfigRequest, GetBufferConfigResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferConfigResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetBufferState_Impl<Controller::GetBufferStateResponse>::GetBufferState_Impl(zx::unowned_channel _client_end, uint32_t descriptor) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferStateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetBufferStateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferStateRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetBufferStateRequest));
  ::fidl::DecodedMessage<GetBufferStateRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetBufferState(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::GetBufferState Controller::SyncClient::GetBufferState(uint32_t descriptor) {
  return ResultOf::GetBufferState(zx::unowned_channel(this->channel_), std::move(descriptor));
}

Controller::ResultOf::GetBufferState Controller::Call::GetBufferState(zx::unowned_channel _client_end, uint32_t descriptor) {
  return ResultOf::GetBufferState(std::move(_client_end), std::move(descriptor));
}

template <>
Controller::UnownedResultOf::GetBufferState_Impl<Controller::GetBufferStateResponse>::GetBufferState_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetBufferStateRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetBufferStateResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetBufferStateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferStateRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request_buffer.set_actual(sizeof(GetBufferStateRequest));
  ::fidl::DecodedMessage<GetBufferStateRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetBufferState(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetBufferState Controller::SyncClient::GetBufferState(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferState(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetBufferState Controller::Call::GetBufferState(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferState(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetBufferStateResponse> Controller::InPlace::GetBufferState(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferStateRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::GetBufferStateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferStateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetBufferStateRequest, GetBufferStateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferStateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetChunkHandle_Impl<Controller::GetChunkHandleResponse>::GetChunkHandle_Impl(zx::unowned_channel _client_end, uint32_t descriptor, uint32_t chunk_num) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetChunkHandleRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetChunkHandleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetChunkHandleRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  _request.chunk_num = std::move(chunk_num);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetChunkHandleRequest));
  ::fidl::DecodedMessage<GetChunkHandleRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetChunkHandle(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::GetChunkHandle Controller::SyncClient::GetChunkHandle(uint32_t descriptor, uint32_t chunk_num) {
  return ResultOf::GetChunkHandle(zx::unowned_channel(this->channel_), std::move(descriptor), std::move(chunk_num));
}

Controller::ResultOf::GetChunkHandle Controller::Call::GetChunkHandle(zx::unowned_channel _client_end, uint32_t descriptor, uint32_t chunk_num) {
  return ResultOf::GetChunkHandle(std::move(_client_end), std::move(descriptor), std::move(chunk_num));
}

template <>
Controller::UnownedResultOf::GetChunkHandle_Impl<Controller::GetChunkHandleResponse>::GetChunkHandle_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetChunkHandleRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetChunkHandleResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetChunkHandleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetChunkHandleRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request.chunk_num = std::move(chunk_num);
  _request_buffer.set_actual(sizeof(GetChunkHandleRequest));
  ::fidl::DecodedMessage<GetChunkHandleRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetChunkHandle(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetChunkHandle Controller::SyncClient::GetChunkHandle(::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetChunkHandle(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(chunk_num), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetChunkHandle Controller::Call::GetChunkHandle(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, uint32_t chunk_num, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetChunkHandle(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(chunk_num), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetChunkHandleResponse> Controller::InPlace::GetChunkHandle(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetChunkHandleRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::GetChunkHandleRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetChunkHandleResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetChunkHandleRequest, GetChunkHandleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetChunkHandleResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::FreeBuffer_Impl<Controller::FreeBufferResponse>::FreeBuffer_Impl(zx::unowned_channel _client_end, uint32_t descriptor) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<FreeBufferRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, FreeBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<FreeBufferRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(FreeBufferRequest));
  ::fidl::DecodedMessage<FreeBufferRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::FreeBuffer(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::FreeBuffer Controller::SyncClient::FreeBuffer(uint32_t descriptor) {
  return ResultOf::FreeBuffer(zx::unowned_channel(this->channel_), std::move(descriptor));
}

Controller::ResultOf::FreeBuffer Controller::Call::FreeBuffer(zx::unowned_channel _client_end, uint32_t descriptor) {
  return ResultOf::FreeBuffer(std::move(_client_end), std::move(descriptor));
}

template <>
Controller::UnownedResultOf::FreeBuffer_Impl<Controller::FreeBufferResponse>::FreeBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < FreeBufferRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<FreeBufferResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, FreeBufferRequest::PrimarySize);
  auto& _request = *reinterpret_cast<FreeBufferRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request_buffer.set_actual(sizeof(FreeBufferRequest));
  ::fidl::DecodedMessage<FreeBufferRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::FreeBuffer(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::FreeBuffer Controller::SyncClient::FreeBuffer(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::FreeBuffer(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

Controller::UnownedResultOf::FreeBuffer Controller::Call::FreeBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::FreeBuffer(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::FreeBufferResponse> Controller::InPlace::FreeBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<FreeBufferRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::FreeBufferRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::FreeBufferResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<FreeBufferRequest, FreeBufferResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::FreeBufferResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Start_Impl<Controller::StartResponse>::Start_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StartRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartRequest));
  ::fidl::DecodedMessage<StartRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Start(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Start Controller::SyncClient::Start() {
  return ResultOf::Start(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Start Controller::Call::Start(zx::unowned_channel _client_end) {
  return ResultOf::Start(std::move(_client_end));
}

::fidl::DecodeResult<Controller::StartResponse> Controller::InPlace::Start(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StartRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StartRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::StartRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartRequest, StartResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Stop_Impl<Controller::StopResponse>::Stop_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StopRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopRequest));
  ::fidl::DecodedMessage<StopRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Stop(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Stop Controller::SyncClient::Stop() {
  return ResultOf::Stop(zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Stop Controller::Call::Stop(zx::unowned_channel _client_end) {
  return ResultOf::Stop(std::move(_client_end));
}

::fidl::DecodeResult<Controller::StopResponse> Controller::InPlace::Stop(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StopRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StopRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::StopRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StopResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StopRequest, StopResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StopResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kController_Initialize_Ordinal:
    case kController_Initialize_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InitializeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Initialize(std::move(message->allocation),
          Interface::InitializeCompleter::Sync(txn));
      return true;
    }
    case kController_Terminate_Ordinal:
    case kController_Terminate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<TerminateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Terminate(
          Interface::TerminateCompleter::Sync(txn));
      return true;
    }
    case kController_GetAllocation_Ordinal:
    case kController_GetAllocation_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAllocationRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAllocation(
          Interface::GetAllocationCompleter::Sync(txn));
      return true;
    }
    case kController_AllocateBuffer_Ordinal:
    case kController_AllocateBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AllocateBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AllocateBuffer(std::move(message->config),
          Interface::AllocateBufferCompleter::Sync(txn));
      return true;
    }
    case kController_AssignThreadBuffer_Ordinal:
    case kController_AssignThreadBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<AssignThreadBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->AssignThreadBuffer(std::move(message->descriptor), std::move(message->thread),
          Interface::AssignThreadBufferCompleter::Sync(txn));
      return true;
    }
    case kController_ReleaseThreadBuffer_Ordinal:
    case kController_ReleaseThreadBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReleaseThreadBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReleaseThreadBuffer(std::move(message->descriptor), std::move(message->thread),
          Interface::ReleaseThreadBufferCompleter::Sync(txn));
      return true;
    }
    case kController_GetBufferConfig_Ordinal:
    case kController_GetBufferConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetBufferConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetBufferConfig(std::move(message->descriptor),
          Interface::GetBufferConfigCompleter::Sync(txn));
      return true;
    }
    case kController_GetBufferState_Ordinal:
    case kController_GetBufferState_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetBufferStateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetBufferState(std::move(message->descriptor),
          Interface::GetBufferStateCompleter::Sync(txn));
      return true;
    }
    case kController_GetChunkHandle_Ordinal:
    case kController_GetChunkHandle_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetChunkHandleRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetChunkHandle(std::move(message->descriptor), std::move(message->chunk_num),
          Interface::GetChunkHandleCompleter::Sync(txn));
      return true;
    }
    case kController_FreeBuffer_Ordinal:
    case kController_FreeBuffer_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<FreeBufferRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->FreeBuffer(std::move(message->descriptor),
          Interface::FreeBufferCompleter::Sync(txn));
      return true;
    }
    case kController_Start_Ordinal:
    case kController_Start_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Start(
          Interface::StartCompleter::Sync(txn));
      return true;
    }
    case kController_Stop_Ordinal:
    case kController_Stop_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StopRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Stop(
          Interface::StopCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Controller::Interface::InitializeCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<InitializeResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::InitializeResponse(
      ::fidl::DecodedMessage<InitializeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeResponse::PrimarySize,
              InitializeResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializeResponse>(std::move(_response_bytes)));
}
void Controller::Interface::InitializeCompleterBase::ReplySuccess() {
  Controller_Initialize_Response response;

  Reply(Controller_Initialize_Result::WithResponse(&response));
}
void Controller::Interface::InitializeCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_Initialize_Result::WithErr(&error));
}

void Controller::Interface::InitializeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Initialize_Result result) {
  if (_buffer.capacity() < InitializeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<InitializeResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::InitializeResponse(
      ::fidl::DecodedMessage<InitializeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeResponse::PrimarySize,
              InitializeResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(InitializeResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InitializeResponse>(std::move(_buffer)));
}
void Controller::Interface::InitializeCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_Initialize_Response response;

  Reply(std::move(_buffer), Controller_Initialize_Result::WithResponse(&response));
}

void Controller::Interface::InitializeCompleterBase::Reply(::fidl::DecodedMessage<InitializeResponse> params) {
  Controller::SetTransactionHeaderFor::InitializeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::TerminateCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TerminateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<TerminateResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::TerminateResponse(
      ::fidl::DecodedMessage<TerminateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              TerminateResponse::PrimarySize,
              TerminateResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(TerminateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TerminateResponse>(std::move(_response_bytes)));
}
void Controller::Interface::TerminateCompleterBase::ReplySuccess() {
  Controller_Terminate_Response response;

  Reply(Controller_Terminate_Result::WithResponse(&response));
}
void Controller::Interface::TerminateCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_Terminate_Result::WithErr(&error));
}

void Controller::Interface::TerminateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_Terminate_Result result) {
  if (_buffer.capacity() < TerminateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<TerminateResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::TerminateResponse(
      ::fidl::DecodedMessage<TerminateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              TerminateResponse::PrimarySize,
              TerminateResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(TerminateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TerminateResponse>(std::move(_buffer)));
}
void Controller::Interface::TerminateCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_Terminate_Response response;

  Reply(std::move(_buffer), Controller_Terminate_Result::WithResponse(&response));
}

void Controller::Interface::TerminateCompleterBase::Reply(::fidl::DecodedMessage<TerminateResponse> params) {
  Controller::SetTransactionHeaderFor::TerminateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetAllocationCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Allocation* allocation) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAllocationResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetAllocationResponse _response = {};
  Controller::SetTransactionHeaderFor::GetAllocationResponse(
      ::fidl::DecodedMessage<GetAllocationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAllocationResponse::PrimarySize,
              GetAllocationResponse::PrimarySize)));
  _response.allocation = std::move(allocation);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetAllocationCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Allocation* allocation) {
  if (_buffer.capacity() < GetAllocationResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAllocationResponse _response = {};
  Controller::SetTransactionHeaderFor::GetAllocationResponse(
      ::fidl::DecodedMessage<GetAllocationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAllocationResponse::PrimarySize,
              GetAllocationResponse::PrimarySize)));
  _response.allocation = std::move(allocation);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetAllocationCompleterBase::Reply(::fidl::DecodedMessage<GetAllocationResponse> params) {
  Controller::SetTransactionHeaderFor::GetAllocationResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::AllocateBufferCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AllocateBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AllocateBufferResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::AllocateBufferResponse(
      ::fidl::DecodedMessage<AllocateBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AllocateBufferResponse::PrimarySize,
              AllocateBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AllocateBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateBufferResponse>(std::move(_response_bytes)));
}
void Controller::Interface::AllocateBufferCompleterBase::ReplySuccess(uint32_t descriptor) {
  Controller_AllocateBuffer_Response response;
  response.descriptor = std::move(descriptor);

  Reply(Controller_AllocateBuffer_Result::WithResponse(&response));
}
void Controller::Interface::AllocateBufferCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_AllocateBuffer_Result::WithErr(&error));
}

void Controller::Interface::AllocateBufferCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AllocateBuffer_Result result) {
  if (_buffer.capacity() < AllocateBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AllocateBufferResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::AllocateBufferResponse(
      ::fidl::DecodedMessage<AllocateBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AllocateBufferResponse::PrimarySize,
              AllocateBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(AllocateBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AllocateBufferResponse>(std::move(_buffer)));
}
void Controller::Interface::AllocateBufferCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint32_t descriptor) {
  Controller_AllocateBuffer_Response response;
  response.descriptor = std::move(descriptor);

  Reply(std::move(_buffer), Controller_AllocateBuffer_Result::WithResponse(&response));
}

void Controller::Interface::AllocateBufferCompleterBase::Reply(::fidl::DecodedMessage<AllocateBufferResponse> params) {
  Controller::SetTransactionHeaderFor::AllocateBufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::AssignThreadBufferCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<AssignThreadBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<AssignThreadBufferResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::AssignThreadBufferResponse(
      ::fidl::DecodedMessage<AssignThreadBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AssignThreadBufferResponse::PrimarySize,
              AssignThreadBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(AssignThreadBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AssignThreadBufferResponse>(std::move(_response_bytes)));
}
void Controller::Interface::AssignThreadBufferCompleterBase::ReplySuccess() {
  Controller_AssignThreadBuffer_Response response;

  Reply(Controller_AssignThreadBuffer_Result::WithResponse(&response));
}
void Controller::Interface::AssignThreadBufferCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_AssignThreadBuffer_Result::WithErr(&error));
}

void Controller::Interface::AssignThreadBufferCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_AssignThreadBuffer_Result result) {
  if (_buffer.capacity() < AssignThreadBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<AssignThreadBufferResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::AssignThreadBufferResponse(
      ::fidl::DecodedMessage<AssignThreadBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              AssignThreadBufferResponse::PrimarySize,
              AssignThreadBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(AssignThreadBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<AssignThreadBufferResponse>(std::move(_buffer)));
}
void Controller::Interface::AssignThreadBufferCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_AssignThreadBuffer_Response response;

  Reply(std::move(_buffer), Controller_AssignThreadBuffer_Result::WithResponse(&response));
}

void Controller::Interface::AssignThreadBufferCompleterBase::Reply(::fidl::DecodedMessage<AssignThreadBufferResponse> params) {
  Controller::SetTransactionHeaderFor::AssignThreadBufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::ReleaseThreadBufferCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReleaseThreadBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ReleaseThreadBufferResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::ReleaseThreadBufferResponse(
      ::fidl::DecodedMessage<ReleaseThreadBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReleaseThreadBufferResponse::PrimarySize,
              ReleaseThreadBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReleaseThreadBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseThreadBufferResponse>(std::move(_response_bytes)));
}
void Controller::Interface::ReleaseThreadBufferCompleterBase::ReplySuccess() {
  Controller_ReleaseThreadBuffer_Response response;

  Reply(Controller_ReleaseThreadBuffer_Result::WithResponse(&response));
}
void Controller::Interface::ReleaseThreadBufferCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_ReleaseThreadBuffer_Result::WithErr(&error));
}

void Controller::Interface::ReleaseThreadBufferCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::Controller_ReleaseThreadBuffer_Result result) {
  if (_buffer.capacity() < ReleaseThreadBufferResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ReleaseThreadBufferResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::ReleaseThreadBufferResponse(
      ::fidl::DecodedMessage<ReleaseThreadBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReleaseThreadBufferResponse::PrimarySize,
              ReleaseThreadBufferResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ReleaseThreadBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ReleaseThreadBufferResponse>(std::move(_buffer)));
}
void Controller::Interface::ReleaseThreadBufferCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_ReleaseThreadBuffer_Response response;

  Reply(std::move(_buffer), Controller_ReleaseThreadBuffer_Result::WithResponse(&response));
}

void Controller::Interface::ReleaseThreadBufferCompleterBase::Reply(::fidl::DecodedMessage<ReleaseThreadBufferResponse> params) {
  Controller::SetTransactionHeaderFor::ReleaseThreadBufferResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetBufferConfigCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig* config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferConfigResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetBufferConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::GetBufferConfigResponse(
      ::fidl::DecodedMessage<GetBufferConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferConfigResponse::PrimarySize,
              GetBufferConfigResponse::PrimarySize)));
  _response.config = std::move(config);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetBufferConfigCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferConfig* config) {
  if (_buffer.capacity() < GetBufferConfigResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetBufferConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::GetBufferConfigResponse(
      ::fidl::DecodedMessage<GetBufferConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferConfigResponse::PrimarySize,
              GetBufferConfigResponse::PrimarySize)));
  _response.config = std::move(config);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetBufferConfigCompleterBase::Reply(::fidl::DecodedMessage<GetBufferConfigResponse> params) {
  Controller::SetTransactionHeaderFor::GetBufferConfigResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetBufferStateCompleterBase::Reply(::llcpp::fuchsia::hardware::cpu::insntrace::BufferState* state) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferStateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetBufferStateResponse _response = {};
  Controller::SetTransactionHeaderFor::GetBufferStateResponse(
      ::fidl::DecodedMessage<GetBufferStateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferStateResponse::PrimarySize,
              GetBufferStateResponse::PrimarySize)));
  _response.state = std::move(state);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetBufferStateCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::hardware::cpu::insntrace::BufferState* state) {
  if (_buffer.capacity() < GetBufferStateResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetBufferStateResponse _response = {};
  Controller::SetTransactionHeaderFor::GetBufferStateResponse(
      ::fidl::DecodedMessage<GetBufferStateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferStateResponse::PrimarySize,
              GetBufferStateResponse::PrimarySize)));
  _response.state = std::move(state);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetBufferStateCompleterBase::Reply(::fidl::DecodedMessage<GetBufferStateResponse> params) {
  Controller::SetTransactionHeaderFor::GetBufferStateResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetChunkHandleCompleterBase::Reply(::zx::vmo buffer) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetChunkHandleResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetChunkHandleResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetChunkHandleResponse(
      ::fidl::DecodedMessage<GetChunkHandleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetChunkHandleResponse::PrimarySize,
              GetChunkHandleResponse::PrimarySize)));
  _response.buffer = std::move(buffer);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetChunkHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetChunkHandleResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetChunkHandleCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::vmo buffer) {
  if (_buffer.capacity() < GetChunkHandleResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetChunkHandleResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetChunkHandleResponse(
      ::fidl::DecodedMessage<GetChunkHandleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetChunkHandleResponse::PrimarySize,
              GetChunkHandleResponse::PrimarySize)));
  _response.buffer = std::move(buffer);
  _buffer.set_actual(sizeof(GetChunkHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetChunkHandleResponse>(std::move(_buffer)));
}

void Controller::Interface::GetChunkHandleCompleterBase::Reply(::fidl::DecodedMessage<GetChunkHandleResponse> params) {
  Controller::SetTransactionHeaderFor::GetChunkHandleResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::FreeBufferCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<FreeBufferResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<FreeBufferResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::FreeBufferResponse(
      ::fidl::DecodedMessage<FreeBufferResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              FreeBufferResponse::PrimarySize,
              FreeBufferResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(FreeBufferResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<FreeBufferResponse>(std::move(_response_bytes)));
}


void Controller::Interface::StartCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StartResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::StartResponse(
      ::fidl::DecodedMessage<StartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartResponse::PrimarySize,
              StartResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StartResponse>(std::move(_response_bytes)));
}


void Controller::Interface::StopCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StopResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::StopResponse(
      ::fidl::DecodedMessage<StopResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StopResponse::PrimarySize,
              StopResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StopResponse>(std::move(_response_bytes)));
}



void Controller::SetTransactionHeaderFor::InitializeRequest(const ::fidl::DecodedMessage<Controller::InitializeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Initialize_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::InitializeResponse(const ::fidl::DecodedMessage<Controller::InitializeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Initialize_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::TerminateRequest(const ::fidl::DecodedMessage<Controller::TerminateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Terminate_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::TerminateResponse(const ::fidl::DecodedMessage<Controller::TerminateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Terminate_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::GetAllocationRequest(const ::fidl::DecodedMessage<Controller::GetAllocationRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetAllocation_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::GetAllocationResponse(const ::fidl::DecodedMessage<Controller::GetAllocationResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetAllocation_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::AllocateBufferRequest(const ::fidl::DecodedMessage<Controller::AllocateBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_AllocateBuffer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::AllocateBufferResponse(const ::fidl::DecodedMessage<Controller::AllocateBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_AllocateBuffer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::AssignThreadBufferRequest(const ::fidl::DecodedMessage<Controller::AssignThreadBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_AssignThreadBuffer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::AssignThreadBufferResponse(const ::fidl::DecodedMessage<Controller::AssignThreadBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_AssignThreadBuffer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::ReleaseThreadBufferRequest(const ::fidl::DecodedMessage<Controller::ReleaseThreadBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseThreadBuffer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::ReleaseThreadBufferResponse(const ::fidl::DecodedMessage<Controller::ReleaseThreadBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_ReleaseThreadBuffer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::GetBufferConfigRequest(const ::fidl::DecodedMessage<Controller::GetBufferConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferConfig_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::GetBufferConfigResponse(const ::fidl::DecodedMessage<Controller::GetBufferConfigResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferConfig_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::GetBufferStateRequest(const ::fidl::DecodedMessage<Controller::GetBufferStateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferState_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::GetBufferStateResponse(const ::fidl::DecodedMessage<Controller::GetBufferStateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferState_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::GetChunkHandleRequest(const ::fidl::DecodedMessage<Controller::GetChunkHandleRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetChunkHandle_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::GetChunkHandleResponse(const ::fidl::DecodedMessage<Controller::GetChunkHandleResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetChunkHandle_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::FreeBufferRequest(const ::fidl::DecodedMessage<Controller::FreeBufferRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_FreeBuffer_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::FreeBufferResponse(const ::fidl::DecodedMessage<Controller::FreeBufferResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_FreeBuffer_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::StartRequest(const ::fidl::DecodedMessage<Controller::StartRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Start_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::StartResponse(const ::fidl::DecodedMessage<Controller::StartResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Start_GenOrdinal);
}

void Controller::SetTransactionHeaderFor::StopRequest(const ::fidl::DecodedMessage<Controller::StopRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Stop_GenOrdinal);
}
void Controller::SetTransactionHeaderFor::StopResponse(const ::fidl::DecodedMessage<Controller::StopResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Stop_GenOrdinal);
}

}  // namespace insntrace
}  // namespace cpu
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

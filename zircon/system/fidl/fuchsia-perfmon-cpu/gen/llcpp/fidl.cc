// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/perfmon/cpu/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace perfmon {
namespace cpu {

void ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Controller_Start_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Controller_Start_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Controller_Start_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Controller_StageConfig_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Controller_StageConfig_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Controller_StageConfig_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Controller_Initialize_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Controller_Initialize_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Controller_Initialize_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kController_GetProperties_Ordinal = 0x4a9f6d2100000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetProperties_GenOrdinal = 0x81aa89f0ac87173lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetPropertiesRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Initialize_Ordinal = 0x6fe7b83800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Initialize_GenOrdinal = 0x4a03bc2d8348c317lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerInitializeRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Terminate_Ordinal = 0x57b56a800000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Terminate_GenOrdinal = 0xa591f0cfbb1a6f9lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerTerminateRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerTerminateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerTerminateResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetAllocation_Ordinal = 0x6c4a81f00000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetAllocation_GenOrdinal = 0x3b4bffd18849f074lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_StageConfig_Ordinal = 0x5889caf900000000lu;
[[maybe_unused]]
constexpr uint64_t kController_StageConfig_GenOrdinal = 0x340032f97698973alu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStageConfigRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetConfig_Ordinal = 0x1ec2af4000000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetConfig_GenOrdinal = 0x5da0a02d12fbfdd3lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetConfigRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferHandle_Ordinal = 0x7fb9183100000000lu;
[[maybe_unused]]
constexpr uint64_t kController_GetBufferHandle_GenOrdinal = 0x1a49fd7f34915efflu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetBufferHandleRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Start_Ordinal = 0x4efe358200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Start_GenOrdinal = 0x3c166469384c06f8lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStartRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStartResponseTable;
[[maybe_unused]]
constexpr uint64_t kController_Stop_Ordinal = 0x21f2d4200000000lu;
[[maybe_unused]]
constexpr uint64_t kController_Stop_GenOrdinal = 0x36a98bbc8ee7e3d2lu;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStopRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStopResponseTable;

}  // namespace
template <>
Controller::ResultOf::GetProperties_Impl<Controller::GetPropertiesResponse>::GetProperties_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPropertiesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetPropertiesRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetPropertiesRequest));
  ::fidl::DecodedMessage<GetPropertiesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetProperties(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetProperties Controller::SyncClient::GetProperties() {
    return ResultOf::GetProperties(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetProperties Controller::Call::GetProperties(::zx::unowned_channel _client_end) {
  return ResultOf::GetProperties(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetProperties_Impl<Controller::GetPropertiesResponse>::GetProperties_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetPropertiesRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetPropertiesRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetPropertiesRequest));
  ::fidl::DecodedMessage<GetPropertiesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetProperties(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetProperties Controller::SyncClient::GetProperties(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProperties(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetProperties Controller::Call::GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetProperties(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetPropertiesResponse> Controller::InPlace::GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetPropertiesRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetPropertiesRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetPropertiesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetPropertiesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetPropertiesRequest, GetPropertiesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetPropertiesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Initialize_Impl<Controller::InitializeResponse>::Initialize_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, InitializeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializeRequest*>(_write_bytes);
  _request.allocation = std::move(allocation);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(InitializeRequest));
  ::fidl::DecodedMessage<InitializeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Initialize(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::Initialize Controller::SyncClient::Initialize(::llcpp::fuchsia::perfmon::cpu::Allocation allocation) {
    return ResultOf::Initialize(::zx::unowned_channel(this->channel_), std::move(allocation));
}

Controller::ResultOf::Initialize Controller::Call::Initialize(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation) {
  return ResultOf::Initialize(std::move(_client_end), std::move(allocation));
}

template <>
Controller::UnownedResultOf::Initialize_Impl<Controller::InitializeResponse>::Initialize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < InitializeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<InitializeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, InitializeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InitializeRequest*>(_request_buffer.data());
  _request.allocation = std::move(allocation);
  _request_buffer.set_actual(sizeof(InitializeRequest));
  ::fidl::DecodedMessage<InitializeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::Initialize(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::Initialize Controller::SyncClient::Initialize(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Initialize(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(allocation), std::move(_response_buffer));
}

Controller::UnownedResultOf::Initialize Controller::Call::Initialize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Initialize(std::move(_client_end), std::move(_request_buffer), std::move(allocation), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::InitializeResponse> Controller::InPlace::Initialize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<InitializeRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::InitializeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::InitializeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InitializeRequest, InitializeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::InitializeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Terminate_Impl<Controller::TerminateResponse>::Terminate_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TerminateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, TerminateRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(TerminateRequest));
  ::fidl::DecodedMessage<TerminateRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Terminate(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Terminate Controller::SyncClient::Terminate() {
    return ResultOf::Terminate(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Terminate Controller::Call::Terminate(::zx::unowned_channel _client_end) {
  return ResultOf::Terminate(std::move(_client_end));
}

::fidl::DecodeResult<Controller::TerminateResponse> Controller::InPlace::Terminate(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(TerminateRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<TerminateRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::TerminateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::TerminateResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<TerminateRequest, TerminateResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::TerminateResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetAllocation_Impl<Controller::GetAllocationResponse>::GetAllocation_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAllocationRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAllocationRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAllocationRequest));
  ::fidl::DecodedMessage<GetAllocationRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetAllocation(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetAllocation Controller::SyncClient::GetAllocation() {
    return ResultOf::GetAllocation(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetAllocation Controller::Call::GetAllocation(::zx::unowned_channel _client_end) {
  return ResultOf::GetAllocation(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetAllocation_Impl<Controller::GetAllocationResponse>::GetAllocation_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAllocationRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAllocationRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAllocationRequest));
  ::fidl::DecodedMessage<GetAllocationRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetAllocation(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetAllocation Controller::SyncClient::GetAllocation(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAllocation(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetAllocation Controller::Call::GetAllocation(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAllocation(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetAllocationResponse> Controller::InPlace::GetAllocation(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAllocationRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAllocationRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetAllocationRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetAllocationResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAllocationRequest, GetAllocationResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetAllocationResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::StageConfig_Impl<Controller::StageConfigResponse>::StageConfig_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Config config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StageConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StageConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StageConfigRequest*>(_write_bytes);
  _request.config = std::move(config);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StageConfigRequest));
  ::fidl::DecodedMessage<StageConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::StageConfig(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::StageConfig Controller::SyncClient::StageConfig(::llcpp::fuchsia::perfmon::cpu::Config config) {
    return ResultOf::StageConfig(::zx::unowned_channel(this->channel_), std::move(config));
}

Controller::ResultOf::StageConfig Controller::Call::StageConfig(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Config config) {
  return ResultOf::StageConfig(std::move(_client_end), std::move(config));
}

template <>
Controller::UnownedResultOf::StageConfig_Impl<Controller::StageConfigResponse>::StageConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < StageConfigRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<StageConfigResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, StageConfigRequest::PrimarySize);
  auto& _request = *reinterpret_cast<StageConfigRequest*>(_request_buffer.data());
  _request.config = std::move(config);
  _request_buffer.set_actual(sizeof(StageConfigRequest));
  ::fidl::DecodedMessage<StageConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::StageConfig(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::StageConfig Controller::SyncClient::StageConfig(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StageConfig(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(config), std::move(_response_buffer));
}

Controller::UnownedResultOf::StageConfig Controller::Call::StageConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::StageConfig(std::move(_client_end), std::move(_request_buffer), std::move(config), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::StageConfigResponse> Controller::InPlace::StageConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StageConfigRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::StageConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StageConfigResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StageConfigRequest, StageConfigResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StageConfigResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetConfig_Impl<Controller::GetConfigResponse>::GetConfig_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetConfigRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetConfigRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetConfigRequest));
  ::fidl::DecodedMessage<GetConfigRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetConfig(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::GetConfig Controller::SyncClient::GetConfig() {
    return ResultOf::GetConfig(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::GetConfig Controller::Call::GetConfig(::zx::unowned_channel _client_end) {
  return ResultOf::GetConfig(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::GetConfig_Impl<Controller::GetConfigResponse>::GetConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetConfigRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetConfigRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetConfigRequest));
  ::fidl::DecodedMessage<GetConfigRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetConfig(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetConfig Controller::SyncClient::GetConfig(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetConfig(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetConfig Controller::Call::GetConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetConfig(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetConfigResponse> Controller::InPlace::GetConfig(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetConfigRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetConfigRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::GetConfigRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetConfigResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetConfigRequest, GetConfigResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetConfigResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::GetBufferHandle_Impl<Controller::GetBufferHandleResponse>::GetBufferHandle_Impl(::zx::unowned_channel _client_end, uint32_t descriptor) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferHandleRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetBufferHandleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferHandleRequest*>(_write_bytes);
  _request.descriptor = std::move(descriptor);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetBufferHandleRequest));
  ::fidl::DecodedMessage<GetBufferHandleRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::GetBufferHandle(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Controller::ResultOf::GetBufferHandle Controller::SyncClient::GetBufferHandle(uint32_t descriptor) {
    return ResultOf::GetBufferHandle(::zx::unowned_channel(this->channel_), std::move(descriptor));
}

Controller::ResultOf::GetBufferHandle Controller::Call::GetBufferHandle(::zx::unowned_channel _client_end, uint32_t descriptor) {
  return ResultOf::GetBufferHandle(std::move(_client_end), std::move(descriptor));
}

template <>
Controller::UnownedResultOf::GetBufferHandle_Impl<Controller::GetBufferHandleResponse>::GetBufferHandle_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetBufferHandleRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetBufferHandleResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetBufferHandleRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetBufferHandleRequest*>(_request_buffer.data());
  _request.descriptor = std::move(descriptor);
  _request_buffer.set_actual(sizeof(GetBufferHandleRequest));
  ::fidl::DecodedMessage<GetBufferHandleRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::GetBufferHandle(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Controller::UnownedResultOf::GetBufferHandle Controller::SyncClient::GetBufferHandle(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferHandle(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

Controller::UnownedResultOf::GetBufferHandle Controller::Call::GetBufferHandle(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetBufferHandle(std::move(_client_end), std::move(_request_buffer), std::move(descriptor), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::GetBufferHandleResponse> Controller::InPlace::GetBufferHandle(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferHandleRequest> params, ::fidl::BytePart response_buffer) {
  Controller::SetTransactionHeaderFor::GetBufferHandleRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferHandleResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetBufferHandleRequest, GetBufferHandleResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::GetBufferHandleResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Start_Impl<Controller::StartResponse>::Start_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StartRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StartRequest));
  ::fidl::DecodedMessage<StartRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Start(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Start Controller::SyncClient::Start() {
    return ResultOf::Start(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Start Controller::Call::Start(::zx::unowned_channel _client_end) {
  return ResultOf::Start(std::move(_client_end));
}

template <>
Controller::UnownedResultOf::Start_Impl<Controller::StartResponse>::Start_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(StartRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, StartRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(StartRequest));
  ::fidl::DecodedMessage<StartRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Controller::InPlace::Start(std::move(_client_end), std::move(_response_buffer)));
}

Controller::UnownedResultOf::Start Controller::SyncClient::Start(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Start(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Controller::UnownedResultOf::Start Controller::Call::Start(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Start(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Controller::StartResponse> Controller::InPlace::Start(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StartRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StartRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::StartRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StartRequest, StartResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StartResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Controller::ResultOf::Stop_Impl<Controller::StopResponse>::Stop_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, StopRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopRequest));
  ::fidl::DecodedMessage<StopRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Controller::InPlace::Stop(std::move(_client_end), Super::response_buffer()));
}

Controller::ResultOf::Stop Controller::SyncClient::Stop() {
    return ResultOf::Stop(::zx::unowned_channel(this->channel_));
}

Controller::ResultOf::Stop Controller::Call::Stop(::zx::unowned_channel _client_end) {
  return ResultOf::Stop(std::move(_client_end));
}

::fidl::DecodeResult<Controller::StopResponse> Controller::InPlace::Stop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(StopRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<StopRequest> params(std::move(_request_buffer));
  Controller::SetTransactionHeaderFor::StopRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StopResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<StopRequest, StopResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Controller::StopResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Controller::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kController_GetProperties_Ordinal:
    case kController_GetProperties_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetPropertiesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetProperties(
          Interface::GetPropertiesCompleter::Sync(txn));
      return true;
    }
    case kController_Initialize_Ordinal:
    case kController_Initialize_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InitializeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Initialize(std::move(message->allocation),
          Interface::InitializeCompleter::Sync(txn));
      return true;
    }
    case kController_Terminate_Ordinal:
    case kController_Terminate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<TerminateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Terminate(
          Interface::TerminateCompleter::Sync(txn));
      return true;
    }
    case kController_GetAllocation_Ordinal:
    case kController_GetAllocation_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAllocationRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAllocation(
          Interface::GetAllocationCompleter::Sync(txn));
      return true;
    }
    case kController_StageConfig_Ordinal:
    case kController_StageConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StageConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->StageConfig(std::move(message->config),
          Interface::StageConfigCompleter::Sync(txn));
      return true;
    }
    case kController_GetConfig_Ordinal:
    case kController_GetConfig_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetConfigRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetConfig(
          Interface::GetConfigCompleter::Sync(txn));
      return true;
    }
    case kController_GetBufferHandle_Ordinal:
    case kController_GetBufferHandle_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetBufferHandleRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetBufferHandle(std::move(message->descriptor),
          Interface::GetBufferHandleCompleter::Sync(txn));
      return true;
    }
    case kController_Start_Ordinal:
    case kController_Start_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StartRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Start(
          Interface::StartCompleter::Sync(txn));
      return true;
    }
    case kController_Stop_Ordinal:
    case kController_Stop_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<StopRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Stop(
          Interface::StopCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Controller::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Controller::Interface::GetPropertiesCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Properties properties) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetPropertiesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetPropertiesResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetPropertiesResponse(
      ::fidl::DecodedMessage<GetPropertiesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetPropertiesResponse::PrimarySize,
              GetPropertiesResponse::PrimarySize)));
  _response.properties = std::move(properties);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetPropertiesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetPropertiesResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetPropertiesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Properties properties) {
  if (_buffer.capacity() < GetPropertiesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetPropertiesResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetPropertiesResponse(
      ::fidl::DecodedMessage<GetPropertiesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetPropertiesResponse::PrimarySize,
              GetPropertiesResponse::PrimarySize)));
  _response.properties = std::move(properties);
  _buffer.set_actual(sizeof(GetPropertiesResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetPropertiesResponse>(std::move(_buffer)));
}

void Controller::Interface::GetPropertiesCompleterBase::Reply(::fidl::DecodedMessage<GetPropertiesResponse> params) {
  Controller::SetTransactionHeaderFor::GetPropertiesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::InitializeCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InitializeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  InitializeResponse _response = {};
  Controller::SetTransactionHeaderFor::InitializeResponse(
      ::fidl::DecodedMessage<InitializeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeResponse::PrimarySize,
              InitializeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::InitializeCompleterBase::ReplySuccess() {
  Controller_Initialize_Response response;

  Reply(Controller_Initialize_Result::WithResponse(&response));
}
void Controller::Interface::InitializeCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_Initialize_Result::WithErr(&error));
}

void Controller::Interface::InitializeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result result) {
  if (_buffer.capacity() < InitializeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  InitializeResponse _response = {};
  Controller::SetTransactionHeaderFor::InitializeResponse(
      ::fidl::DecodedMessage<InitializeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              InitializeResponse::PrimarySize,
              InitializeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::InitializeCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_Initialize_Response response;

  Reply(std::move(_buffer), Controller_Initialize_Result::WithResponse(&response));
}

void Controller::Interface::InitializeCompleterBase::Reply(::fidl::DecodedMessage<InitializeResponse> params) {
  Controller::SetTransactionHeaderFor::InitializeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::TerminateCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<TerminateResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<TerminateResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::TerminateResponse(
      ::fidl::DecodedMessage<TerminateResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              TerminateResponse::PrimarySize,
              TerminateResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(TerminateResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<TerminateResponse>(std::move(_response_bytes)));
}


void Controller::Interface::GetAllocationCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Allocation* allocation) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAllocationResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetAllocationResponse _response = {};
  Controller::SetTransactionHeaderFor::GetAllocationResponse(
      ::fidl::DecodedMessage<GetAllocationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAllocationResponse::PrimarySize,
              GetAllocationResponse::PrimarySize)));
  _response.allocation = std::move(allocation);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetAllocationCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation* allocation) {
  if (_buffer.capacity() < GetAllocationResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAllocationResponse _response = {};
  Controller::SetTransactionHeaderFor::GetAllocationResponse(
      ::fidl::DecodedMessage<GetAllocationResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAllocationResponse::PrimarySize,
              GetAllocationResponse::PrimarySize)));
  _response.allocation = std::move(allocation);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetAllocationCompleterBase::Reply(::fidl::DecodedMessage<GetAllocationResponse> params) {
  Controller::SetTransactionHeaderFor::GetAllocationResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::StageConfigCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StageConfigResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  StageConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::StageConfigResponse(
      ::fidl::DecodedMessage<StageConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StageConfigResponse::PrimarySize,
              StageConfigResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::StageConfigCompleterBase::ReplySuccess() {
  Controller_StageConfig_Response response;

  Reply(Controller_StageConfig_Result::WithResponse(&response));
}
void Controller::Interface::StageConfigCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_StageConfig_Result::WithErr(&error));
}

void Controller::Interface::StageConfigCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result result) {
  if (_buffer.capacity() < StageConfigResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  StageConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::StageConfigResponse(
      ::fidl::DecodedMessage<StageConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StageConfigResponse::PrimarySize,
              StageConfigResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::StageConfigCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_StageConfig_Response response;

  Reply(std::move(_buffer), Controller_StageConfig_Result::WithResponse(&response));
}

void Controller::Interface::StageConfigCompleterBase::Reply(::fidl::DecodedMessage<StageConfigResponse> params) {
  Controller::SetTransactionHeaderFor::StageConfigResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetConfigCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Config* config) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetConfigResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::GetConfigResponse(
      ::fidl::DecodedMessage<GetConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetConfigResponse::PrimarySize,
              GetConfigResponse::PrimarySize)));
  _response.config = std::move(config);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetConfigCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Config* config) {
  if (_buffer.capacity() < GetConfigResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetConfigResponse _response = {};
  Controller::SetTransactionHeaderFor::GetConfigResponse(
      ::fidl::DecodedMessage<GetConfigResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetConfigResponse::PrimarySize,
              GetConfigResponse::PrimarySize)));
  _response.config = std::move(config);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Controller::Interface::GetConfigCompleterBase::Reply(::fidl::DecodedMessage<GetConfigResponse> params) {
  Controller::SetTransactionHeaderFor::GetConfigResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::GetBufferHandleCompleterBase::Reply(::zx::vmo vmo) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetBufferHandleResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetBufferHandleResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::GetBufferHandleResponse(
      ::fidl::DecodedMessage<GetBufferHandleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferHandleResponse::PrimarySize,
              GetBufferHandleResponse::PrimarySize)));
  _response.vmo = std::move(vmo);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetBufferHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetBufferHandleResponse>(std::move(_response_bytes)));
}

void Controller::Interface::GetBufferHandleCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::vmo vmo) {
  if (_buffer.capacity() < GetBufferHandleResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetBufferHandleResponse*>(_buffer.data());
  Controller::SetTransactionHeaderFor::GetBufferHandleResponse(
      ::fidl::DecodedMessage<GetBufferHandleResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetBufferHandleResponse::PrimarySize,
              GetBufferHandleResponse::PrimarySize)));
  _response.vmo = std::move(vmo);
  _buffer.set_actual(sizeof(GetBufferHandleResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetBufferHandleResponse>(std::move(_buffer)));
}

void Controller::Interface::GetBufferHandleCompleterBase::Reply(::fidl::DecodedMessage<GetBufferHandleResponse> params) {
  Controller::SetTransactionHeaderFor::GetBufferHandleResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::StartCompleterBase::Reply(::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StartResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  StartResponse _response = {};
  Controller::SetTransactionHeaderFor::StartResponse(
      ::fidl::DecodedMessage<StartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartResponse::PrimarySize,
              StartResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::StartCompleterBase::ReplySuccess() {
  Controller_Start_Response response;

  Reply(Controller_Start_Result::WithResponse(&response));
}
void Controller::Interface::StartCompleterBase::ReplyError(int32_t error) {
  Reply(Controller_Start_Result::WithErr(&error));
}

void Controller::Interface::StartCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result result) {
  if (_buffer.capacity() < StartResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  StartResponse _response = {};
  Controller::SetTransactionHeaderFor::StartResponse(
      ::fidl::DecodedMessage<StartResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StartResponse::PrimarySize,
              StartResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Controller::Interface::StartCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Controller_Start_Response response;

  Reply(std::move(_buffer), Controller_Start_Result::WithResponse(&response));
}

void Controller::Interface::StartCompleterBase::Reply(::fidl::DecodedMessage<StartResponse> params) {
  Controller::SetTransactionHeaderFor::StartResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Controller::Interface::StopCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<StopResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<StopResponse*>(_write_bytes);
  Controller::SetTransactionHeaderFor::StopResponse(
      ::fidl::DecodedMessage<StopResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              StopResponse::PrimarySize,
              StopResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(StopResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<StopResponse>(std::move(_response_bytes)));
}



void Controller::SetTransactionHeaderFor::GetPropertiesRequest(const ::fidl::DecodedMessage<Controller::GetPropertiesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetProperties_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetPropertiesResponse(const ::fidl::DecodedMessage<Controller::GetPropertiesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetProperties_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::InitializeRequest(const ::fidl::DecodedMessage<Controller::InitializeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Initialize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::InitializeResponse(const ::fidl::DecodedMessage<Controller::InitializeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Initialize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::TerminateRequest(const ::fidl::DecodedMessage<Controller::TerminateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Terminate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::TerminateResponse(const ::fidl::DecodedMessage<Controller::TerminateResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Terminate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetAllocationRequest(const ::fidl::DecodedMessage<Controller::GetAllocationRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetAllocation_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetAllocationResponse(const ::fidl::DecodedMessage<Controller::GetAllocationResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetAllocation_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::StageConfigRequest(const ::fidl::DecodedMessage<Controller::StageConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_StageConfig_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::StageConfigResponse(const ::fidl::DecodedMessage<Controller::StageConfigResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_StageConfig_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetConfigRequest(const ::fidl::DecodedMessage<Controller::GetConfigRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetConfig_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetConfigResponse(const ::fidl::DecodedMessage<Controller::GetConfigResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetConfig_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::GetBufferHandleRequest(const ::fidl::DecodedMessage<Controller::GetBufferHandleRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferHandle_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::GetBufferHandleResponse(const ::fidl::DecodedMessage<Controller::GetBufferHandleResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_GetBufferHandle_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::StartRequest(const ::fidl::DecodedMessage<Controller::StartRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Start_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::StartResponse(const ::fidl::DecodedMessage<Controller::StartResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Start_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Controller::SetTransactionHeaderFor::StopRequest(const ::fidl::DecodedMessage<Controller::StopRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Stop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Controller::SetTransactionHeaderFor::StopResponse(const ::fidl::DecodedMessage<Controller::StopResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kController_Stop_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace cpu
}  // namespace perfmon
}  // namespace fuchsia
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace perfmon {
namespace cpu {

class PropertyFlags final {
public:
  constexpr PropertyFlags() : value_(0u) {}
  explicit constexpr PropertyFlags(uint64_t value) : value_(value) {}
  const static PropertyFlags HAS_LAST_BRANCH;
  const static PropertyFlags mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const PropertyFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const PropertyFlags& other) const { return value_ != other.value_; }
  constexpr inline PropertyFlags operator~() const;
  constexpr inline PropertyFlags operator|(const PropertyFlags& other) const;
  constexpr inline PropertyFlags operator&(const PropertyFlags& other) const;
  constexpr inline PropertyFlags operator^(const PropertyFlags& other) const;
  constexpr inline void operator|=(const PropertyFlags& other);
  constexpr inline void operator&=(const PropertyFlags& other);
  constexpr inline void operator^=(const PropertyFlags& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::HAS_LAST_BRANCH = ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(1u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::mask = ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(1u);

constexpr inline ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::operator~() const {
  return ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::operator|(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::operator&(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::PropertyFlags PropertyFlags::operator^(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::PropertyFlags(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void PropertyFlags::operator|=(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void PropertyFlags::operator&=(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void PropertyFlags::operator^=(
    const ::llcpp::fuchsia::perfmon::cpu::PropertyFlags& other) {
  this->value_ ^= other.value_;
}

struct Properties;
class EventConfigFlags final {
public:
  constexpr EventConfigFlags() : value_(0u) {}
  explicit constexpr EventConfigFlags(uint32_t value) : value_(value) {}
  const static EventConfigFlags COLLECT_OS;
  const static EventConfigFlags COLLECT_USER;
  const static EventConfigFlags COLLECT_PC;
  const static EventConfigFlags IS_TIMEBASE;
  const static EventConfigFlags COLLECT_LAST_BRANCH;
  const static EventConfigFlags mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const EventConfigFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const EventConfigFlags& other) const { return value_ != other.value_; }
  constexpr inline EventConfigFlags operator~() const;
  constexpr inline EventConfigFlags operator|(const EventConfigFlags& other) const;
  constexpr inline EventConfigFlags operator&(const EventConfigFlags& other) const;
  constexpr inline EventConfigFlags operator^(const EventConfigFlags& other) const;
  constexpr inline void operator|=(const EventConfigFlags& other);
  constexpr inline void operator&=(const EventConfigFlags& other);
  constexpr inline void operator^=(const EventConfigFlags& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::COLLECT_OS = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(1u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::COLLECT_USER = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(2u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::COLLECT_PC = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(4u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::IS_TIMEBASE = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(8u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::COLLECT_LAST_BRANCH = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(16u);
constexpr const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::mask = ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(31u);

constexpr inline ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::operator~() const {
  return ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::operator|(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::operator&(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags EventConfigFlags::operator^(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) const {
  return ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void EventConfigFlags::operator|=(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void EventConfigFlags::operator&=(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void EventConfigFlags::operator^=(
    const ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags& other) {
  this->value_ ^= other.value_;
}

struct EventConfig;
struct Config;
struct Controller_Start_Response;
struct Controller_Start_Result;
struct Controller_StageConfig_Response;
struct Controller_StageConfig_Result;
struct Controller_Initialize_Response;
struct Controller_Initialize_Result;
struct Allocation;
class Controller;

extern "C" const fidl_type_t fuchsia_perfmon_cpu_PropertiesTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_PropertiesTable;

// The properties of this system.
struct Properties {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_PropertiesTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_PropertiesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // S/W API version = `API_VERSION`.
  uint16_t api_version = {};

  // The H/W Performance Monitor version.
  // This is the version defined by the architecture.
  uint16_t pm_version = {};

  // The maximum number of events that can be simultaneously supported.
  // The combination of events that can be simultaneously supported is
  // architecture/model specific.
  uint16_t max_num_events = {};

  // The maximum number of fixed events that can be simultaneously
  // supported, and their maximum width.
  // These values are for informational/display purposes.
  uint16_t max_num_fixed_events = {};

  uint16_t max_fixed_counter_width = {};

  // The maximum number of programmable events that can be simultaneously
  // supported, and their maximum width.
  // These values are for informational/display purposes.
  uint16_t max_num_programmable_events = {};

  uint16_t max_programmable_counter_width = {};

  // The maximum number of misc events that can be simultaneously
  // supported, and their maximum width.
  // These values are for informational/display purposes.
  uint16_t max_num_misc_events = {};

  uint16_t max_misc_counter_width = {};

  // Various flags.
  ::llcpp::fuchsia::perfmon::cpu::PropertyFlags flags = {};
};

// The maximum number of events we support simultaneously.
// Typically the h/w supports less than this, e.g., 7 or so.
constexpr uint16_t MAX_NUM_EVENTS = 32u;

extern "C" const fidl_type_t fuchsia_perfmon_cpu_EventConfigTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_EventConfigTable;

struct EventConfig {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_EventConfigTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_EventConfigTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // Event to collect data for.
  // The values are architecture specific ids.
  // Each event may appear at most once.
  uint16_t event = {};

  // Sampling rate.
  // - If rate is non-zero then when the event gets this many hits data is
  //   collected (e.g., pc, time).
  //   The rate can be non-zero for counting based events only.
  // - If rate is zero then:
  //     If there is a timebase event then data for this event is collected
  //     when data for the timebase event is collected.
  //     Otherwise data for the event is collected once, when tracing stops.
  uint32_t rate = {};

  // Flags for the event.
  ::llcpp::fuchsia::perfmon::cpu::EventConfigFlags flags = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_ConfigTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ConfigTable;

// Passed to `StageConfig()` to select the data to be collected.
struct Config {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ConfigTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ConfigTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 384;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 384;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // Events to collect data for.
  ::fidl::Array<::llcpp::fuchsia::perfmon::cpu::EventConfig, 32> events = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_Start_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_Start_ResponseTable;

struct Controller_Start_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_Start_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_Start_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_Start_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_Start_ResultTable;

struct Controller_Start_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_Start_Result();
  ~Controller_Start_Result();

  Controller_Start_Result(Controller_Start_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_Start_Result& operator=(Controller_Start_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_Start_Result WithResponse(::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response* val) {
    Controller_Start_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_Start_Result WithErr(int32_t* val) {
    Controller_Start_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_Start_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_Start_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_Start_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_StageConfig_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_StageConfig_ResponseTable;

struct Controller_StageConfig_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_StageConfig_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_StageConfig_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_StageConfig_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_StageConfig_ResultTable;

struct Controller_StageConfig_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_StageConfig_Result();
  ~Controller_StageConfig_Result();

  Controller_StageConfig_Result(Controller_StageConfig_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_StageConfig_Result& operator=(Controller_StageConfig_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_StageConfig_Result WithResponse(::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response* val) {
    Controller_StageConfig_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_StageConfig_Result WithErr(int32_t* val) {
    Controller_StageConfig_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_StageConfig_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_StageConfig_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_StageConfig_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_Initialize_ResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_Initialize_ResponseTable;

struct Controller_Initialize_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_Initialize_ResponseTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_Initialize_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_Controller_Initialize_ResultTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_Controller_Initialize_ResultTable;

struct Controller_Initialize_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
  };

  Controller_Initialize_Result();
  ~Controller_Initialize_Result();

  Controller_Initialize_Result(Controller_Initialize_Result&& other) {
    ordinal_ = Ordinal::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  Controller_Initialize_Result& operator=(Controller_Initialize_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == Ordinal::kResponse; }

  static Controller_Initialize_Result WithResponse(::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response* val) {
    Controller_Initialize_Result result;
    result.set_response(val);
    return result;
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T* v) {
    mutable_response() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response>::value && std::is_move_assignable<T>::value>
  set_response(T* v) {
    mutable_response() = std::move(*v);
  }

  ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response const & response() const { return response_; }

  bool is_err() const { return ordinal_ == Ordinal::kErr; }

  static Controller_Initialize_Result WithErr(int32_t* val) {
    Controller_Initialize_Result result;
    result.set_err(val);
    return result;
  }

  int32_t& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_copy_assignable<T>::value>
  set_err(const T* v) {
    mutable_err() = *v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, int32_t>::value && std::is_move_assignable<T>::value>
  set_err(T* v) {
    mutable_err() = std::move(*v);
  }

  int32_t const & err() const { return err_; }

  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_Controller_Initialize_ResultTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_Controller_Initialize_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 8;

 private:
  enum class Ordinal : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  void Destroy();
  void MoveImpl_(Controller_Initialize_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  union {
    ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response response_;
    int32_t err_;
  };
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_AllocationTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_AllocationTable;

// The allocation configuration for a data collection run.
// This is generally the first call to allocate resources for a trace,
// "trace" is used generically here: == "data collection run".
struct Allocation {
  static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_AllocationTable;
  static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_AllocationTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

  // The number of buffers to allocate for trace data.
  // This must be #cpus for now.
  uint32_t num_buffers = {};

  // The size of each buffer in 4K pages.
  // Each cpu gets same buffer size.
  uint32_t buffer_size_in_pages = {};
};

extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetPropertiesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetPropertiesRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerInitializeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerInitializeRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerTerminateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerTerminateRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerTerminateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerTerminateResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetAllocationRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStageConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStageConfigRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetConfigRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetConfigRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetBufferHandleRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetBufferHandleRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStartRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStartRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStartResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStartResponseTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStopRequestTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStopRequestTable;
extern "C" const fidl_type_t fuchsia_perfmon_cpu_ControllerStopResponseTable;
extern "C" const fidl_type_t v1_fuchsia_perfmon_cpu_ControllerStopResponseTable;

class Controller final {
  Controller() = delete;
 public:

  struct GetPropertiesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Properties properties;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerGetPropertiesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPropertiesRequest = ::fidl::AnyZeroArgMessage;

  struct InitializeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerInitializeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct InitializeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Allocation allocation;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerInitializeRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerInitializeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = InitializeResponse;
  };

  using TerminateResponse = ::fidl::AnyZeroArgMessage;
  using TerminateRequest = ::fidl::AnyZeroArgMessage;

  struct GetAllocationResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Allocation* allocation;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerGetAllocationResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAllocationRequest = ::fidl::AnyZeroArgMessage;

  struct StageConfigResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerStageConfigResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct StageConfigRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Config config;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerStageConfigRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerStageConfigRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 400;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 400;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = StageConfigResponse;
  };

  struct GetConfigResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Config* config;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerGetConfigResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 384;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 384;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetConfigRequest = ::fidl::AnyZeroArgMessage;

  struct GetBufferHandleResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::vmo vmo;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerGetBufferHandleResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetBufferHandleRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t descriptor;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerGetBufferHandleRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerGetBufferHandleRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetBufferHandleResponse;
  };

  struct StartResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_perfmon_cpu_ControllerStartResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_perfmon_cpu_ControllerStartResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using StartRequest = ::fidl::AnyZeroArgMessage;

  using StopResponse = ::fidl::AnyZeroArgMessage;
  using StopRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Initialize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Initialize_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation);
      ~Initialize_Impl() = default;
      Initialize_Impl(Initialize_Impl&& other) = default;
      Initialize_Impl& operator=(Initialize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Terminate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Terminate_Impl(::zx::unowned_channel _client_end);
      ~Terminate_Impl() = default;
      Terminate_Impl(Terminate_Impl&& other) = default;
      Terminate_Impl& operator=(Terminate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAllocation_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAllocation_Impl(::zx::unowned_channel _client_end);
      ~GetAllocation_Impl() = default;
      GetAllocation_Impl(GetAllocation_Impl&& other) = default;
      GetAllocation_Impl& operator=(GetAllocation_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StageConfig_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      StageConfig_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Config config);
      ~StageConfig_Impl() = default;
      StageConfig_Impl(StageConfig_Impl&& other) = default;
      StageConfig_Impl& operator=(StageConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfig_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetConfig_Impl(::zx::unowned_channel _client_end);
      ~GetConfig_Impl() = default;
      GetConfig_Impl(GetConfig_Impl&& other) = default;
      GetConfig_Impl& operator=(GetConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferHandle_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetBufferHandle_Impl(::zx::unowned_channel _client_end, uint32_t descriptor);
      ~GetBufferHandle_Impl() = default;
      GetBufferHandle_Impl(GetBufferHandle_Impl&& other) = default;
      GetBufferHandle_Impl& operator=(GetBufferHandle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using Initialize = Initialize_Impl<InitializeResponse>;
    using Terminate = Terminate_Impl<TerminateResponse>;
    using GetAllocation = GetAllocation_Impl<GetAllocationResponse>;
    using StageConfig = StageConfig_Impl<StageConfigResponse>;
    using GetConfig = GetConfig_Impl<GetConfigResponse>;
    using GetBufferHandle = GetBufferHandle_Impl<GetBufferHandleResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetProperties_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetProperties_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetProperties_Impl() = default;
      GetProperties_Impl(GetProperties_Impl&& other) = default;
      GetProperties_Impl& operator=(GetProperties_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Initialize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Initialize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer);
      ~Initialize_Impl() = default;
      Initialize_Impl(Initialize_Impl&& other) = default;
      Initialize_Impl& operator=(Initialize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Terminate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Terminate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Terminate_Impl() = default;
      Terminate_Impl(Terminate_Impl&& other) = default;
      Terminate_Impl& operator=(Terminate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAllocation_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAllocation_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAllocation_Impl() = default;
      GetAllocation_Impl(GetAllocation_Impl&& other) = default;
      GetAllocation_Impl& operator=(GetAllocation_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class StageConfig_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      StageConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer);
      ~StageConfig_Impl() = default;
      StageConfig_Impl(StageConfig_Impl&& other) = default;
      StageConfig_Impl& operator=(StageConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfig_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetConfig_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetConfig_Impl() = default;
      GetConfig_Impl(GetConfig_Impl&& other) = default;
      GetConfig_Impl& operator=(GetConfig_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBufferHandle_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetBufferHandle_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);
      ~GetBufferHandle_Impl() = default;
      GetBufferHandle_Impl(GetBufferHandle_Impl&& other) = default;
      GetBufferHandle_Impl& operator=(GetBufferHandle_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Start_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Start_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Start_Impl() = default;
      Start_Impl(Start_Impl&& other) = default;
      Start_Impl& operator=(Start_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Stop_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Stop_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Stop_Impl() = default;
      Stop_Impl(Stop_Impl&& other) = default;
      Stop_Impl& operator=(Stop_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetProperties = GetProperties_Impl<GetPropertiesResponse>;
    using Initialize = Initialize_Impl<InitializeResponse>;
    using Terminate = Terminate_Impl<TerminateResponse>;
    using GetAllocation = GetAllocation_Impl<GetAllocationResponse>;
    using StageConfig = StageConfig_Impl<StageConfigResponse>;
    using GetConfig = GetConfig_Impl<GetConfigResponse>;
    using GetBufferHandle = GetBufferHandle_Impl<GetBufferHandleResponse>;
    using Start = Start_Impl<StartResponse>;
    using Stop = Stop_Impl<StopResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Fetch the performance monitor properties of the system.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetProperties GetProperties();

    // Fetch the performance monitor properties of the system.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetProperties GetProperties(::fidl::BytePart _response_buffer);

    // Create a trace, allocating the needed trace buffers and other resources.
    // "other resources" is basically a catch-all for other things that will
    // be needed. This does not include reserving the events, that is done
    // later by `StageConfig()`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Initialize Initialize(::llcpp::fuchsia::perfmon::cpu::Allocation allocation);

    // Create a trace, allocating the needed trace buffers and other resources.
    // "other resources" is basically a catch-all for other things that will
    // be needed. This does not include reserving the events, that is done
    // later by `StageConfig()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Initialize Initialize(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed.
    // Tracing is first stopped if not already stopped.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Terminate Terminate();


    // Return the trace allocation configuration, if there is one.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAllocation GetAllocation();

    // Return the trace allocation configuration, if there is one.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAllocation GetAllocation(::fidl::BytePart _response_buffer);

    // Stage performance monitor specification for a cpu.
    // Must be called with data collection off and after `Initialize()`.
    // Note: This doesn't actually configure the h/w, this just stages
    // the values for subsequent use by `Start()`.
    // Allocates 424 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::StageConfig StageConfig(::llcpp::fuchsia::perfmon::cpu::Config config);

    // Stage performance monitor specification for a cpu.
    // Must be called with data collection off and after `Initialize()`.
    // Note: This doesn't actually configure the h/w, this just stages
    // the values for subsequent use by `Start()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::StageConfig StageConfig(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer);

    // Fetch performance monitor specification for a cpu, if it exists.
    // Must be called with data collection off and after `StageConfig()`.
    // Allocates 424 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetConfig GetConfig();

    // Fetch performance monitor specification for a cpu, if it exists.
    // Must be called with data collection off and after `StageConfig()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetConfig GetConfig(::fidl::BytePart _response_buffer);

    // Return a handle of a trace buffer, if it exists, and if `descriptor`
    // is valid.
    // `descriptor` is (0, 1, 2, ..., `num_buffers`-1)
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetBufferHandle GetBufferHandle(uint32_t descriptor);

    // Return a handle of a trace buffer, if it exists, and if `descriptor`
    // is valid.
    // `descriptor` is (0, 1, 2, ..., `num_buffers`-1)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetBufferHandle GetBufferHandle(::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Turn on data collection.
    // Must be called after `Initialize()` + `StageConfig()` and with data
    // collection off.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Start Start();

    // Turn on data collection.
    // Must be called after `Initialize()` + `StageConfig()` and with data
    // collection off.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Start Start(::fidl::BytePart _response_buffer);

    // Turn off data collection.
    // May be called any time after `Initialize()` has been called and before
    // `Terminate()`. If called at other times the call is ignored.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Stop Stop();


   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Fetch the performance monitor properties of the system.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end);

    // Fetch the performance monitor properties of the system.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetProperties GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Create a trace, allocating the needed trace buffers and other resources.
    // "other resources" is basically a catch-all for other things that will
    // be needed. This does not include reserving the events, that is done
    // later by `StageConfig()`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Initialize Initialize(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation);

    // Create a trace, allocating the needed trace buffers and other resources.
    // "other resources" is basically a catch-all for other things that will
    // be needed. This does not include reserving the events, that is done
    // later by `StageConfig()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Initialize Initialize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation allocation, ::fidl::BytePart _response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed.
    // Tracing is first stopped if not already stopped.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Terminate Terminate(::zx::unowned_channel _client_end);


    // Return the trace allocation configuration, if there is one.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAllocation GetAllocation(::zx::unowned_channel _client_end);

    // Return the trace allocation configuration, if there is one.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAllocation GetAllocation(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Stage performance monitor specification for a cpu.
    // Must be called with data collection off and after `Initialize()`.
    // Note: This doesn't actually configure the h/w, this just stages
    // the values for subsequent use by `Start()`.
    // Allocates 424 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::StageConfig StageConfig(::zx::unowned_channel _client_end, ::llcpp::fuchsia::perfmon::cpu::Config config);

    // Stage performance monitor specification for a cpu.
    // Must be called with data collection off and after `Initialize()`.
    // Note: This doesn't actually configure the h/w, this just stages
    // the values for subsequent use by `Start()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::StageConfig StageConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::perfmon::cpu::Config config, ::fidl::BytePart _response_buffer);

    // Fetch performance monitor specification for a cpu, if it exists.
    // Must be called with data collection off and after `StageConfig()`.
    // Allocates 424 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetConfig GetConfig(::zx::unowned_channel _client_end);

    // Fetch performance monitor specification for a cpu, if it exists.
    // Must be called with data collection off and after `StageConfig()`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetConfig GetConfig(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Return a handle of a trace buffer, if it exists, and if `descriptor`
    // is valid.
    // `descriptor` is (0, 1, 2, ..., `num_buffers`-1)
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetBufferHandle GetBufferHandle(::zx::unowned_channel _client_end, uint32_t descriptor);

    // Return a handle of a trace buffer, if it exists, and if `descriptor`
    // is valid.
    // `descriptor` is (0, 1, 2, ..., `num_buffers`-1)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetBufferHandle GetBufferHandle(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t descriptor, ::fidl::BytePart _response_buffer);

    // Turn on data collection.
    // Must be called after `Initialize()` + `StageConfig()` and with data
    // collection off.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Start Start(::zx::unowned_channel _client_end);

    // Turn on data collection.
    // Must be called after `Initialize()` + `StageConfig()` and with data
    // collection off.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Start Start(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Turn off data collection.
    // May be called any time after `Initialize()` has been called and before
    // `Terminate()`. If called at other times the call is ignored.
    // May be called multiple times.
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Stop Stop(::zx::unowned_channel _client_end);


  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Fetch the performance monitor properties of the system.
    static ::fidl::DecodeResult<GetPropertiesResponse> GetProperties(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Create a trace, allocating the needed trace buffers and other resources.
    // "other resources" is basically a catch-all for other things that will
    // be needed. This does not include reserving the events, that is done
    // later by `StageConfig()`.
    static ::fidl::DecodeResult<InitializeResponse> Initialize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<InitializeRequest> params, ::fidl::BytePart response_buffer);

    // Free all trace buffers and any other resources allocated for the trace.
    // This is also done when the connection is closed.
    // Tracing is first stopped if not already stopped.
    // May be called multiple times.
    static ::fidl::DecodeResult<TerminateResponse> Terminate(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Return the trace allocation configuration, if there is one.
    static ::fidl::DecodeResult<GetAllocationResponse> GetAllocation(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Stage performance monitor specification for a cpu.
    // Must be called with data collection off and after `Initialize()`.
    // Note: This doesn't actually configure the h/w, this just stages
    // the values for subsequent use by `Start()`.
    static ::fidl::DecodeResult<StageConfigResponse> StageConfig(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<StageConfigRequest> params, ::fidl::BytePart response_buffer);

    // Fetch performance monitor specification for a cpu, if it exists.
    // Must be called with data collection off and after `StageConfig()`.
    static ::fidl::DecodeResult<GetConfigResponse> GetConfig(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Return a handle of a trace buffer, if it exists, and if `descriptor`
    // is valid.
    // `descriptor` is (0, 1, 2, ..., `num_buffers`-1)
    static ::fidl::DecodeResult<GetBufferHandleResponse> GetBufferHandle(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferHandleRequest> params, ::fidl::BytePart response_buffer);

    // Turn on data collection.
    // Must be called after `Initialize()` + `StageConfig()` and with data
    // collection off.
    static ::fidl::DecodeResult<StartResponse> Start(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Turn off data collection.
    // May be called any time after `Initialize()` has been called and before
    // `Terminate()`. If called at other times the call is ignored.
    // May be called multiple times.
    static ::fidl::DecodeResult<StopResponse> Stop(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Controller;
    using _Base = ::fidl::CompleterBase;

    class GetPropertiesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Properties properties);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Properties properties);
      void Reply(::fidl::DecodedMessage<GetPropertiesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPropertiesCompleter = ::fidl::Completer<GetPropertiesCompleterBase>;

    virtual void GetProperties(GetPropertiesCompleter::Sync _completer) = 0;

    class InitializeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<InitializeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using InitializeCompleter = ::fidl::Completer<InitializeCompleterBase>;

    virtual void Initialize(::llcpp::fuchsia::perfmon::cpu::Allocation allocation, InitializeCompleter::Sync _completer) = 0;

    class TerminateCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using TerminateCompleter = ::fidl::Completer<TerminateCompleterBase>;

    virtual void Terminate(TerminateCompleter::Sync _completer) = 0;

    class GetAllocationCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Allocation* allocation);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Allocation* allocation);
      void Reply(::fidl::DecodedMessage<GetAllocationResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAllocationCompleter = ::fidl::Completer<GetAllocationCompleterBase>;

    virtual void GetAllocation(GetAllocationCompleter::Sync _completer) = 0;

    class StageConfigCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<StageConfigResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StageConfigCompleter = ::fidl::Completer<StageConfigCompleterBase>;

    virtual void StageConfig(::llcpp::fuchsia::perfmon::cpu::Config config, StageConfigCompleter::Sync _completer) = 0;

    class GetConfigCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Config* config);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Config* config);
      void Reply(::fidl::DecodedMessage<GetConfigResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetConfigCompleter = ::fidl::Completer<GetConfigCompleterBase>;

    virtual void GetConfig(GetConfigCompleter::Sync _completer) = 0;

    class GetBufferHandleCompleterBase : public _Base {
     public:
      void Reply(::zx::vmo vmo);
      void Reply(::fidl::BytePart _buffer, ::zx::vmo vmo);
      void Reply(::fidl::DecodedMessage<GetBufferHandleResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetBufferHandleCompleter = ::fidl::Completer<GetBufferHandleCompleterBase>;

    virtual void GetBufferHandle(uint32_t descriptor, GetBufferHandleCompleter::Sync _completer) = 0;

    class StartCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<StartResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StartCompleter = ::fidl::Completer<StartCompleterBase>;

    virtual void Start(StartCompleter::Sync _completer) = 0;

    class StopCompleterBase : public _Base {
     public:
      void Reply();

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using StopCompleter = ::fidl::Completer<StopCompleterBase>;

    virtual void Stop(StopCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetPropertiesRequest(const ::fidl::DecodedMessage<Controller::GetPropertiesRequest>& _msg);
    static void GetPropertiesResponse(const ::fidl::DecodedMessage<Controller::GetPropertiesResponse>& _msg);
    static void InitializeRequest(const ::fidl::DecodedMessage<Controller::InitializeRequest>& _msg);
    static void InitializeResponse(const ::fidl::DecodedMessage<Controller::InitializeResponse>& _msg);
    static void TerminateRequest(const ::fidl::DecodedMessage<Controller::TerminateRequest>& _msg);
    static void TerminateResponse(const ::fidl::DecodedMessage<Controller::TerminateResponse>& _msg);
    static void GetAllocationRequest(const ::fidl::DecodedMessage<Controller::GetAllocationRequest>& _msg);
    static void GetAllocationResponse(const ::fidl::DecodedMessage<Controller::GetAllocationResponse>& _msg);
    static void StageConfigRequest(const ::fidl::DecodedMessage<Controller::StageConfigRequest>& _msg);
    static void StageConfigResponse(const ::fidl::DecodedMessage<Controller::StageConfigResponse>& _msg);
    static void GetConfigRequest(const ::fidl::DecodedMessage<Controller::GetConfigRequest>& _msg);
    static void GetConfigResponse(const ::fidl::DecodedMessage<Controller::GetConfigResponse>& _msg);
    static void GetBufferHandleRequest(const ::fidl::DecodedMessage<Controller::GetBufferHandleRequest>& _msg);
    static void GetBufferHandleResponse(const ::fidl::DecodedMessage<Controller::GetBufferHandleResponse>& _msg);
    static void StartRequest(const ::fidl::DecodedMessage<Controller::StartRequest>& _msg);
    static void StartResponse(const ::fidl::DecodedMessage<Controller::StartResponse>& _msg);
    static void StopRequest(const ::fidl::DecodedMessage<Controller::StopRequest>& _msg);
    static void StopResponse(const ::fidl::DecodedMessage<Controller::StopResponse>& _msg);
  };
};

constexpr uint16_t API_VERSION = 0u;

}  // namespace cpu
}  // namespace perfmon
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::PropertyFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::PropertyFlags>);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::PropertyFlags) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Properties> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Properties>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, api_version) == 0);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, pm_version) == 2);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_num_events) == 4);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_num_fixed_events) == 6);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_fixed_counter_width) == 8);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_num_programmable_events) == 10);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_programmable_counter_width) == 12);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_num_misc_events) == 14);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, max_misc_counter_width) == 16);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Properties, flags) == 24);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Properties) == ::llcpp::fuchsia::perfmon::cpu::Properties::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::EventConfigFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::EventConfigFlags>);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::EventConfigFlags) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::EventConfig> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::EventConfig>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::EventConfig, event) == 0);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::EventConfig, rate) == 4);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::EventConfig, flags) == 8);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::EventConfig) == ::llcpp::fuchsia::perfmon::cpu::EventConfig::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Config> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Config>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Config, events) == 0);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Config) == ::llcpp::fuchsia::perfmon::cpu::Config::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response) == ::llcpp::fuchsia::perfmon::cpu::Controller_Start_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_Start_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response) == ::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_StageConfig_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response) == ::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Controller_Initialize_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Allocation> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::perfmon::cpu::Allocation>);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Allocation, num_buffers) == 0);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Allocation, buffer_size_in_pages) == 4);
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Allocation) == ::llcpp::fuchsia::perfmon::cpu::Allocation::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::GetPropertiesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::GetPropertiesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::GetPropertiesResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::GetPropertiesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::GetPropertiesResponse, properties) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::InitializeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::InitializeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::InitializeRequest)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::InitializeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::InitializeRequest, allocation) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::InitializeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::InitializeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::InitializeResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::InitializeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::InitializeResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::GetAllocationResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::GetAllocationResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::GetAllocationResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::GetAllocationResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::GetAllocationResponse, allocation) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigRequest)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigRequest, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::StageConfigResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::GetConfigResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::GetConfigResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::GetConfigResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::GetConfigResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::GetConfigResponse, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleRequest)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleRequest, descriptor) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::GetBufferHandleResponse, vmo) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::perfmon::cpu::Controller::StartResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::perfmon::cpu::Controller::StartResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::perfmon::cpu::Controller::StartResponse)
    == ::llcpp::fuchsia::perfmon::cpu::Controller::StartResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::perfmon::cpu::Controller::StartResponse, result) == 16);

}  // namespace fidl

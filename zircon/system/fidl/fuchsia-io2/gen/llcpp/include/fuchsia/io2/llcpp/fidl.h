// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/debuglog.h>
#include <lib/zx/event.h>
#include <lib/zx/eventpair.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>
#include <zircon/fidl.h>

#include <fuchsia/mem/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace io2 {

struct MemoryInfo;
struct File_GetMemRange_Response;
struct File_GetMemRange_Result;
class VmoFlags final {
public:
  constexpr VmoFlags() : value_(0u) {}
  explicit constexpr VmoFlags(uint64_t value) : value_(value) {}
  const static VmoFlags READ;
  const static VmoFlags WRITE;
  const static VmoFlags EXECUTE;
  const static VmoFlags PRIVATE_CLONE;
  const static VmoFlags SHARED_BUFFER;
  const static VmoFlags mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const VmoFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const VmoFlags& other) const { return value_ != other.value_; }
  constexpr inline VmoFlags operator~() const;
  constexpr inline VmoFlags operator|(const VmoFlags& other) const;
  constexpr inline VmoFlags operator&(const VmoFlags& other) const;
  constexpr inline VmoFlags operator^(const VmoFlags& other) const;
  constexpr inline void operator|=(const VmoFlags& other);
  constexpr inline void operator&=(const VmoFlags& other);
  constexpr inline void operator^=(const VmoFlags& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::READ = ::llcpp::fuchsia::io2::VmoFlags(1u);
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::WRITE = ::llcpp::fuchsia::io2::VmoFlags(2u);
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::EXECUTE = ::llcpp::fuchsia::io2::VmoFlags(4u);
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::PRIVATE_CLONE = ::llcpp::fuchsia::io2::VmoFlags(65536u);
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::SHARED_BUFFER = ::llcpp::fuchsia::io2::VmoFlags(131072u);
constexpr const ::llcpp::fuchsia::io2::VmoFlags VmoFlags::mask = ::llcpp::fuchsia::io2::VmoFlags(196615u);

constexpr inline ::llcpp::fuchsia::io2::VmoFlags VmoFlags::operator~() const {
  return ::llcpp::fuchsia::io2::VmoFlags(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::VmoFlags VmoFlags::operator|(
    const ::llcpp::fuchsia::io2::VmoFlags& other) const {
  return ::llcpp::fuchsia::io2::VmoFlags(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::VmoFlags VmoFlags::operator&(
    const ::llcpp::fuchsia::io2::VmoFlags& other) const {
  return ::llcpp::fuchsia::io2::VmoFlags(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::VmoFlags VmoFlags::operator^(
    const ::llcpp::fuchsia::io2::VmoFlags& other) const {
  return ::llcpp::fuchsia::io2::VmoFlags(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void VmoFlags::operator|=(
    const ::llcpp::fuchsia::io2::VmoFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void VmoFlags::operator&=(
    const ::llcpp::fuchsia::io2::VmoFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void VmoFlags::operator^=(
    const ::llcpp::fuchsia::io2::VmoFlags& other) {
  this->value_ ^= other.value_;
}

struct TtyInfo;
struct File_Read_Response;
struct File_Read_Result;
struct File_ReadAt_Response;
struct File_ReadAt_Result;
struct Node_GetToken_Response;
struct Node_GetToken_Result;
enum class SeekOrigin : uint32_t {
  START = 1u,
  CURRENT = 2u,
  END = 3u,
};


struct PosixSocketInfo;
struct PipeInfo;
class Operations final {
public:
  constexpr Operations() : value_(0u) {}
  explicit constexpr Operations(uint64_t value) : value_(value) {}
  const static Operations CONNECT;
  const static Operations READ_BYTES;
  const static Operations WRITE_BYTES;
  const static Operations EXECUTE;
  const static Operations GET_ATTRIBUTES;
  const static Operations UPDATE_ATTRIBUTES;
  const static Operations ENUMERATE;
  const static Operations TRAVERSE;
  const static Operations MODIFY_DIRECTORY;
  const static Operations ADMIN;
  const static Operations mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const Operations& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const Operations& other) const { return value_ != other.value_; }
  constexpr inline Operations operator~() const;
  constexpr inline Operations operator|(const Operations& other) const;
  constexpr inline Operations operator&(const Operations& other) const;
  constexpr inline Operations operator^(const Operations& other) const;
  constexpr inline void operator|=(const Operations& other);
  constexpr inline void operator&=(const Operations& other);
  constexpr inline void operator^=(const Operations& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::Operations Operations::CONNECT = ::llcpp::fuchsia::io2::Operations(1u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::READ_BYTES = ::llcpp::fuchsia::io2::Operations(2u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::WRITE_BYTES = ::llcpp::fuchsia::io2::Operations(4u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::EXECUTE = ::llcpp::fuchsia::io2::Operations(8u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::GET_ATTRIBUTES = ::llcpp::fuchsia::io2::Operations(16u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::UPDATE_ATTRIBUTES = ::llcpp::fuchsia::io2::Operations(32u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::ENUMERATE = ::llcpp::fuchsia::io2::Operations(64u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::TRAVERSE = ::llcpp::fuchsia::io2::Operations(128u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::MODIFY_DIRECTORY = ::llcpp::fuchsia::io2::Operations(256u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::ADMIN = ::llcpp::fuchsia::io2::Operations(72057594037927936u);
constexpr const ::llcpp::fuchsia::io2::Operations Operations::mask = ::llcpp::fuchsia::io2::Operations(72057594037928447u);

constexpr inline ::llcpp::fuchsia::io2::Operations Operations::operator~() const {
  return ::llcpp::fuchsia::io2::Operations(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::Operations Operations::operator|(
    const ::llcpp::fuchsia::io2::Operations& other) const {
  return ::llcpp::fuchsia::io2::Operations(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::Operations Operations::operator&(
    const ::llcpp::fuchsia::io2::Operations& other) const {
  return ::llcpp::fuchsia::io2::Operations(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::Operations Operations::operator^(
    const ::llcpp::fuchsia::io2::Operations& other) const {
  return ::llcpp::fuchsia::io2::Operations(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void Operations::operator|=(
    const ::llcpp::fuchsia::io2::Operations& other) {
  this->value_ |= other.value_;
}

constexpr inline void Operations::operator&=(
    const ::llcpp::fuchsia::io2::Operations& other) {
  this->value_ &= other.value_;
}

constexpr inline void Operations::operator^=(
    const ::llcpp::fuchsia::io2::Operations& other) {
  this->value_ ^= other.value_;
}

enum class OpenMode : uint32_t {
  OPEN_EXISTING = 1u,
  MAYBE_CREATE = 2u,
  ALWAYS_CREATE = 3u,
  OPEN_MOUNT_POINT = 268435456u,
};


struct Node_UpdateAttributes_Response;
struct Node_UpdateAttributes_Result;
struct Node_Sync_Response;
struct Node_Sync_Result;
class NodeProtocolSet final {
public:
  constexpr NodeProtocolSet() : value_(0u) {}
  explicit constexpr NodeProtocolSet(uint64_t value) : value_(value) {}
  const static NodeProtocolSet CONNECTOR;
  const static NodeProtocolSet DIRECTORY;
  const static NodeProtocolSet FILE;
  const static NodeProtocolSet MEMORY;
  const static NodeProtocolSet POSIX_SOCKET;
  const static NodeProtocolSet PIPE;
  const static NodeProtocolSet DEBUGLOG;
  const static NodeProtocolSet DEVICE;
  const static NodeProtocolSet TTY;
  const static NodeProtocolSet mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const NodeProtocolSet& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const NodeProtocolSet& other) const { return value_ != other.value_; }
  constexpr inline NodeProtocolSet operator~() const;
  constexpr inline NodeProtocolSet operator|(const NodeProtocolSet& other) const;
  constexpr inline NodeProtocolSet operator&(const NodeProtocolSet& other) const;
  constexpr inline NodeProtocolSet operator^(const NodeProtocolSet& other) const;
  constexpr inline void operator|=(const NodeProtocolSet& other);
  constexpr inline void operator&=(const NodeProtocolSet& other);
  constexpr inline void operator^=(const NodeProtocolSet& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::CONNECTOR = ::llcpp::fuchsia::io2::NodeProtocolSet(1u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::DIRECTORY = ::llcpp::fuchsia::io2::NodeProtocolSet(2u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::FILE = ::llcpp::fuchsia::io2::NodeProtocolSet(4u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::MEMORY = ::llcpp::fuchsia::io2::NodeProtocolSet(8u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::POSIX_SOCKET = ::llcpp::fuchsia::io2::NodeProtocolSet(16u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::PIPE = ::llcpp::fuchsia::io2::NodeProtocolSet(32u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::DEBUGLOG = ::llcpp::fuchsia::io2::NodeProtocolSet(64u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::DEVICE = ::llcpp::fuchsia::io2::NodeProtocolSet(268435456u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::TTY = ::llcpp::fuchsia::io2::NodeProtocolSet(536870912u);
constexpr const ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::mask = ::llcpp::fuchsia::io2::NodeProtocolSet(805306495u);

constexpr inline ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::operator~() const {
  return ::llcpp::fuchsia::io2::NodeProtocolSet(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::operator|(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) const {
  return ::llcpp::fuchsia::io2::NodeProtocolSet(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::operator&(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) const {
  return ::llcpp::fuchsia::io2::NodeProtocolSet(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeProtocolSet NodeProtocolSet::operator^(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) const {
  return ::llcpp::fuchsia::io2::NodeProtocolSet(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void NodeProtocolSet::operator|=(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) {
  this->value_ |= other.value_;
}

constexpr inline void NodeProtocolSet::operator&=(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) {
  this->value_ &= other.value_;
}

constexpr inline void NodeProtocolSet::operator^=(
    const ::llcpp::fuchsia::io2::NodeProtocolSet& other) {
  this->value_ ^= other.value_;
}

class NodeAttributesQuery final {
public:
  constexpr NodeAttributesQuery() : value_(0u) {}
  explicit constexpr NodeAttributesQuery(uint64_t value) : value_(value) {}
  const static NodeAttributesQuery PROTOCOLS;
  const static NodeAttributesQuery ABILITIES;
  const static NodeAttributesQuery CONTENT_SIZE;
  const static NodeAttributesQuery STORAGE_SIZE;
  const static NodeAttributesQuery LINK_COUNT;
  const static NodeAttributesQuery CREATION_TIME;
  const static NodeAttributesQuery MODIFICATION_TIME;
  const static NodeAttributesQuery ID;
  const static NodeAttributesQuery mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const NodeAttributesQuery& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const NodeAttributesQuery& other) const { return value_ != other.value_; }
  constexpr inline NodeAttributesQuery operator~() const;
  constexpr inline NodeAttributesQuery operator|(const NodeAttributesQuery& other) const;
  constexpr inline NodeAttributesQuery operator&(const NodeAttributesQuery& other) const;
  constexpr inline NodeAttributesQuery operator^(const NodeAttributesQuery& other) const;
  constexpr inline void operator|=(const NodeAttributesQuery& other);
  constexpr inline void operator&=(const NodeAttributesQuery& other);
  constexpr inline void operator^=(const NodeAttributesQuery& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::PROTOCOLS = ::llcpp::fuchsia::io2::NodeAttributesQuery(1u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::ABILITIES = ::llcpp::fuchsia::io2::NodeAttributesQuery(2u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::CONTENT_SIZE = ::llcpp::fuchsia::io2::NodeAttributesQuery(4u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::STORAGE_SIZE = ::llcpp::fuchsia::io2::NodeAttributesQuery(8u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::LINK_COUNT = ::llcpp::fuchsia::io2::NodeAttributesQuery(16u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::CREATION_TIME = ::llcpp::fuchsia::io2::NodeAttributesQuery(32u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::MODIFICATION_TIME = ::llcpp::fuchsia::io2::NodeAttributesQuery(64u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::ID = ::llcpp::fuchsia::io2::NodeAttributesQuery(128u);
constexpr const ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::mask = ::llcpp::fuchsia::io2::NodeAttributesQuery(255u);

constexpr inline ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::operator~() const {
  return ::llcpp::fuchsia::io2::NodeAttributesQuery(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::operator|(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) const {
  return ::llcpp::fuchsia::io2::NodeAttributesQuery(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::operator&(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) const {
  return ::llcpp::fuchsia::io2::NodeAttributesQuery(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::NodeAttributesQuery NodeAttributesQuery::operator^(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) const {
  return ::llcpp::fuchsia::io2::NodeAttributesQuery(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void NodeAttributesQuery::operator|=(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) {
  this->value_ |= other.value_;
}

constexpr inline void NodeAttributesQuery::operator&=(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) {
  this->value_ &= other.value_;
}

constexpr inline void NodeAttributesQuery::operator^=(
    const ::llcpp::fuchsia::io2::NodeAttributesQuery& other) {
  this->value_ ^= other.value_;
}

struct IdleEvent;
struct NodeAttributes;
struct Node_GetAttributes_Response;
struct Node_GetAttributes_Result;
struct DirectoryEntry;
struct DirectoryWatchedEvent;
class DirectoryWatcher;
struct DirectoryIterator_GetNext_Response;
struct DirectoryIterator_GetNext_Result;
class DirectoryIterator;
struct File_Write_Response;
struct File_Write_Result;
struct File_WriteAt_Response;
struct File_WriteAt_Result;
struct File_Seek_Response;
struct File_Seek_Result;
struct File_Resize_Response;
struct File_Resize_Result;
class FileSignal final {
public:
  constexpr FileSignal() : value_(0u) {}
  explicit constexpr FileSignal(uint32_t value) : value_(value) {}
  const static FileSignal READABLE;
  const static FileSignal WRITABLE;
  const static FileSignal mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const FileSignal& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const FileSignal& other) const { return value_ != other.value_; }
  constexpr inline FileSignal operator~() const;
  constexpr inline FileSignal operator|(const FileSignal& other) const;
  constexpr inline FileSignal operator&(const FileSignal& other) const;
  constexpr inline FileSignal operator^(const FileSignal& other) const;
  constexpr inline void operator|=(const FileSignal& other);
  constexpr inline void operator&=(const FileSignal& other);
  constexpr inline void operator^=(const FileSignal& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::io2::FileSignal FileSignal::READABLE = ::llcpp::fuchsia::io2::FileSignal(16777216u);
constexpr const ::llcpp::fuchsia::io2::FileSignal FileSignal::WRITABLE = ::llcpp::fuchsia::io2::FileSignal(33554432u);
constexpr const ::llcpp::fuchsia::io2::FileSignal FileSignal::mask = ::llcpp::fuchsia::io2::FileSignal(50331648u);

constexpr inline ::llcpp::fuchsia::io2::FileSignal FileSignal::operator~() const {
  return ::llcpp::fuchsia::io2::FileSignal(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::FileSignal FileSignal::operator|(
    const ::llcpp::fuchsia::io2::FileSignal& other) const {
  return ::llcpp::fuchsia::io2::FileSignal(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::FileSignal FileSignal::operator&(
    const ::llcpp::fuchsia::io2::FileSignal& other) const {
  return ::llcpp::fuchsia::io2::FileSignal(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::FileSignal FileSignal::operator^(
    const ::llcpp::fuchsia::io2::FileSignal& other) const {
  return ::llcpp::fuchsia::io2::FileSignal(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void FileSignal::operator|=(
    const ::llcpp::fuchsia::io2::FileSignal& other) {
  this->value_ |= other.value_;
}

constexpr inline void FileSignal::operator&=(
    const ::llcpp::fuchsia::io2::FileSignal& other) {
  this->value_ &= other.value_;
}

constexpr inline void FileSignal::operator^=(
    const ::llcpp::fuchsia::io2::FileSignal& other) {
  this->value_ ^= other.value_;
}

struct FileInfo;
struct Directory_Unlink_Response;
struct Directory_Unlink_Result;
struct Directory_Rename_Response;
struct Directory_Rename_Result;
struct Directory_Link_Response;
struct Directory_Link_Result;
struct DirectoryWatchOptions;
class DirectoryWatchMask final {
public:
  constexpr DirectoryWatchMask() : value_(0u) {}
  explicit constexpr DirectoryWatchMask(uint64_t value) : value_(value) {}
  const static DirectoryWatchMask EXISTING;
  const static DirectoryWatchMask IDLE;
  const static DirectoryWatchMask ADDED;
  const static DirectoryWatchMask REMOVED;
  const static DirectoryWatchMask mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const DirectoryWatchMask& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const DirectoryWatchMask& other) const { return value_ != other.value_; }
  constexpr inline DirectoryWatchMask operator~() const;
  constexpr inline DirectoryWatchMask operator|(const DirectoryWatchMask& other) const;
  constexpr inline DirectoryWatchMask operator&(const DirectoryWatchMask& other) const;
  constexpr inline DirectoryWatchMask operator^(const DirectoryWatchMask& other) const;
  constexpr inline void operator|=(const DirectoryWatchMask& other);
  constexpr inline void operator&=(const DirectoryWatchMask& other);
  constexpr inline void operator^=(const DirectoryWatchMask& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::EXISTING = ::llcpp::fuchsia::io2::DirectoryWatchMask(1u);
constexpr const ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::IDLE = ::llcpp::fuchsia::io2::DirectoryWatchMask(2u);
constexpr const ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::ADDED = ::llcpp::fuchsia::io2::DirectoryWatchMask(4u);
constexpr const ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::REMOVED = ::llcpp::fuchsia::io2::DirectoryWatchMask(8u);
constexpr const ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::mask = ::llcpp::fuchsia::io2::DirectoryWatchMask(15u);

constexpr inline ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::operator~() const {
  return ::llcpp::fuchsia::io2::DirectoryWatchMask(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::operator|(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) const {
  return ::llcpp::fuchsia::io2::DirectoryWatchMask(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::operator&(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) const {
  return ::llcpp::fuchsia::io2::DirectoryWatchMask(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DirectoryWatchMask DirectoryWatchMask::operator^(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) const {
  return ::llcpp::fuchsia::io2::DirectoryWatchMask(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void DirectoryWatchMask::operator|=(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) {
  this->value_ |= other.value_;
}

constexpr inline void DirectoryWatchMask::operator&=(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) {
  this->value_ &= other.value_;
}

constexpr inline void DirectoryWatchMask::operator^=(
    const ::llcpp::fuchsia::io2::DirectoryWatchMask& other) {
  this->value_ ^= other.value_;
}

struct DirectoryInfo;
struct DirectoryEnumerateOptions;
class DeviceSignal final {
public:
  constexpr DeviceSignal() : value_(0u) {}
  explicit constexpr DeviceSignal(uint32_t value) : value_(value) {}
  const static DeviceSignal READABLE;
  const static DeviceSignal WRITABLE;
  const static DeviceSignal ERROR;
  const static DeviceSignal HANGUP;
  const static DeviceSignal OOB;
  const static DeviceSignal mask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const DeviceSignal& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const DeviceSignal& other) const { return value_ != other.value_; }
  constexpr inline DeviceSignal operator~() const;
  constexpr inline DeviceSignal operator|(const DeviceSignal& other) const;
  constexpr inline DeviceSignal operator&(const DeviceSignal& other) const;
  constexpr inline DeviceSignal operator^(const DeviceSignal& other) const;
  constexpr inline void operator|=(const DeviceSignal& other);
  constexpr inline void operator&=(const DeviceSignal& other);
  constexpr inline void operator^=(const DeviceSignal& other);

private:
  uint32_t value_;
};
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::READABLE = ::llcpp::fuchsia::io2::DeviceSignal(16777216u);
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::WRITABLE = ::llcpp::fuchsia::io2::DeviceSignal(33554432u);
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::ERROR = ::llcpp::fuchsia::io2::DeviceSignal(67108864u);
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::HANGUP = ::llcpp::fuchsia::io2::DeviceSignal(134217728u);
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::OOB = ::llcpp::fuchsia::io2::DeviceSignal(268435456u);
constexpr const ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::mask = ::llcpp::fuchsia::io2::DeviceSignal(520093696u);

constexpr inline ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::operator~() const {
  return ::llcpp::fuchsia::io2::DeviceSignal(static_cast<uint32_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::operator|(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) const {
  return ::llcpp::fuchsia::io2::DeviceSignal(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::operator&(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) const {
  return ::llcpp::fuchsia::io2::DeviceSignal(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::DeviceSignal DeviceSignal::operator^(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) const {
  return ::llcpp::fuchsia::io2::DeviceSignal(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void DeviceSignal::operator|=(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) {
  this->value_ |= other.value_;
}

constexpr inline void DeviceSignal::operator&=(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) {
  this->value_ &= other.value_;
}

constexpr inline void DeviceSignal::operator^=(
    const ::llcpp::fuchsia::io2::DeviceSignal& other) {
  this->value_ ^= other.value_;
}

struct DeviceInfo;
struct DebuglogInfo;
struct ConnectorInfo;
struct Representation;
struct ConnectionInfo;
class ConnectionInfoQuery final {
public:
  constexpr ConnectionInfoQuery() : value_(0u) {}
  explicit constexpr ConnectionInfoQuery(uint64_t value) : value_(value) {}
  const static ConnectionInfoQuery REPRESENTATION;
  const static ConnectionInfoQuery RIGHTS;
  const static ConnectionInfoQuery AVAILABLE_OPERATIONS;
  const static ConnectionInfoQuery mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const ConnectionInfoQuery& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const ConnectionInfoQuery& other) const { return value_ != other.value_; }
  constexpr inline ConnectionInfoQuery operator~() const;
  constexpr inline ConnectionInfoQuery operator|(const ConnectionInfoQuery& other) const;
  constexpr inline ConnectionInfoQuery operator&(const ConnectionInfoQuery& other) const;
  constexpr inline ConnectionInfoQuery operator^(const ConnectionInfoQuery& other) const;
  constexpr inline void operator|=(const ConnectionInfoQuery& other);
  constexpr inline void operator&=(const ConnectionInfoQuery& other);
  constexpr inline void operator^=(const ConnectionInfoQuery& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::REPRESENTATION = ::llcpp::fuchsia::io2::ConnectionInfoQuery(1u);
constexpr const ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::RIGHTS = ::llcpp::fuchsia::io2::ConnectionInfoQuery(2u);
constexpr const ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::AVAILABLE_OPERATIONS = ::llcpp::fuchsia::io2::ConnectionInfoQuery(4u);
constexpr const ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::mask = ::llcpp::fuchsia::io2::ConnectionInfoQuery(7u);

constexpr inline ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::operator~() const {
  return ::llcpp::fuchsia::io2::ConnectionInfoQuery(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::operator|(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) const {
  return ::llcpp::fuchsia::io2::ConnectionInfoQuery(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::operator&(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) const {
  return ::llcpp::fuchsia::io2::ConnectionInfoQuery(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionInfoQuery ConnectionInfoQuery::operator^(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) const {
  return ::llcpp::fuchsia::io2::ConnectionInfoQuery(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void ConnectionInfoQuery::operator|=(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) {
  this->value_ |= other.value_;
}

constexpr inline void ConnectionInfoQuery::operator&=(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) {
  this->value_ &= other.value_;
}

constexpr inline void ConnectionInfoQuery::operator^=(
    const ::llcpp::fuchsia::io2::ConnectionInfoQuery& other) {
  this->value_ ^= other.value_;
}

class ConnectionFlags final {
public:
  constexpr ConnectionFlags() : value_(0u) {}
  explicit constexpr ConnectionFlags(uint64_t value) : value_(value) {}
  const static ConnectionFlags GET_CONNECTION_INFO;
  const static ConnectionFlags CONNECT;
  const static ConnectionFlags APPEND;
  const static ConnectionFlags TRUNCATE;
  const static ConnectionFlags mask;

  explicit constexpr inline operator uint64_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const ConnectionFlags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const ConnectionFlags& other) const { return value_ != other.value_; }
  constexpr inline ConnectionFlags operator~() const;
  constexpr inline ConnectionFlags operator|(const ConnectionFlags& other) const;
  constexpr inline ConnectionFlags operator&(const ConnectionFlags& other) const;
  constexpr inline ConnectionFlags operator^(const ConnectionFlags& other) const;
  constexpr inline void operator|=(const ConnectionFlags& other);
  constexpr inline void operator&=(const ConnectionFlags& other);
  constexpr inline void operator^=(const ConnectionFlags& other);

private:
  uint64_t value_;
};
constexpr const ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::GET_CONNECTION_INFO = ::llcpp::fuchsia::io2::ConnectionFlags(1u);
constexpr const ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::CONNECT = ::llcpp::fuchsia::io2::ConnectionFlags(2u);
constexpr const ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::APPEND = ::llcpp::fuchsia::io2::ConnectionFlags(4u);
constexpr const ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::TRUNCATE = ::llcpp::fuchsia::io2::ConnectionFlags(8u);
constexpr const ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::mask = ::llcpp::fuchsia::io2::ConnectionFlags(15u);

constexpr inline ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::operator~() const {
  return ::llcpp::fuchsia::io2::ConnectionFlags(static_cast<uint64_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::operator|(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) const {
  return ::llcpp::fuchsia::io2::ConnectionFlags(static_cast<uint64_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::operator&(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) const {
  return ::llcpp::fuchsia::io2::ConnectionFlags(static_cast<uint64_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::io2::ConnectionFlags ConnectionFlags::operator^(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) const {
  return ::llcpp::fuchsia::io2::ConnectionFlags(static_cast<uint64_t>(this->value_ ^ other.value_));
}

constexpr inline void ConnectionFlags::operator|=(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) {
  this->value_ |= other.value_;
}

constexpr inline void ConnectionFlags::operator&=(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) {
  this->value_ &= other.value_;
}

constexpr inline void ConnectionFlags::operator^=(
    const ::llcpp::fuchsia::io2::ConnectionFlags& other) {
  this->value_ ^= other.value_;
}

struct ConnectionOptions;
class Node;
class Pipe;
class Memory;
class File;
class Directory;
class Debuglog;

extern "C" const fidl_type_t v1_fuchsia_io2_MemoryInfoTable;

// Auxiliary data for the memory object representation of a node.
// The node is a file which is represented as a VMO.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.io2/Memory`] protocol.
struct MemoryInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Although a VMO is returned as a part of this structure, that VMO may
  // back multiple files. To identify the logical portion of the VMO that
  // represents the single file, offset and size are also supplied.
  //
  // If the range covers the entire VMO (i.e. the offset is zero and the
  // length matches the size of the VMO), then all clients must receive a
  // VMO with the same koid. This can be a duplicate of the same underlying
  // page-aligned VMO.
  //
  // The rights on this VMO should correspond to the rights on the
  // node connection.
  const ::llcpp::fuchsia::mem::Range& buffer() const {
    ZX_ASSERT(has_buffer());
    return *reinterpret_cast<const ::llcpp::fuchsia::mem::Range*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::mem::Range& buffer() {
    ZX_ASSERT(has_buffer());
    return *reinterpret_cast<::llcpp::fuchsia::mem::Range*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_buffer() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  MemoryInfo() = default;
  ~MemoryInfo() = default;
  MemoryInfo(MemoryInfo&& other) noexcept = default;
  MemoryInfo& operator=(MemoryInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 40;
  static constexpr bool HasPointer = true;

 private:
  MemoryInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class MemoryInfo::Builder {
 public:
  MemoryInfo view() { return MemoryInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Although a VMO is returned as a part of this structure, that VMO may
  // back multiple files. To identify the logical portion of the VMO that
  // represents the single file, offset and size are also supplied.
  //
  // If the range covers the entire VMO (i.e. the offset is zero and the
  // length matches the size of the VMO), then all clients must receive a
  // VMO with the same koid. This can be a duplicate of the same underlying
  // page-aligned VMO.
  //
  // The rights on this VMO should correspond to the rights on the
  // node connection.
  Builder&& set_buffer(::llcpp::fuchsia::mem::Range* elem);

 private:
  Builder() = default;
  friend Builder MemoryInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_GetMemRange_ResultTable;

struct File_GetMemRange_Result {
  File_GetMemRange_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_GetMemRange_Result WithResponse(::llcpp::fuchsia::io2::File_GetMemRange_Response* val) {
    File_GetMemRange_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_GetMemRange_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_GetMemRange_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_GetMemRange_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_GetMemRange_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_GetMemRange_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_GetMemRange_Result WithErr(int32_t* val) {
    File_GetMemRange_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_GetMemRange_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_TtyInfoTable;

// The object may be cast to a Tty interface.
struct TtyInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // An optional event which transmits information about a device's state.
  //
  // The [`DeviceSignal`] values may be observed on this event.
  const ::zx::eventpair& event() const {
    ZX_ASSERT(has_event());
    return *reinterpret_cast<const ::zx::eventpair*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::eventpair& event() {
    ZX_ASSERT(has_event());
    return *reinterpret_cast<::zx::eventpair*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_event() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  TtyInfo() = default;
  ~TtyInfo() = default;
  TtyInfo(TtyInfo&& other) noexcept = default;
  TtyInfo& operator=(TtyInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_TtyInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  TtyInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class TtyInfo::Builder {
 public:
  TtyInfo view() { return TtyInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // An optional event which transmits information about a device's state.
  //
  // The [`DeviceSignal`] values may be observed on this event.
  Builder&& set_event(::zx::eventpair* elem);

 private:
  Builder() = default;
  friend Builder TtyInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Read_ResultTable;

struct File_Read_Result {
  File_Read_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_Read_Result WithResponse(::llcpp::fuchsia::io2::File_Read_Response* val) {
    File_Read_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_Read_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_Read_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Read_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_Read_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Read_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_Read_Result WithErr(int32_t* val) {
    File_Read_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Read_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8208;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_ReadAt_ResultTable;

struct File_ReadAt_Result {
  File_ReadAt_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_ReadAt_Result WithResponse(::llcpp::fuchsia::io2::File_ReadAt_Response* val) {
    File_ReadAt_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_ReadAt_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_ReadAt_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_ReadAt_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_ReadAt_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_ReadAt_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_ReadAt_Result WithErr(int32_t* val) {
    File_ReadAt_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_ReadAt_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8208;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_GetToken_ResultTable;

struct Node_GetToken_Result {
  Node_GetToken_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Node_GetToken_Result WithResponse(::llcpp::fuchsia::io2::Node_GetToken_Response* val) {
    Node_GetToken_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Node_GetToken_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Node_GetToken_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_GetToken_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Node_GetToken_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_GetToken_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Node_GetToken_Result WithErr(int32_t* val) {
    Node_GetToken_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_GetToken_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_PosixSocketInfoTable;

// Auxiliary data for the POSIX socket representation of a node.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.posix.socket/Control`] protocol.
struct PosixSocketInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // The backing transport for the socket.
  // The rights on this socket should correspond to the rights on the
  // node connection.
  const ::zx::socket& socket() const {
    ZX_ASSERT(has_socket());
    return *reinterpret_cast<const ::zx::socket*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::socket& socket() {
    ZX_ASSERT(has_socket());
    return *reinterpret_cast<::zx::socket*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_socket() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  PosixSocketInfo() = default;
  ~PosixSocketInfo() = default;
  PosixSocketInfo(PosixSocketInfo&& other) noexcept = default;
  PosixSocketInfo& operator=(PosixSocketInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PosixSocketInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  PosixSocketInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class PosixSocketInfo::Builder {
 public:
  PosixSocketInfo view() { return PosixSocketInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // The backing transport for the socket.
  // The rights on this socket should correspond to the rights on the
  // node connection.
  Builder&& set_socket(::zx::socket* elem);

 private:
  Builder() = default;
  friend Builder PosixSocketInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_PipeInfoTable;

// The pipe representation of a node.
// A pipe is a data streaming interface, commonly used for standard in/out.
// There is no universal requirement as to if it is uni- or bi-directional.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.io2/Pipe`] protocol.
struct PipeInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // The backing socket transport for the pipe.
  // The rights on this socket should correspond to the rights on the
  // node connection.
  const ::zx::socket& socket() const {
    ZX_ASSERT(has_socket());
    return *reinterpret_cast<const ::zx::socket*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::socket& socket() {
    ZX_ASSERT(has_socket());
    return *reinterpret_cast<::zx::socket*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_socket() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  PipeInfo() = default;
  ~PipeInfo() = default;
  PipeInfo(PipeInfo&& other) noexcept = default;
  PipeInfo& operator=(PipeInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  PipeInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class PipeInfo::Builder {
 public:
  PipeInfo view() { return PipeInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // The backing socket transport for the pipe.
  // The rights on this socket should correspond to the rights on the
  // node connection.
  Builder&& set_socket(::zx::socket* elem);

 private:
  Builder() = default;
  friend Builder PipeInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_UpdateAttributes_ResultTable;

struct Node_UpdateAttributes_Result {
  Node_UpdateAttributes_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Node_UpdateAttributes_Result WithResponse(::llcpp::fuchsia::io2::Node_UpdateAttributes_Response* val) {
    Node_UpdateAttributes_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Node_UpdateAttributes_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Node_UpdateAttributes_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_UpdateAttributes_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Node_UpdateAttributes_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_UpdateAttributes_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Node_UpdateAttributes_Result WithErr(int32_t* val) {
    Node_UpdateAttributes_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_UpdateAttributes_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_Sync_ResultTable;

struct Node_Sync_Result {
  Node_Sync_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Node_Sync_Result WithResponse(::llcpp::fuchsia::io2::Node_Sync_Response* val) {
    Node_Sync_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Node_Sync_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Node_Sync_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_Sync_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Node_Sync_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_Sync_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Node_Sync_Result WithErr(int32_t* val) {
    Node_Sync_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_Sync_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_NodeAttributesTable;

// Objective information about a filesystem node.
// See [`Node.GetAttributes`] and [`Node.UpdateAttributes`].
//
// The attributes of a node should be stable, independent of the
// specific protocol used to access it.
//
// If a particular attribute is not applicable or not supported,
// filesystems should leave the corresponding field absent.
struct NodeAttributes final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Describes the kinds of representations supported by the node.
  // Note: This is not the result of the connection-time negotiation,
  // which is conveyed via `representation`.
  //
  // This attribute is read-only.
  const ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() const {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_protocols() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Describes the kinds of operations supported by the node.
  // Note: This is distinct from the rights used at connection time.
  //
  // This attribute is read-only.
  const ::llcpp::fuchsia::io2::Operations& abilities() const {
    ZX_ASSERT(has_abilities());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(2 - 1).data);
  }
  ::llcpp::fuchsia::io2::Operations& abilities() {
    ZX_ASSERT(has_abilities());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_abilities() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // Node size, in bytes.
  //
  // This attribute is read-only.
  const uint64_t& content_size() const {
    ZX_ASSERT(has_content_size());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(3 - 1).data);
  }
  uint64_t& content_size() {
    ZX_ASSERT(has_content_size());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_content_size() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  // Space needed to store the node (possibly larger than size), in bytes.
  //
  // This attribute is read-only.
  const uint64_t& storage_size() const {
    ZX_ASSERT(has_storage_size());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(4 - 1).data);
  }
  uint64_t& storage_size() {
    ZX_ASSERT(has_storage_size());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(4 - 1).data);
  }
  bool has_storage_size() const {
    return EnvelopesView::count() >= 4 && EnvelopesView::at(4 - 1).data != nullptr;
  }

  // Number of hard links to the node. It must be at least one.
  //
  // This attribute is read-only.
  const uint64_t& link_count() const {
    ZX_ASSERT(has_link_count());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(5 - 1).data);
  }
  uint64_t& link_count() {
    ZX_ASSERT(has_link_count());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(5 - 1).data);
  }
  bool has_link_count() const {
    return EnvelopesView::count() >= 5 && EnvelopesView::at(5 - 1).data != nullptr;
  }

  // Time of creation in nanoseconds since the Unix epoch, UTC.
  // It may be updated manually after creation.
  const uint64_t& creation_time() const {
    ZX_ASSERT(has_creation_time());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(6 - 1).data);
  }
  uint64_t& creation_time() {
    ZX_ASSERT(has_creation_time());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(6 - 1).data);
  }
  bool has_creation_time() const {
    return EnvelopesView::count() >= 6 && EnvelopesView::at(6 - 1).data != nullptr;
  }

  // Time of last modification in nanoseconds since the Unix epoch, UTC.
  const uint64_t& modification_time() const {
    ZX_ASSERT(has_modification_time());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(7 - 1).data);
  }
  uint64_t& modification_time() {
    ZX_ASSERT(has_modification_time());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(7 - 1).data);
  }
  bool has_modification_time() const {
    return EnvelopesView::count() >= 7 && EnvelopesView::at(7 - 1).data != nullptr;
  }

  // An ID for the node. See [`fuchsia.io2/Id`].
  // This `id` should be unique among all entries of a directory.
  //
  // This attribute is read-only.
  const uint64_t& id() const {
    ZX_ASSERT(has_id());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(8 - 1).data);
  }
  uint64_t& id() {
    ZX_ASSERT(has_id());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(8 - 1).data);
  }
  bool has_id() const {
    return EnvelopesView::count() >= 8 && EnvelopesView::at(8 - 1).data != nullptr;
  }

  NodeAttributes() = default;
  ~NodeAttributes() = default;
  NodeAttributes(NodeAttributes&& other) noexcept = default;
  NodeAttributes& operator=(NodeAttributes&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeAttributesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 192;
  static constexpr bool HasPointer = true;

 private:
  NodeAttributes(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class NodeAttributes::Builder {
 public:
  NodeAttributes view() { return NodeAttributes(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Describes the kinds of representations supported by the node.
  // Note: This is not the result of the connection-time negotiation,
  // which is conveyed via `representation`.
  //
  // This attribute is read-only.
  Builder&& set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem);

  // Describes the kinds of operations supported by the node.
  // Note: This is distinct from the rights used at connection time.
  //
  // This attribute is read-only.
  Builder&& set_abilities(::llcpp::fuchsia::io2::Operations* elem);

  // Node size, in bytes.
  //
  // This attribute is read-only.
  Builder&& set_content_size(uint64_t* elem);

  // Space needed to store the node (possibly larger than size), in bytes.
  //
  // This attribute is read-only.
  Builder&& set_storage_size(uint64_t* elem);

  // Number of hard links to the node. It must be at least one.
  //
  // This attribute is read-only.
  Builder&& set_link_count(uint64_t* elem);

  // Time of creation in nanoseconds since the Unix epoch, UTC.
  // It may be updated manually after creation.
  Builder&& set_creation_time(uint64_t* elem);

  // Time of last modification in nanoseconds since the Unix epoch, UTC.
  Builder&& set_modification_time(uint64_t* elem);

  // An ID for the node. See [`fuchsia.io2/Id`].
  // This `id` should be unique among all entries of a directory.
  //
  // This attribute is read-only.
  Builder&& set_id(uint64_t* elem);

 private:
  Builder() = default;
  friend Builder NodeAttributes::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 8> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_GetAttributes_ResultTable;

struct Node_GetAttributes_Result {
  Node_GetAttributes_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Node_GetAttributes_Result WithResponse(::llcpp::fuchsia::io2::Node_GetAttributes_Response* val) {
    Node_GetAttributes_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Node_GetAttributes_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Node_GetAttributes_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_GetAttributes_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Node_GetAttributes_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Node_GetAttributes_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Node_GetAttributes_Result WithErr(int32_t* val) {
    Node_GetAttributes_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_GetAttributes_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 208;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEntryTable;

// Information about an immediate child node of a directory.
//
// If a particular attribute is not applicable or not supported,
// implementations should leave the corresponding field absent.
struct DirectoryEntry final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Name of the node. This field must be present.
  const ::fidl::StringView& name() const {
    ZX_ASSERT(has_name());
    return *reinterpret_cast<const ::fidl::StringView*>(EnvelopesView::at(1 - 1).data);
  }
  ::fidl::StringView& name() {
    ZX_ASSERT(has_name());
    return *reinterpret_cast<::fidl::StringView*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_name() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Describes the kinds of representations supported by the node.
  const ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() const {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(2 - 1).data);
  }
  ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_protocols() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // Describes the kinds of operations supported by the node.
  const ::llcpp::fuchsia::io2::Operations& abilities() const {
    ZX_ASSERT(has_abilities());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  ::llcpp::fuchsia::io2::Operations& abilities() {
    ZX_ASSERT(has_abilities());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_abilities() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  // An ID for the node. See [`fuchsia.io2/Id`].
  // This `id` should be unique among all entries of a directory.
  const uint64_t& id() const {
    ZX_ASSERT(has_id());
    return *reinterpret_cast<const uint64_t*>(EnvelopesView::at(4 - 1).data);
  }
  uint64_t& id() {
    ZX_ASSERT(has_id());
    return *reinterpret_cast<uint64_t*>(EnvelopesView::at(4 - 1).data);
  }
  bool has_id() const {
    return EnvelopesView::count() >= 4 && EnvelopesView::at(4 - 1).data != nullptr;
  }

  DirectoryEntry() = default;
  ~DirectoryEntry() = default;
  DirectoryEntry(DirectoryEntry&& other) noexcept = default;
  DirectoryEntry& operator=(DirectoryEntry&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryEntryTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 360;
  static constexpr bool HasPointer = true;

 private:
  DirectoryEntry(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DirectoryEntry::Builder {
 public:
  DirectoryEntry view() { return DirectoryEntry(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Name of the node. This field must be present.
  Builder&& set_name(::fidl::StringView* elem);

  // Describes the kinds of representations supported by the node.
  Builder&& set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem);

  // Describes the kinds of operations supported by the node.
  Builder&& set_abilities(::llcpp::fuchsia::io2::Operations* elem);

  // An ID for the node. See [`fuchsia.io2/Id`].
  // This `id` should be unique among all entries of a directory.
  Builder&& set_id(uint64_t* elem);

 private:
  Builder() = default;
  friend Builder DirectoryEntry::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 4> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchedEventTable;

// Events returned from [`DirectoryWatcher.GetNext`].
struct DirectoryWatchedEvent {
  DirectoryWatchedEvent() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kExisting = 1,  // 0x1
    kIdle = 2,  // 0x2
    kAdded = 3,  // 0x3
    kRemoved = 4,  // 0x4
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_existing() const { return ordinal() == Ordinal::kExisting; }

  static DirectoryWatchedEvent WithExisting(::llcpp::fuchsia::io2::DirectoryEntry* val) {
    DirectoryWatchedEvent result;
    result.set_existing(val);
    return result;
  }

  // Indicates a node already existed in the directory when watching started.
  void set_existing(::llcpp::fuchsia::io2::DirectoryEntry* elem) {
    ordinal_ = Ordinal::kExisting;
    envelope_.data = static_cast<void*>(elem);
  }

  // Indicates a node already existed in the directory when watching started.
  ::llcpp::fuchsia::io2::DirectoryEntry& mutable_existing() {
    ZX_ASSERT(ordinal() == Ordinal::kExisting);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryEntry*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DirectoryEntry& existing() const {
    ZX_ASSERT(ordinal() == Ordinal::kExisting);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryEntry*>(envelope_.data);
  }

  bool is_idle() const { return ordinal() == Ordinal::kIdle; }

  static DirectoryWatchedEvent WithIdle(::llcpp::fuchsia::io2::IdleEvent* val) {
    DirectoryWatchedEvent result;
    result.set_idle(val);
    return result;
  }

  // Indicates that no more `existing` events will be sent.
  void set_idle(::llcpp::fuchsia::io2::IdleEvent* elem) {
    ordinal_ = Ordinal::kIdle;
    envelope_.data = static_cast<void*>(elem);
  }

  // Indicates that no more `existing` events will be sent.
  ::llcpp::fuchsia::io2::IdleEvent& mutable_idle() {
    ZX_ASSERT(ordinal() == Ordinal::kIdle);
    return *static_cast<::llcpp::fuchsia::io2::IdleEvent*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::IdleEvent& idle() const {
    ZX_ASSERT(ordinal() == Ordinal::kIdle);
    return *static_cast<::llcpp::fuchsia::io2::IdleEvent*>(envelope_.data);
  }

  bool is_added() const { return ordinal() == Ordinal::kAdded; }

  static DirectoryWatchedEvent WithAdded(::llcpp::fuchsia::io2::DirectoryEntry* val) {
    DirectoryWatchedEvent result;
    result.set_added(val);
    return result;
  }

  // Indicates a node has been created (either new or moved) into a
  // directory.
  void set_added(::llcpp::fuchsia::io2::DirectoryEntry* elem) {
    ordinal_ = Ordinal::kAdded;
    envelope_.data = static_cast<void*>(elem);
  }

  // Indicates a node has been created (either new or moved) into a
  // directory.
  ::llcpp::fuchsia::io2::DirectoryEntry& mutable_added() {
    ZX_ASSERT(ordinal() == Ordinal::kAdded);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryEntry*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DirectoryEntry& added() const {
    ZX_ASSERT(ordinal() == Ordinal::kAdded);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryEntry*>(envelope_.data);
  }

  bool is_removed() const { return ordinal() == Ordinal::kRemoved; }

  static DirectoryWatchedEvent WithRemoved(::fidl::StringView* val) {
    DirectoryWatchedEvent result;
    result.set_removed(val);
    return result;
  }

  // Indicates a node has been removed (either deleted or moved) from the
  // directory.
  void set_removed(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kRemoved;
    envelope_.data = static_cast<void*>(elem);
  }

  // Indicates a node has been removed (either deleted or moved) from the
  // directory.
  ::fidl::StringView& mutable_removed() {
    ZX_ASSERT(ordinal() == Ordinal::kRemoved);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& removed() const {
    ZX_ASSERT(ordinal() == Ordinal::kRemoved);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data;
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryWatchedEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 376;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kExisting = 1,  // 0x1
    kIdle = 2,  // 0x2
    kAdded = 3,  // 0x3
    kRemoved = 4,  // 0x4
  };

  Ordinal ordinal() const {
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1:
      case 1263581438:
        return Ordinal::kExisting;
      case 2:
      case 1234379794:
        return Ordinal::kIdle;
      case 3:
      case 1712492072:
        return Ordinal::kAdded;
      case 4:
      case 91294460:
        return Ordinal::kRemoved;
    }
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIterator_GetNext_ResultTable;

struct DirectoryIterator_GetNext_Result {
  DirectoryIterator_GetNext_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static DirectoryIterator_GetNext_Result WithResponse(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response* val) {
    DirectoryIterator_GetNext_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static DirectoryIterator_GetNext_Result WithErr(int32_t* val) {
    DirectoryIterator_GetNext_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryIterator_GetNext_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 3080208;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Write_ResultTable;

struct File_Write_Result {
  File_Write_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_Write_Result WithResponse(::llcpp::fuchsia::io2::File_Write_Response* val) {
    File_Write_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_Write_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_Write_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Write_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_Write_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Write_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_Write_Result WithErr(int32_t* val) {
    File_Write_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Write_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_WriteAt_ResultTable;

struct File_WriteAt_Result {
  File_WriteAt_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_WriteAt_Result WithResponse(::llcpp::fuchsia::io2::File_WriteAt_Response* val) {
    File_WriteAt_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_WriteAt_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_WriteAt_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_WriteAt_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_WriteAt_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_WriteAt_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_WriteAt_Result WithErr(int32_t* val) {
    File_WriteAt_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_WriteAt_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Seek_ResultTable;

struct File_Seek_Result {
  File_Seek_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_Seek_Result WithResponse(::llcpp::fuchsia::io2::File_Seek_Response* val) {
    File_Seek_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_Seek_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_Seek_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Seek_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_Seek_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Seek_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_Seek_Result WithErr(int32_t* val) {
    File_Seek_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Seek_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Resize_ResultTable;

struct File_Resize_Result {
  File_Resize_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static File_Resize_Result WithResponse(::llcpp::fuchsia::io2::File_Resize_Response* val) {
    File_Resize_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::File_Resize_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::File_Resize_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Resize_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::File_Resize_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::File_Resize_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static File_Resize_Result WithErr(int32_t* val) {
    File_Resize_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Resize_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_FileInfoTable;

// Auxiliary data for the file representation of a node.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.io2/File`] protocol.
struct FileInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // An optional event which transmits information about an object's
  // readability or writability. This event relays information about the
  // underlying object, not the capability granted to client: this event
  // may be signalled "readable" on a connection that does not have
  // the capability to read.
  //
  // This event will be present if the following conditions are met:
  //
  // - The `available_operations` on the file connection is not empty.
  // - The filesystem supports signalling readability/writability events.
  //
  // The [`FileSignal`] values may be observed on this event.
  const ::zx::event& observer() const {
    ZX_ASSERT(has_observer());
    return *reinterpret_cast<const ::zx::event*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::event& observer() {
    ZX_ASSERT(has_observer());
    return *reinterpret_cast<::zx::event*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_observer() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Returns if the file is opened in append mode.
  // In append mode, the seek offset is moved to the end before every
  // write, the two steps performed in an atomic manner.
  const bool& is_append() const {
    ZX_ASSERT(has_is_append());
    return *reinterpret_cast<const bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool& is_append() {
    ZX_ASSERT(has_is_append());
    return *reinterpret_cast<bool*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_is_append() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  FileInfo() = default;
  ~FileInfo() = default;
  FileInfo(FileInfo&& other) noexcept = default;
  FileInfo& operator=(FileInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr bool HasPointer = true;

 private:
  FileInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class FileInfo::Builder {
 public:
  FileInfo view() { return FileInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // An optional event which transmits information about an object's
  // readability or writability. This event relays information about the
  // underlying object, not the capability granted to client: this event
  // may be signalled "readable" on a connection that does not have
  // the capability to read.
  //
  // This event will be present if the following conditions are met:
  //
  // - The `available_operations` on the file connection is not empty.
  // - The filesystem supports signalling readability/writability events.
  //
  // The [`FileSignal`] values may be observed on this event.
  Builder&& set_observer(::zx::event* elem);

  // Returns if the file is opened in append mode.
  // In append mode, the seek offset is moved to the end before every
  // write, the two steps performed in an atomic manner.
  Builder&& set_is_append(bool* elem);

 private:
  Builder() = default;
  friend Builder FileInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 2> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Unlink_ResultTable;

struct Directory_Unlink_Result {
  Directory_Unlink_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Directory_Unlink_Result WithResponse(::llcpp::fuchsia::io2::Directory_Unlink_Response* val) {
    Directory_Unlink_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Directory_Unlink_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Directory_Unlink_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Unlink_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Directory_Unlink_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Unlink_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Directory_Unlink_Result WithErr(int32_t* val) {
    Directory_Unlink_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Unlink_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Rename_ResultTable;

struct Directory_Rename_Result {
  Directory_Rename_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Directory_Rename_Result WithResponse(::llcpp::fuchsia::io2::Directory_Rename_Response* val) {
    Directory_Rename_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Directory_Rename_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Directory_Rename_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Rename_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Directory_Rename_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Rename_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Directory_Rename_Result WithErr(int32_t* val) {
    Directory_Rename_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Rename_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Link_ResultTable;

struct Directory_Link_Result {
  Directory_Link_Result() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_response() const { return ordinal() == Ordinal::kResponse; }

  static Directory_Link_Result WithResponse(::llcpp::fuchsia::io2::Directory_Link_Response* val) {
    Directory_Link_Result result;
    result.set_response(val);
    return result;
  }

  void set_response(::llcpp::fuchsia::io2::Directory_Link_Response* elem) {
    ordinal_ = Ordinal::kResponse;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::Directory_Link_Response& mutable_response() {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Link_Response*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::Directory_Link_Response& response() const {
    ZX_ASSERT(ordinal() == Ordinal::kResponse);
    return *static_cast<::llcpp::fuchsia::io2::Directory_Link_Response*>(envelope_.data);
  }

  bool is_err() const { return ordinal() == Ordinal::kErr; }

  static Directory_Link_Result WithErr(int32_t* val) {
    Directory_Link_Result result;
    result.set_err(val);
    return result;
  }

  void set_err(int32_t* elem) {
    ordinal_ = Ordinal::kErr;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_err() {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal() == Ordinal::kErr);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Link_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchOptionsTable;

struct DirectoryWatchOptions final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  DirectoryWatchOptions() = default;
  ~DirectoryWatchOptions() = default;
  DirectoryWatchOptions(DirectoryWatchOptions&& other) noexcept = default;
  DirectoryWatchOptions& operator=(DirectoryWatchOptions&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryWatchOptionsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

 private:
  DirectoryWatchOptions(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DirectoryWatchOptions::Builder {
 public:
  DirectoryWatchOptions view() { return DirectoryWatchOptions(0, nullptr); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

 private:
  Builder() = default;
  friend Builder DirectoryWatchOptions::Build();
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryInfoTable;

// Auxiliary data for the directory representation of a node.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.io2/Directory`] protocol.
struct DirectoryInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  DirectoryInfo() = default;
  ~DirectoryInfo() = default;
  DirectoryInfo(DirectoryInfo&& other) noexcept = default;
  DirectoryInfo& operator=(DirectoryInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

 private:
  DirectoryInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DirectoryInfo::Builder {
 public:
  DirectoryInfo view() { return DirectoryInfo(0, nullptr); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

 private:
  Builder() = default;
  friend Builder DirectoryInfo::Build();
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEnumerateOptionsTable;

// Options to pass to [`fuchsia.io2/Directory.Enumerate`].
struct DirectoryEnumerateOptions final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  DirectoryEnumerateOptions() = default;
  ~DirectoryEnumerateOptions() = default;
  DirectoryEnumerateOptions(DirectoryEnumerateOptions&& other) noexcept = default;
  DirectoryEnumerateOptions& operator=(DirectoryEnumerateOptions&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryEnumerateOptionsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

 private:
  DirectoryEnumerateOptions(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DirectoryEnumerateOptions::Builder {
 public:
  DirectoryEnumerateOptions view() { return DirectoryEnumerateOptions(0, nullptr); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

 private:
  Builder() = default;
  friend Builder DirectoryEnumerateOptions::Build();
};

extern "C" const fidl_type_t v1_fuchsia_io2_DeviceInfoTable;

// The object may be cast to the shared interface of devices.
struct DeviceInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // An optional event which transmits information about a device's state.
  //
  // The [`DeviceSignal`] values may be observed on this event.
  const ::zx::eventpair& event() const {
    ZX_ASSERT(has_event());
    return *reinterpret_cast<const ::zx::eventpair*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::eventpair& event() {
    ZX_ASSERT(has_event());
    return *reinterpret_cast<::zx::eventpair*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_event() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  DeviceInfo() = default;
  ~DeviceInfo() = default;
  DeviceInfo(DeviceInfo&& other) noexcept = default;
  DeviceInfo& operator=(DeviceInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DeviceInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  DeviceInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DeviceInfo::Builder {
 public:
  DeviceInfo view() { return DeviceInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // An optional event which transmits information about a device's state.
  //
  // The [`DeviceSignal`] values may be observed on this event.
  Builder&& set_event(::zx::eventpair* elem);

 private:
  Builder() = default;
  friend Builder DeviceInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogInfoTable;

// The debuglog representation of a node.
// The selection of this variant in [`Representation`] implies that the
// connection speaks the [`fuchsia.io2/Debuglog`] protocol.
struct DebuglogInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // The backing debuglog kernel object.
  const ::zx::debuglog& debuglog() const {
    ZX_ASSERT(has_debuglog());
    return *reinterpret_cast<const ::zx::debuglog*>(EnvelopesView::at(1 - 1).data);
  }
  ::zx::debuglog& debuglog() {
    ZX_ASSERT(has_debuglog());
    return *reinterpret_cast<::zx::debuglog*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_debuglog() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  DebuglogInfo() = default;
  ~DebuglogInfo() = default;
  DebuglogInfo(DebuglogInfo&& other) noexcept = default;
  DebuglogInfo& operator=(DebuglogInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  DebuglogInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class DebuglogInfo::Builder {
 public:
  DebuglogInfo view() { return DebuglogInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // The backing debuglog kernel object.
  Builder&& set_debuglog(::zx::debuglog* elem);

 private:
  Builder() = default;
  friend Builder DebuglogInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_ConnectorInfoTable;

// Auxiliary data for the connector representation of a node, used for
// protocol discovery and connection.
//
// It supports connecting to arbitrary protocols exported by the filesystem
// server at a path, including ones that do not compose [`fuchsia.io2/Node`].
struct ConnectorInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  ConnectorInfo() = default;
  ~ConnectorInfo() = default;
  ConnectorInfo(ConnectorInfo&& other) noexcept = default;
  ConnectorInfo& operator=(ConnectorInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_ConnectorInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

 private:
  ConnectorInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class ConnectorInfo::Builder {
 public:
  ConnectorInfo view() { return ConnectorInfo(0, nullptr); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

 private:
  Builder() = default;
  friend Builder ConnectorInfo::Build();
};

extern "C" const fidl_type_t v1_fuchsia_io2_RepresentationTable;

// Describes how the connection should be handled, and provides auxiliary
// handles and information for the connection where applicable.
// Refer to [`Node.Describe`] and [`Node.OnConnectionInfo`].
//
// If handles are returned which offer alternative ways of access to the node,
// the rights on the handles should correspond to the rights on the connection.
//
// If the client specified more than one protocol in `protocols` during
// [`Directory.Open`] or [`Node.Reopen`], the [`Representation`] xunion carries
// additionally the result of the connection-time negotiation via its tag.
//
// The elements have one-to-one correspondence with the members of
// [`NodeProtocolSet`].
struct Representation {
  Representation() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kConnector = 1,  // 0x1
    kDirectory = 2,  // 0x2
    kFile = 3,  // 0x3
    kMemory = 4,  // 0x4
    kPosixSocket = 5,  // 0x5
    kPipe = 6,  // 0x6
    kDebuglog = 7,  // 0x7
    kDevice = 8,  // 0x8
    kTty = 9,  // 0x9
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_connector() const { return ordinal() == Ordinal::kConnector; }

  static Representation WithConnector(::llcpp::fuchsia::io2::ConnectorInfo* val) {
    Representation result;
    result.set_connector(val);
    return result;
  }

  // See [`NodeProtocolSet.CONNECTOR`].
  void set_connector(::llcpp::fuchsia::io2::ConnectorInfo* elem) {
    ordinal_ = Ordinal::kConnector;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.CONNECTOR`].
  ::llcpp::fuchsia::io2::ConnectorInfo& mutable_connector() {
    ZX_ASSERT(ordinal() == Ordinal::kConnector);
    return *static_cast<::llcpp::fuchsia::io2::ConnectorInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::ConnectorInfo& connector() const {
    ZX_ASSERT(ordinal() == Ordinal::kConnector);
    return *static_cast<::llcpp::fuchsia::io2::ConnectorInfo*>(envelope_.data);
  }

  bool is_directory() const { return ordinal() == Ordinal::kDirectory; }

  static Representation WithDirectory(::llcpp::fuchsia::io2::DirectoryInfo* val) {
    Representation result;
    result.set_directory(val);
    return result;
  }

  // See [`NodeProtocolSet.DIRECTORY`].
  void set_directory(::llcpp::fuchsia::io2::DirectoryInfo* elem) {
    ordinal_ = Ordinal::kDirectory;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.DIRECTORY`].
  ::llcpp::fuchsia::io2::DirectoryInfo& mutable_directory() {
    ZX_ASSERT(ordinal() == Ordinal::kDirectory);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DirectoryInfo& directory() const {
    ZX_ASSERT(ordinal() == Ordinal::kDirectory);
    return *static_cast<::llcpp::fuchsia::io2::DirectoryInfo*>(envelope_.data);
  }

  bool is_file() const { return ordinal() == Ordinal::kFile; }

  static Representation WithFile(::llcpp::fuchsia::io2::FileInfo* val) {
    Representation result;
    result.set_file(val);
    return result;
  }

  // See [`NodeProtocolSet.FILE`].
  void set_file(::llcpp::fuchsia::io2::FileInfo* elem) {
    ordinal_ = Ordinal::kFile;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.FILE`].
  ::llcpp::fuchsia::io2::FileInfo& mutable_file() {
    ZX_ASSERT(ordinal() == Ordinal::kFile);
    return *static_cast<::llcpp::fuchsia::io2::FileInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::FileInfo& file() const {
    ZX_ASSERT(ordinal() == Ordinal::kFile);
    return *static_cast<::llcpp::fuchsia::io2::FileInfo*>(envelope_.data);
  }

  bool is_memory() const { return ordinal() == Ordinal::kMemory; }

  static Representation WithMemory(::llcpp::fuchsia::io2::MemoryInfo* val) {
    Representation result;
    result.set_memory(val);
    return result;
  }

  // See [`NodeProtocolSet.MEMORY`].
  void set_memory(::llcpp::fuchsia::io2::MemoryInfo* elem) {
    ordinal_ = Ordinal::kMemory;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.MEMORY`].
  ::llcpp::fuchsia::io2::MemoryInfo& mutable_memory() {
    ZX_ASSERT(ordinal() == Ordinal::kMemory);
    return *static_cast<::llcpp::fuchsia::io2::MemoryInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::MemoryInfo& memory() const {
    ZX_ASSERT(ordinal() == Ordinal::kMemory);
    return *static_cast<::llcpp::fuchsia::io2::MemoryInfo*>(envelope_.data);
  }

  bool is_posix_socket() const { return ordinal() == Ordinal::kPosixSocket; }

  static Representation WithPosixSocket(::llcpp::fuchsia::io2::PosixSocketInfo* val) {
    Representation result;
    result.set_posix_socket(val);
    return result;
  }

  // See [`NodeProtocolSet.POSIX_SOCKET`].
  void set_posix_socket(::llcpp::fuchsia::io2::PosixSocketInfo* elem) {
    ordinal_ = Ordinal::kPosixSocket;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.POSIX_SOCKET`].
  ::llcpp::fuchsia::io2::PosixSocketInfo& mutable_posix_socket() {
    ZX_ASSERT(ordinal() == Ordinal::kPosixSocket);
    return *static_cast<::llcpp::fuchsia::io2::PosixSocketInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::PosixSocketInfo& posix_socket() const {
    ZX_ASSERT(ordinal() == Ordinal::kPosixSocket);
    return *static_cast<::llcpp::fuchsia::io2::PosixSocketInfo*>(envelope_.data);
  }

  bool is_pipe() const { return ordinal() == Ordinal::kPipe; }

  static Representation WithPipe(::llcpp::fuchsia::io2::PipeInfo* val) {
    Representation result;
    result.set_pipe(val);
    return result;
  }

  // See [`NodeProtocolSet.PIPE`].
  void set_pipe(::llcpp::fuchsia::io2::PipeInfo* elem) {
    ordinal_ = Ordinal::kPipe;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.PIPE`].
  ::llcpp::fuchsia::io2::PipeInfo& mutable_pipe() {
    ZX_ASSERT(ordinal() == Ordinal::kPipe);
    return *static_cast<::llcpp::fuchsia::io2::PipeInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::PipeInfo& pipe() const {
    ZX_ASSERT(ordinal() == Ordinal::kPipe);
    return *static_cast<::llcpp::fuchsia::io2::PipeInfo*>(envelope_.data);
  }

  bool is_debuglog() const { return ordinal() == Ordinal::kDebuglog; }

  static Representation WithDebuglog(::llcpp::fuchsia::io2::DebuglogInfo* val) {
    Representation result;
    result.set_debuglog(val);
    return result;
  }

  // See [`NodeProtocolSet.DEBUGLOG`].
  void set_debuglog(::llcpp::fuchsia::io2::DebuglogInfo* elem) {
    ordinal_ = Ordinal::kDebuglog;
    envelope_.data = static_cast<void*>(elem);
  }

  // See [`NodeProtocolSet.DEBUGLOG`].
  ::llcpp::fuchsia::io2::DebuglogInfo& mutable_debuglog() {
    ZX_ASSERT(ordinal() == Ordinal::kDebuglog);
    return *static_cast<::llcpp::fuchsia::io2::DebuglogInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DebuglogInfo& debuglog() const {
    ZX_ASSERT(ordinal() == Ordinal::kDebuglog);
    return *static_cast<::llcpp::fuchsia::io2::DebuglogInfo*>(envelope_.data);
  }

  bool is_device() const { return ordinal() == Ordinal::kDevice; }

  static Representation WithDevice(::llcpp::fuchsia::io2::DeviceInfo* val) {
    Representation result;
    result.set_device(val);
    return result;
  }

  void set_device(::llcpp::fuchsia::io2::DeviceInfo* elem) {
    ordinal_ = Ordinal::kDevice;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::DeviceInfo& mutable_device() {
    ZX_ASSERT(ordinal() == Ordinal::kDevice);
    return *static_cast<::llcpp::fuchsia::io2::DeviceInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::DeviceInfo& device() const {
    ZX_ASSERT(ordinal() == Ordinal::kDevice);
    return *static_cast<::llcpp::fuchsia::io2::DeviceInfo*>(envelope_.data);
  }

  bool is_tty() const { return ordinal() == Ordinal::kTty; }

  static Representation WithTty(::llcpp::fuchsia::io2::TtyInfo* val) {
    Representation result;
    result.set_tty(val);
    return result;
  }

  void set_tty(::llcpp::fuchsia::io2::TtyInfo* elem) {
    ordinal_ = Ordinal::kTty;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fuchsia::io2::TtyInfo& mutable_tty() {
    ZX_ASSERT(ordinal() == Ordinal::kTty);
    return *static_cast<::llcpp::fuchsia::io2::TtyInfo*>(envelope_.data);
  }
  const ::llcpp::fuchsia::io2::TtyInfo& tty() const {
    ZX_ASSERT(ordinal() == Ordinal::kTty);
    return *static_cast<::llcpp::fuchsia::io2::TtyInfo*>(envelope_.data);
  }
  void* unknownData() const {
    ZX_ASSERT(which() == Tag::kUnknown);
    return envelope_.data;
  }
  Tag which() const;

  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_RepresentationTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 64;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kConnector = 1,  // 0x1
    kDirectory = 2,  // 0x2
    kFile = 3,  // 0x3
    kMemory = 4,  // 0x4
    kPosixSocket = 5,  // 0x5
    kPipe = 6,  // 0x6
    kDebuglog = 7,  // 0x7
    kDevice = 8,  // 0x8
    kTty = 9,  // 0x9
  };

  Ordinal ordinal() const {
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1:
      case 1071926213:
        return Ordinal::kConnector;
      case 2:
      case 1691175305:
        return Ordinal::kDirectory;
      case 3:
      case 1881902475:
        return Ordinal::kFile;
      case 4:
      case 1844477091:
        return Ordinal::kMemory;
      case 5:
      case 220595477:
        return Ordinal::kPosixSocket;
      case 6:
      case 439014286:
        return Ordinal::kPipe;
      case 7:
      case 718851311:
        return Ordinal::kDebuglog;
      case 8:
      case 1049166327:
        return Ordinal::kDevice;
      case 9:
      case 1598881365:
        return Ordinal::kTty;
    }
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fuchsia_io2_ConnectionInfoTable;

// Returns run-time information about a node that is specific to the
// current connection.
struct ConnectionInfo final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // The active variant corresponds to one of the supported protocols
  // of the node, and represents the result of the connection-time
  // negotiation. Provides auxiliary handles if applicable.
  const ::llcpp::fuchsia::io2::Representation& representation() const {
    ZX_ASSERT(has_representation());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Representation*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::io2::Representation& representation() {
    ZX_ASSERT(has_representation());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Representation*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_representation() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Information about the rights possessed by the current connection.
  // Note: `rights` limits the set of operations allowed on the connection,
  // but does not guarantee their availability. For example, one may have
  // the [`Rights.EXECUTE`] right on a file connection, but the file itself
  // does not have the `EXECUTE` ability, and hence cannot be executed.
  // See [`ConnectionOptions.rights`].
  const ::llcpp::fuchsia::io2::Operations& rights() const {
    ZX_ASSERT(has_rights());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(2 - 1).data);
  }
  ::llcpp::fuchsia::io2::Operations& rights() {
    ZX_ASSERT(has_rights());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_rights() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // The set of available operations on this channel. It is always the
  // intersection between the rights possessed by this connection, and the
  // abilities of the node. The value may be zero in the case of an empty
  // intersection.
  // See [`ConnectionOptions.rights`].
  const ::llcpp::fuchsia::io2::Operations& available_operations() const {
    ZX_ASSERT(has_available_operations());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  ::llcpp::fuchsia::io2::Operations& available_operations() {
    ZX_ASSERT(has_available_operations());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_available_operations() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  ConnectionInfo() = default;
  ~ConnectionInfo() = default;
  ConnectionInfo(ConnectionInfo&& other) noexcept = default;
  ConnectionInfo& operator=(ConnectionInfo&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_ConnectionInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 152;
  static constexpr bool HasPointer = true;

 private:
  ConnectionInfo(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class ConnectionInfo::Builder {
 public:
  ConnectionInfo view() { return ConnectionInfo(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // The active variant corresponds to one of the supported protocols
  // of the node, and represents the result of the connection-time
  // negotiation. Provides auxiliary handles if applicable.
  Builder&& set_representation(::llcpp::fuchsia::io2::Representation* elem);

  // Information about the rights possessed by the current connection.
  // Note: `rights` limits the set of operations allowed on the connection,
  // but does not guarantee their availability. For example, one may have
  // the [`Rights.EXECUTE`] right on a file connection, but the file itself
  // does not have the `EXECUTE` ability, and hence cannot be executed.
  // See [`ConnectionOptions.rights`].
  Builder&& set_rights(::llcpp::fuchsia::io2::Operations* elem);

  // The set of available operations on this channel. It is always the
  // intersection between the rights possessed by this connection, and the
  // abilities of the node. The value may be zero in the case of an empty
  // intersection.
  // See [`ConnectionOptions.rights`].
  Builder&& set_available_operations(::llcpp::fuchsia::io2::Operations* elem);

 private:
  Builder() = default;
  friend Builder ConnectionInfo::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 3> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_ConnectionOptionsTable;

// Options for [`Directory.Open`] and [`Node.Reopen`].
struct ConnectionOptions final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  // Flags which can affect the behavior when opening and reopening.
  // If absent, assumes a default of zero.
  const ::llcpp::fuchsia::io2::ConnectionFlags& flags() const {
    ZX_ASSERT(has_flags());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::ConnectionFlags*>(EnvelopesView::at(1 - 1).data);
  }
  ::llcpp::fuchsia::io2::ConnectionFlags& flags() {
    ZX_ASSERT(has_flags());
    return *reinterpret_cast<::llcpp::fuchsia::io2::ConnectionFlags*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_flags() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  // Specifies the set of representations accepted by the client, to support
  // a form of protocol negotiation on the node being opened.
  // Refer to the definition of [`NodeProtocolSet`] for more details.
  // It cannot be zero.
  //
  // In addition, clients may assert the type of the object by setting
  // the protocol corresponding to the expected type:
  //
  // * If the caller expected a directory but the node cannot be accessed
  //   as a directory, the error is `ZX_ERR_NOT_DIR`.
  // * If the caller expected a file but the node cannot be accessed as a
  //   file, the error is `ZX_ERR_NOT_FILE`.
  // * In other mismatched cases, the error is `ZX_ERR_WRONG_TYPE`.
  //
  // During [`Directory.Open`], if a new object is to be created, `protocols`
  // determines the type of object to create; it must be present.
  // If a valid object type cannot be unambiguously inferred e.g.
  // both `DIRECTORY` and `FILE` were set, the request must fail.
  //
  // During [`Node.Reopen`], clients may specify a different but compatible
  // `protocols` to do a "protocol upgrade".
  //
  // If more than one protocol is present in `protocols`, the resultant
  // protocol may become any one of them. Clients should specify
  // [`ConnectionFlags.GET_CONNECTION_INFO`] to receive a
  // [`Node.OnConnectionInfo`] event, in order to ascertain the protocol.
  //
  // If absent, indicates that the caller accepts any type of node, and
  // the resulting protocol is unspecified.
  const ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() const {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(2 - 1).data);
  }
  ::llcpp::fuchsia::io2::NodeProtocolSet& protocols() {
    ZX_ASSERT(has_protocols());
    return *reinterpret_cast<::llcpp::fuchsia::io2::NodeProtocolSet*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_protocols() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  // Requests the specified rights on the new connection. If absent, inherits
  // the same rights as the source connection.
  //
  // ## Rights Hierarchy
  //
  // Respecting principles of least privileges, `rights` must meet the
  // following restrictions:
  //
  // * A connection must have nonzero rights.
  // * Rights must never increase in a derived connection:
  //   + During [`Directory.Open`], you may only request the same rights as
  //     what the directory connection already has, or a subset of those.
  //   + During [`Node.Reopen`], similarly, you may only request the same or
  //     a subset of rights possessed by the original connection.
  // * Exceeding those rights causes `object_request` to be closed with a
  //   `ZX_ERR_ACCESS_DENIED` epitaph.
  //
  // The proper enforcement of the rights hierarchy is a powerful refinement
  // over the existing access control facilities offered by directory
  // sandboxing. The rights manipulation should be implemented mechanically
  // without knowledge of any specific rights, and servers should propagate
  // unknown bits members, to gracefully handle future rights extensions.
  //
  // ## Rights Inheritance
  //
  // Absent `rights` field means inheriting the same rights as the source.
  //
  // * During [`Node.Reopen`], the new connection would have the same rights
  //   as the connection where the `Reopen` call is made.
  // * During [`Directory.Open`], the connection would have the same
  //   rights as the connection where the `Open` call is made.
  //
  // Note: `rights` limits the set of operations allowed on the new
  // connection, but does not guarantee their availability. For convenience,
  // clients may query the [`ConnectionInfo.available_operations`] field on a
  // new connection, which is the intersection of the rights and abilities
  // and indicates the guaranteed set of available operations.
  //
  // See [`fuchsia.io2/Rights`] and [`fuchsia.io2/Abilities`].
  const ::llcpp::fuchsia::io2::Operations& rights() const {
    ZX_ASSERT(has_rights());
    return *reinterpret_cast<const ::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  ::llcpp::fuchsia::io2::Operations& rights() {
    ZX_ASSERT(has_rights());
    return *reinterpret_cast<::llcpp::fuchsia::io2::Operations*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_rights() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  ConnectionOptions() = default;
  ~ConnectionOptions() = default;
  ConnectionOptions(ConnectionOptions&& other) noexcept = default;
  ConnectionOptions& operator=(ConnectionOptions&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_ConnectionOptionsTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 72;
  static constexpr bool HasPointer = true;

 private:
  ConnectionOptions(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class ConnectionOptions::Builder {
 public:
  ConnectionOptions view() { return ConnectionOptions(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  // Flags which can affect the behavior when opening and reopening.
  // If absent, assumes a default of zero.
  Builder&& set_flags(::llcpp::fuchsia::io2::ConnectionFlags* elem);

  // Specifies the set of representations accepted by the client, to support
  // a form of protocol negotiation on the node being opened.
  // Refer to the definition of [`NodeProtocolSet`] for more details.
  // It cannot be zero.
  //
  // In addition, clients may assert the type of the object by setting
  // the protocol corresponding to the expected type:
  //
  // * If the caller expected a directory but the node cannot be accessed
  //   as a directory, the error is `ZX_ERR_NOT_DIR`.
  // * If the caller expected a file but the node cannot be accessed as a
  //   file, the error is `ZX_ERR_NOT_FILE`.
  // * In other mismatched cases, the error is `ZX_ERR_WRONG_TYPE`.
  //
  // During [`Directory.Open`], if a new object is to be created, `protocols`
  // determines the type of object to create; it must be present.
  // If a valid object type cannot be unambiguously inferred e.g.
  // both `DIRECTORY` and `FILE` were set, the request must fail.
  //
  // During [`Node.Reopen`], clients may specify a different but compatible
  // `protocols` to do a "protocol upgrade".
  //
  // If more than one protocol is present in `protocols`, the resultant
  // protocol may become any one of them. Clients should specify
  // [`ConnectionFlags.GET_CONNECTION_INFO`] to receive a
  // [`Node.OnConnectionInfo`] event, in order to ascertain the protocol.
  //
  // If absent, indicates that the caller accepts any type of node, and
  // the resulting protocol is unspecified.
  Builder&& set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem);

  // Requests the specified rights on the new connection. If absent, inherits
  // the same rights as the source connection.
  //
  // ## Rights Hierarchy
  //
  // Respecting principles of least privileges, `rights` must meet the
  // following restrictions:
  //
  // * A connection must have nonzero rights.
  // * Rights must never increase in a derived connection:
  //   + During [`Directory.Open`], you may only request the same rights as
  //     what the directory connection already has, or a subset of those.
  //   + During [`Node.Reopen`], similarly, you may only request the same or
  //     a subset of rights possessed by the original connection.
  // * Exceeding those rights causes `object_request` to be closed with a
  //   `ZX_ERR_ACCESS_DENIED` epitaph.
  //
  // The proper enforcement of the rights hierarchy is a powerful refinement
  // over the existing access control facilities offered by directory
  // sandboxing. The rights manipulation should be implemented mechanically
  // without knowledge of any specific rights, and servers should propagate
  // unknown bits members, to gracefully handle future rights extensions.
  //
  // ## Rights Inheritance
  //
  // Absent `rights` field means inheriting the same rights as the source.
  //
  // * During [`Node.Reopen`], the new connection would have the same rights
  //   as the connection where the `Reopen` call is made.
  // * During [`Directory.Open`], the connection would have the same
  //   rights as the connection where the `Open` call is made.
  //
  // Note: `rights` limits the set of operations allowed on the new
  // connection, but does not guarantee their availability. For convenience,
  // clients may query the [`ConnectionInfo.available_operations`] field on a
  // new connection, which is the intersection of the rights and abilities
  // and indicates the guaranteed set of available operations.
  //
  // See [`fuchsia.io2/Rights`] and [`fuchsia.io2/Abilities`].
  Builder&& set_rights(::llcpp::fuchsia::io2::Operations* elem);

 private:
  Builder() = default;
  friend Builder ConnectionOptions::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 3> envelopes_ = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_GetMemRange_ResponseTable;

struct File_GetMemRange_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_GetMemRange_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  ::llcpp::fuchsia::mem::Range buffer = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Read_ResponseTable;

struct File_Read_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Read_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8192;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<uint8_t> data = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_ReadAt_ResponseTable;

struct File_ReadAt_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_ReadAt_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8192;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<uint8_t> data = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_GetToken_ResponseTable;

struct Node_GetToken_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_GetToken_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  ::zx::handle token = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_UpdateAttributes_ResponseTable;

struct Node_UpdateAttributes_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_UpdateAttributes_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_Sync_ResponseTable;

struct Node_Sync_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_Sync_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

// The maximum I/O size that is allowed for read/write operations using
// byte vectors.
constexpr uint64_t MAX_TRANSFER_SIZE = 8192u;

// The maximum length, in bytes, of a filesystem path.
constexpr uint64_t MAX_PATH_LENGTH = 4095u;

// The maximum length, in bytes, of a single filesystem component.
constexpr uint64_t MAX_NAME_LENGTH = 255u;

// The maximum number of directory entires or watcher events returned
// in a batch by a hanging-get pattern.
constexpr uint64_t MAX_DIRECTORY_BATCH_SIZE = 8192u;

extern "C" const fidl_type_t v1_fuchsia_io2_IdleEventTable;

struct IdleEvent {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_IdleEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Node_GetAttributes_ResponseTable;

struct Node_GetAttributes_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Node_GetAttributes_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 192;
  static constexpr bool HasPointer = true;

  ::llcpp::fuchsia::io2::NodeAttributes attributes = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatcherGetNextRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatcherGetNextResponseTable;

// DirectoryWatcher transmits messages from a filesystem server about
// events happening in the filesystem. Clients can register new watchers
// using the [`fuchsia.io2/Directory.Watch`] method, where they can
// filter which events they want to receive notifications for.
class DirectoryWatcher final {
  DirectoryWatcher() = delete;
 public:

  struct GetNextResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryWatchedEvent> events;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryWatcherGetNextResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 3276800;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetNextRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetNext_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetNext_Impl(::zx::unowned_channel _client_end);
      ~GetNext_Impl() = default;
      GetNext_Impl(GetNext_Impl&& other) = default;
      GetNext_Impl& operator=(GetNext_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetNext = GetNext_Impl<GetNextResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetNext_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetNext_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetNext_Impl() = default;
      GetNext_Impl(GetNext_Impl&& other) = default;
      GetNext_Impl& operator=(GetNext_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetNext = GetNext_Impl<GetNextResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // A hanging get to obtain the next batch of events.
    //
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // Clients should attempt to maintain one in-flight `GetNext` call as much
    // as possible. If `GetNext` is not constantly polled, the filesystem
    // server might hit an upper limit on the number of buffered events,
    // resulting in dropping. Should this happen, the connection will be closed
    // with a `ZX_ERR_IO_OVERRUN` epitaph.
    //
    // When the watched directory is deleted, this connection will be closed
    // with a `ZX_ERR_UNAVAILABLE` epitaph.
    // When the filesystem server is dying, this connection will be closed
    // with a `ZX_ERR_PEER_CLOSED` epitaph.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetNext GetNext();

    // A hanging get to obtain the next batch of events.
    //
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // Clients should attempt to maintain one in-flight `GetNext` call as much
    // as possible. If `GetNext` is not constantly polled, the filesystem
    // server might hit an upper limit on the number of buffered events,
    // resulting in dropping. Should this happen, the connection will be closed
    // with a `ZX_ERR_IO_OVERRUN` epitaph.
    //
    // When the watched directory is deleted, this connection will be closed
    // with a `ZX_ERR_UNAVAILABLE` epitaph.
    // When the filesystem server is dying, this connection will be closed
    // with a `ZX_ERR_PEER_CLOSED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetNext GetNext(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // A hanging get to obtain the next batch of events.
    //
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // Clients should attempt to maintain one in-flight `GetNext` call as much
    // as possible. If `GetNext` is not constantly polled, the filesystem
    // server might hit an upper limit on the number of buffered events,
    // resulting in dropping. Should this happen, the connection will be closed
    // with a `ZX_ERR_IO_OVERRUN` epitaph.
    //
    // When the watched directory is deleted, this connection will be closed
    // with a `ZX_ERR_UNAVAILABLE` epitaph.
    // When the filesystem server is dying, this connection will be closed
    // with a `ZX_ERR_PEER_CLOSED` epitaph.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetNext GetNext(::zx::unowned_channel _client_end);

    // A hanging get to obtain the next batch of events.
    //
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // Clients should attempt to maintain one in-flight `GetNext` call as much
    // as possible. If `GetNext` is not constantly polled, the filesystem
    // server might hit an upper limit on the number of buffered events,
    // resulting in dropping. Should this happen, the connection will be closed
    // with a `ZX_ERR_IO_OVERRUN` epitaph.
    //
    // When the watched directory is deleted, this connection will be closed
    // with a `ZX_ERR_UNAVAILABLE` epitaph.
    // When the filesystem server is dying, this connection will be closed
    // with a `ZX_ERR_PEER_CLOSED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetNext GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // A hanging get to obtain the next batch of events.
    //
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // Clients should attempt to maintain one in-flight `GetNext` call as much
    // as possible. If `GetNext` is not constantly polled, the filesystem
    // server might hit an upper limit on the number of buffered events,
    // resulting in dropping. Should this happen, the connection will be closed
    // with a `ZX_ERR_IO_OVERRUN` epitaph.
    //
    // When the watched directory is deleted, this connection will be closed
    // with a `ZX_ERR_UNAVAILABLE` epitaph.
    // When the filesystem server is dying, this connection will be closed
    // with a `ZX_ERR_PEER_CLOSED` epitaph.
    static ::fidl::DecodeResult<GetNextResponse> GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DirectoryWatcher;
    using _Base = ::fidl::CompleterBase;

    class GetNextCompleterBase : public _Base {
     public:
      void Reply(::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryWatchedEvent> events);
      void Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryWatchedEvent> events);
      void Reply(::fidl::DecodedMessage<GetNextResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetNextCompleter = ::fidl::Completer<GetNextCompleterBase>;

    virtual void GetNext(GetNextCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetNextRequest(const ::fidl::DecodedMessage<DirectoryWatcher::GetNextRequest>& _msg);
    static void GetNextResponse(const ::fidl::DecodedMessage<DirectoryWatcher::GetNextResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIterator_GetNext_ResponseTable;

struct DirectoryIterator_GetNext_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryIterator_GetNext_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 3080192;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryEntry> entries = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIteratorGetNextRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIteratorGetNextResponseTable;

class DirectoryIterator final {
  DirectoryIterator() = delete;
 public:

  struct GetNextResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryIteratorGetNextResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 3080208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetNextRequest = ::fidl::AnyZeroArgMessage;


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetNext_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetNext_Impl(::zx::unowned_channel _client_end);
      ~GetNext_Impl() = default;
      GetNext_Impl(GetNext_Impl&& other) = default;
      GetNext_Impl& operator=(GetNext_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetNext = GetNext_Impl<GetNextResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetNext_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetNext_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetNext_Impl() = default;
      GetNext_Impl(GetNext_Impl&& other) = default;
      GetNext_Impl& operator=(GetNext_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetNext = GetNext_Impl<GetNextResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Reads a collection of variably sized directory entries into a buffer.
    //
    // The number of entries in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to `Enumerate`.
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // When the end of iteration is reached, the returned `entries` vector
    // will be empty.
    //
    // This method does not require any rights, as the rights are checked
    // in the [`Directory.Enumerate`] call.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetNext GetNext();

    // Reads a collection of variably sized directory entries into a buffer.
    //
    // The number of entries in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to `Enumerate`.
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // When the end of iteration is reached, the returned `entries` vector
    // will be empty.
    //
    // This method does not require any rights, as the rights are checked
    // in the [`Directory.Enumerate`] call.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetNext GetNext(::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Reads a collection of variably sized directory entries into a buffer.
    //
    // The number of entries in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to `Enumerate`.
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // When the end of iteration is reached, the returned `entries` vector
    // will be empty.
    //
    // This method does not require any rights, as the rights are checked
    // in the [`Directory.Enumerate`] call.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetNext GetNext(::zx::unowned_channel _client_end);

    // Reads a collection of variably sized directory entries into a buffer.
    //
    // The number of entries in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to `Enumerate`.
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // When the end of iteration is reached, the returned `entries` vector
    // will be empty.
    //
    // This method does not require any rights, as the rights are checked
    // in the [`Directory.Enumerate`] call.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetNext GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Reads a collection of variably sized directory entries into a buffer.
    //
    // The number of entries in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to `Enumerate`.
    // The caller should always use a receiving buffer size as large as the
    // maximum channel limit.
    //
    // When the end of iteration is reached, the returned `entries` vector
    // will be empty.
    //
    // This method does not require any rights, as the rights are checked
    // in the [`Directory.Enumerate`] call.
    static ::fidl::DecodeResult<GetNextResponse> GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DirectoryIterator;
    using _Base = ::fidl::CompleterBase;

    class GetNextCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result result);
      void ReplySuccess(::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryEntry> entries);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryEntry> entries);
      void Reply(::fidl::DecodedMessage<GetNextResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetNextCompleter = ::fidl::Completer<GetNextCompleterBase>;

    virtual void GetNext(GetNextCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetNextRequest(const ::fidl::DecodedMessage<DirectoryIterator::GetNextRequest>& _msg);
    static void GetNextResponse(const ::fidl::DecodedMessage<DirectoryIterator::GetNextResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Write_ResponseTable;

struct File_Write_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Write_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t actual_count = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_WriteAt_ResponseTable;

struct File_WriteAt_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_WriteAt_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t actual_count = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Seek_ResponseTable;

struct File_Seek_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Seek_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t offset_from_start = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_File_Resize_ResponseTable;

struct File_Resize_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_File_Resize_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Unlink_ResponseTable;

struct Directory_Unlink_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Unlink_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Rename_ResponseTable;

struct Directory_Rename_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Rename_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_Directory_Link_ResponseTable;

struct Directory_Link_Response {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_Directory_Link_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};
};

extern "C" const fidl_type_t v1_fuchsia_io2_NodeReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeSyncResponseTable;

// Node defines the minimal protocol for entities which can be accessed
// in a filesystem.
class Node final {
  Node() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_NodeSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Node;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<Node::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Node::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Node::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Node::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<Node::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Node::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Node::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<Node::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<Node::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<Node::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<Node::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Node::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Node::SyncResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_PipeReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeSyncResponseTable;

// A node for streaming unstructured data.
// No pipe-specific methods are provided by this protocol. The client should
// access the pipe via the socket object returned from the `PipeInfo` member
// in [`fuchsia.io2/Representation`].
class Pipe final {
  Pipe() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_PipeSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Pipe;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<Pipe::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Pipe::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Pipe::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Pipe::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<Pipe::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Pipe::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Pipe::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<Pipe::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<Pipe::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<Pipe::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<Pipe::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Pipe::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Pipe::SyncResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_MemoryReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemorySyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemorySyncResponseTable;

// A file-like node backed by a VMO.
// No memory-specific methods are provided by this protocol.
// The client should access it via the the [`MemoryInfo.buffer`] object in
// [`fuchsia.io2/Representation`].
class Memory final {
  Memory() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemoryUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_MemorySyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Memory;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<Memory::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Memory::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Memory::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Memory::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<Memory::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Memory::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Memory::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<Memory::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<Memory::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<Memory::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<Memory::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Memory::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Memory::SyncResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_FileReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSeekRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSeekResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadAtRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadAtResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteAtRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteAtResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileResizeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileResizeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetMemRangeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetMemRangeResponseTable;

// A [`fuchsia.io2/Node`] which contains a sequence of bytes of definite
// length.
class File final {
  File() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct SeekResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_Seek_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileSeekResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SeekRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::SeekOrigin origin;
    int64_t offset;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileSeekRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SeekResponse;
  };

  struct ReadResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_Read_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileReadResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8208;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReadRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileReadRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReadResponse;
  };

  struct WriteResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_Write_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileWriteResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct WriteRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileWriteRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = WriteResponse;
  };

  struct ReadAtResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_ReadAt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileReadAtResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8208;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReadAtRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileReadAtRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReadAtResponse;
  };

  struct WriteAtResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_WriteAt_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileWriteAtResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct WriteAtRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileWriteAtRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = WriteAtResponse;
  };

  struct ResizeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_Resize_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileResizeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ResizeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t length;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileResizeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ResizeResponse;
  };

  struct GetMemRangeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::File_GetMemRange_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileGetMemRangeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetMemRangeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::VmoFlags flags;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_FileGetMemRangeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetMemRangeResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Seek_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Seek_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset);
      ~Seek_Impl() = default;
      Seek_Impl(Seek_Impl&& other) = default;
      Seek_Impl& operator=(Seek_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Read_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Read_Impl(::zx::unowned_channel _client_end, uint64_t count);
      ~Read_Impl() = default;
      Read_Impl(Read_Impl&& other) = default;
      Read_Impl& operator=(Read_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Write_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Write_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data);
      ~Write_Impl() = default;
      Write_Impl(Write_Impl&& other) = default;
      Write_Impl& operator=(Write_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadAt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReadAt_Impl(::zx::unowned_channel _client_end, uint64_t count, uint64_t offset);
      ~ReadAt_Impl() = default;
      ReadAt_Impl(ReadAt_Impl&& other) = default;
      ReadAt_Impl& operator=(ReadAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WriteAt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WriteAt_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset);
      ~WriteAt_Impl() = default;
      WriteAt_Impl(WriteAt_Impl&& other) = default;
      WriteAt_Impl& operator=(WriteAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Resize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Resize_Impl(::zx::unowned_channel _client_end, uint64_t length);
      ~Resize_Impl() = default;
      Resize_Impl(Resize_Impl&& other) = default;
      Resize_Impl& operator=(Resize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetMemRange_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetMemRange_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::VmoFlags flags);
      ~GetMemRange_Impl() = default;
      GetMemRange_Impl(GetMemRange_Impl&& other) = default;
      GetMemRange_Impl& operator=(GetMemRange_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using Seek = Seek_Impl<SeekResponse>;
    using Read = Read_Impl<ReadResponse>;
    using Write = Write_Impl<WriteResponse>;
    using ReadAt = ReadAt_Impl<ReadAtResponse>;
    using WriteAt = WriteAt_Impl<WriteAtResponse>;
    using Resize = Resize_Impl<ResizeResponse>;
    using GetMemRange = GetMemRange_Impl<GetMemRangeResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Seek_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Seek_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer);
      ~Seek_Impl() = default;
      Seek_Impl(Seek_Impl&& other) = default;
      Seek_Impl& operator=(Seek_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Read_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Read_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);
      ~Read_Impl() = default;
      Read_Impl(Read_Impl&& other) = default;
      Read_Impl& operator=(Read_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Write_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Write_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);
      ~Write_Impl() = default;
      Write_Impl(Write_Impl&& other) = default;
      Write_Impl& operator=(Write_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadAt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReadAt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);
      ~ReadAt_Impl() = default;
      ReadAt_Impl(ReadAt_Impl&& other) = default;
      ReadAt_Impl& operator=(ReadAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WriteAt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WriteAt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);
      ~WriteAt_Impl() = default;
      WriteAt_Impl(WriteAt_Impl&& other) = default;
      WriteAt_Impl& operator=(WriteAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Resize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Resize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);
      ~Resize_Impl() = default;
      Resize_Impl(Resize_Impl&& other) = default;
      Resize_Impl& operator=(Resize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetMemRange_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetMemRange_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer);
      ~GetMemRange_Impl() = default;
      GetMemRange_Impl(GetMemRange_Impl&& other) = default;
      GetMemRange_Impl& operator=(GetMemRange_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using Seek = Seek_Impl<SeekResponse>;
    using Read = Read_Impl<ReadResponse>;
    using Write = Write_Impl<WriteResponse>;
    using ReadAt = ReadAt_Impl<ReadAtResponse>;
    using WriteAt = WriteAt_Impl<WriteAtResponse>;
    using Resize = Resize_Impl<ResizeResponse>;
    using GetMemRange = GetMemRange_Impl<GetMemRangeResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Moves the offset at which the next invocation of [`Read`] or [`Write`]
    // will occur. The seek offset is specific to each file connection.
    //
    // + request `origin` the reference point where `offset` will be based on.
    // + request `offset` the number of bytes to seek.
    // - response `offset_from_start` the adjusted seek offset, from the start
    //   of the file.
    //
    // This method does not require any rights.
    // Allocates 80 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Seek Seek(::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset);

    // Moves the offset at which the next invocation of [`Read`] or [`Write`]
    // will occur. The seek offset is specific to each file connection.
    //
    // + request `origin` the reference point where `offset` will be based on.
    // + request `offset` the number of bytes to seek.
    // - response `offset_from_start` the adjusted seek offset, from the start
    //   of the file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Seek Seek(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer);

    // Reads up to 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that the seek offset
    //   has reached the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that the
    //   seek offset is already at or beyond the end of file, and no data could
    //   be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually read anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Read Read(uint64_t count);

    // Reads up to 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that the seek offset
    //   has reached the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that the
    //   seek offset is already at or beyond the end of file, and no data could
    //   be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually read anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Read Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    // If the file is in append mode, the seek offset is first set to the end
    // of the file, followed by the write, in one atomic step.
    //
    // The file size may grow if the seek offset plus `data.length` is beyond
    // the current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file. The seek offset
    //   is still updated if in append mode.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Write Write(::fidl::VectorView<uint8_t> data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    // If the file is in append mode, the seek offset is first set to the end
    // of the file, followed by the write, in one atomic step.
    //
    // The file size may grow if the seek offset plus `data.length` is beyond
    // the current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file. The seek offset
    //   is still updated if in append mode.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Write Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);

    // Reads up to 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that `ReadAt` has hit
    //   the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that `offset`
    //   is at or past the end of file, and no data can be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually reading anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::ReadAt ReadAt(uint64_t count, uint64_t offset);

    // Reads up to 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that `ReadAt` has hit
    //   the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that `offset`
    //   is at or past the end of file, and no data can be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually reading anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReadAt ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Writes data at the provided offset.
    // Does not affect the seek offset.
    //
    // The file size may grow if `offset` plus `data.length` is past the
    // current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // + request `offset` the offset from start of the file to begin writing.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::WriteAt WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset);

    // Writes data at the provided offset.
    // Does not affect the seek offset.
    //
    // The file size may grow if `offset` plus `data.length` is past the
    // current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // + request `offset` the offset from start of the file to begin writing.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WriteAt WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Shrinks or grows the file size to 'length' bytes.
    //
    // If file size is reduced by this operation, the extra trailing data'
    // is discarded.
    // If file size is increased by this operation, the extended area appears
    // as if it was zeroed.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Resize Resize(uint64_t length);

    // Shrinks or grows the file size to 'length' bytes.
    //
    // If file size is reduced by this operation, the extra trailing data'
    // is discarded.
    // If file size is increased by this operation, the extended area appears
    // as if it was zeroed.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Resize Resize(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);

    // Acquires a [`fuchsia.mem/Range`] representing this file, if
    // there is one, with the requested access rights.
    //
    // + request `flags` a [`VmoFlags`] indicating the desired mode of access.
    // - response `buffer` the requested [`fuchsia.mem/Range`].
    // * error a [`zx.status`] value indicating the failure.
    //
    // This method requires the following rights:
    //
    // * [`Rights.READ_BYTES`] if `flags` includes [`VmoFlags.READ`].
    // * [`Rights.WRITE_BYTES`] if `flags` includes [`VmoFlags.WRITE`].
    // * [`Rights.EXECUTE`] if `flags` includes [`VmoFlags.EXECUTE`].
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetMemRange GetMemRange(::llcpp::fuchsia::io2::VmoFlags flags);

    // Acquires a [`fuchsia.mem/Range`] representing this file, if
    // there is one, with the requested access rights.
    //
    // + request `flags` a [`VmoFlags`] indicating the desired mode of access.
    // - response `buffer` the requested [`fuchsia.mem/Range`].
    // * error a [`zx.status`] value indicating the failure.
    //
    // This method requires the following rights:
    //
    // * [`Rights.READ_BYTES`] if `flags` includes [`VmoFlags.READ`].
    // * [`Rights.WRITE_BYTES`] if `flags` includes [`VmoFlags.WRITE`].
    // * [`Rights.EXECUTE`] if `flags` includes [`VmoFlags.EXECUTE`].
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetMemRange GetMemRange(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Moves the offset at which the next invocation of [`Read`] or [`Write`]
    // will occur. The seek offset is specific to each file connection.
    //
    // + request `origin` the reference point where `offset` will be based on.
    // + request `offset` the number of bytes to seek.
    // - response `offset_from_start` the adjusted seek offset, from the start
    //   of the file.
    //
    // This method does not require any rights.
    // Allocates 80 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Seek Seek(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset);

    // Moves the offset at which the next invocation of [`Read`] or [`Write`]
    // will occur. The seek offset is specific to each file connection.
    //
    // + request `origin` the reference point where `offset` will be based on.
    // + request `offset` the number of bytes to seek.
    // - response `offset_from_start` the adjusted seek offset, from the start
    //   of the file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Seek Seek(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer);

    // Reads up to 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that the seek offset
    //   has reached the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that the
    //   seek offset is already at or beyond the end of file, and no data could
    //   be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually read anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Read Read(::zx::unowned_channel _client_end, uint64_t count);

    // Reads up to 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that the seek offset
    //   has reached the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that the
    //   seek offset is already at or beyond the end of file, and no data could
    //   be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually read anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Read Read(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    // If the file is in append mode, the seek offset is first set to the end
    // of the file, followed by the write, in one atomic step.
    //
    // The file size may grow if the seek offset plus `data.length` is beyond
    // the current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file. The seek offset
    //   is still updated if in append mode.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Write Write(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    // If the file is in append mode, the seek offset is first set to the end
    // of the file, followed by the write, in one atomic step.
    //
    // The file size may grow if the seek offset plus `data.length` is beyond
    // the current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file. The seek offset
    //   is still updated if in append mode.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Write Write(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);

    // Reads up to 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that `ReadAt` has hit
    //   the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that `offset`
    //   is at or past the end of file, and no data can be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually reading anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::ReadAt ReadAt(::zx::unowned_channel _client_end, uint64_t count, uint64_t offset);

    // Reads up to 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that `ReadAt` has hit
    //   the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that `offset`
    //   is at or past the end of file, and no data can be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually reading anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReadAt ReadAt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Writes data at the provided offset.
    // Does not affect the seek offset.
    //
    // The file size may grow if `offset` plus `data.length` is past the
    // current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // + request `offset` the offset from start of the file to begin writing.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::WriteAt WriteAt(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset);

    // Writes data at the provided offset.
    // Does not affect the seek offset.
    //
    // The file size may grow if `offset` plus `data.length` is past the
    // current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // + request `offset` the offset from start of the file to begin writing.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WriteAt WriteAt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Shrinks or grows the file size to 'length' bytes.
    //
    // If file size is reduced by this operation, the extra trailing data'
    // is discarded.
    // If file size is increased by this operation, the extended area appears
    // as if it was zeroed.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Resize Resize(::zx::unowned_channel _client_end, uint64_t length);

    // Shrinks or grows the file size to 'length' bytes.
    //
    // If file size is reduced by this operation, the extra trailing data'
    // is discarded.
    // If file size is increased by this operation, the extended area appears
    // as if it was zeroed.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Resize Resize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);

    // Acquires a [`fuchsia.mem/Range`] representing this file, if
    // there is one, with the requested access rights.
    //
    // + request `flags` a [`VmoFlags`] indicating the desired mode of access.
    // - response `buffer` the requested [`fuchsia.mem/Range`].
    // * error a [`zx.status`] value indicating the failure.
    //
    // This method requires the following rights:
    //
    // * [`Rights.READ_BYTES`] if `flags` includes [`VmoFlags.READ`].
    // * [`Rights.WRITE_BYTES`] if `flags` includes [`VmoFlags.WRITE`].
    // * [`Rights.EXECUTE`] if `flags` includes [`VmoFlags.EXECUTE`].
    // Allocates 88 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetMemRange GetMemRange(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::VmoFlags flags);

    // Acquires a [`fuchsia.mem/Range`] representing this file, if
    // there is one, with the requested access rights.
    //
    // + request `flags` a [`VmoFlags`] indicating the desired mode of access.
    // - response `buffer` the requested [`fuchsia.mem/Range`].
    // * error a [`zx.status`] value indicating the failure.
    //
    // This method requires the following rights:
    //
    // * [`Rights.READ_BYTES`] if `flags` includes [`VmoFlags.READ`].
    // * [`Rights.WRITE_BYTES`] if `flags` includes [`VmoFlags.WRITE`].
    // * [`Rights.EXECUTE`] if `flags` includes [`VmoFlags.EXECUTE`].
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetMemRange GetMemRange(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Moves the offset at which the next invocation of [`Read`] or [`Write`]
    // will occur. The seek offset is specific to each file connection.
    //
    // + request `origin` the reference point where `offset` will be based on.
    // + request `offset` the number of bytes to seek.
    // - response `offset_from_start` the adjusted seek offset, from the start
    //   of the file.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SeekResponse> Seek(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer);

    // Reads up to 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that the seek offset
    //   has reached the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that the
    //   seek offset is already at or beyond the end of file, and no data could
    //   be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually read anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    static ::fidl::DecodeResult<ReadResponse> Read(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    // If the file is in append mode, the seek offset is first set to the end
    // of the file, followed by the write, in one atomic step.
    //
    // The file size may grow if the seek offset plus `data.length` is beyond
    // the current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file. The seek offset
    //   is still updated if in append mode.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    static ::fidl::DecodeResult<WriteResponse> Write(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer);

    // Reads up to 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // ## Invariants
    //
    // * The returned `data.length` will never be greater than `count`.
    // * If `data.length` is less than `count`, it means that `ReadAt` has hit
    //   the end of file as part of this operation.
    // * If `data.length` is zero while `count` is not, it means that `offset`
    //   is at or past the end of file, and no data can be read.
    // * If `count` is zero, the server should perform all the checks ensuring
    //   read access without actually reading anything, and return an empty
    //   `data` vector.
    //
    // This method requires the [`Rights.READ_BYTES`] right.
    static ::fidl::DecodeResult<ReadAtResponse> ReadAt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer);

    // Writes data at the provided offset.
    // Does not affect the seek offset.
    //
    // The file size may grow if `offset` plus `data.length` is past the
    // current end of file.
    //
    // + request `data` the byte buffer to write to the file.
    // + request `offset` the offset from start of the file to begin writing.
    // - response `actual_count` the number of bytes written.
    //
    // ## Invariants
    //
    // * The returned `actual_count` will never be greater than `data.length`.
    // * If the server is unable to write all the data due to e.g. not enough
    //   space, `actual_count` may be less than `data.length`.
    // * If `data.length` is zero, the server should perform all the checks
    //   ensuring write access without mutating the file.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    static ::fidl::DecodeResult<WriteAtResponse> WriteAt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer);

    // Shrinks or grows the file size to 'length' bytes.
    //
    // If file size is reduced by this operation, the extra trailing data'
    // is discarded.
    // If file size is increased by this operation, the extended area appears
    // as if it was zeroed.
    //
    // This method requires the [`Rights.WRITE_BYTES`] right.
    static ::fidl::DecodeResult<ResizeResponse> Resize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ResizeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a [`fuchsia.mem/Range`] representing this file, if
    // there is one, with the requested access rights.
    //
    // + request `flags` a [`VmoFlags`] indicating the desired mode of access.
    // - response `buffer` the requested [`fuchsia.mem/Range`].
    // * error a [`zx.status`] value indicating the failure.
    //
    // This method requires the following rights:
    //
    // * [`Rights.READ_BYTES`] if `flags` includes [`VmoFlags.READ`].
    // * [`Rights.WRITE_BYTES`] if `flags` includes [`VmoFlags.WRITE`].
    // * [`Rights.EXECUTE`] if `flags` includes [`VmoFlags.EXECUTE`].
    static ::fidl::DecodeResult<GetMemRangeResponse> GetMemRange(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMemRangeRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = File;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class SeekCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_Seek_Result result);
      void ReplySuccess(uint64_t offset_from_start);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Seek_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t offset_from_start);
      void Reply(::fidl::DecodedMessage<SeekResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SeekCompleter = ::fidl::Completer<SeekCompleterBase>;

    virtual void Seek(::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, SeekCompleter::Sync _completer) = 0;

    class ReadCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_Read_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> data);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Read_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadCompleter = ::fidl::Completer<ReadCompleterBase>;

    virtual void Read(uint64_t count, ReadCompleter::Sync _completer) = 0;

    class WriteCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_Write_Result result);
      void ReplySuccess(uint64_t actual_count);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Write_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t actual_count);
      void Reply(::fidl::DecodedMessage<WriteResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteCompleter = ::fidl::Completer<WriteCompleterBase>;

    virtual void Write(::fidl::VectorView<uint8_t> data, WriteCompleter::Sync _completer) = 0;

    class ReadAtCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_ReadAt_Result result);
      void ReplySuccess(::fidl::VectorView<uint8_t> data);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_ReadAt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadAtCompleter = ::fidl::Completer<ReadAtCompleterBase>;

    virtual void ReadAt(uint64_t count, uint64_t offset, ReadAtCompleter::Sync _completer) = 0;

    class WriteAtCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_WriteAt_Result result);
      void ReplySuccess(uint64_t actual_count);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_WriteAt_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, uint64_t actual_count);
      void Reply(::fidl::DecodedMessage<WriteAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteAtCompleter = ::fidl::Completer<WriteAtCompleterBase>;

    virtual void WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset, WriteAtCompleter::Sync _completer) = 0;

    class ResizeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_Resize_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Resize_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<ResizeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ResizeCompleter = ::fidl::Completer<ResizeCompleterBase>;

    virtual void Resize(uint64_t length, ResizeCompleter::Sync _completer) = 0;

    class GetMemRangeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::File_GetMemRange_Result result);
      void ReplySuccess(::llcpp::fuchsia::mem::Range buffer);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_GetMemRange_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::mem::Range buffer);
      void Reply(::fidl::DecodedMessage<GetMemRangeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetMemRangeCompleter = ::fidl::Completer<GetMemRangeCompleterBase>;

    virtual void GetMemRange(::llcpp::fuchsia::io2::VmoFlags flags, GetMemRangeCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<File::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<File::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<File::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<File::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<File::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<File::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<File::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<File::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<File::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<File::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<File::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<File::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<File::SyncResponse>& _msg);
    static void SeekRequest(const ::fidl::DecodedMessage<File::SeekRequest>& _msg);
    static void SeekResponse(const ::fidl::DecodedMessage<File::SeekResponse>& _msg);
    static void ReadRequest(const ::fidl::DecodedMessage<File::ReadRequest>& _msg);
    static void ReadResponse(const ::fidl::DecodedMessage<File::ReadResponse>& _msg);
    static void WriteRequest(const ::fidl::DecodedMessage<File::WriteRequest>& _msg);
    static void WriteResponse(const ::fidl::DecodedMessage<File::WriteResponse>& _msg);
    static void ReadAtRequest(const ::fidl::DecodedMessage<File::ReadAtRequest>& _msg);
    static void ReadAtResponse(const ::fidl::DecodedMessage<File::ReadAtResponse>& _msg);
    static void WriteAtRequest(const ::fidl::DecodedMessage<File::WriteAtRequest>& _msg);
    static void WriteAtResponse(const ::fidl::DecodedMessage<File::WriteAtResponse>& _msg);
    static void ResizeRequest(const ::fidl::DecodedMessage<File::ResizeRequest>& _msg);
    static void ResizeResponse(const ::fidl::DecodedMessage<File::ResizeResponse>& _msg);
    static void GetMemRangeRequest(const ::fidl::DecodedMessage<File::GetMemRangeRequest>& _msg);
    static void GetMemRangeResponse(const ::fidl::DecodedMessage<File::GetMemRangeResponse>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectorySyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectorySyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUnlinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUnlinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEnumerateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEnumerateResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryRenameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryRenameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryLinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryLinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchResponseTable;

// A [`fuchsia.io2/Node`] that is capable of containing other nodes.
class Directory final {
  Directory() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectorySyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct OpenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView path;
    ::llcpp::fuchsia::io2::OpenMode mode;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryOpenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 4168;
    static constexpr uint32_t AltPrimarySize = 64;
    static constexpr uint32_t AltMaxOutOfLine = 4168;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct UnlinkResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Directory_Unlink_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryUnlinkResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UnlinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryUnlinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4096;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4096;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UnlinkResponse;
  };

  struct EnumerateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options;
    ::zx::channel iterator;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryEnumerateRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct RenameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Directory_Rename_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryRenameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct RenameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryRenameRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 512;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 512;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = RenameResponse;
  };

  struct LinkResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Directory_Link_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryLinkResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LinkRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryLinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 512;
    static constexpr uint32_t AltPrimarySize = 56;
    static constexpr uint32_t AltMaxOutOfLine = 512;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LinkResponse;
  };

  struct WatchRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::DirectoryWatchMask mask;
    ::llcpp::fuchsia::io2::DirectoryWatchOptions options;
    ::zx::channel watcher;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DirectoryWatchRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Open_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Open_Impl(::zx::unowned_channel _client_end, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Open_Impl() = default;
      Open_Impl(Open_Impl&& other) = default;
      Open_Impl& operator=(Open_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Unlink_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::StringView path);
      ~Unlink_Impl() = default;
      Unlink_Impl(Unlink_Impl&& other) = default;
      Unlink_Impl& operator=(Unlink_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Enumerate_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Enumerate_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);
      ~Enumerate_Impl() = default;
      Enumerate_Impl(Enumerate_Impl&& other) = default;
      Enumerate_Impl& operator=(Enumerate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Rename_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Rename_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);
      ~Rename_Impl() = default;
      Rename_Impl(Rename_Impl&& other) = default;
      Rename_Impl& operator=(Rename_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Link_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Link_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);
      ~Link_Impl() = default;
      Link_Impl(Link_Impl&& other) = default;
      Link_Impl& operator=(Link_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Watch_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Watch_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);
      ~Watch_Impl() = default;
      Watch_Impl(Watch_Impl&& other) = default;
      Watch_Impl& operator=(Watch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using Open = Open_Impl;
    using Unlink = Unlink_Impl<UnlinkResponse>;
    using Enumerate = Enumerate_Impl;
    using Rename = Rename_Impl<RenameResponse>;
    using Link = Link_Impl<LinkResponse>;
    using Watch = Watch_Impl;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Open_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Open_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Open_Impl() = default;
      Open_Impl(Open_Impl&& other) = default;
      Open_Impl& operator=(Open_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Unlink_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);
      ~Unlink_Impl() = default;
      Unlink_Impl(Unlink_Impl&& other) = default;
      Unlink_Impl& operator=(Unlink_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Enumerate_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Enumerate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);
      ~Enumerate_Impl() = default;
      Enumerate_Impl(Enumerate_Impl&& other) = default;
      Enumerate_Impl& operator=(Enumerate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Rename_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Rename_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);
      ~Rename_Impl() = default;
      Rename_Impl(Rename_Impl&& other) = default;
      Rename_Impl& operator=(Rename_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Link_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Link_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);
      ~Link_Impl() = default;
      Link_Impl(Link_Impl&& other) = default;
      Link_Impl& operator=(Link_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class Watch_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Watch_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);
      ~Watch_Impl() = default;
      Watch_Impl(Watch_Impl&& other) = default;
      Watch_Impl& operator=(Watch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using Open = Open_Impl;
    using Unlink = Unlink_Impl<UnlinkResponse>;
    using Enumerate = Enumerate_Impl;
    using Rename = Rename_Impl<RenameResponse>;
    using Link = Link_Impl<LinkResponse>;
    using Watch = Watch_Impl;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Opens or creates a new node relative to this directory node.
    //
    // + `path` identifies the node to open.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //   See [`fuchsia.io2/Path`] for what constitutes a valid path.
    //   To open another connection to the current directory, use
    //   [`fuchsia.io2/Node.Reopen`] instead.
    // + `mode` controls whether to open existing/create new etc.
    // + `options` additional options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // This method requires the following rights on the current connection:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.TRAVERSE`]
    //
    // Errors are presented as an epitaph on the `object_request` channel.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the requested rights exceeds
    //   what is allowed.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // Request is heap-allocated.
    ResultOf::Open Open(::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Opens or creates a new node relative to this directory node.
    //
    // + `path` identifies the node to open.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //   See [`fuchsia.io2/Path`] for what constitutes a valid path.
    //   To open another connection to the current directory, use
    //   [`fuchsia.io2/Node.Reopen`] instead.
    // + `mode` controls whether to open existing/create new etc.
    // + `options` additional options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // This method requires the following rights on the current connection:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.TRAVERSE`]
    //
    // Errors are presented as an epitaph on the `object_request` channel.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the requested rights exceeds
    //   what is allowed.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Open Open(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Removes a child node from the this directory's list of entries.
    //
    // Note: this does not guarantee that the underlying object is destroyed.
    // Although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are closed.
    //
    // + `path` identifies the node to be detached.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the connection does not have
    //   [`Rights.WRITE_BYTES`].
    // * error `ZX_ERR_NOT_SUPPORTED` if the underlying filesystem does not
    //   support writing.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // * error `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    // * error `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point,
    //   containing a remote channel.
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires the following rights:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Unlink Unlink(::fidl::StringView path);

    // Removes a child node from the this directory's list of entries.
    //
    // Note: this does not guarantee that the underlying object is destroyed.
    // Although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are closed.
    //
    // + `path` identifies the node to be detached.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the connection does not have
    //   [`Rights.WRITE_BYTES`].
    // * error `ZX_ERR_NOT_SUPPORTED` if the underlying filesystem does not
    //   support writing.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // * error `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    // * error `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point,
    //   containing a remote channel.
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires the following rights:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Unlink Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);

    // Initiates a directory listing operation over the input channel,
    // starting at seek offset 0.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `iterator` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Enumerate Enumerate(::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);

    // Initiates a directory listing operation over the input channel,
    // starting at seek offset 0.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `iterator` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Enumerate Enumerate(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);

    // Renames a node named `src` to the name `dst`, in a directory represented
    // by `dst_parent_token`.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Rename Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Renames a node named `src` to the name `dst`, in a directory represented
    // by `dst_parent_token`.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Rename Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Creates a link to a node named `src` by the name `dst`,
    // in a directory represented by `dst_parent_token`.
    //
    // Directories cannot be linked, to prevent reference cycles.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // * error `ZX_ERR_INVALID_ARGS` if `src` is a directory.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Link Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Creates a link to a node named `src` by the name `dst`,
    // in a directory represented by `dst_parent_token`.
    //
    // Directories cannot be linked, to prevent reference cycles.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // * error `ZX_ERR_INVALID_ARGS` if `src` is a directory.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Link Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Watches a directory, monitoring events for children being added or
    // removed on the server end of the `watcher` channel.
    //
    // Mask specifies a bit mask of events to observe.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `watcher` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Watch Watch(::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);

    // Watches a directory, monitoring events for children being added or
    // removed on the server end of the `watcher` channel.
    //
    // Mask specifies a bit mask of events to observe.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `watcher` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Watch Watch(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Opens or creates a new node relative to this directory node.
    //
    // + `path` identifies the node to open.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //   See [`fuchsia.io2/Path`] for what constitutes a valid path.
    //   To open another connection to the current directory, use
    //   [`fuchsia.io2/Node.Reopen`] instead.
    // + `mode` controls whether to open existing/create new etc.
    // + `options` additional options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // This method requires the following rights on the current connection:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.TRAVERSE`]
    //
    // Errors are presented as an epitaph on the `object_request` channel.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the requested rights exceeds
    //   what is allowed.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // Request is heap-allocated.
    static ResultOf::Open Open(::zx::unowned_channel _client_end, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Opens or creates a new node relative to this directory node.
    //
    // + `path` identifies the node to open.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //   See [`fuchsia.io2/Path`] for what constitutes a valid path.
    //   To open another connection to the current directory, use
    //   [`fuchsia.io2/Node.Reopen`] instead.
    // + `mode` controls whether to open existing/create new etc.
    // + `options` additional options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // This method requires the following rights on the current connection:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.TRAVERSE`]
    //
    // Errors are presented as an epitaph on the `object_request` channel.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the requested rights exceeds
    //   what is allowed.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Open Open(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Removes a child node from the this directory's list of entries.
    //
    // Note: this does not guarantee that the underlying object is destroyed.
    // Although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are closed.
    //
    // + `path` identifies the node to be detached.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the connection does not have
    //   [`Rights.WRITE_BYTES`].
    // * error `ZX_ERR_NOT_SUPPORTED` if the underlying filesystem does not
    //   support writing.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // * error `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    // * error `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point,
    //   containing a remote channel.
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires the following rights:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Unlink Unlink(::zx::unowned_channel _client_end, ::fidl::StringView path);

    // Removes a child node from the this directory's list of entries.
    //
    // Note: this does not guarantee that the underlying object is destroyed.
    // Although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are closed.
    //
    // + `path` identifies the node to be detached.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the connection does not have
    //   [`Rights.WRITE_BYTES`].
    // * error `ZX_ERR_NOT_SUPPORTED` if the underlying filesystem does not
    //   support writing.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // * error `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    // * error `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point,
    //   containing a remote channel.
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires the following rights:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Unlink Unlink(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer);

    // Initiates a directory listing operation over the input channel,
    // starting at seek offset 0.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `iterator` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Enumerate Enumerate(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);

    // Initiates a directory listing operation over the input channel,
    // starting at seek offset 0.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `iterator` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Enumerate Enumerate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator);

    // Renames a node named `src` to the name `dst`, in a directory represented
    // by `dst_parent_token`.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Rename Rename(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Renames a node named `src` to the name `dst`, in a directory represented
    // by `dst_parent_token`.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Rename Rename(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Creates a link to a node named `src` by the name `dst`,
    // in a directory represented by `dst_parent_token`.
    //
    // Directories cannot be linked, to prevent reference cycles.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // * error `ZX_ERR_INVALID_ARGS` if `src` is a directory.
    // Allocates 48 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Link Link(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst);

    // Creates a link to a node named `src` by the name `dst`,
    // in a directory represented by `dst_parent_token`.
    //
    // Directories cannot be linked, to prevent reference cycles.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // * error `ZX_ERR_INVALID_ARGS` if `src` is a directory.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Link Link(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer);

    // Watches a directory, monitoring events for children being added or
    // removed on the server end of the `watcher` channel.
    //
    // Mask specifies a bit mask of events to observe.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `watcher` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Watch Watch(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);

    // Watches a directory, monitoring events for children being added or
    // removed on the server end of the `watcher` channel.
    //
    // Mask specifies a bit mask of events to observe.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `watcher` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Watch Watch(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Opens or creates a new node relative to this directory node.
    //
    // + `path` identifies the node to open.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //   See [`fuchsia.io2/Path`] for what constitutes a valid path.
    //   To open another connection to the current directory, use
    //   [`fuchsia.io2/Node.Reopen`] instead.
    // + `mode` controls whether to open existing/create new etc.
    // + `options` additional options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // This method requires the following rights on the current connection:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.TRAVERSE`]
    //
    // Errors are presented as an epitaph on the `object_request` channel.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the requested rights exceeds
    //   what is allowed.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    static ::fidl::internal::StatusAndError Open(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params);

    // Removes a child node from the this directory's list of entries.
    //
    // Note: this does not guarantee that the underlying object is destroyed.
    // Although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are closed.
    //
    // + `path` identifies the node to be detached.
    //   If `path` contains multiple segments, then the directory is traversed,
    //   one segment at a time, relative to the directory represented by this
    //   connection.
    //
    // * error `ZX_ERR_ACCESS_DENIED` if the connection does not have
    //   [`Rights.WRITE_BYTES`].
    // * error `ZX_ERR_NOT_SUPPORTED` if the underlying filesystem does not
    //   support writing.
    // * error `ZX_ERR_BAD_PATH` if `path` is invalid.
    // * error `ZX_ERR_NOT_EMPTY` if `path` refers to a non-empty directory.
    // * error `ZX_ERR_UNAVAILABLE` if `path` refers to a mount point,
    //   containing a remote channel.
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires the following rights:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    static ::fidl::DecodeResult<UnlinkResponse> Unlink(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a directory listing operation over the input channel,
    // starting at seek offset 0.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `iterator` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    static ::fidl::internal::StatusAndError Enumerate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EnumerateRequest> params);

    // Renames a node named `src` to the name `dst`, in a directory represented
    // by `dst_parent_token`.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    static ::fidl::DecodeResult<RenameResponse> Rename(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to a node named `src` by the name `dst`,
    // in a directory represented by `dst_parent_token`.
    //
    // Directories cannot be linked, to prevent reference cycles.
    //
    // `src` and `dst` must be valid node names.
    // See [`fuchsia.io2/Name`] for what constitutes a valid name.
    //
    // This method requires the following rights on both the current
    // connection, and the connection identified by `dst_parent_token`:
    //
    // * [`Rights.ENUMERATE`]
    // * [`Rights.MODIFY_DIRECTORY`]
    //
    // * error `ZX_ERR_INVALID_ARGS` if `src` or `dst` is invalid.
    // * error `ZX_ERR_INVALID_ARGS` if `src` is a directory.
    static ::fidl::DecodeResult<LinkResponse> Link(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, monitoring events for children being added or
    // removed on the server end of the `watcher` channel.
    //
    // Mask specifies a bit mask of events to observe.
    //
    // This method requires the [`Rights.ENUMERATE`] right. If this right is
    // absent, `watcher` will be closed with a `ZX_ERR_ACCESS_DENIED` epitaph.
    static ::fidl::internal::StatusAndError Watch(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Directory;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    using OpenCompleter = ::fidl::Completer<>;

    virtual void Open(::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, OpenCompleter::Sync _completer) = 0;

    class UnlinkCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Directory_Unlink_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Unlink_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UnlinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnlinkCompleter = ::fidl::Completer<UnlinkCompleterBase>;

    virtual void Unlink(::fidl::StringView path, UnlinkCompleter::Sync _completer) = 0;

    using EnumerateCompleter = ::fidl::Completer<>;

    virtual void Enumerate(::llcpp::fuchsia::io2::DirectoryEnumerateOptions options, ::zx::channel iterator, EnumerateCompleter::Sync _completer) = 0;

    class RenameCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Directory_Rename_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Rename_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<RenameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RenameCompleter = ::fidl::Completer<RenameCompleterBase>;

    virtual void Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, RenameCompleter::Sync _completer) = 0;

    class LinkCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Directory_Link_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Link_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<LinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LinkCompleter = ::fidl::Completer<LinkCompleterBase>;

    virtual void Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, LinkCompleter::Sync _completer) = 0;

    using WatchCompleter = ::fidl::Completer<>;

    virtual void Watch(::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher, WatchCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<Directory::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Directory::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Directory::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Directory::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<Directory::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Directory::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Directory::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<Directory::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<Directory::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<Directory::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<Directory::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Directory::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Directory::SyncResponse>& _msg);
    static void OpenRequest(const ::fidl::DecodedMessage<Directory::OpenRequest>& _msg);
    static void UnlinkRequest(const ::fidl::DecodedMessage<Directory::UnlinkRequest>& _msg);
    static void UnlinkResponse(const ::fidl::DecodedMessage<Directory::UnlinkResponse>& _msg);
    static void EnumerateRequest(const ::fidl::DecodedMessage<Directory::EnumerateRequest>& _msg);
    static void RenameRequest(const ::fidl::DecodedMessage<Directory::RenameRequest>& _msg);
    static void RenameResponse(const ::fidl::DecodedMessage<Directory::RenameResponse>& _msg);
    static void LinkRequest(const ::fidl::DecodedMessage<Directory::LinkRequest>& _msg);
    static void LinkResponse(const ::fidl::DecodedMessage<Directory::LinkResponse>& _msg);
    static void WatchRequest(const ::fidl::DecodedMessage<Directory::WatchRequest>& _msg);
  };
};

extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogReopenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogOnConnectionInfoEventTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogUpdateAttributesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogSyncResponseTable;

// A node for interacting with the kernel debug log.
// It may be manipulated via the debuglog object returned from
// the `DebuglogInfo` member in [`fuchsia.io2/Representation`].
class Debuglog final {
  Debuglog() = delete;
 public:

  struct ReopenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionOptions options;
    ::zx::channel object_request;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogReopenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 72;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 72;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct DescribeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfoQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogDescribeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = DescribeResponse;
  };

  struct OnConnectionInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::ConnectionInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogOnConnectionInfoEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 152;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetTokenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetToken_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_GetAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogGetAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 208;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributesQuery query;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogGetAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAttributesResponse;
  };

  struct UpdateAttributesResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogUpdateAttributesResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct UpdateAttributesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogUpdateAttributesRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 192;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 192;
    static constexpr bool HasFlexibleEnvelope = true;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = UpdateAttributesResponse;
  };

  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io2::Node_Sync_Result result;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_io2_DebuglogSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;


  struct EventHandlers {
    // An event produced eagerly by the server if requested by
    // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
    // first message from the server, and is sent exactly once.
    //
    // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //   All members should be present.
    //
    // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
    // always manifested as an epitaph.
    fit::callback<zx_status_t(::llcpp::fuchsia::io2::ConnectionInfo info)> on_connection_info;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Reopen_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);
      ~Reopen_Impl() = default;
      Reopen_Impl(Reopen_Impl&& other) = default;
      Reopen_Impl& operator=(Reopen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class Close_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetToken_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetToken_Impl() = default;
      GetToken_Impl(GetToken_Impl&& other) = default;
      GetToken_Impl& operator=(GetToken_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);
      ~GetAttributes_Impl() = default;
      GetAttributes_Impl(GetAttributes_Impl&& other) = default;
      GetAttributes_Impl& operator=(GetAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class UpdateAttributes_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~UpdateAttributes_Impl() = default;
      UpdateAttributes_Impl(UpdateAttributes_Impl&& other) = default;
      UpdateAttributes_Impl& operator=(UpdateAttributes_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Reopen = Reopen_Impl;
    using Close = Close_Impl;
    using Describe = Describe_Impl<DescribeResponse>;
    using GetToken = GetToken_Impl<GetTokenResponse>;
    using GetAttributes = GetAttributes_Impl<GetAttributesResponse>;
    using UpdateAttributes = UpdateAttributes_Impl<UpdateAttributesResponse>;
    using Sync = Sync_Impl<SyncResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Reopen Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Reopen Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Describe Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetToken GetToken();

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetToken GetToken(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetAttributes GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttributes GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::UpdateAttributes UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::UpdateAttributes UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Reopen Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    // Allocates 16 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);


    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetToken GetToken(::zx::unowned_channel _client_end);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetToken GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttributes GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Allocates 272 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::UpdateAttributes UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates another connection to the same node.
    //
    // + `options` options applicable to both `Open` and `Reopen`,
    //   including negotiating protocol and restricting rights.
    //   See [`fuchsia.io2/ConnectionOptions`].
    // + `object_request` is the server end of a channel created for the new
    //   connection. The caller may proceed to send messages on the
    //   corresponding client end right away.
    //
    // For files, the cloned connection and the original connection have
    // independent seek offsets.
    static ::fidl::internal::StatusAndError Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params);

    // Terminates the connection to the node.
    //
    // After calling `Close`, the client must not send any other requests.
    // The result of `Close` arrives as an epitaph, where the channel is closed
    // by the server upon processing this operation.
    //
    // Closing the client end of the channel should be semantically equivalent
    // to calling `Close` without monitoring the status epitaph.
    //
    // This method does not require any rights.
    static ::fidl::internal::StatusAndError Close(::zx::unowned_channel _client_end);

    // Returns extra connection information and auxiliary handles.
    //
    // + `query` specifies the fields in `ConnectionInfo` that the caller is
    //   interested in.
    // - `info` see [`fuchsia.io2/ConnectionInfo`] for details on the fields.
    //
    // When all known bits in `query` are set, the return value matches
    // the one from [`OnConnectionInfo`], as if the caller requested that event
    // using [`ConnectionFlags.GET_CONNECTION_INFO`].
    //
    // If the `Describe` operation fails, the connection is closed with the
    // associated error.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a token which can be used to identify this connection at
    // a later point in time.
    //
    // This method does not require any rights. Note that the token identifies
    // the connection, hence carries the rights information on this connection.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // The attributes of a node should be stable, independent of the
    // specific protocol used to access it.
    //
    // + `query` a bit-mask specifying which attributes to fetch. The server
    //   should not return more than necessary.
    // - `attributes` the returned attributes.
    //
    // This method requires the [`Rights.GET_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<GetAttributesResponse> GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    //
    // + `attributes` the presence of a table field in `attributes` indicates
    // the intent to update the corresponding attribute.
    //
    // This method requires the [`Rights.UPDATE_ATTRIBUTES`] right.
    static ::fidl::DecodeResult<UpdateAttributesResponse> UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method will return when the filesystem server has flushed the
    // relevant updates to the underlying media, but does not guarantee the
    // underlying media has persisted the information, nor that any information
    // is committed to hardware. Clients may use `Sync` to ensure ordering
    // between operations.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Debuglog;
    using _Base = ::fidl::CompleterBase;

    using ReopenCompleter = ::fidl::Completer<>;

    virtual void Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request, ReopenCompleter::Sync _completer) = 0;

    using CloseCompleter = ::fidl::Completer<>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query, DescribeCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::zx::handle token);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class GetAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes);
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttributesCompleter = ::fidl::Completer<GetAttributesCompleterBase>;

    virtual void GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query, GetAttributesCompleter::Sync _completer) = 0;

    class UpdateAttributesCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UpdateAttributesCompleter = ::fidl::Completer<UpdateAttributesCompleterBase>;

    virtual void UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes, UpdateAttributesCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess();
      void ReplyError(int32_t error);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result);
      void ReplySuccess(::fidl::BytePart _buffer);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info);

  // An event produced eagerly by the server if requested by
  // [`ConnectionFlags.GET_CONNECTION_INFO`]. This event will be the
  // first message from the server, and is sent exactly once.
  //
  // - `info` See [`fuchsia.io2/ConnectionInfo`] for details on the fields.
  //   All members should be present.
  //
  // Different from [`fuchsia.io/OnOpen`], an error during open/reopen is
  // always manifested as an epitaph.
  // Messages are encoded in-place.
  static zx_status_t SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ReopenRequest(const ::fidl::DecodedMessage<Debuglog::ReopenRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Debuglog::CloseRequest>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Debuglog::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Debuglog::DescribeResponse>& _msg);
    static void OnConnectionInfoResponse(const ::fidl::DecodedMessage<Debuglog::OnConnectionInfoResponse>& _msg);
    static void GetTokenRequest(const ::fidl::DecodedMessage<Debuglog::GetTokenRequest>& _msg);
    static void GetTokenResponse(const ::fidl::DecodedMessage<Debuglog::GetTokenResponse>& _msg);
    static void GetAttributesRequest(const ::fidl::DecodedMessage<Debuglog::GetAttributesRequest>& _msg);
    static void GetAttributesResponse(const ::fidl::DecodedMessage<Debuglog::GetAttributesResponse>& _msg);
    static void UpdateAttributesRequest(const ::fidl::DecodedMessage<Debuglog::UpdateAttributesRequest>& _msg);
    static void UpdateAttributesResponse(const ::fidl::DecodedMessage<Debuglog::UpdateAttributesResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Debuglog::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Debuglog::SyncResponse>& _msg);
  };
};

}  // namespace io2
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::io2::MemoryInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::MemoryInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_GetMemRange_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_GetMemRange_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_GetMemRange_Response, buffer) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_GetMemRange_Response) == ::llcpp::fuchsia::io2::File_GetMemRange_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_GetMemRange_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_GetMemRange_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::VmoFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::VmoFlags>);
static_assert(sizeof(::llcpp::fuchsia::io2::VmoFlags) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::TtyInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::TtyInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Read_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Read_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_Read_Response, data) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_Read_Response) == ::llcpp::fuchsia::io2::File_Read_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Read_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Read_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_ReadAt_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_ReadAt_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_ReadAt_Response, data) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_ReadAt_Response) == ::llcpp::fuchsia::io2::File_ReadAt_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_ReadAt_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_ReadAt_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_GetToken_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_GetToken_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Node_GetToken_Response, token) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Node_GetToken_Response) == ::llcpp::fuchsia::io2::Node_GetToken_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_GetToken_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_GetToken_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::PosixSocketInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::PosixSocketInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::PipeInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::PipeInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Operations> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Operations>);
static_assert(sizeof(::llcpp::fuchsia::io2::Operations) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_UpdateAttributes_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_UpdateAttributes_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Node_UpdateAttributes_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Node_UpdateAttributes_Response) == ::llcpp::fuchsia::io2::Node_UpdateAttributes_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_UpdateAttributes_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_UpdateAttributes_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_Sync_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_Sync_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Node_Sync_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Node_Sync_Response) == ::llcpp::fuchsia::io2::Node_Sync_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_Sync_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_Sync_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::NodeProtocolSet> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::NodeProtocolSet>);
static_assert(sizeof(::llcpp::fuchsia::io2::NodeProtocolSet) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::NodeAttributesQuery> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::NodeAttributesQuery>);
static_assert(sizeof(::llcpp::fuchsia::io2::NodeAttributesQuery) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::IdleEvent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::IdleEvent>);
static_assert(offsetof(::llcpp::fuchsia::io2::IdleEvent, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::IdleEvent) == ::llcpp::fuchsia::io2::IdleEvent::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::NodeAttributes> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::NodeAttributes>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_GetAttributes_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_GetAttributes_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Node_GetAttributes_Response, attributes) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Node_GetAttributes_Response) == ::llcpp::fuchsia::io2::Node_GetAttributes_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node_GetAttributes_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Node_GetAttributes_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryEntry> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryEntry>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryWatchedEvent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryWatchedEvent>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryWatcher::GetNextResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::DirectoryWatcher::GetNextResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::DirectoryWatcher::GetNextResponse)
    == ::llcpp::fuchsia::io2::DirectoryWatcher::GetNextResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::DirectoryWatcher::GetNextResponse, events) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response, entries) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response) == ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryIterator::GetNextResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::DirectoryIterator::GetNextResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::DirectoryIterator::GetNextResponse)
    == ::llcpp::fuchsia::io2::DirectoryIterator::GetNextResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::DirectoryIterator::GetNextResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Write_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Write_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_Write_Response, actual_count) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_Write_Response) == ::llcpp::fuchsia::io2::File_Write_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Write_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Write_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_WriteAt_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_WriteAt_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_WriteAt_Response, actual_count) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_WriteAt_Response) == ::llcpp::fuchsia::io2::File_WriteAt_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_WriteAt_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_WriteAt_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Seek_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Seek_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_Seek_Response, offset_from_start) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_Seek_Response) == ::llcpp::fuchsia::io2::File_Seek_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Seek_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Seek_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Resize_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Resize_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::File_Resize_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::File_Resize_Response) == ::llcpp::fuchsia::io2::File_Resize_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File_Resize_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::File_Resize_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::FileSignal> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::FileSignal>);
static_assert(sizeof(::llcpp::fuchsia::io2::FileSignal) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::FileInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::FileInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Unlink_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Unlink_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory_Unlink_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Directory_Unlink_Response) == ::llcpp::fuchsia::io2::Directory_Unlink_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Unlink_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Unlink_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Rename_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Rename_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory_Rename_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Directory_Rename_Response) == ::llcpp::fuchsia::io2::Directory_Rename_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Rename_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Rename_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Link_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Link_Response>);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory_Link_Response, __reserved) == 0);
static_assert(sizeof(::llcpp::fuchsia::io2::Directory_Link_Response) == ::llcpp::fuchsia::io2::Directory_Link_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory_Link_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Directory_Link_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryWatchOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryWatchOptions>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryWatchMask> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryWatchMask>);
static_assert(sizeof(::llcpp::fuchsia::io2::DirectoryWatchMask) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DirectoryEnumerateOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DirectoryEnumerateOptions>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DeviceSignal> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DeviceSignal>);
static_assert(sizeof(::llcpp::fuchsia::io2::DeviceSignal) == sizeof(uint32_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DeviceInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DeviceInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::DebuglogInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::DebuglogInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::ConnectorInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::ConnectorInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Representation> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::Representation>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::ConnectionInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::ConnectionInfo>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::ConnectionInfoQuery> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::ConnectionInfoQuery>);
static_assert(sizeof(::llcpp::fuchsia::io2::ConnectionInfoQuery) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::ConnectionFlags> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::ConnectionFlags>);
static_assert(sizeof(::llcpp::fuchsia::io2::ConnectionFlags) == sizeof(uint64_t));

template <>
struct IsFidlType<::llcpp::fuchsia::io2::ConnectionOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::io2::ConnectionOptions>);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::ReopenRequest)
    == ::llcpp::fuchsia::io2::Node::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::DescribeRequest)
    == ::llcpp::fuchsia::io2::Node::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::DescribeResponse)
    == ::llcpp::fuchsia::io2::Node::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::Node::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::GetTokenResponse)
    == ::llcpp::fuchsia::io2::Node::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::Node::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::Node::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::Node::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::Node::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Node::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Node::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Node::SyncResponse)
    == ::llcpp::fuchsia::io2::Node::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Node::SyncResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::ReopenRequest)
    == ::llcpp::fuchsia::io2::Pipe::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::DescribeRequest)
    == ::llcpp::fuchsia::io2::Pipe::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::DescribeResponse)
    == ::llcpp::fuchsia::io2::Pipe::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::Pipe::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::GetTokenResponse)
    == ::llcpp::fuchsia::io2::Pipe::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::Pipe::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::Pipe::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::Pipe::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::Pipe::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Pipe::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Pipe::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Pipe::SyncResponse)
    == ::llcpp::fuchsia::io2::Pipe::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Pipe::SyncResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::ReopenRequest)
    == ::llcpp::fuchsia::io2::Memory::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::DescribeRequest)
    == ::llcpp::fuchsia::io2::Memory::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::DescribeResponse)
    == ::llcpp::fuchsia::io2::Memory::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::Memory::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::GetTokenResponse)
    == ::llcpp::fuchsia::io2::Memory::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::Memory::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::Memory::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::Memory::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::Memory::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Memory::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Memory::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Memory::SyncResponse)
    == ::llcpp::fuchsia::io2::Memory::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Memory::SyncResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ReopenRequest)
    == ::llcpp::fuchsia::io2::File::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::DescribeRequest)
    == ::llcpp::fuchsia::io2::File::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::DescribeResponse)
    == ::llcpp::fuchsia::io2::File::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::File::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::GetTokenResponse)
    == ::llcpp::fuchsia::io2::File::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::File::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::File::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::File::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::File::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::SyncResponse)
    == ::llcpp::fuchsia::io2::File::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::SyncResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::SeekRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::SeekRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::SeekRequest)
    == ::llcpp::fuchsia::io2::File::SeekRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::SeekRequest, origin) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::File::SeekRequest, offset) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::SeekResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::SeekResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::SeekResponse)
    == ::llcpp::fuchsia::io2::File::SeekResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::SeekResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ReadRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ReadRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ReadRequest)
    == ::llcpp::fuchsia::io2::File::ReadRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReadRequest, count) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ReadResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ReadResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ReadResponse)
    == ::llcpp::fuchsia::io2::File::ReadResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReadResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::WriteRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::WriteRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::WriteRequest)
    == ::llcpp::fuchsia::io2::File::WriteRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::WriteRequest, data) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::WriteResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::WriteResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::WriteResponse)
    == ::llcpp::fuchsia::io2::File::WriteResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::WriteResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ReadAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ReadAtRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ReadAtRequest)
    == ::llcpp::fuchsia::io2::File::ReadAtRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReadAtRequest, count) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReadAtRequest, offset) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ReadAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ReadAtResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ReadAtResponse)
    == ::llcpp::fuchsia::io2::File::ReadAtResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ReadAtResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::WriteAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::WriteAtRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::WriteAtRequest)
    == ::llcpp::fuchsia::io2::File::WriteAtRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::WriteAtRequest, data) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::File::WriteAtRequest, offset) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::WriteAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::WriteAtResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::WriteAtResponse)
    == ::llcpp::fuchsia::io2::File::WriteAtResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::WriteAtResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ResizeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ResizeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ResizeRequest)
    == ::llcpp::fuchsia::io2::File::ResizeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ResizeRequest, length) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::ResizeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::ResizeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::ResizeResponse)
    == ::llcpp::fuchsia::io2::File::ResizeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::ResizeResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::GetMemRangeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::GetMemRangeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::GetMemRangeRequest)
    == ::llcpp::fuchsia::io2::File::GetMemRangeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::GetMemRangeRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::File::GetMemRangeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::File::GetMemRangeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::File::GetMemRangeResponse)
    == ::llcpp::fuchsia::io2::File::GetMemRangeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::File::GetMemRangeResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::ReopenRequest)
    == ::llcpp::fuchsia::io2::Directory::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::DescribeRequest)
    == ::llcpp::fuchsia::io2::Directory::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::DescribeResponse)
    == ::llcpp::fuchsia::io2::Directory::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::Directory::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::GetTokenResponse)
    == ::llcpp::fuchsia::io2::Directory::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::Directory::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::Directory::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::Directory::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::Directory::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::SyncResponse)
    == ::llcpp::fuchsia::io2::Directory::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::SyncResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::OpenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::OpenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::OpenRequest)
    == ::llcpp::fuchsia::io2::Directory::OpenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::OpenRequest, path) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::OpenRequest, mode) == 32);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::OpenRequest, options) == 40);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::OpenRequest, object_request) == 56);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::UnlinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::UnlinkRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::UnlinkRequest)
    == ::llcpp::fuchsia::io2::Directory::UnlinkRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::UnlinkRequest, path) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::UnlinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::UnlinkResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::UnlinkResponse)
    == ::llcpp::fuchsia::io2::Directory::UnlinkResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::UnlinkResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::EnumerateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::EnumerateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::EnumerateRequest)
    == ::llcpp::fuchsia::io2::Directory::EnumerateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::EnumerateRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::EnumerateRequest, iterator) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::RenameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::RenameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::RenameRequest)
    == ::llcpp::fuchsia::io2::Directory::RenameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::RenameRequest, src) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::RenameRequest, dst_parent_token) == 32);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::RenameRequest, dst) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::RenameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::RenameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::RenameResponse)
    == ::llcpp::fuchsia::io2::Directory::RenameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::RenameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::LinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::LinkRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::LinkRequest)
    == ::llcpp::fuchsia::io2::Directory::LinkRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::LinkRequest, src) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::LinkRequest, dst_parent_token) == 32);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::LinkRequest, dst) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::LinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::LinkResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::LinkResponse)
    == ::llcpp::fuchsia::io2::Directory::LinkResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::LinkResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Directory::WatchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Directory::WatchRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Directory::WatchRequest)
    == ::llcpp::fuchsia::io2::Directory::WatchRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::WatchRequest, mask) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::WatchRequest, options) == 24);
static_assert(offsetof(::llcpp::fuchsia::io2::Directory::WatchRequest, watcher) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::ReopenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::ReopenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::ReopenRequest)
    == ::llcpp::fuchsia::io2::Debuglog::ReopenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::ReopenRequest, options) == 16);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::ReopenRequest, object_request) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::DescribeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::DescribeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::DescribeRequest)
    == ::llcpp::fuchsia::io2::Debuglog::DescribeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::DescribeRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::DescribeResponse)
    == ::llcpp::fuchsia::io2::Debuglog::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::OnConnectionInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::OnConnectionInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::OnConnectionInfoResponse)
    == ::llcpp::fuchsia::io2::Debuglog::OnConnectionInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::OnConnectionInfoResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::GetTokenResponse)
    == ::llcpp::fuchsia::io2::Debuglog::GetTokenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::GetTokenResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::GetAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::GetAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::GetAttributesRequest)
    == ::llcpp::fuchsia::io2::Debuglog::GetAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::GetAttributesRequest, query) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::GetAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::GetAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::GetAttributesResponse)
    == ::llcpp::fuchsia::io2::Debuglog::GetAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::GetAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::UpdateAttributesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::UpdateAttributesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::UpdateAttributesRequest)
    == ::llcpp::fuchsia::io2::Debuglog::UpdateAttributesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::UpdateAttributesRequest, attributes) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::UpdateAttributesResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::UpdateAttributesResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::UpdateAttributesResponse)
    == ::llcpp::fuchsia::io2::Debuglog::UpdateAttributesResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::UpdateAttributesResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::io2::Debuglog::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::io2::Debuglog::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::io2::Debuglog::SyncResponse)
    == ::llcpp::fuchsia::io2::Debuglog::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::io2::Debuglog::SyncResponse, result) == 16);

}  // namespace fidl

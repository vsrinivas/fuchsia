// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/io2/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace io2 {

::llcpp::fuchsia::io2::MemoryInfo::Builder MemoryInfo::Build() {
  return MemoryInfo::Builder();
}

auto ::llcpp::fuchsia::io2::MemoryInfo::Builder::set_buffer(::llcpp::fuchsia::mem::Range* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::File_GetMemRange_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_GetMemRange_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_GetMemRange_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_GetMemRange_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::TtyInfo::Builder TtyInfo::Build() {
  return TtyInfo::Builder();
}

auto ::llcpp::fuchsia::io2::TtyInfo::Builder::set_event(::zx::event* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::File_Read_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_Read_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_Read_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_Read_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::File_ReadAt_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_ReadAt_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_ReadAt_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_ReadAt_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::Node_GetToken_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Node_GetToken_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Node_GetToken_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Node_GetToken_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::PosixSocketInfo::Builder PosixSocketInfo::Build() {
  return PosixSocketInfo::Builder();
}

auto ::llcpp::fuchsia::io2::PosixSocketInfo::Builder::set_socket(::zx::socket* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

::llcpp::fuchsia::io2::PipeInfo::Builder PipeInfo::Build() {
  return PipeInfo::Builder();
}

auto ::llcpp::fuchsia::io2::PipeInfo::Builder::set_socket(::zx::socket* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Node_UpdateAttributes_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Node_UpdateAttributes_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Node_UpdateAttributes_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::Node_Sync_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Node_Sync_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Node_Sync_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Node_Sync_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::NodeAttributes::Builder NodeAttributes::Build() {
  return NodeAttributes::Builder();
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_abilities(::llcpp::fuchsia::io2::Operations* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_content_size(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_storage_size(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[4 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 4) {
    max_ordinal_ = 4;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_link_count(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[5 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 5) {
    max_ordinal_ = 5;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_creation_time(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[6 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 6) {
    max_ordinal_ = 6;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::NodeAttributes::Builder::set_modification_time(uint64_t* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[7 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 7) {
    max_ordinal_ = 7;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::Node_GetAttributes_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Node_GetAttributes_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Node_GetAttributes_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Node_GetAttributes_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::DirectoryEntry::Builder DirectoryEntry::Build() {
  return DirectoryEntry::Builder();
}

auto ::llcpp::fuchsia::io2::DirectoryEntry::Builder::set_name(::fidl::StringView* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::DirectoryEntry::Builder::set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::DirectoryEntry::Builder::set_abilities(::llcpp::fuchsia::io2::Operations* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DirectoryIterator_GetNext_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(DirectoryIterator_GetNext_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(DirectoryIterator_GetNext_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryIterator_GetNext_Ordinal = 0x70aca67800000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryIterator_GetNext_GenOrdinal = 0x5d2068db7393845clu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIteratorGetNextRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryIteratorGetNextResponseTable;

}  // namespace
template <>
DirectoryIterator::ResultOf::GetNext_Impl<DirectoryIterator::GetNextResponse>::GetNext_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNextRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNextRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNextRequest));
  ::fidl::DecodedMessage<GetNextRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryIterator::InPlace::GetNext(std::move(_client_end), Super::response_buffer()));
}

DirectoryIterator::ResultOf::GetNext DirectoryIterator::SyncClient::GetNext() {
    return ResultOf::GetNext(::zx::unowned_channel(this->channel_));
}

DirectoryIterator::ResultOf::GetNext DirectoryIterator::Call::GetNext(::zx::unowned_channel _client_end) {
  return ResultOf::GetNext(std::move(_client_end));
}

template <>
DirectoryIterator::UnownedResultOf::GetNext_Impl<DirectoryIterator::GetNextResponse>::GetNext_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetNextRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetNextRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetNextRequest));
  ::fidl::DecodedMessage<GetNextRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryIterator::InPlace::GetNext(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryIterator::UnownedResultOf::GetNext DirectoryIterator::SyncClient::GetNext(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNext(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryIterator::UnownedResultOf::GetNext DirectoryIterator::Call::GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNext(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryIterator::GetNextResponse> DirectoryIterator::InPlace::GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetNextRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetNextRequest> params(std::move(_request_buffer));
  DirectoryIterator::SetTransactionHeaderFor::GetNextRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryIterator::GetNextResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNextRequest, GetNextResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryIterator::GetNextResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool DirectoryIterator::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectoryIterator_GetNext_Ordinal:
    case kDirectoryIterator_GetNext_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNextRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetNext(
          Interface::GetNextCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryIterator::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DirectoryIterator::Interface::GetNextCompleterBase::Reply(::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNextResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetNextResponse _response = {};
  DirectoryIterator::SetTransactionHeaderFor::GetNextResponse(
      ::fidl::DecodedMessage<GetNextResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNextResponse::PrimarySize,
              GetNextResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void DirectoryIterator::Interface::GetNextCompleterBase::ReplySuccess(::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryEntry> entries) {
  DirectoryIterator_GetNext_Response response;
  response.entries = std::move(entries);

  Reply(DirectoryIterator_GetNext_Result::WithResponse(&response));
}
void DirectoryIterator::Interface::GetNextCompleterBase::ReplyError(int32_t error) {
  Reply(DirectoryIterator_GetNext_Result::WithErr(&error));
}

void DirectoryIterator::Interface::GetNextCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::DirectoryIterator_GetNext_Result result) {
  if (_buffer.capacity() < GetNextResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetNextResponse _response = {};
  DirectoryIterator::SetTransactionHeaderFor::GetNextResponse(
      ::fidl::DecodedMessage<GetNextResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNextResponse::PrimarySize,
              GetNextResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void DirectoryIterator::Interface::GetNextCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryEntry> entries) {
  DirectoryIterator_GetNext_Response response;
  response.entries = std::move(entries);

  Reply(std::move(_buffer), DirectoryIterator_GetNext_Result::WithResponse(&response));
}

void DirectoryIterator::Interface::GetNextCompleterBase::Reply(::fidl::DecodedMessage<GetNextResponse> params) {
  DirectoryIterator::SetTransactionHeaderFor::GetNextResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void DirectoryIterator::SetTransactionHeaderFor::GetNextRequest(const ::fidl::DecodedMessage<DirectoryIterator::GetNextRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryIterator_GetNext_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void DirectoryIterator::SetTransactionHeaderFor::GetNextResponse(const ::fidl::DecodedMessage<DirectoryIterator::GetNextResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryIterator_GetNext_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
auto ::llcpp::fuchsia::io2::DirectoryWatchedEvent::which() const -> Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal()) {
  case Ordinal::kExisting:
  case Ordinal::kIdle:
  case Ordinal::kAdded:
  case Ordinal::kRemoved:
    return static_cast<Tag>(ordinal());
  default:
    return Tag::kUnknown;
  }
}

void ::llcpp::fuchsia::io2::DirectoryWatchedEvent::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DirectoryWatchedEvent) == sizeof(fidl_xunion_t));
  static_assert(offsetof(DirectoryWatchedEvent, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(DirectoryWatchedEvent, envelope_) == offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectoryWatcher_GetNext_Ordinal = 0x7de5be100000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectoryWatcher_GetNext_GenOrdinal = 0x74de3b9a6548cb77lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatcherGetNextRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatcherGetNextResponseTable;

}  // namespace
template <>
DirectoryWatcher::ResultOf::GetNext_Impl<DirectoryWatcher::GetNextResponse>::GetNext_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNextRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNextRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNextRequest));
  ::fidl::DecodedMessage<GetNextRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      DirectoryWatcher::InPlace::GetNext(std::move(_client_end), Super::response_buffer()));
}

DirectoryWatcher::ResultOf::GetNext DirectoryWatcher::SyncClient::GetNext() {
    return ResultOf::GetNext(::zx::unowned_channel(this->channel_));
}

DirectoryWatcher::ResultOf::GetNext DirectoryWatcher::Call::GetNext(::zx::unowned_channel _client_end) {
  return ResultOf::GetNext(std::move(_client_end));
}

template <>
DirectoryWatcher::UnownedResultOf::GetNext_Impl<DirectoryWatcher::GetNextResponse>::GetNext_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetNextRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetNextRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetNextRequest));
  ::fidl::DecodedMessage<GetNextRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      DirectoryWatcher::InPlace::GetNext(std::move(_client_end), std::move(_response_buffer)));
}

DirectoryWatcher::UnownedResultOf::GetNext DirectoryWatcher::SyncClient::GetNext(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNext(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

DirectoryWatcher::UnownedResultOf::GetNext DirectoryWatcher::Call::GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetNext(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<DirectoryWatcher::GetNextResponse> DirectoryWatcher::InPlace::GetNext(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetNextRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetNextRequest> params(std::move(_request_buffer));
  DirectoryWatcher::SetTransactionHeaderFor::GetNextRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryWatcher::GetNextResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNextRequest, GetNextResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<DirectoryWatcher::GetNextResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool DirectoryWatcher::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectoryWatcher_GetNext_Ordinal:
    case kDirectoryWatcher_GetNext_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNextRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetNext(
          Interface::GetNextCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool DirectoryWatcher::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void DirectoryWatcher::Interface::GetNextCompleterBase::Reply(::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryWatchedEvent> events) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNextResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetNextResponse _response = {};
  DirectoryWatcher::SetTransactionHeaderFor::GetNextResponse(
      ::fidl::DecodedMessage<GetNextResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNextResponse::PrimarySize,
              GetNextResponse::PrimarySize)));
  _response.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryWatcher::Interface::GetNextCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::VectorView<::llcpp::fuchsia::io2::DirectoryWatchedEvent> events) {
  if (_buffer.capacity() < GetNextResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetNextResponse _response = {};
  DirectoryWatcher::SetTransactionHeaderFor::GetNextResponse(
      ::fidl::DecodedMessage<GetNextResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetNextResponse::PrimarySize,
              GetNextResponse::PrimarySize)));
  _response.events = std::move(events);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void DirectoryWatcher::Interface::GetNextCompleterBase::Reply(::fidl::DecodedMessage<GetNextResponse> params) {
  DirectoryWatcher::SetTransactionHeaderFor::GetNextResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void DirectoryWatcher::SetTransactionHeaderFor::GetNextRequest(const ::fidl::DecodedMessage<DirectoryWatcher::GetNextRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryWatcher_GetNext_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void DirectoryWatcher::SetTransactionHeaderFor::GetNextResponse(const ::fidl::DecodedMessage<DirectoryWatcher::GetNextResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectoryWatcher_GetNext_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void ::llcpp::fuchsia::io2::File_Write_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_Write_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_Write_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_Write_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::File_WriteAt_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_WriteAt_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_WriteAt_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_WriteAt_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::File_Seek_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_Seek_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_Seek_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_Seek_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::File_Resize_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(File_Resize_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(File_Resize_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(File_Resize_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::FileInfo::Builder FileInfo::Build() {
  return FileInfo::Builder();
}

auto ::llcpp::fuchsia::io2::FileInfo::Builder::set_observer(::zx::event* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::FileInfo::Builder::set_is_append(bool* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

void ::llcpp::fuchsia::io2::Directory_Unlink_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Directory_Unlink_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Directory_Unlink_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Directory_Unlink_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::Directory_Rename_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Directory_Rename_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Directory_Rename_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Directory_Rename_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::fuchsia::io2::Directory_Link_Result::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Directory_Link_Result) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Directory_Link_Result, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Directory_Link_Result, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::DirectoryWatchOptions::Builder DirectoryWatchOptions::Build() {
  return DirectoryWatchOptions::Builder();
}

::llcpp::fuchsia::io2::DirectoryInfo::Builder DirectoryInfo::Build() {
  return DirectoryInfo::Builder();
}

::llcpp::fuchsia::io2::DeviceInfo::Builder DeviceInfo::Build() {
  return DeviceInfo::Builder();
}

auto ::llcpp::fuchsia::io2::DeviceInfo::Builder::set_event(::zx::event* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

::llcpp::fuchsia::io2::DebuglogInfo::Builder DebuglogInfo::Build() {
  return DebuglogInfo::Builder();
}

auto ::llcpp::fuchsia::io2::DebuglogInfo::Builder::set_debuglog(::zx::debuglog* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

::llcpp::fuchsia::io2::ConnectorInfo::Builder ConnectorInfo::Build() {
  return ConnectorInfo::Builder();
}
auto ::llcpp::fuchsia::io2::Representation::which() const -> Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal()) {
  case Ordinal::kConnector:
  case Ordinal::kDirectory:
  case Ordinal::kFile:
  case Ordinal::kMemory:
  case Ordinal::kPosixSocket:
  case Ordinal::kPipe:
  case Ordinal::kDebuglog:
  case Ordinal::kDevice:
  case Ordinal::kTty:
    return static_cast<Tag>(ordinal());
  default:
    return Tag::kUnknown;
  }
}

void ::llcpp::fuchsia::io2::Representation::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Representation) == sizeof(fidl_xunion_t));
  static_assert(offsetof(Representation, ordinal_) == offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(Representation, envelope_) == offsetof(fidl_xunion_t, envelope));
}

::llcpp::fuchsia::io2::ConnectionInfo::Builder ConnectionInfo::Build() {
  return ConnectionInfo::Builder();
}

auto ::llcpp::fuchsia::io2::ConnectionInfo::Builder::set_representation(::llcpp::fuchsia::io2::Representation* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::ConnectionInfo::Builder::set_rights(::llcpp::fuchsia::io2::Operations* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::ConnectionInfo::Builder::set_available_operations(::llcpp::fuchsia::io2::Operations* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

::llcpp::fuchsia::io2::ConnectionOptions::Builder ConnectionOptions::Build() {
  return ConnectionOptions::Builder();
}

auto ::llcpp::fuchsia::io2::ConnectionOptions::Builder::set_flags(::llcpp::fuchsia::io2::ConnectionFlags* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[1 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 1) {
    max_ordinal_ = 1;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::ConnectionOptions::Builder::set_protocols(::llcpp::fuchsia::io2::NodeProtocolSet* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[2 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 2) {
    max_ordinal_ = 2;
  }
  return std::move(*this);
}

auto ::llcpp::fuchsia::io2::ConnectionOptions::Builder::set_rights(::llcpp::fuchsia::io2::Operations* elem) -> Builder&& {
  ZX_ASSERT(elem);
  envelopes_[3 - 1].data = static_cast<void*>(elem);
  if (max_ordinal_ < 3) {
    max_ordinal_ = 3;
  }
  return std::move(*this);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kNode_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kNode_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kNode_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kNode_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_NodeSyncResponseTable;

}  // namespace

Node::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Node::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Node::ResultOf::Reopen Node::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

Node::ResultOf::Reopen Node::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


Node::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Node::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Node::UnownedResultOf::Reopen Node::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

Node::UnownedResultOf::Reopen Node::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Node::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  Node::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Node::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Node::InPlace::Close(std::move(_client_end)));
}

Node::ResultOf::Close Node::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Node::ResultOf::Close Node::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Node::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Node::ResultOf::Describe_Impl<Node::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Node::ResultOf::Describe Node::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

Node::ResultOf::Describe Node::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
Node::UnownedResultOf::Describe_Impl<Node::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Node::UnownedResultOf::Describe Node::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Node::UnownedResultOf::Describe Node::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::DescribeResponse> Node::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  Node::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::GetToken_Impl<Node::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::GetToken Node::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Node::ResultOf::GetToken Node::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Node::UnownedResultOf::GetToken_Impl<Node::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::GetToken Node::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::GetToken Node::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::GetTokenResponse> Node::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::GetAttributes_Impl<Node::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Node::ResultOf::GetAttributes Node::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

Node::ResultOf::GetAttributes Node::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
Node::UnownedResultOf::GetAttributes_Impl<Node::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Node::UnownedResultOf::GetAttributes Node::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Node::UnownedResultOf::GetAttributes Node::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::GetAttributesResponse> Node::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Node::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::UpdateAttributes_Impl<Node::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Node::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Node::ResultOf::UpdateAttributes Node::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

Node::ResultOf::UpdateAttributes Node::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
Node::UnownedResultOf::UpdateAttributes_Impl<Node::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Node::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Node::UnownedResultOf::UpdateAttributes Node::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

Node::UnownedResultOf::UpdateAttributes Node::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::UpdateAttributesResponse> Node::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Node::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Node::ResultOf::Sync_Impl<Node::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Node::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Node::ResultOf::Sync Node::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Node::ResultOf::Sync Node::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Node::UnownedResultOf::Sync_Impl<Node::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Node::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Node::UnownedResultOf::Sync Node::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Node::UnownedResultOf::Sync Node::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Node::SyncResponse> Node::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Node::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Node::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Node::SyncClient::HandleEvents(Node::EventHandlers handlers) {
  return Node::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Node::Call::HandleEvents(::zx::unowned_channel client_end, Node::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kNode_OnConnectionInfo_Ordinal:
    case kNode_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Node::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kNode_Reopen_Ordinal:
    case kNode_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kNode_Close_Ordinal:
    case kNode_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kNode_Describe_Ordinal:
    case kNode_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kNode_GetToken_Ordinal:
    case kNode_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kNode_GetAttributes_Ordinal:
    case kNode_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kNode_UpdateAttributes_Ordinal:
    case kNode_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kNode_Sync_Ordinal:
    case kNode_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Node::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Node::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  Node::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Node::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Node::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Node::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Node::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  Node::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  Node::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Node::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  Node::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Node::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  Node::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void Node::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void Node::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  Node::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void Node::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Node::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  Node::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void Node::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void Node::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  Node::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void Node::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  Node::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  Node::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void Node::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void Node::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  Node::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void Node::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  Node::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Node::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  Node::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void Node::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  Node::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Node::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void Node::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Node::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Node::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<Node::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Node::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Node::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Node::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Node::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<Node::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Node::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Node::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Node::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<Node::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Node::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<Node::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<Node::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Node::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<Node::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Node::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Node::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Node::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Node::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kNode_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kPipe_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kPipe_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kPipe_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kPipe_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_PipeSyncResponseTable;

}  // namespace

Pipe::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Pipe::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Pipe::ResultOf::Reopen Pipe::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

Pipe::ResultOf::Reopen Pipe::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


Pipe::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Pipe::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Pipe::UnownedResultOf::Reopen Pipe::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

Pipe::UnownedResultOf::Reopen Pipe::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Pipe::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  Pipe::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Pipe::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Pipe::InPlace::Close(std::move(_client_end)));
}

Pipe::ResultOf::Close Pipe::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Pipe::ResultOf::Close Pipe::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Pipe::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Pipe::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Pipe::ResultOf::Describe_Impl<Pipe::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Pipe::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Pipe::ResultOf::Describe Pipe::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

Pipe::ResultOf::Describe Pipe::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
Pipe::UnownedResultOf::Describe_Impl<Pipe::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Pipe::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Pipe::UnownedResultOf::Describe Pipe::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Pipe::UnownedResultOf::Describe Pipe::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Pipe::DescribeResponse> Pipe::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  Pipe::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Pipe::ResultOf::GetToken_Impl<Pipe::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Pipe::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Pipe::ResultOf::GetToken Pipe::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Pipe::ResultOf::GetToken Pipe::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Pipe::UnownedResultOf::GetToken_Impl<Pipe::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Pipe::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Pipe::UnownedResultOf::GetToken Pipe::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Pipe::UnownedResultOf::GetToken Pipe::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Pipe::GetTokenResponse> Pipe::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Pipe::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Pipe::ResultOf::GetAttributes_Impl<Pipe::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Pipe::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Pipe::ResultOf::GetAttributes Pipe::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

Pipe::ResultOf::GetAttributes Pipe::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
Pipe::UnownedResultOf::GetAttributes_Impl<Pipe::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Pipe::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Pipe::UnownedResultOf::GetAttributes Pipe::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Pipe::UnownedResultOf::GetAttributes Pipe::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Pipe::GetAttributesResponse> Pipe::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Pipe::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Pipe::ResultOf::UpdateAttributes_Impl<Pipe::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Pipe::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Pipe::ResultOf::UpdateAttributes Pipe::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

Pipe::ResultOf::UpdateAttributes Pipe::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
Pipe::UnownedResultOf::UpdateAttributes_Impl<Pipe::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Pipe::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Pipe::UnownedResultOf::UpdateAttributes Pipe::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

Pipe::UnownedResultOf::UpdateAttributes Pipe::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Pipe::UpdateAttributesResponse> Pipe::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Pipe::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Pipe::ResultOf::Sync_Impl<Pipe::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Pipe::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Pipe::ResultOf::Sync Pipe::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Pipe::ResultOf::Sync Pipe::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Pipe::UnownedResultOf::Sync_Impl<Pipe::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Pipe::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Pipe::UnownedResultOf::Sync Pipe::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Pipe::UnownedResultOf::Sync Pipe::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Pipe::SyncResponse> Pipe::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Pipe::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Pipe::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Pipe::SyncClient::HandleEvents(Pipe::EventHandlers handlers) {
  return Pipe::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Pipe::Call::HandleEvents(::zx::unowned_channel client_end, Pipe::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kPipe_OnConnectionInfo_Ordinal:
    case kPipe_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Pipe::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kPipe_Reopen_Ordinal:
    case kPipe_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kPipe_Close_Ordinal:
    case kPipe_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kPipe_Describe_Ordinal:
    case kPipe_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kPipe_GetToken_Ordinal:
    case kPipe_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kPipe_GetAttributes_Ordinal:
    case kPipe_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kPipe_UpdateAttributes_Ordinal:
    case kPipe_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kPipe_Sync_Ordinal:
    case kPipe_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Pipe::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Pipe::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  Pipe::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Pipe::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Pipe::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Pipe::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Pipe::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Pipe::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  Pipe::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Pipe::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  Pipe::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Pipe::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  Pipe::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Pipe::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  Pipe::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void Pipe::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void Pipe::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  Pipe::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void Pipe::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Pipe::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Pipe::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  Pipe::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void Pipe::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void Pipe::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  Pipe::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void Pipe::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  Pipe::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Pipe::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  Pipe::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void Pipe::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void Pipe::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  Pipe::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void Pipe::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  Pipe::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Pipe::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  Pipe::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void Pipe::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void Pipe::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  Pipe::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Pipe::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void Pipe::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Pipe::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Pipe::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<Pipe::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Pipe::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Pipe::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Pipe::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Pipe::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<Pipe::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Pipe::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Pipe::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Pipe::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<Pipe::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Pipe::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<Pipe::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<Pipe::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Pipe::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<Pipe::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Pipe::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Pipe::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Pipe::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Pipe::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kPipe_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kMemory_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kMemory_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemoryUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kMemory_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kMemory_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_MemorySyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_MemorySyncResponseTable;

}  // namespace

Memory::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Memory::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Memory::ResultOf::Reopen Memory::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

Memory::ResultOf::Reopen Memory::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


Memory::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Memory::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Memory::UnownedResultOf::Reopen Memory::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

Memory::UnownedResultOf::Reopen Memory::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Memory::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  Memory::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Memory::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Memory::InPlace::Close(std::move(_client_end)));
}

Memory::ResultOf::Close Memory::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Memory::ResultOf::Close Memory::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Memory::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Memory::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Memory::ResultOf::Describe_Impl<Memory::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Memory::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Memory::ResultOf::Describe Memory::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

Memory::ResultOf::Describe Memory::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
Memory::UnownedResultOf::Describe_Impl<Memory::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Memory::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Memory::UnownedResultOf::Describe Memory::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Memory::UnownedResultOf::Describe Memory::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Memory::DescribeResponse> Memory::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  Memory::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Memory::ResultOf::GetToken_Impl<Memory::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Memory::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Memory::ResultOf::GetToken Memory::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Memory::ResultOf::GetToken Memory::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Memory::UnownedResultOf::GetToken_Impl<Memory::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Memory::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Memory::UnownedResultOf::GetToken Memory::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Memory::UnownedResultOf::GetToken Memory::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Memory::GetTokenResponse> Memory::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Memory::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Memory::ResultOf::GetAttributes_Impl<Memory::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Memory::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Memory::ResultOf::GetAttributes Memory::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

Memory::ResultOf::GetAttributes Memory::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
Memory::UnownedResultOf::GetAttributes_Impl<Memory::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Memory::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Memory::UnownedResultOf::GetAttributes Memory::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Memory::UnownedResultOf::GetAttributes Memory::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Memory::GetAttributesResponse> Memory::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Memory::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Memory::ResultOf::UpdateAttributes_Impl<Memory::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Memory::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Memory::ResultOf::UpdateAttributes Memory::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

Memory::ResultOf::UpdateAttributes Memory::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
Memory::UnownedResultOf::UpdateAttributes_Impl<Memory::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Memory::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Memory::UnownedResultOf::UpdateAttributes Memory::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

Memory::UnownedResultOf::UpdateAttributes Memory::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Memory::UpdateAttributesResponse> Memory::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Memory::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Memory::ResultOf::Sync_Impl<Memory::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Memory::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Memory::ResultOf::Sync Memory::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Memory::ResultOf::Sync Memory::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Memory::UnownedResultOf::Sync_Impl<Memory::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Memory::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Memory::UnownedResultOf::Sync Memory::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Memory::UnownedResultOf::Sync Memory::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Memory::SyncResponse> Memory::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Memory::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Memory::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Memory::SyncClient::HandleEvents(Memory::EventHandlers handlers) {
  return Memory::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Memory::Call::HandleEvents(::zx::unowned_channel client_end, Memory::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kMemory_OnConnectionInfo_Ordinal:
    case kMemory_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Memory::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kMemory_Reopen_Ordinal:
    case kMemory_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kMemory_Close_Ordinal:
    case kMemory_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kMemory_Describe_Ordinal:
    case kMemory_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kMemory_GetToken_Ordinal:
    case kMemory_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kMemory_GetAttributes_Ordinal:
    case kMemory_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kMemory_UpdateAttributes_Ordinal:
    case kMemory_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kMemory_Sync_Ordinal:
    case kMemory_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Memory::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Memory::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  Memory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Memory::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Memory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Memory::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Memory::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Memory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  Memory::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Memory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  Memory::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Memory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  Memory::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Memory::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  Memory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void Memory::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void Memory::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  Memory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void Memory::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Memory::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Memory::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  Memory::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void Memory::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void Memory::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  Memory::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void Memory::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  Memory::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Memory::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  Memory::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void Memory::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void Memory::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  Memory::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void Memory::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  Memory::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Memory::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  Memory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void Memory::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void Memory::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  Memory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Memory::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void Memory::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Memory::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Memory::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<Memory::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Memory::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Memory::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Memory::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Memory::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<Memory::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Memory::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Memory::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Memory::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<Memory::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Memory::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<Memory::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<Memory::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Memory::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<Memory::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Memory::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Memory::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Memory::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Memory::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kMemory_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kFile_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Seek_Ordinal = 0x3e95a93600000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Seek_GenOrdinal = 0x6cd7bdfcc294f64elu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSeekRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileSeekResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Read_Ordinal = 0x1a1df2b800000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Read_GenOrdinal = 0x6ab0b2e9f1e01f70lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Write_Ordinal = 0xcc807f200000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Write_GenOrdinal = 0x17872fc3d6725e01lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_ReadAt_Ordinal = 0x6b9eac3400000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_ReadAt_GenOrdinal = 0x774898cce31c78aalu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadAtRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileReadAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_WriteAt_Ordinal = 0x40b5055d00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_WriteAt_GenOrdinal = 0x7b2af74fa0191292lu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteAtRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileWriteAtResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_Resize_Ordinal = 0x24efd03800000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_Resize_GenOrdinal = 0x57e9585fedaeaa1clu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileResizeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileResizeResponseTable;
[[maybe_unused]]
constexpr uint64_t kFile_GetMemRange_Ordinal = 0x150b497e00000000lu;
[[maybe_unused]]
constexpr uint64_t kFile_GetMemRange_GenOrdinal = 0x53842973559bd6ablu;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetMemRangeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_FileGetMemRangeResponseTable;

}  // namespace

File::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      File::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

File::ResultOf::Reopen File::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

File::ResultOf::Reopen File::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


File::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      File::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

File::UnownedResultOf::Reopen File::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

File::UnownedResultOf::Reopen File::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError File::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  File::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


File::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      File::InPlace::Close(std::move(_client_end)));
}

File::ResultOf::Close File::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

File::ResultOf::Close File::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError File::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
File::ResultOf::Describe_Impl<File::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Describe File::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

File::ResultOf::Describe File::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
File::UnownedResultOf::Describe_Impl<File::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Describe File::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

File::UnownedResultOf::Describe File::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<File::DescribeResponse> File::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetToken_Impl<File::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::GetToken File::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

File::ResultOf::GetToken File::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
File::UnownedResultOf::GetToken_Impl<File::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::GetToken File::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::GetToken File::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetTokenResponse> File::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetAttributes_Impl<File::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::GetAttributes File::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

File::ResultOf::GetAttributes File::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
File::UnownedResultOf::GetAttributes_Impl<File::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::GetAttributes File::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

File::UnownedResultOf::GetAttributes File::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetAttributesResponse> File::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::UpdateAttributes_Impl<File::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::UpdateAttributes File::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

File::ResultOf::UpdateAttributes File::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
File::UnownedResultOf::UpdateAttributes_Impl<File::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::UpdateAttributes File::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

File::UnownedResultOf::UpdateAttributes File::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<File::UpdateAttributesResponse> File::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Sync_Impl<File::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

File::ResultOf::Sync File::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

File::ResultOf::Sync File::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
File::UnownedResultOf::Sync_Impl<File::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

File::UnownedResultOf::Sync File::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

File::UnownedResultOf::Sync File::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SyncResponse> File::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  File::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Seek_Impl<File::SeekResponse>::Seek_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SeekRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SeekRequest*>(_write_bytes);
  _request.origin = std::move(origin);
  _request.offset = std::move(offset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Seek(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Seek File::SyncClient::Seek(::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset) {
    return ResultOf::Seek(::zx::unowned_channel(this->channel_), std::move(origin), std::move(offset));
}

File::ResultOf::Seek File::Call::Seek(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset) {
  return ResultOf::Seek(std::move(_client_end), std::move(origin), std::move(offset));
}

template <>
File::UnownedResultOf::Seek_Impl<File::SeekResponse>::Seek_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SeekRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SeekResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SeekRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SeekRequest*>(_request_buffer.data());
  _request.origin = std::move(origin);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(SeekRequest));
  ::fidl::DecodedMessage<SeekRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Seek(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Seek File::SyncClient::Seek(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Seek(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(origin), std::move(offset), std::move(_response_buffer));
}

File::UnownedResultOf::Seek File::Call::Seek(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::SeekOrigin origin, int64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Seek(std::move(_client_end), std::move(_request_buffer), std::move(origin), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<File::SeekResponse> File::InPlace::Seek(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::SeekRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SeekRequest, SeekResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::SeekResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Read_Impl<File::ReadResponse>::Read_Impl(::zx::unowned_channel _client_end, uint64_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_write_bytes);
  _request.count = std::move(count);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Read(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Read File::SyncClient::Read(uint64_t count) {
    return ResultOf::Read(::zx::unowned_channel(this->channel_), std::move(count));
}

File::ResultOf::Read File::Call::Read(::zx::unowned_channel _client_end, uint64_t count) {
  return ResultOf::Read(std::move(_client_end), std::move(count));
}

template <>
File::UnownedResultOf::Read_Impl<File::ReadResponse>::Read_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadRequest*>(_request_buffer.data());
  _request.count = std::move(count);
  _request_buffer.set_actual(sizeof(ReadRequest));
  ::fidl::DecodedMessage<ReadRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Read(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Read File::SyncClient::Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(_response_buffer));
}

File::UnownedResultOf::Read File::Call::Read(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Read(std::move(_client_end), std::move(_request_buffer), std::move(count), std::move(_response_buffer));
}

::fidl::DecodeResult<File::ReadResponse> File::InPlace::Read(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::ReadRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadRequest, ReadResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Write_Impl<File::WriteResponse>::Write_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteRequest _request = {};
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::Write(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Write File::SyncClient::Write(::fidl::VectorView<uint8_t> data) {
    return ResultOf::Write(::zx::unowned_channel(this->channel_), std::move(data));
}

File::ResultOf::Write File::Call::Write(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data) {
  return ResultOf::Write(std::move(_client_end), std::move(data));
}

template <>
File::UnownedResultOf::Write_Impl<File::WriteResponse>::Write_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteRequest _request = {};
  _request.data = std::move(data);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::Write(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Write File::SyncClient::Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(_response_buffer));
}

File::UnownedResultOf::Write File::Call::Write(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Write(std::move(_client_end), std::move(_request_buffer), std::move(data), std::move(_response_buffer));
}

::fidl::DecodeResult<File::WriteResponse> File::InPlace::Write(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::WriteRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteRequest, WriteResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::ReadAt_Impl<File::ReadAtResponse>::ReadAt_Impl(::zx::unowned_channel _client_end, uint64_t count, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAtRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadAtRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAtRequest*>(_write_bytes);
  _request.count = std::move(count);
  _request.offset = std::move(offset);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadAtRequest));
  ::fidl::DecodedMessage<ReadAtRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::ReadAt(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::ReadAt File::SyncClient::ReadAt(uint64_t count, uint64_t offset) {
    return ResultOf::ReadAt(::zx::unowned_channel(this->channel_), std::move(count), std::move(offset));
}

File::ResultOf::ReadAt File::Call::ReadAt(::zx::unowned_channel _client_end, uint64_t count, uint64_t offset) {
  return ResultOf::ReadAt(std::move(_client_end), std::move(count), std::move(offset));
}

template <>
File::UnownedResultOf::ReadAt_Impl<File::ReadAtResponse>::ReadAt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadAtRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadAtRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadAtRequest*>(_request_buffer.data());
  _request.count = std::move(count);
  _request.offset = std::move(offset);
  _request_buffer.set_actual(sizeof(ReadAtRequest));
  ::fidl::DecodedMessage<ReadAtRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::ReadAt(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::ReadAt File::SyncClient::ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAt(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(count), std::move(offset), std::move(_response_buffer));
}

File::UnownedResultOf::ReadAt File::Call::ReadAt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadAt(std::move(_client_end), std::move(_request_buffer), std::move(count), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<File::ReadAtResponse> File::InPlace::ReadAt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::ReadAtRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadAtRequest, ReadAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ReadAtResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::WriteAt_Impl<File::WriteAtResponse>::WriteAt_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WriteAtRequest _request = {};
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::WriteAt(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::WriteAt File::SyncClient::WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset) {
    return ResultOf::WriteAt(::zx::unowned_channel(this->channel_), std::move(data), std::move(offset));
}

File::ResultOf::WriteAt File::Call::WriteAt(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset) {
  return ResultOf::WriteAt(std::move(_client_end), std::move(data), std::move(offset));
}

template <>
File::UnownedResultOf::WriteAt_Impl<File::WriteAtResponse>::WriteAt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WriteAtRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WriteAtResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WriteAtRequest _request = {};
  _request.data = std::move(data);
  _request.offset = std::move(offset);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WriteAtRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      File::InPlace::WriteAt(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::WriteAt File::SyncClient::WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAt(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(data), std::move(offset), std::move(_response_buffer));
}

File::UnownedResultOf::WriteAt File::Call::WriteAt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WriteAt(std::move(_client_end), std::move(_request_buffer), std::move(data), std::move(offset), std::move(_response_buffer));
}

::fidl::DecodeResult<File::WriteAtResponse> File::InPlace::WriteAt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::WriteAtRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WriteAtRequest, WriteAtResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::WriteAtResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::Resize_Impl<File::ResizeResponse>::Resize_Impl(::zx::unowned_channel _client_end, uint64_t length) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResizeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ResizeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ResizeRequest*>(_write_bytes);
  _request.length = std::move(length);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ResizeRequest));
  ::fidl::DecodedMessage<ResizeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::Resize(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::Resize File::SyncClient::Resize(uint64_t length) {
    return ResultOf::Resize(::zx::unowned_channel(this->channel_), std::move(length));
}

File::ResultOf::Resize File::Call::Resize(::zx::unowned_channel _client_end, uint64_t length) {
  return ResultOf::Resize(std::move(_client_end), std::move(length));
}

template <>
File::UnownedResultOf::Resize_Impl<File::ResizeResponse>::Resize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ResizeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ResizeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ResizeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ResizeRequest*>(_request_buffer.data());
  _request.length = std::move(length);
  _request_buffer.set_actual(sizeof(ResizeRequest));
  ::fidl::DecodedMessage<ResizeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::Resize(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::Resize File::SyncClient::Resize(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Resize(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(length), std::move(_response_buffer));
}

File::UnownedResultOf::Resize File::Call::Resize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Resize(std::move(_client_end), std::move(_request_buffer), std::move(length), std::move(_response_buffer));
}

::fidl::DecodeResult<File::ResizeResponse> File::InPlace::Resize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ResizeRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::ResizeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ResizeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ResizeRequest, ResizeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::ResizeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
File::ResultOf::GetMemRange_Impl<File::GetMemRangeResponse>::GetMemRange_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::VmoFlags flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetMemRangeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetMemRangeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetMemRangeRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetMemRangeRequest));
  ::fidl::DecodedMessage<GetMemRangeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      File::InPlace::GetMemRange(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

File::ResultOf::GetMemRange File::SyncClient::GetMemRange(::llcpp::fuchsia::io2::VmoFlags flags) {
    return ResultOf::GetMemRange(::zx::unowned_channel(this->channel_), std::move(flags));
}

File::ResultOf::GetMemRange File::Call::GetMemRange(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::VmoFlags flags) {
  return ResultOf::GetMemRange(std::move(_client_end), std::move(flags));
}

template <>
File::UnownedResultOf::GetMemRange_Impl<File::GetMemRangeResponse>::GetMemRange_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetMemRangeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetMemRangeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetMemRangeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetMemRangeRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(GetMemRangeRequest));
  ::fidl::DecodedMessage<GetMemRangeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      File::InPlace::GetMemRange(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

File::UnownedResultOf::GetMemRange File::SyncClient::GetMemRange(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetMemRange(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

File::UnownedResultOf::GetMemRange File::Call::GetMemRange(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::VmoFlags flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetMemRange(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<File::GetMemRangeResponse> File::InPlace::GetMemRange(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetMemRangeRequest> params, ::fidl::BytePart response_buffer) {
  File::SetTransactionHeaderFor::GetMemRangeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetMemRangeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetMemRangeRequest, GetMemRangeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<File::GetMemRangeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t File::SyncClient::HandleEvents(File::EventHandlers handlers) {
  return File::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t File::Call::HandleEvents(::zx::unowned_channel client_end, File::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kFile_OnConnectionInfo_Ordinal:
    case kFile_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool File::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kFile_Reopen_Ordinal:
    case kFile_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kFile_Close_Ordinal:
    case kFile_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kFile_Describe_Ordinal:
    case kFile_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kFile_GetToken_Ordinal:
    case kFile_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kFile_GetAttributes_Ordinal:
    case kFile_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kFile_UpdateAttributes_Ordinal:
    case kFile_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kFile_Sync_Ordinal:
    case kFile_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kFile_Seek_Ordinal:
    case kFile_Seek_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SeekRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Seek(std::move(message->origin), std::move(message->offset),
          Interface::SeekCompleter::Sync(txn));
      return true;
    }
    case kFile_Read_Ordinal:
    case kFile_Read_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Read(std::move(message->count),
          Interface::ReadCompleter::Sync(txn));
      return true;
    }
    case kFile_Write_Ordinal:
    case kFile_Write_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Write(std::move(message->data),
          Interface::WriteCompleter::Sync(txn));
      return true;
    }
    case kFile_ReadAt_Ordinal:
    case kFile_ReadAt_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadAt(std::move(message->count), std::move(message->offset),
          Interface::ReadAtCompleter::Sync(txn));
      return true;
    }
    case kFile_WriteAt_Ordinal:
    case kFile_WriteAt_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WriteAtRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WriteAt(std::move(message->data), std::move(message->offset),
          Interface::WriteAtCompleter::Sync(txn));
      return true;
    }
    case kFile_Resize_Ordinal:
    case kFile_Resize_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ResizeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Resize(std::move(message->length),
          Interface::ResizeCompleter::Sync(txn));
      return true;
    }
    case kFile_GetMemRange_Ordinal:
    case kFile_GetMemRange_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetMemRangeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetMemRange(std::move(message->flags),
          Interface::GetMemRangeCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool File::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void File::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  File::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  File::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void File::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  File::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t File::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  File::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  File::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t File::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  File::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void File::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  File::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void File::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void File::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  File::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void File::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  File::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  File::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void File::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void File::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  File::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void File::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  File::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  File::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void File::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void File::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  File::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void File::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  File::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  File::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void File::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  File::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void File::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  File::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::SeekCompleterBase::Reply(::llcpp::fuchsia::io2::File_Seek_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SeekResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SeekResponse _response = {};
  File::SetTransactionHeaderFor::SeekResponse(
      ::fidl::DecodedMessage<SeekResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SeekResponse::PrimarySize,
              SeekResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::SeekCompleterBase::ReplySuccess(uint64_t offset_from_start) {
  File_Seek_Response response;
  response.offset_from_start = std::move(offset_from_start);

  Reply(File_Seek_Result::WithResponse(&response));
}
void File::Interface::SeekCompleterBase::ReplyError(int32_t error) {
  Reply(File_Seek_Result::WithErr(&error));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Seek_Result result) {
  if (_buffer.capacity() < SeekResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SeekResponse _response = {};
  File::SetTransactionHeaderFor::SeekResponse(
      ::fidl::DecodedMessage<SeekResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SeekResponse::PrimarySize,
              SeekResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::SeekCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint64_t offset_from_start) {
  File_Seek_Response response;
  response.offset_from_start = std::move(offset_from_start);

  Reply(std::move(_buffer), File_Seek_Result::WithResponse(&response));
}

void File::Interface::SeekCompleterBase::Reply(::fidl::DecodedMessage<SeekResponse> params) {
  File::SetTransactionHeaderFor::SeekResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadCompleterBase::Reply(::llcpp::fuchsia::io2::File_Read_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadResponse _response = {};
  File::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ReadCompleterBase::ReplySuccess(::fidl::VectorView<uint8_t> data) {
  File_Read_Response response;
  response.data = std::move(data);

  Reply(File_Read_Result::WithResponse(&response));
}
void File::Interface::ReadCompleterBase::ReplyError(int32_t error) {
  Reply(File_Read_Result::WithErr(&error));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Read_Result result) {
  if (_buffer.capacity() < ReadResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadResponse _response = {};
  File::SetTransactionHeaderFor::ReadResponse(
      ::fidl::DecodedMessage<ReadResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadResponse::PrimarySize,
              ReadResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ReadCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> data) {
  File_Read_Response response;
  response.data = std::move(data);

  Reply(std::move(_buffer), File_Read_Result::WithResponse(&response));
}

void File::Interface::ReadCompleterBase::Reply(::fidl::DecodedMessage<ReadResponse> params) {
  File::SetTransactionHeaderFor::ReadResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteCompleterBase::Reply(::llcpp::fuchsia::io2::File_Write_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  WriteResponse _response = {};
  File::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::WriteCompleterBase::ReplySuccess(uint64_t actual_count) {
  File_Write_Response response;
  response.actual_count = std::move(actual_count);

  Reply(File_Write_Result::WithResponse(&response));
}
void File::Interface::WriteCompleterBase::ReplyError(int32_t error) {
  Reply(File_Write_Result::WithErr(&error));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Write_Result result) {
  if (_buffer.capacity() < WriteResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WriteResponse _response = {};
  File::SetTransactionHeaderFor::WriteResponse(
      ::fidl::DecodedMessage<WriteResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteResponse::PrimarySize,
              WriteResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::WriteCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint64_t actual_count) {
  File_Write_Response response;
  response.actual_count = std::move(actual_count);

  Reply(std::move(_buffer), File_Write_Result::WithResponse(&response));
}

void File::Interface::WriteCompleterBase::Reply(::fidl::DecodedMessage<WriteResponse> params) {
  File::SetTransactionHeaderFor::WriteResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ReadAtCompleterBase::Reply(::llcpp::fuchsia::io2::File_ReadAt_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadAtResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadAtResponse _response = {};
  File::SetTransactionHeaderFor::ReadAtResponse(
      ::fidl::DecodedMessage<ReadAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAtResponse::PrimarySize,
              ReadAtResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ReadAtCompleterBase::ReplySuccess(::fidl::VectorView<uint8_t> data) {
  File_ReadAt_Response response;
  response.data = std::move(data);

  Reply(File_ReadAt_Result::WithResponse(&response));
}
void File::Interface::ReadAtCompleterBase::ReplyError(int32_t error) {
  Reply(File_ReadAt_Result::WithErr(&error));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_ReadAt_Result result) {
  if (_buffer.capacity() < ReadAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadAtResponse _response = {};
  File::SetTransactionHeaderFor::ReadAtResponse(
      ::fidl::DecodedMessage<ReadAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadAtResponse::PrimarySize,
              ReadAtResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ReadAtCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::fidl::VectorView<uint8_t> data) {
  File_ReadAt_Response response;
  response.data = std::move(data);

  Reply(std::move(_buffer), File_ReadAt_Result::WithResponse(&response));
}

void File::Interface::ReadAtCompleterBase::Reply(::fidl::DecodedMessage<ReadAtResponse> params) {
  File::SetTransactionHeaderFor::ReadAtResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::WriteAtCompleterBase::Reply(::llcpp::fuchsia::io2::File_WriteAt_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WriteAtResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  WriteAtResponse _response = {};
  File::SetTransactionHeaderFor::WriteAtResponse(
      ::fidl::DecodedMessage<WriteAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAtResponse::PrimarySize,
              WriteAtResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::WriteAtCompleterBase::ReplySuccess(uint64_t actual_count) {
  File_WriteAt_Response response;
  response.actual_count = std::move(actual_count);

  Reply(File_WriteAt_Result::WithResponse(&response));
}
void File::Interface::WriteAtCompleterBase::ReplyError(int32_t error) {
  Reply(File_WriteAt_Result::WithErr(&error));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_WriteAt_Result result) {
  if (_buffer.capacity() < WriteAtResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WriteAtResponse _response = {};
  File::SetTransactionHeaderFor::WriteAtResponse(
      ::fidl::DecodedMessage<WriteAtResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WriteAtResponse::PrimarySize,
              WriteAtResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::WriteAtCompleterBase::ReplySuccess(::fidl::BytePart _buffer, uint64_t actual_count) {
  File_WriteAt_Response response;
  response.actual_count = std::move(actual_count);

  Reply(std::move(_buffer), File_WriteAt_Result::WithResponse(&response));
}

void File::Interface::WriteAtCompleterBase::Reply(::fidl::DecodedMessage<WriteAtResponse> params) {
  File::SetTransactionHeaderFor::WriteAtResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::ResizeCompleterBase::Reply(::llcpp::fuchsia::io2::File_Resize_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResizeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  ResizeResponse _response = {};
  File::SetTransactionHeaderFor::ResizeResponse(
      ::fidl::DecodedMessage<ResizeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResizeResponse::PrimarySize,
              ResizeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ResizeCompleterBase::ReplySuccess() {
  File_Resize_Response response;

  Reply(File_Resize_Result::WithResponse(&response));
}
void File::Interface::ResizeCompleterBase::ReplyError(int32_t error) {
  Reply(File_Resize_Result::WithErr(&error));
}

void File::Interface::ResizeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_Resize_Result result) {
  if (_buffer.capacity() < ResizeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ResizeResponse _response = {};
  File::SetTransactionHeaderFor::ResizeResponse(
      ::fidl::DecodedMessage<ResizeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResizeResponse::PrimarySize,
              ResizeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::ResizeCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  File_Resize_Response response;

  Reply(std::move(_buffer), File_Resize_Result::WithResponse(&response));
}

void File::Interface::ResizeCompleterBase::Reply(::fidl::DecodedMessage<ResizeResponse> params) {
  File::SetTransactionHeaderFor::ResizeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void File::Interface::GetMemRangeCompleterBase::Reply(::llcpp::fuchsia::io2::File_GetMemRange_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetMemRangeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetMemRangeResponse _response = {};
  File::SetTransactionHeaderFor::GetMemRangeResponse(
      ::fidl::DecodedMessage<GetMemRangeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetMemRangeResponse::PrimarySize,
              GetMemRangeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetMemRangeCompleterBase::ReplySuccess(::llcpp::fuchsia::mem::Range buffer) {
  File_GetMemRange_Response response;
  response.buffer = std::move(buffer);

  Reply(File_GetMemRange_Result::WithResponse(&response));
}
void File::Interface::GetMemRangeCompleterBase::ReplyError(int32_t error) {
  Reply(File_GetMemRange_Result::WithErr(&error));
}

void File::Interface::GetMemRangeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::File_GetMemRange_Result result) {
  if (_buffer.capacity() < GetMemRangeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetMemRangeResponse _response = {};
  File::SetTransactionHeaderFor::GetMemRangeResponse(
      ::fidl::DecodedMessage<GetMemRangeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetMemRangeResponse::PrimarySize,
              GetMemRangeResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void File::Interface::GetMemRangeCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::mem::Range buffer) {
  File_GetMemRange_Response response;
  response.buffer = std::move(buffer);

  Reply(std::move(_buffer), File_GetMemRange_Result::WithResponse(&response));
}

void File::Interface::GetMemRangeCompleterBase::Reply(::fidl::DecodedMessage<GetMemRangeResponse> params) {
  File::SetTransactionHeaderFor::GetMemRangeResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void File::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<File::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<File::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<File::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<File::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<File::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<File::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<File::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<File::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<File::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<File::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<File::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<File::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<File::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::SeekRequest(const ::fidl::DecodedMessage<File::SeekRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Seek_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::SeekResponse(const ::fidl::DecodedMessage<File::SeekResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Seek_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::ReadRequest(const ::fidl::DecodedMessage<File::ReadRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Read_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::ReadResponse(const ::fidl::DecodedMessage<File::ReadResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Read_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::WriteRequest(const ::fidl::DecodedMessage<File::WriteRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Write_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::WriteResponse(const ::fidl::DecodedMessage<File::WriteResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Write_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::ReadAtRequest(const ::fidl::DecodedMessage<File::ReadAtRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_ReadAt_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::ReadAtResponse(const ::fidl::DecodedMessage<File::ReadAtResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_ReadAt_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::WriteAtRequest(const ::fidl::DecodedMessage<File::WriteAtRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_WriteAt_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::WriteAtResponse(const ::fidl::DecodedMessage<File::WriteAtResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_WriteAt_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::ResizeRequest(const ::fidl::DecodedMessage<File::ResizeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Resize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::ResizeResponse(const ::fidl::DecodedMessage<File::ResizeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_Resize_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void File::SetTransactionHeaderFor::GetMemRangeRequest(const ::fidl::DecodedMessage<File::GetMemRangeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetMemRange_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void File::SetTransactionHeaderFor::GetMemRangeResponse(const ::fidl::DecodedMessage<File::GetMemRangeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFile_GetMemRange_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDirectory_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectorySyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectorySyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Open_Ordinal = 0x77699f2300000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Open_GenOrdinal = 0x38473cc20ba23253lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryOpenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Unlink_Ordinal = 0x392cf05700000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Unlink_GenOrdinal = 0x6c6dd97d65572cdblu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUnlinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Enumerate_Ordinal = 0x2a43c2d300000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Enumerate_GenOrdinal = 0xbe14c8b05a90a63lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEnumerateRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryEnumerateResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rename_Ordinal = 0x2ca2f41a00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Rename_GenOrdinal = 0x1fe02df8f70742b7lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryRenameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Link_Ordinal = 0x28f770e00000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Link_GenOrdinal = 0x42634f09df52fdcclu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryLinkRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kDirectory_Watch_Ordinal = 0x6a29d55100000000lu;
[[maybe_unused]]
constexpr uint64_t kDirectory_Watch_GenOrdinal = 0x7f88ab8c3f500618lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DirectoryWatchResponseTable;

}  // namespace

Directory::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Reopen Directory::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

Directory::ResultOf::Reopen Directory::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


Directory::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Reopen Directory::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

Directory::UnownedResultOf::Reopen Directory::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Directory::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  Directory::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Directory::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Directory::InPlace::Close(std::move(_client_end)));
}

Directory::ResultOf::Close Directory::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Close Directory::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Directory::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Directory::ResultOf::Describe_Impl<Directory::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Describe Directory::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

Directory::ResultOf::Describe Directory::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
Directory::UnownedResultOf::Describe_Impl<Directory::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Describe Directory::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Directory::UnownedResultOf::Describe Directory::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::DescribeResponse> Directory::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::GetToken_Impl<Directory::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::GetToken Directory::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Directory::ResultOf::GetToken Directory::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::GetToken_Impl<Directory::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::GetToken Directory::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::GetToken Directory::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::GetTokenResponse> Directory::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::GetAttributes_Impl<Directory::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::GetAttributes Directory::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

Directory::ResultOf::GetAttributes Directory::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
Directory::UnownedResultOf::GetAttributes_Impl<Directory::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::GetAttributes Directory::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Directory::UnownedResultOf::GetAttributes Directory::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::GetAttributesResponse> Directory::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::UpdateAttributes_Impl<Directory::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::UpdateAttributes Directory::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

Directory::ResultOf::UpdateAttributes Directory::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
Directory::UnownedResultOf::UpdateAttributes_Impl<Directory::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::UpdateAttributes Directory::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

Directory::UnownedResultOf::UpdateAttributes Directory::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::UpdateAttributesResponse> Directory::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Sync_Impl<Directory::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Directory::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Directory::ResultOf::Sync Directory::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Directory::ResultOf::Sync Directory::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Directory::UnownedResultOf::Sync_Impl<Directory::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Directory::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Sync Directory::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Directory::UnownedResultOf::Sync Directory::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::SyncResponse> Directory::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Directory::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Directory::ResultOf::Open_Impl::Open_Impl(::zx::unowned_channel _client_end, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OpenRequest _request = {};
  _request.path = std::move(path);
  _request.mode = std::move(mode);
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Open Directory::SyncClient::Open(::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Open(::zx::unowned_channel(this->channel_), std::move(path), std::move(mode), std::move(options), std::move(object_request));
}

Directory::ResultOf::Open Directory::Call::Open(::zx::unowned_channel _client_end, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Open(std::move(_client_end), std::move(path), std::move(mode), std::move(options), std::move(object_request));
}


Directory::UnownedResultOf::Open_Impl::Open_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  OpenRequest _request = {};
  _request.path = std::move(path);
  _request.mode = std::move(mode);
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Open Directory::SyncClient::Open(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Open(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(mode), std::move(options), std::move(object_request));
}

Directory::UnownedResultOf::Open Directory::Call::Open(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::llcpp::fuchsia::io2::OpenMode mode, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Open(std::move(_client_end), std::move(_request_buffer), std::move(path), std::move(mode), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Directory::InPlace::Open(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  Directory::SetTransactionHeaderFor::OpenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Directory::ResultOf::Unlink_Impl<Directory::UnlinkResponse>::Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Unlink Directory::SyncClient::Unlink(::fidl::StringView path) {
    return ResultOf::Unlink(::zx::unowned_channel(this->channel_), std::move(path));
}

Directory::ResultOf::Unlink Directory::Call::Unlink(::zx::unowned_channel _client_end, ::fidl::StringView path) {
  return ResultOf::Unlink(std::move(_client_end), std::move(path));
}

template <>
Directory::UnownedResultOf::Unlink_Impl<Directory::UnlinkResponse>::Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Unlink Directory::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

Directory::UnownedResultOf::Unlink Directory::Call::Unlink(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(std::move(_client_end), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::UnlinkResponse> Directory::InPlace::Unlink(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::UnlinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::UnlinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Directory::ResultOf::Enumerate_Impl::Enumerate_Impl(::zx::unowned_channel _client_end, ::zx::channel iterator) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EnumerateRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, EnumerateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnumerateRequest*>(_write_bytes);
  _request.iterator = std::move(iterator);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(EnumerateRequest));
  ::fidl::DecodedMessage<EnumerateRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Directory::InPlace::Enumerate(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Enumerate Directory::SyncClient::Enumerate(::zx::channel iterator) {
    return ResultOf::Enumerate(::zx::unowned_channel(this->channel_), std::move(iterator));
}

Directory::ResultOf::Enumerate Directory::Call::Enumerate(::zx::unowned_channel _client_end, ::zx::channel iterator) {
  return ResultOf::Enumerate(std::move(_client_end), std::move(iterator));
}


Directory::UnownedResultOf::Enumerate_Impl::Enumerate_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel iterator) {
  if (_request_buffer.capacity() < EnumerateRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, EnumerateRequest::PrimarySize);
  auto& _request = *reinterpret_cast<EnumerateRequest*>(_request_buffer.data());
  _request.iterator = std::move(iterator);
  _request_buffer.set_actual(sizeof(EnumerateRequest));
  ::fidl::DecodedMessage<EnumerateRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Directory::InPlace::Enumerate(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Enumerate Directory::SyncClient::Enumerate(::fidl::BytePart _request_buffer, ::zx::channel iterator) {
  return UnownedResultOf::Enumerate(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(iterator));
}

Directory::UnownedResultOf::Enumerate Directory::Call::Enumerate(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel iterator) {
  return UnownedResultOf::Enumerate(std::move(_client_end), std::move(_request_buffer), std::move(iterator));
}

::fidl::internal::StatusAndError Directory::InPlace::Enumerate(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<EnumerateRequest> params) {
  Directory::SetTransactionHeaderFor::EnumerateRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Directory::ResultOf::Rename_Impl<Directory::RenameResponse>::Rename_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Rename Directory::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
    return ResultOf::Rename(::zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Directory::ResultOf::Rename Directory::Call::Rename(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Directory::UnownedResultOf::Rename_Impl<Directory::RenameResponse>::Rename_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Rename Directory::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Directory::UnownedResultOf::Rename Directory::Call::Rename(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::RenameResponse> Directory::InPlace::Rename(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::RenameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::RenameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Directory::ResultOf::Link_Impl<Directory::LinkResponse>::Link_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Link(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Directory::ResultOf::Link Directory::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
    return ResultOf::Link(::zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Directory::ResultOf::Link Directory::Call::Link(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Directory::UnownedResultOf::Link_Impl<Directory::LinkResponse>::Link_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Directory::InPlace::Link(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Directory::UnownedResultOf::Link Directory::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Directory::UnownedResultOf::Link Directory::Call::Link(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Directory::LinkResponse> Directory::InPlace::Link(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  Directory::SetTransactionHeaderFor::LinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Directory::LinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Directory::ResultOf::Watch_Impl::Watch_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  WatchRequest _request = {};
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WatchRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Watch(std::move(_client_end), std::move(_decoded_request)));
}

Directory::ResultOf::Watch Directory::SyncClient::Watch(::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
    return ResultOf::Watch(::zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher));
}

Directory::ResultOf::Watch Directory::Call::Watch(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
  return ResultOf::Watch(std::move(_client_end), std::move(mask), std::move(options), std::move(watcher));
}


Directory::UnownedResultOf::Watch_Impl::Watch_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  WatchRequest _request = {};
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WatchRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Directory::InPlace::Watch(std::move(_client_end), std::move(_decoded_request)));
}

Directory::UnownedResultOf::Watch Directory::SyncClient::Watch(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
  return UnownedResultOf::Watch(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher));
}

Directory::UnownedResultOf::Watch Directory::Call::Watch(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::DirectoryWatchMask mask, ::llcpp::fuchsia::io2::DirectoryWatchOptions options, ::zx::channel watcher) {
  return UnownedResultOf::Watch(std::move(_client_end), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher));
}

::fidl::internal::StatusAndError Directory::InPlace::Watch(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params) {
  Directory::SetTransactionHeaderFor::WatchRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

zx_status_t Directory::SyncClient::HandleEvents(Directory::EventHandlers handlers) {
  return Directory::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Directory::Call::HandleEvents(::zx::unowned_channel client_end, Directory::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kDirectory_OnConnectionInfo_Ordinal:
    case kDirectory_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Directory::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDirectory_Reopen_Ordinal:
    case kDirectory_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Close_Ordinal:
    case kDirectory_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Describe_Ordinal:
    case kDirectory_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetToken_Ordinal:
    case kDirectory_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_GetAttributes_Ordinal:
    case kDirectory_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kDirectory_UpdateAttributes_Ordinal:
    case kDirectory_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Sync_Ordinal:
    case kDirectory_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Open_Ordinal:
    case kDirectory_Open_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->path), std::move(message->mode), std::move(message->options), std::move(message->object_request),
          Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Unlink_Ordinal:
    case kDirectory_Unlink_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
          Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Enumerate_Ordinal:
    case kDirectory_Enumerate_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EnumerateRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Enumerate(std::move(message->iterator),
          Interface::EnumerateCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Rename_Ordinal:
    case kDirectory_Rename_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Link_Ordinal:
    case kDirectory_Link_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kDirectory_Watch_Ordinal:
    case kDirectory_Watch_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
          Interface::WatchCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Directory::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Directory::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  Directory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Directory::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Directory::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Directory::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Directory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  Directory::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  Directory::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Directory::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  Directory::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Directory::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  Directory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void Directory::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  Directory::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void Directory::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Directory::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  Directory::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void Directory::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void Directory::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  Directory::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void Directory::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  Directory::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  Directory::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void Directory::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void Directory::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  Directory::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void Directory::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  Directory::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  Directory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void Directory::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  Directory::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void Directory::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Directory::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::UnlinkCompleterBase::Reply(::llcpp::fuchsia::io2::Directory_Unlink_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UnlinkResponse _response = {};
  Directory::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::UnlinkCompleterBase::ReplySuccess() {
  Directory_Unlink_Response response;

  Reply(Directory_Unlink_Result::WithResponse(&response));
}
void Directory::Interface::UnlinkCompleterBase::ReplyError(int32_t error) {
  Reply(Directory_Unlink_Result::WithErr(&error));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Unlink_Result result) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UnlinkResponse _response = {};
  Directory::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::UnlinkCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Directory_Unlink_Response response;

  Reply(std::move(_buffer), Directory_Unlink_Result::WithResponse(&response));
}

void Directory::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  Directory::SetTransactionHeaderFor::UnlinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::RenameCompleterBase::Reply(::llcpp::fuchsia::io2::Directory_Rename_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  RenameResponse _response = {};
  Directory::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::RenameCompleterBase::ReplySuccess() {
  Directory_Rename_Response response;

  Reply(Directory_Rename_Result::WithResponse(&response));
}
void Directory::Interface::RenameCompleterBase::ReplyError(int32_t error) {
  Reply(Directory_Rename_Result::WithErr(&error));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Rename_Result result) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  RenameResponse _response = {};
  Directory::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::RenameCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Directory_Rename_Response response;

  Reply(std::move(_buffer), Directory_Rename_Result::WithResponse(&response));
}

void Directory::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  Directory::SetTransactionHeaderFor::RenameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Directory::Interface::LinkCompleterBase::Reply(::llcpp::fuchsia::io2::Directory_Link_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  LinkResponse _response = {};
  Directory::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::LinkCompleterBase::ReplySuccess() {
  Directory_Link_Response response;

  Reply(Directory_Link_Result::WithResponse(&response));
}
void Directory::Interface::LinkCompleterBase::ReplyError(int32_t error) {
  Reply(Directory_Link_Result::WithErr(&error));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Directory_Link_Result result) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  LinkResponse _response = {};
  Directory::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Directory::Interface::LinkCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Directory_Link_Response response;

  Reply(std::move(_buffer), Directory_Link_Result::WithResponse(&response));
}

void Directory::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  Directory::SetTransactionHeaderFor::LinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Directory::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<Directory::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Directory::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Directory::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Directory::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<Directory::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Directory::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Directory::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<Directory::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<Directory::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<Directory::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<Directory::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Directory::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Directory::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::OpenRequest(const ::fidl::DecodedMessage<Directory::OpenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Open_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::UnlinkRequest(const ::fidl::DecodedMessage<Directory::UnlinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Unlink_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::UnlinkResponse(const ::fidl::DecodedMessage<Directory::UnlinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Unlink_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::EnumerateRequest(const ::fidl::DecodedMessage<Directory::EnumerateRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Enumerate_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::RenameRequest(const ::fidl::DecodedMessage<Directory::RenameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rename_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::RenameResponse(const ::fidl::DecodedMessage<Directory::RenameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Rename_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::LinkRequest(const ::fidl::DecodedMessage<Directory::LinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Link_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Directory::SetTransactionHeaderFor::LinkResponse(const ::fidl::DecodedMessage<Directory::LinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Link_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Directory::SetTransactionHeaderFor::WatchRequest(const ::fidl::DecodedMessage<Directory::WatchRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDirectory_Watch_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kDebuglog_Reopen_Ordinal = 0x58b509fd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Reopen_GenOrdinal = 0x74170eb73121c69flu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogReopenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogReopenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Close_Ordinal = 0x1d6d8aad00000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Close_GenOrdinal = 0x2dec2818386e5d68lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Describe_Ordinal = 0x4c10829300000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Describe_GenOrdinal = 0x4aac591060c65c2flu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_OnConnectionInfo_Ordinal = 0x774d459800000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_OnConnectionInfo_GenOrdinal = 0x6637fc43ceeaa437lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogOnConnectionInfoRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogOnConnectionInfoEventTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_GetToken_Ordinal = 0x11b59cd700000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_GetToken_GenOrdinal = 0x4f2b25c934c5d8e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetTokenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_GetAttributes_Ordinal = 0x12cd1a6000000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_GetAttributes_GenOrdinal = 0x675e1e73d076d1e4lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogGetAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_UpdateAttributes_Ordinal = 0x7c3a238d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_UpdateAttributes_GenOrdinal = 0x7d59d73f59ba21b5lu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogUpdateAttributesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogUpdateAttributesResponseTable;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Sync_Ordinal = 0x5de3a4cd00000000lu;
[[maybe_unused]]
constexpr uint64_t kDebuglog_Sync_GenOrdinal = 0xac3a8c1a2e063adlu;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_io2_DebuglogSyncResponseTable;

}  // namespace

Debuglog::ResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReopenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Debuglog::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Debuglog::ResultOf::Reopen Debuglog::SyncClient::Reopen(::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
    return ResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(options), std::move(object_request));
}

Debuglog::ResultOf::Reopen Debuglog::Call::Reopen(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return ResultOf::Reopen(std::move(_client_end), std::move(options), std::move(object_request));
}


Debuglog::UnownedResultOf::Reopen_Impl::Reopen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  if (_request_buffer.capacity() < ReopenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  ReopenRequest _request = {};
  _request.options = std::move(options);
  _request.object_request = std::move(object_request);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<ReopenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Debuglog::InPlace::Reopen(std::move(_client_end), std::move(_decoded_request)));
}

Debuglog::UnownedResultOf::Reopen Debuglog::SyncClient::Reopen(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(options), std::move(object_request));
}

Debuglog::UnownedResultOf::Reopen Debuglog::Call::Reopen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionOptions options, ::zx::channel object_request) {
  return UnownedResultOf::Reopen(std::move(_client_end), std::move(_request_buffer), std::move(options), std::move(object_request));
}

::fidl::internal::StatusAndError Debuglog::InPlace::Reopen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReopenRequest> params) {
  Debuglog::SetTransactionHeaderFor::ReopenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}


Debuglog::ResultOf::Close_Impl::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Debuglog::InPlace::Close(std::move(_client_end)));
}

Debuglog::ResultOf::Close Debuglog::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Debuglog::ResultOf::Close Debuglog::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

::fidl::internal::StatusAndError Debuglog::InPlace::Close(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Debuglog::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Debuglog::ResultOf::Describe_Impl<Debuglog::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Debuglog::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Debuglog::ResultOf::Describe Debuglog::SyncClient::Describe(::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(query));
}

Debuglog::ResultOf::Describe Debuglog::Call::Describe(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::ConnectionInfoQuery query) {
  return ResultOf::Describe(std::move(_client_end), std::move(query));
}

template <>
Debuglog::UnownedResultOf::Describe_Impl<Debuglog::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < DescribeRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<DescribeResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  auto& _request = *reinterpret_cast<DescribeRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Debuglog::InPlace::Describe(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Debuglog::UnownedResultOf::Describe Debuglog::SyncClient::Describe(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Debuglog::UnownedResultOf::Describe Debuglog::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::ConnectionInfoQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Debuglog::DescribeResponse> Debuglog::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<DescribeRequest> params, ::fidl::BytePart response_buffer) {
  Debuglog::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Debuglog::ResultOf::GetToken_Impl<Debuglog::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Debuglog::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Debuglog::ResultOf::GetToken Debuglog::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Debuglog::ResultOf::GetToken Debuglog::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Debuglog::UnownedResultOf::GetToken_Impl<Debuglog::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Debuglog::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Debuglog::UnownedResultOf::GetToken Debuglog::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Debuglog::UnownedResultOf::GetToken Debuglog::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Debuglog::GetTokenResponse> Debuglog::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Debuglog::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Debuglog::ResultOf::GetAttributes_Impl<Debuglog::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_write_bytes);
  _request.query = std::move(query);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Debuglog::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Debuglog::ResultOf::GetAttributes Debuglog::SyncClient::GetAttributes(::llcpp::fuchsia::io2::NodeAttributesQuery query) {
    return ResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(query));
}

Debuglog::ResultOf::GetAttributes Debuglog::Call::GetAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributesQuery query) {
  return ResultOf::GetAttributes(std::move(_client_end), std::move(query));
}

template <>
Debuglog::UnownedResultOf::GetAttributes_Impl<Debuglog::GetAttributesResponse>::GetAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetAttributesRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetAttributesRequest*>(_request_buffer.data());
  _request.query = std::move(query);
  _request_buffer.set_actual(sizeof(GetAttributesRequest));
  ::fidl::DecodedMessage<GetAttributesRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Debuglog::InPlace::GetAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Debuglog::UnownedResultOf::GetAttributes Debuglog::SyncClient::GetAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

Debuglog::UnownedResultOf::GetAttributes Debuglog::Call::GetAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributesQuery query, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttributes(std::move(_client_end), std::move(_request_buffer), std::move(query), std::move(_response_buffer));
}

::fidl::DecodeResult<Debuglog::GetAttributesResponse> Debuglog::InPlace::GetAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Debuglog::SetTransactionHeaderFor::GetAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::GetAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttributesRequest, GetAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::GetAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Debuglog::ResultOf::UpdateAttributes_Impl<Debuglog::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Debuglog::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Debuglog::ResultOf::UpdateAttributes Debuglog::SyncClient::UpdateAttributes(::llcpp::fuchsia::io2::NodeAttributes attributes) {
    return ResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(attributes));
}

Debuglog::ResultOf::UpdateAttributes Debuglog::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  return ResultOf::UpdateAttributes(std::move(_client_end), std::move(attributes));
}

template <>
Debuglog::UnownedResultOf::UpdateAttributes_Impl<Debuglog::UpdateAttributesResponse>::UpdateAttributes_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UpdateAttributesRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UpdateAttributesResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UpdateAttributesRequest _request = {};
  _request.attributes = std::move(attributes);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UpdateAttributesRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Debuglog::InPlace::UpdateAttributes(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Debuglog::UnownedResultOf::UpdateAttributes Debuglog::SyncClient::UpdateAttributes(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

Debuglog::UnownedResultOf::UpdateAttributes Debuglog::Call::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::UpdateAttributes(std::move(_client_end), std::move(_request_buffer), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Debuglog::UpdateAttributesResponse> Debuglog::InPlace::UpdateAttributes(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UpdateAttributesRequest> params, ::fidl::BytePart response_buffer) {
  Debuglog::SetTransactionHeaderFor::UpdateAttributesRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::UpdateAttributesResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UpdateAttributesRequest, UpdateAttributesResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::UpdateAttributesResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Debuglog::ResultOf::Sync_Impl<Debuglog::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Debuglog::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Debuglog::ResultOf::Sync Debuglog::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Debuglog::ResultOf::Sync Debuglog::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Debuglog::UnownedResultOf::Sync_Impl<Debuglog::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Debuglog::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Debuglog::UnownedResultOf::Sync Debuglog::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Debuglog::UnownedResultOf::Sync Debuglog::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Debuglog::SyncResponse> Debuglog::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Debuglog::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Debuglog::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Debuglog::SyncClient::HandleEvents(Debuglog::EventHandlers handlers) {
  return Debuglog::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Debuglog::Call::HandleEvents(::zx::unowned_channel client_end, Debuglog::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnConnectionInfoResponse::MaxNumHandles >= x) {
      x = OnConnectionInfoResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kDebuglog_OnConnectionInfo_Ordinal:
    case kDebuglog_OnConnectionInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnConnectionInfoResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_connection_info(std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Debuglog::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kDebuglog_Reopen_Ordinal:
    case kDebuglog_Reopen_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReopenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Reopen(std::move(message->options), std::move(message->object_request),
          Interface::ReopenCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_Close_Ordinal:
    case kDebuglog_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_Describe_Ordinal:
    case kDebuglog_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Describe(std::move(message->query),
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_GetToken_Ordinal:
    case kDebuglog_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_GetAttributes_Ordinal:
    case kDebuglog_GetAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetAttributes(std::move(message->query),
          Interface::GetAttributesCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_UpdateAttributes_Ordinal:
    case kDebuglog_UpdateAttributes_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UpdateAttributesRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->UpdateAttributes(std::move(message->attributes),
          Interface::UpdateAttributesCompleter::Sync(txn));
      return true;
    }
    case kDebuglog_Sync_Ordinal:
    case kDebuglog_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Debuglog::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Debuglog::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  DescribeResponse _response = {};
  Debuglog::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Debuglog::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Debuglog::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Debuglog::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Debuglog::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Debuglog::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnConnectionInfoResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnConnectionInfoResponse _response = {};
  Debuglog::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Debuglog::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::ConnectionInfo info) {
  if (_buffer.capacity() < OnConnectionInfoResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnConnectionInfoResponse _response = {};
  Debuglog::SetTransactionHeaderFor::OnConnectionInfoResponse(
      ::fidl::DecodedMessage<OnConnectionInfoResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnConnectionInfoResponse::PrimarySize,
              OnConnectionInfoResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Debuglog::SendOnConnectionInfoEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnConnectionInfoResponse> params) {
  Debuglog::SetTransactionHeaderFor::OnConnectionInfoResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Debuglog::Interface::GetTokenCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetTokenResponse _response = {};
  Debuglog::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::GetTokenCompleterBase::ReplySuccess(::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(Node_GetToken_Result::WithResponse(&response));
}
void Debuglog::Interface::GetTokenCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetToken_Result::WithErr(&error));
}

void Debuglog::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetToken_Result result) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetTokenResponse _response = {};
  Debuglog::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::GetTokenCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::zx::handle token) {
  Node_GetToken_Response response;
  response.token = std::move(token);

  Reply(std::move(_buffer), Node_GetToken_Result::WithResponse(&response));
}

void Debuglog::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Debuglog::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Debuglog::Interface::GetAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttributesResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  GetAttributesResponse _response = {};
  Debuglog::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::GetAttributesCompleterBase::ReplySuccess(::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(Node_GetAttributes_Result::WithResponse(&response));
}
void Debuglog::Interface::GetAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_GetAttributes_Result::WithErr(&error));
}

void Debuglog::Interface::GetAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_GetAttributes_Result result) {
  if (_buffer.capacity() < GetAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetAttributesResponse _response = {};
  Debuglog::SetTransactionHeaderFor::GetAttributesResponse(
      ::fidl::DecodedMessage<GetAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttributesResponse::PrimarySize,
              GetAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::GetAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::NodeAttributes attributes) {
  Node_GetAttributes_Response response;
  response.attributes = std::move(attributes);

  Reply(std::move(_buffer), Node_GetAttributes_Result::WithResponse(&response));
}

void Debuglog::Interface::GetAttributesCompleterBase::Reply(::fidl::DecodedMessage<GetAttributesResponse> params) {
  Debuglog::SetTransactionHeaderFor::GetAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Debuglog::Interface::UpdateAttributesCompleterBase::Reply(::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UpdateAttributesResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  UpdateAttributesResponse _response = {};
  Debuglog::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::UpdateAttributesCompleterBase::ReplySuccess() {
  Node_UpdateAttributes_Response response;

  Reply(Node_UpdateAttributes_Result::WithResponse(&response));
}
void Debuglog::Interface::UpdateAttributesCompleterBase::ReplyError(int32_t error) {
  Reply(Node_UpdateAttributes_Result::WithErr(&error));
}

void Debuglog::Interface::UpdateAttributesCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_UpdateAttributes_Result result) {
  if (_buffer.capacity() < UpdateAttributesResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  UpdateAttributesResponse _response = {};
  Debuglog::SetTransactionHeaderFor::UpdateAttributesResponse(
      ::fidl::DecodedMessage<UpdateAttributesResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UpdateAttributesResponse::PrimarySize,
              UpdateAttributesResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::UpdateAttributesCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_UpdateAttributes_Response response;

  Reply(std::move(_buffer), Node_UpdateAttributes_Result::WithResponse(&response));
}

void Debuglog::Interface::UpdateAttributesCompleterBase::Reply(::fidl::DecodedMessage<UpdateAttributesResponse> params) {
  Debuglog::SetTransactionHeaderFor::UpdateAttributesResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Debuglog::Interface::SyncCompleterBase::Reply(::llcpp::fuchsia::io2::Node_Sync_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  SyncResponse _response = {};
  Debuglog::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::SyncCompleterBase::ReplySuccess() {
  Node_Sync_Response response;

  Reply(Node_Sync_Result::WithResponse(&response));
}
void Debuglog::Interface::SyncCompleterBase::ReplyError(int32_t error) {
  Reply(Node_Sync_Result::WithErr(&error));
}

void Debuglog::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io2::Node_Sync_Result result) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  SyncResponse _response = {};
  Debuglog::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.result = std::move(result);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}
void Debuglog::Interface::SyncCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  Node_Sync_Response response;

  Reply(std::move(_buffer), Node_Sync_Result::WithResponse(&response));
}

void Debuglog::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Debuglog::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Debuglog::SetTransactionHeaderFor::ReopenRequest(const ::fidl::DecodedMessage<Debuglog::ReopenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Reopen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Debuglog::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Debuglog::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Debuglog::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Debuglog::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::OnConnectionInfoResponse(const ::fidl::DecodedMessage<Debuglog::OnConnectionInfoResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_OnConnectionInfo_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Debuglog::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Debuglog::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Debuglog::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::GetAttributesRequest(const ::fidl::DecodedMessage<Debuglog::GetAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Debuglog::SetTransactionHeaderFor::GetAttributesResponse(const ::fidl::DecodedMessage<Debuglog::GetAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_GetAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::UpdateAttributesRequest(const ::fidl::DecodedMessage<Debuglog::UpdateAttributesRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Debuglog::SetTransactionHeaderFor::UpdateAttributesResponse(const ::fidl::DecodedMessage<Debuglog::UpdateAttributesResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_UpdateAttributes_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Debuglog::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Debuglog::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Debuglog::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Debuglog::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kDebuglog_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace io2
}  // namespace fuchsia
}  // namespace llcpp

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/job.h>
#include <lib/zx/process.h>
#include <lib/zx/thread.h>
#include <lib/zx/vmar.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>
#include <fuchsia/ldsvc/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace process {

struct ProcessStartData;
struct HandleInfo;
class Resolver;
struct NameInfo;
struct LaunchInfo;
class Launcher;

extern "C" const fidl_type_t fuchsia_process_ProcessStartDataTable;
extern "C" const fidl_type_t v1_fuchsia_process_ProcessStartDataTable;

// The information required to start a process.
//
// To start the process, call `zx_process_start` with the arguments provided.
struct ProcessStartData {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_process_ProcessStartDataTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The process that was created.
  ::zx::process process = {};

  // The vmar object that was created when the process was created.
  //
  // See <https://fuchsia.dev/fuchsia-src/reference/syscalls/process_create.md>.
  ::zx::vmar root_vmar = {};

  // The initial thread for the process.
  //
  // Should be passed to `zx_process_start` when starting the process.
  ::zx::thread thread = {};

  // The address of the initial entry point in the process.
  //
  // Should be passed to `zx_process_start` when starting the process.
  uint64_t entry = {};

  // The stack pointer value for the initial thread of the process.
  //
  // Should be passed to `zx_process_start` when starting the process.
  uint64_t stack = {};

  // The bootstrap channel to pass to the process on startup.
  //
  // Should be passed to `zx_process_start` when starting the process.
  ::zx::channel bootstrap = {};

  // The base address of the vDSO to pass to the process on startup.
  //
  // Should be passed to `zx_process_start` when starting the process.
  uint64_t vdso_base = {};

  // The base load address of the ELF file loaded.
  //
  // Most often used by debuggers or other tools that inspect the process.
  uint64_t base = {};
};

extern "C" const fidl_type_t fuchsia_process_HandleInfoTable;
extern "C" const fidl_type_t v1_fuchsia_process_HandleInfoTable;

// Information about a handle provided to a process at startup.
//
// Processes are given a set of initial handles as part of the bootstrapping
// sequence. Some of these handles are associated with zx.procarg identifiers
// that designate their intended use by the new process.
//
// This structure represents one such handle and its associated zx.procarg
// identifier.
struct HandleInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_process_HandleInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  // The handle to use for this process argument.
  ::zx::handle handle = {};

  // Process argument identifier.
  //
  // See <zircon/processargs.h> for definitions of well-known process
  // arguments.
  uint32_t id = {};
};

extern "C" const fidl_type_t fuchsia_process_ResolverResolveRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_ResolverResolveRequestTable;
extern "C" const fidl_type_t fuchsia_process_ResolverResolveResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_ResolverResolveResponseTable;

// An interface for resolving names to executables and library loaders.
//
// An executable itself is often not sufficient to create a working process
// because many executables also load shared libraries. On Fuchsia, there is no
// global pool of shared libraries. Instead, every process has an associated
// `fuchsia.ldsvc.Loader`, which provides access to a private pool of shared
// libraries appropriate for that process.
//
// This interface provides a protocol for resolving a name into both the
// `handle<vmo>` for the executable and the `fuchsia.ldsvc.Loader` for its
// associated shared libraries.
//
// This interface is rarely used directly. Instead, `fdio_spawn` and
// `fdio_spawn_etc` use this interface internally when they try to run a file
// with a `#!resolve` directive.
class Resolver final {
  Resolver() = delete;
 public:
  static constexpr char Name[] = "fuchsia.process.Resolver";

  struct ResolveResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::vmo executable;
    ::zx::channel ldsvc;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_ResolverResolveResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_ResolverResolveResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ResolveRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView name;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_ResolverResolveRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_ResolverResolveRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 2048;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 2048;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ResolveResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Resolve_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Resolve_Impl(::zx::unowned_channel _client_end, ::fidl::StringView name);
      ~Resolve_Impl() = default;
      Resolve_Impl(Resolve_Impl&& other) = default;
      Resolve_Impl& operator=(Resolve_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Resolve = Resolve_Impl<ResolveResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Resolve_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Resolve_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);
      ~Resolve_Impl() = default;
      Resolve_Impl(Resolve_Impl&& other) = default;
      Resolve_Impl& operator=(Resolve_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Resolve = Resolve_Impl<ResolveResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Resolves the given `name` to an `executable` and an shared library
    // loader.
    //
    // If present, the `executable` is suitable for use as the `executable`
    // property of `LaunchInfo`. If present, the `ldsvc` is suitable for use as
    // the `PA_LDSVC_LOADER` handle when launching the process.
    //
    // For example, the resolver might locate the given `name` inside a package
    // and return the executable binary from the package as well as a shared
    // library loader scoped to that package.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Resolve Resolve(::fidl::StringView name);

    // Resolves the given `name` to an `executable` and an shared library
    // loader.
    //
    // If present, the `executable` is suitable for use as the `executable`
    // property of `LaunchInfo`. If present, the `ldsvc` is suitable for use as
    // the `PA_LDSVC_LOADER` handle when launching the process.
    //
    // For example, the resolver might locate the given `name` inside a package
    // and return the executable binary from the package as well as a shared
    // library loader scoped to that package.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Resolve Resolve(::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Resolves the given `name` to an `executable` and an shared library
    // loader.
    //
    // If present, the `executable` is suitable for use as the `executable`
    // property of `LaunchInfo`. If present, the `ldsvc` is suitable for use as
    // the `PA_LDSVC_LOADER` handle when launching the process.
    //
    // For example, the resolver might locate the given `name` inside a package
    // and return the executable binary from the package as well as a shared
    // library loader scoped to that package.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Resolve Resolve(::zx::unowned_channel _client_end, ::fidl::StringView name);

    // Resolves the given `name` to an `executable` and an shared library
    // loader.
    //
    // If present, the `executable` is suitable for use as the `executable`
    // property of `LaunchInfo`. If present, the `ldsvc` is suitable for use as
    // the `PA_LDSVC_LOADER` handle when launching the process.
    //
    // For example, the resolver might locate the given `name` inside a package
    // and return the executable binary from the package as well as a shared
    // library loader scoped to that package.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Resolve Resolve(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView name, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Resolves the given `name` to an `executable` and an shared library
    // loader.
    //
    // If present, the `executable` is suitable for use as the `executable`
    // property of `LaunchInfo`. If present, the `ldsvc` is suitable for use as
    // the `PA_LDSVC_LOADER` handle when launching the process.
    //
    // For example, the resolver might locate the given `name` inside a package
    // and return the executable binary from the package as well as a shared
    // library loader scoped to that package.
    static ::fidl::DecodeResult<ResolveResponse> Resolve(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ResolveRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Resolver;
    using _Base = ::fidl::CompleterBase;

    class ResolveCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::vmo executable, ::zx::channel ldsvc);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::vmo executable, ::zx::channel ldsvc);
      void Reply(::fidl::DecodedMessage<ResolveResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ResolveCompleter = ::fidl::Completer<ResolveCompleterBase>;

    virtual void Resolve(::fidl::StringView name, ResolveCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void ResolveRequest(const ::fidl::DecodedMessage<Resolver::ResolveRequest>& _msg);
    static void ResolveResponse(const ::fidl::DecodedMessage<Resolver::ResolveResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_process_NameInfoTable;
extern "C" const fidl_type_t v1_fuchsia_process_NameInfoTable;

// A namespace entry provided to a process at startup.
//
// Processes are given a set of initial handles as part of the bootstrapping
// sequence. Some of these handles are associated with paths that designate
// their intended use by the new process as namespace entries.
//
// This structure represents one such handle and its associated namespace path.
struct NameInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_process_NameInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4096;
  static constexpr bool HasPointer = true;

  // Path at which to install the associated directory.
  //
  // Must be an absolute path (i.e., start with '/').
  ::fidl::StringView path = {};

  // The associated directory.
  ::zx::channel directory = {};
};

// The maximum size for a name used by `Resolver`.
constexpr uint32_t MAX_RESOLVE_NAME_SIZE = 2048u;

constexpr uint32_t MAX = 4294967295u;

extern "C" const fidl_type_t fuchsia_process_LaunchInfoTable;
extern "C" const fidl_type_t v1_fuchsia_process_LaunchInfoTable;

// The information needed to launch a process.
struct LaunchInfo {
  static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LaunchInfoTable;
  static constexpr uint32_t MaxNumHandles = 2;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 32;
  static constexpr bool HasPointer = true;

  // The executable to run in the process.
  ::zx::vmo executable = {};

  // The job in which to create the process.
  ::zx::job job = {};

  // The name to assign to the created process.
  ::fidl::StringView name = {};
};

extern "C" const fidl_type_t fuchsia_process_LauncherLaunchRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherLaunchRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherLaunchResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherLaunchResponseTable;
extern "C" const fidl_type_t fuchsia_process_LauncherCreateWithoutStartingRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherCreateWithoutStartingRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherCreateWithoutStartingResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherCreateWithoutStartingResponseTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddArgsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddArgsRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddArgsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddArgsResponseTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddEnvironsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddEnvironsRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddEnvironsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddEnvironsResponseTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddNamesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddNamesRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddNamesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddNamesResponseTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddHandlesRequestTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddHandlesRequestTable;
extern "C" const fidl_type_t fuchsia_process_LauncherAddHandlesResponseTable;
extern "C" const fidl_type_t v1_fuchsia_process_LauncherAddHandlesResponseTable;

// A low-level interface for launching processes.
//
// This interface is used for manually assembling a process. The caller supplies
// all the capabilities for the newly created process.
//
// That create processes typically use `fdio_spawn` or `fdio_spawn_etc` rather
// than using this interface directly. The `fdio_spawn` and `fdio_spawn_etc`
// functions are implemented using this interface.
//
// Debuggers and other clients that need to create processes in a suspended
// state often use this interface directly. These clients use the
// `CreateWithoutStarting` method to create the process without actually
// starting it.
class Launcher final {
  Launcher() = delete;
 public:
  static constexpr char Name[] = "fuchsia.process.Launcher";

  struct LaunchResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::zx::process process;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherLaunchResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherLaunchResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LaunchRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::process::LaunchInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherLaunchRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherLaunchRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 32;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LaunchResponse;
  };

  struct CreateWithoutStartingResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    ::llcpp::fuchsia::process::ProcessStartData* data;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherCreateWithoutStartingResponseTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherCreateWithoutStartingResponseTable;
    static constexpr uint32_t MaxNumHandles = 4;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 56;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 56;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct CreateWithoutStartingRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::process::LaunchInfo info;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherCreateWithoutStartingRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherCreateWithoutStartingRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 32;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = CreateWithoutStartingResponse;
  };

  struct AddArgsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::fidl::VectorView<uint8_t>> args;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherAddArgsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherAddArgsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct AddEnvironsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherAddEnvironsRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherAddEnvironsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct AddNamesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherAddNamesRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherAddNamesRequestTable;
    static constexpr uint32_t MaxNumHandles = 4294967295;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct AddHandlesRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_process_LauncherAddHandlesRequestTable;
    static constexpr const fidl_type_t* AltType = &fuchsia_process_LauncherAddHandlesRequestTable;
    static constexpr uint32_t MaxNumHandles = 4294967295;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool HasPointer = true;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Launch_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Launch_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::process::LaunchInfo info);
      ~Launch_Impl() = default;
      Launch_Impl(Launch_Impl&& other) = default;
      Launch_Impl& operator=(Launch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateWithoutStarting_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      CreateWithoutStarting_Impl(::zx::unowned_channel _client_end, ::llcpp::fuchsia::process::LaunchInfo info);
      ~CreateWithoutStarting_Impl() = default;
      CreateWithoutStarting_Impl(CreateWithoutStarting_Impl&& other) = default;
      CreateWithoutStarting_Impl& operator=(CreateWithoutStarting_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class AddArgs_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddArgs_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::fidl::VectorView<uint8_t>> args);
      ~AddArgs_Impl() = default;
      AddArgs_Impl(AddArgs_Impl&& other) = default;
      AddArgs_Impl& operator=(AddArgs_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddEnvirons_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddEnvirons_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);
      ~AddEnvirons_Impl() = default;
      AddEnvirons_Impl(AddEnvirons_Impl&& other) = default;
      AddEnvirons_Impl& operator=(AddEnvirons_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddNames_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddNames_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);
      ~AddNames_Impl() = default;
      AddNames_Impl(AddNames_Impl&& other) = default;
      AddNames_Impl& operator=(AddNames_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddHandles_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddHandles_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);
      ~AddHandles_Impl() = default;
      AddHandles_Impl(AddHandles_Impl&& other) = default;
      AddHandles_Impl& operator=(AddHandles_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using Launch = Launch_Impl<LaunchResponse>;
    using CreateWithoutStarting = CreateWithoutStarting_Impl<CreateWithoutStartingResponse>;
    using AddArgs = AddArgs_Impl;
    using AddEnvirons = AddEnvirons_Impl;
    using AddNames = AddNames_Impl;
    using AddHandles = AddHandles_Impl;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Launch_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Launch_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);
      ~Launch_Impl() = default;
      Launch_Impl(Launch_Impl&& other) = default;
      Launch_Impl& operator=(Launch_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class CreateWithoutStarting_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      CreateWithoutStarting_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);
      ~CreateWithoutStarting_Impl() = default;
      CreateWithoutStarting_Impl(CreateWithoutStarting_Impl&& other) = default;
      CreateWithoutStarting_Impl& operator=(CreateWithoutStarting_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    class AddArgs_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddArgs_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> args);
      ~AddArgs_Impl() = default;
      AddArgs_Impl(AddArgs_Impl&& other) = default;
      AddArgs_Impl& operator=(AddArgs_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddEnvirons_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddEnvirons_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);
      ~AddEnvirons_Impl() = default;
      AddEnvirons_Impl(AddEnvirons_Impl&& other) = default;
      AddEnvirons_Impl& operator=(AddEnvirons_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddNames_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddNames_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);
      ~AddNames_Impl() = default;
      AddNames_Impl(AddNames_Impl&& other) = default;
      AddNames_Impl& operator=(AddNames_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    class AddHandles_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      AddHandles_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);
      ~AddHandles_Impl() = default;
      AddHandles_Impl(AddHandles_Impl&& other) = default;
      AddHandles_Impl& operator=(AddHandles_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };

   public:
    using Launch = Launch_Impl<LaunchResponse>;
    using CreateWithoutStarting = CreateWithoutStarting_Impl<CreateWithoutStartingResponse>;
    using AddArgs = AddArgs_Impl;
    using AddEnvirons = AddEnvirons_Impl;
    using AddNames = AddNames_Impl;
    using AddHandles = AddHandles_Impl;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Creates and starts the process described by `info`.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // `process` is present if, and only if, `status` is `ZX_OK`.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Launch Launch(::llcpp::fuchsia::process::LaunchInfo info);

    // Creates and starts the process described by `info`.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // `process` is present if, and only if, `status` is `ZX_OK`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Launch Launch(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);

    // Creates the process described by `info` but does not start it.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // The caller is responsible for calling `zx_process_start` using the data
    // in `ProcessStartData` to actually start the process.
    //
    // `data` is present if, and only if, `status` is `ZX_OK`.
    // Allocates 160 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::CreateWithoutStarting CreateWithoutStarting(::llcpp::fuchsia::process::LaunchInfo info);

    // Creates the process described by `info` but does not start it.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // The caller is responsible for calling `zx_process_start` using the data
    // in `ProcessStartData` to actually start the process.
    //
    // `data` is present if, and only if, `status` is `ZX_OK`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::CreateWithoutStarting CreateWithoutStarting(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);

    // Adds the given arguments to the command-line for the process.
    //
    // Calling this method multiple times concatenates the arguments.
    // Request is heap-allocated.
    ResultOf::AddArgs AddArgs(::fidl::VectorView<::fidl::VectorView<uint8_t>> args);

    // Adds the given arguments to the command-line for the process.
    //
    // Calling this method multiple times concatenates the arguments.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddArgs AddArgs(::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> args);

    // Adds the given variables to the environment variables for the process.
    //
    // Calling this method multiple times concatenates the variables.
    // Request is heap-allocated.
    ResultOf::AddEnvirons AddEnvirons(::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);

    // Adds the given variables to the environment variables for the process.
    //
    // Calling this method multiple times concatenates the variables.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddEnvirons AddEnvirons(::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);

    // Adds the given names to the namespace for the process.
    //
    // The paths in the namespace must be non-overlapping. See
    // <https://fuchsia.dev/fuchsia-src/concepts/framework/namespaces> for details.
    //
    // Calling this method multiple times concatenates the names.
    // Request is heap-allocated.
    ResultOf::AddNames AddNames(::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);

    // Adds the given names to the namespace for the process.
    //
    // The paths in the namespace must be non-overlapping. See
    // <https://fuchsia.dev/fuchsia-src/concepts/framework/namespaces> for details.
    //
    // Calling this method multiple times concatenates the names.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddNames AddNames(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);

    // Adds the given handles to the startup handles for the process.
    //
    // Calling this method multiple times concatenates the handles.
    // Request is heap-allocated.
    ResultOf::AddHandles AddHandles(::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);

    // Adds the given handles to the startup handles for the process.
    //
    // Calling this method multiple times concatenates the handles.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::AddHandles AddHandles(::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Creates and starts the process described by `info`.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // `process` is present if, and only if, `status` is `ZX_OK`.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Launch Launch(::zx::unowned_channel _client_end, ::llcpp::fuchsia::process::LaunchInfo info);

    // Creates and starts the process described by `info`.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // `process` is present if, and only if, `status` is `ZX_OK`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Launch Launch(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);

    // Creates the process described by `info` but does not start it.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // The caller is responsible for calling `zx_process_start` using the data
    // in `ProcessStartData` to actually start the process.
    //
    // `data` is present if, and only if, `status` is `ZX_OK`.
    // Allocates 160 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::CreateWithoutStarting CreateWithoutStarting(::zx::unowned_channel _client_end, ::llcpp::fuchsia::process::LaunchInfo info);

    // Creates the process described by `info` but does not start it.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // The caller is responsible for calling `zx_process_start` using the data
    // in `ProcessStartData` to actually start the process.
    //
    // `data` is present if, and only if, `status` is `ZX_OK`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::CreateWithoutStarting CreateWithoutStarting(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::process::LaunchInfo info, ::fidl::BytePart _response_buffer);

    // Adds the given arguments to the command-line for the process.
    //
    // Calling this method multiple times concatenates the arguments.
    // Request is heap-allocated.
    static ResultOf::AddArgs AddArgs(::zx::unowned_channel _client_end, ::fidl::VectorView<::fidl::VectorView<uint8_t>> args);

    // Adds the given arguments to the command-line for the process.
    //
    // Calling this method multiple times concatenates the arguments.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddArgs AddArgs(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> args);

    // Adds the given variables to the environment variables for the process.
    //
    // Calling this method multiple times concatenates the variables.
    // Request is heap-allocated.
    static ResultOf::AddEnvirons AddEnvirons(::zx::unowned_channel _client_end, ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);

    // Adds the given variables to the environment variables for the process.
    //
    // Calling this method multiple times concatenates the variables.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddEnvirons AddEnvirons(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::fidl::VectorView<uint8_t>> environ);

    // Adds the given names to the namespace for the process.
    //
    // The paths in the namespace must be non-overlapping. See
    // <https://fuchsia.dev/fuchsia-src/concepts/framework/namespaces> for details.
    //
    // Calling this method multiple times concatenates the names.
    // Request is heap-allocated.
    static ResultOf::AddNames AddNames(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);

    // Adds the given names to the namespace for the process.
    //
    // The paths in the namespace must be non-overlapping. See
    // <https://fuchsia.dev/fuchsia-src/concepts/framework/namespaces> for details.
    //
    // Calling this method multiple times concatenates the names.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddNames AddNames(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names);

    // Adds the given handles to the startup handles for the process.
    //
    // Calling this method multiple times concatenates the handles.
    // Request is heap-allocated.
    static ResultOf::AddHandles AddHandles(::zx::unowned_channel _client_end, ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);

    // Adds the given handles to the startup handles for the process.
    //
    // Calling this method multiple times concatenates the handles.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::AddHandles AddHandles(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Creates and starts the process described by `info`.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // `process` is present if, and only if, `status` is `ZX_OK`.
    static ::fidl::DecodeResult<LaunchResponse> Launch(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LaunchRequest> params, ::fidl::BytePart response_buffer);

    // Creates the process described by `info` but does not start it.
    //
    // After processing this message, the `Launcher` is reset to its initial
    // state and is ready to launch another process.
    //
    // The caller is responsible for calling `zx_process_start` using the data
    // in `ProcessStartData` to actually start the process.
    //
    // `data` is present if, and only if, `status` is `ZX_OK`.
    static ::fidl::DecodeResult<CreateWithoutStartingResponse> CreateWithoutStarting(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CreateWithoutStartingRequest> params, ::fidl::BytePart response_buffer);

    // Adds the given arguments to the command-line for the process.
    //
    // Calling this method multiple times concatenates the arguments.
    static ::fidl::internal::StatusAndError AddArgs(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddArgsRequest> params);

    // Adds the given variables to the environment variables for the process.
    //
    // Calling this method multiple times concatenates the variables.
    static ::fidl::internal::StatusAndError AddEnvirons(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddEnvironsRequest> params);

    // Adds the given names to the namespace for the process.
    //
    // The paths in the namespace must be non-overlapping. See
    // <https://fuchsia.dev/fuchsia-src/concepts/framework/namespaces> for details.
    //
    // Calling this method multiple times concatenates the names.
    static ::fidl::internal::StatusAndError AddNames(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddNamesRequest> params);

    // Adds the given handles to the startup handles for the process.
    //
    // Calling this method multiple times concatenates the handles.
    static ::fidl::internal::StatusAndError AddHandles(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AddHandlesRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Launcher;
    using _Base = ::fidl::CompleterBase;

    class LaunchCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::zx::process process);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::zx::process process);
      void Reply(::fidl::DecodedMessage<LaunchResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LaunchCompleter = ::fidl::Completer<LaunchCompleterBase>;

    virtual void Launch(::llcpp::fuchsia::process::LaunchInfo info, LaunchCompleter::Sync _completer) = 0;

    class CreateWithoutStartingCompleterBase : public _Base {
     public:
      void Reply(int32_t status, ::llcpp::fuchsia::process::ProcessStartData* data);
      void Reply(::fidl::BytePart _buffer, int32_t status, ::llcpp::fuchsia::process::ProcessStartData* data);
      void Reply(::fidl::DecodedMessage<CreateWithoutStartingResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CreateWithoutStartingCompleter = ::fidl::Completer<CreateWithoutStartingCompleterBase>;

    virtual void CreateWithoutStarting(::llcpp::fuchsia::process::LaunchInfo info, CreateWithoutStartingCompleter::Sync _completer) = 0;

    using AddArgsCompleter = ::fidl::Completer<>;

    virtual void AddArgs(::fidl::VectorView<::fidl::VectorView<uint8_t>> args, AddArgsCompleter::Sync _completer) = 0;

    using AddEnvironsCompleter = ::fidl::Completer<>;

    virtual void AddEnvirons(::fidl::VectorView<::fidl::VectorView<uint8_t>> environ, AddEnvironsCompleter::Sync _completer) = 0;

    using AddNamesCompleter = ::fidl::Completer<>;

    virtual void AddNames(::fidl::VectorView<::llcpp::fuchsia::process::NameInfo> names, AddNamesCompleter::Sync _completer) = 0;

    using AddHandlesCompleter = ::fidl::Completer<>;

    virtual void AddHandles(::fidl::VectorView<::llcpp::fuchsia::process::HandleInfo> handles, AddHandlesCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void LaunchRequest(const ::fidl::DecodedMessage<Launcher::LaunchRequest>& _msg);
    static void LaunchResponse(const ::fidl::DecodedMessage<Launcher::LaunchResponse>& _msg);
    static void CreateWithoutStartingRequest(const ::fidl::DecodedMessage<Launcher::CreateWithoutStartingRequest>& _msg);
    static void CreateWithoutStartingResponse(const ::fidl::DecodedMessage<Launcher::CreateWithoutStartingResponse>& _msg);
    static void AddArgsRequest(const ::fidl::DecodedMessage<Launcher::AddArgsRequest>& _msg);
    static void AddEnvironsRequest(const ::fidl::DecodedMessage<Launcher::AddEnvironsRequest>& _msg);
    static void AddNamesRequest(const ::fidl::DecodedMessage<Launcher::AddNamesRequest>& _msg);
    static void AddHandlesRequest(const ::fidl::DecodedMessage<Launcher::AddHandlesRequest>& _msg);
  };
};

}  // namespace process
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::process::ProcessStartData> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::process::ProcessStartData>);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, process) == 0);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, root_vmar) == 4);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, thread) == 8);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, entry) == 16);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, stack) == 24);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, bootstrap) == 32);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, vdso_base) == 40);
static_assert(offsetof(::llcpp::fuchsia::process::ProcessStartData, base) == 48);
static_assert(sizeof(::llcpp::fuchsia::process::ProcessStartData) == ::llcpp::fuchsia::process::ProcessStartData::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::process::HandleInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::process::HandleInfo>);
static_assert(offsetof(::llcpp::fuchsia::process::HandleInfo, handle) == 0);
static_assert(offsetof(::llcpp::fuchsia::process::HandleInfo, id) == 4);
static_assert(sizeof(::llcpp::fuchsia::process::HandleInfo) == ::llcpp::fuchsia::process::HandleInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Resolver::ResolveRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Resolver::ResolveRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Resolver::ResolveRequest)
    == ::llcpp::fuchsia::process::Resolver::ResolveRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Resolver::ResolveRequest, name) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Resolver::ResolveResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Resolver::ResolveResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Resolver::ResolveResponse)
    == ::llcpp::fuchsia::process::Resolver::ResolveResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Resolver::ResolveResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::process::Resolver::ResolveResponse, executable) == 20);
static_assert(offsetof(::llcpp::fuchsia::process::Resolver::ResolveResponse, ldsvc) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::process::NameInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::process::NameInfo>);
static_assert(offsetof(::llcpp::fuchsia::process::NameInfo, path) == 0);
static_assert(offsetof(::llcpp::fuchsia::process::NameInfo, directory) == 16);
static_assert(sizeof(::llcpp::fuchsia::process::NameInfo) == ::llcpp::fuchsia::process::NameInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::process::LaunchInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::process::LaunchInfo>);
static_assert(offsetof(::llcpp::fuchsia::process::LaunchInfo, executable) == 0);
static_assert(offsetof(::llcpp::fuchsia::process::LaunchInfo, job) == 4);
static_assert(offsetof(::llcpp::fuchsia::process::LaunchInfo, name) == 8);
static_assert(sizeof(::llcpp::fuchsia::process::LaunchInfo) == ::llcpp::fuchsia::process::LaunchInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::LaunchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::LaunchRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::LaunchRequest)
    == ::llcpp::fuchsia::process::Launcher::LaunchRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::LaunchRequest, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::LaunchResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::LaunchResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::LaunchResponse)
    == ::llcpp::fuchsia::process::Launcher::LaunchResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::LaunchResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::LaunchResponse, process) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::CreateWithoutStartingRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::CreateWithoutStartingRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::CreateWithoutStartingRequest)
    == ::llcpp::fuchsia::process::Launcher::CreateWithoutStartingRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::CreateWithoutStartingRequest, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse)
    == ::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::CreateWithoutStartingResponse, data) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::AddArgsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::AddArgsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::AddArgsRequest)
    == ::llcpp::fuchsia::process::Launcher::AddArgsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::AddArgsRequest, args) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::AddEnvironsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::AddEnvironsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::AddEnvironsRequest)
    == ::llcpp::fuchsia::process::Launcher::AddEnvironsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::AddEnvironsRequest, environ) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::AddNamesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::AddNamesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::AddNamesRequest)
    == ::llcpp::fuchsia::process::Launcher::AddNamesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::AddNamesRequest, names) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::process::Launcher::AddHandlesRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::process::Launcher::AddHandlesRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::process::Launcher::AddHandlesRequest)
    == ::llcpp::fuchsia::process::Launcher::AddHandlesRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::process::Launcher::AddHandlesRequest, handles) == 16);

}  // namespace fidl

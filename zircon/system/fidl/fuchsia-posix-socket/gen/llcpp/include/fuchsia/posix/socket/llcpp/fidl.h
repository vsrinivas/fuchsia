// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace posix {
namespace socket {

class Provider;
class Control;

extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ProviderSocketResponseTable;

// Provider implements the POSIX sockets API.
class Provider final {
  Provider() = delete;
 public:
  static constexpr char Name[] = "fuchsia.posix.socket.Provider";

  struct SocketResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SocketRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SocketResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Socket Socket(int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Socket Socket(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Socket Socket(::zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Socket Socket(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in errno.h.
    static ::fidl::DecodeResult<SocketResponse> Socket(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Provider;
    using _Base = ::fidl::CompleterBase;

    class SocketCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<SocketResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SocketCompleter = ::fidl::Completer<SocketCompleterBase>;

    virtual void Socket(int16_t domain, int16_t type, int16_t protocol, SocketCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void SocketRequest(const ::fidl::DecodedMessage<Provider::SocketRequest>& _msg);
    static void SocketResponse(const ::fidl::DecodedMessage<Provider::SocketResponse>& _msg);
  };
};

extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloneResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloseRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSyncRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeGetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetPeerNameRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptResponseTable;
extern "C" const fidl_type_t v1_fuchsia_posix_socket_ControlGetSockOptResponseTable;

// The control plane for a network socket.
//
// Once a socket has been retrieved from a `Provider`, this interface is then used to further
// configure and use the socket. This interface is essentially POSIX. Its implementation must
// support Linux-specific arguments to {Get,Set}SockOpt.
//
// *Warning:* This protocol is not yet ready for direct use by clients. Instead, clients should
// use the BSD sockets API to interact with sockets. We plan to change this protocol substantially
// and clients that couple directly to this protocol will make those changes more difficult.
class Control final {
  Control() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr uint32_t AltPrimarySize = 48;
    static constexpr uint32_t AltMaxOutOfLine = 24;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = true;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 80;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct NodeGetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlNodeGetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using NodeGetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct NodeSetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlNodeSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct NodeSetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlNodeSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = NodeSetFlagsResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 32;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AcceptResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 128;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 128;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 904;
    static constexpr uint32_t AltPrimarySize = 40;
    static constexpr uint32_t AltMaxOutOfLine = 904;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr const fidl_type_t* AltType = &v1_fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo* info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, int16_t backlog);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, int16_t flags);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeGetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~NodeGetFlags_Impl() = default;
      NodeGetFlags_Impl(NodeGetFlags_Impl&& other) = default;
      NodeGetFlags_Impl& operator=(NodeGetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class NodeSetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~NodeSetFlags_Impl() = default;
      NodeSetFlags_Impl(NodeSetFlags_Impl&& other) = default;
      NodeSetFlags_Impl& operator=(NodeSetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using NodeGetFlags = NodeGetFlags_Impl<NodeGetFlagsResponse>;
    using NodeSetFlags = NodeSetFlags_Impl<NodeSetFlagsResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeGetFlags NodeGetFlags();

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeGetFlags NodeGetFlags(::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::NodeSetFlags NodeSetFlags(uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::NodeSetFlags NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Listen Listen(int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Listen Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Accept Accept(int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Accept Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(::zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(::zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(::zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeGetFlags NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::NodeSetFlags NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a remote address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a remote address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Listen Listen(::zx::unowned_channel _client_end, int16_t backlog);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Listen Listen(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Accepts a buffered incoming connection.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Accept Accept(::zx::unowned_channel _client_end, int16_t flags);

    // Accepts a buffered incoming connection.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Accept Accept(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Retrieves the local socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Retrieves the remote socket address.
    // Allocates 184 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the value of a socket option.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Retrieves the value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(::zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    //
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with
    // `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the `Directory.Open` rights and flags used to access this file.
    //
    // This method does not require any rights.
    // This method has the same functionality as GetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeGetFlagsResponse> NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the `Directory.Open` flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // This method has the same functionality as SetFlags for File and is
    // meant as an in-progress replacement.
    static ::fidl::DecodeResult<NodeSetFlagsResponse> NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a remote address.
    static ::fidl::DecodeResult<ConnectResponse> Connect(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begins listening for new incoming connections. At most `backlog` connections will be
    // buffered.
    static ::fidl::DecodeResult<ListenResponse> Listen(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts a buffered incoming connection.
    static ::fidl::DecodeResult<AcceptResponse> Accept(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the value of a socket option.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Control;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class NodeGetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeGetFlagsCompleter = ::fidl::Completer<NodeGetFlagsCompleterBase>;

    virtual void NodeGetFlags(NodeGetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class NodeSetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using NodeSetFlagsCompleter = ::fidl::Completer<NodeSetFlagsCompleterBase>;

    virtual void NodeSetFlags(uint32_t flags, NodeSetFlagsCompleter::Sync _completer) { _completer.Close(ZX_ERR_NOT_SUPPORTED); }

    class BindCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void CloneRequest(const ::fidl::DecodedMessage<Control::CloneRequest>& _msg);
    static void CloseRequest(const ::fidl::DecodedMessage<Control::CloseRequest>& _msg);
    static void CloseResponse(const ::fidl::DecodedMessage<Control::CloseResponse>& _msg);
    static void DescribeRequest(const ::fidl::DecodedMessage<Control::DescribeRequest>& _msg);
    static void DescribeResponse(const ::fidl::DecodedMessage<Control::DescribeResponse>& _msg);
    static void OnOpenResponse(const ::fidl::DecodedMessage<Control::OnOpenResponse>& _msg);
    static void SyncRequest(const ::fidl::DecodedMessage<Control::SyncRequest>& _msg);
    static void SyncResponse(const ::fidl::DecodedMessage<Control::SyncResponse>& _msg);
    static void GetAttrRequest(const ::fidl::DecodedMessage<Control::GetAttrRequest>& _msg);
    static void GetAttrResponse(const ::fidl::DecodedMessage<Control::GetAttrResponse>& _msg);
    static void SetAttrRequest(const ::fidl::DecodedMessage<Control::SetAttrRequest>& _msg);
    static void SetAttrResponse(const ::fidl::DecodedMessage<Control::SetAttrResponse>& _msg);
    static void NodeGetFlagsRequest(const ::fidl::DecodedMessage<Control::NodeGetFlagsRequest>& _msg);
    static void NodeGetFlagsResponse(const ::fidl::DecodedMessage<Control::NodeGetFlagsResponse>& _msg);
    static void NodeSetFlagsRequest(const ::fidl::DecodedMessage<Control::NodeSetFlagsRequest>& _msg);
    static void NodeSetFlagsResponse(const ::fidl::DecodedMessage<Control::NodeSetFlagsResponse>& _msg);
    static void BindRequest(const ::fidl::DecodedMessage<Control::BindRequest>& _msg);
    static void BindResponse(const ::fidl::DecodedMessage<Control::BindResponse>& _msg);
    static void ConnectRequest(const ::fidl::DecodedMessage<Control::ConnectRequest>& _msg);
    static void ConnectResponse(const ::fidl::DecodedMessage<Control::ConnectResponse>& _msg);
    static void ListenRequest(const ::fidl::DecodedMessage<Control::ListenRequest>& _msg);
    static void ListenResponse(const ::fidl::DecodedMessage<Control::ListenResponse>& _msg);
    static void AcceptRequest(const ::fidl::DecodedMessage<Control::AcceptRequest>& _msg);
    static void AcceptResponse(const ::fidl::DecodedMessage<Control::AcceptResponse>& _msg);
    static void GetSockNameRequest(const ::fidl::DecodedMessage<Control::GetSockNameRequest>& _msg);
    static void GetSockNameResponse(const ::fidl::DecodedMessage<Control::GetSockNameResponse>& _msg);
    static void GetPeerNameRequest(const ::fidl::DecodedMessage<Control::GetPeerNameRequest>& _msg);
    static void GetPeerNameResponse(const ::fidl::DecodedMessage<Control::GetPeerNameResponse>& _msg);
    static void SetSockOptRequest(const ::fidl::DecodedMessage<Control::SetSockOptRequest>& _msg);
    static void SetSockOptResponse(const ::fidl::DecodedMessage<Control::SetSockOptResponse>& _msg);
    static void GetSockOptRequest(const ::fidl::DecodedMessage<Control::GetSockOptRequest>& _msg);
    static void GetSockOptResponse(const ::fidl::DecodedMessage<Control::GetSockOptResponse>& _msg);
  };
};

}  // namespace socket
}  // namespace posix
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::Control::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::Control::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::Control::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeGetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest)
    == ::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse)
    == ::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::NodeSetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindRequest)
    == ::llcpp::fuchsia::posix::socket::Control::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindResponse)
    == ::llcpp::fuchsia::posix::socket::Control::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, optval) == 24);

}  // namespace fidl

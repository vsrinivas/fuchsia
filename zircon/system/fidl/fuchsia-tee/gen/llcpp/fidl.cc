// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/tee/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace tee {

::llcpp::fuchsia::tee::Parameter::Parameter() {
  tag_ = Tag::Invalid;
}

::llcpp::fuchsia::tee::Parameter::~Parameter() {
  Destroy();
}

void ::llcpp::fuchsia::tee::Parameter::Destroy() {
  switch (which()) {
  case Tag::kEmpty:
    empty_.~Empty();
    break;
  case Tag::kBuffer:
    buffer_.~Buffer();
    break;
  case Tag::kValue:
    value_.~Value();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::llcpp::fuchsia::tee::Parameter::MoveImpl_(Parameter&& other) {
  switch (other.which()) {
  case Tag::kEmpty:
    mutable_empty() = std::move(other.mutable_empty());
    break;
  case Tag::kBuffer:
    mutable_buffer() = std::move(other.mutable_buffer());
    break;
  case Tag::kValue:
    mutable_value() = std::move(other.mutable_value());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::fuchsia::tee::Parameter::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::fuchsia::tee::Parameter, empty_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::tee::Parameter, buffer_) == 8);
  static_assert(offsetof(::llcpp::fuchsia::tee::Parameter, value_) == 8);
  static_assert(sizeof(::llcpp::fuchsia::tee::Parameter) == ::llcpp::fuchsia::tee::Parameter::PrimarySize);
}


::llcpp::fuchsia::tee::Empty& ::llcpp::fuchsia::tee::Parameter::mutable_empty() {
  if (which() != Tag::kEmpty) {
    Destroy();
    new (&empty_) ::llcpp::fuchsia::tee::Empty;
  }
  tag_ = Tag::kEmpty;
  return empty_;
}

::llcpp::fuchsia::tee::Buffer& ::llcpp::fuchsia::tee::Parameter::mutable_buffer() {
  if (which() != Tag::kBuffer) {
    Destroy();
    new (&buffer_) ::llcpp::fuchsia::tee::Buffer;
  }
  tag_ = Tag::kBuffer;
  return buffer_;
}

::llcpp::fuchsia::tee::Value& ::llcpp::fuchsia::tee::Parameter::mutable_value() {
  if (which() != Tag::kValue) {
    Destroy();
    new (&value_) ::llcpp::fuchsia::tee::Value;
  }
  tag_ = Tag::kValue;
  return value_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kDevice_GetOsInfo_Ordinal = 0x6d1d83f300000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_GetOsInfo_GenOrdinal = 0x9b65a9e69ce2ff0lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceGetOsInfoResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_Ordinal = 0x3c7d253d00000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_OpenSession_GenOrdinal = 0x611e642d24d5d425lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceOpenSessionRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceOpenSessionResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_InvokeCommand_Ordinal = 0x202511b100000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_InvokeCommand_GenOrdinal = 0x6cba9f107e725868lu;
extern "C" const fidl_type_t fuchsia_tee_DeviceInvokeCommandRequestTable;
extern "C" const fidl_type_t fuchsia_tee_DeviceInvokeCommandResponseTable;
[[maybe_unused]]
constexpr uint64_t kDevice_CloseSession_Ordinal = 0x53bbaea700000000lu;
[[maybe_unused]]
constexpr uint64_t kDevice_CloseSession_GenOrdinal = 0x7c21cc4c0084d8aflu;
extern "C" const fidl_type_t fuchsia_tee_DeviceCloseSessionRequestTable;

}  // namespace
template <>
Device::ResultOf::GetOsInfo_Impl<Device::GetOsInfoResponse>::GetOsInfo_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetOsInfoRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetOsInfoRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetOsInfoRequest));
  ::fidl::DecodedMessage<GetOsInfoRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::GetOsInfo(std::move(_client_end), Super::response_buffer()));
}

Device::ResultOf::GetOsInfo Device::SyncClient::GetOsInfo() {
  return ResultOf::GetOsInfo(zx::unowned_channel(this->channel_));
}

Device::ResultOf::GetOsInfo Device::Call::GetOsInfo(zx::unowned_channel _client_end) {
  return ResultOf::GetOsInfo(std::move(_client_end));
}

template <>
Device::UnownedResultOf::GetOsInfo_Impl<Device::GetOsInfoResponse>::GetOsInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetOsInfoRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetOsInfoRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetOsInfoRequest));
  ::fidl::DecodedMessage<GetOsInfoRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::GetOsInfo(std::move(_client_end), std::move(_response_buffer)));
}

Device::UnownedResultOf::GetOsInfo Device::SyncClient::GetOsInfo(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetOsInfo(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Device::UnownedResultOf::GetOsInfo Device::Call::GetOsInfo(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetOsInfo(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::GetOsInfoResponse> Device::InPlace::GetOsInfo(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetOsInfoRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetOsInfoRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_GetOsInfo_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetOsInfoResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetOsInfoRequest, GetOsInfoResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::GetOsInfoResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(zx::unowned_channel _client_end, ::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, OpenSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenSessionRequest*>(_write_bytes);
  _request.trusted_app = std::move(trusted_app);
  _request.parameter_set = std::move(parameter_set);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenSessionRequest));
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::OpenSession Device::SyncClient::OpenSession(::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  return ResultOf::OpenSession(zx::unowned_channel(this->channel_), std::move(trusted_app), std::move(parameter_set));
}

Device::ResultOf::OpenSession Device::Call::OpenSession(zx::unowned_channel _client_end, ::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  return ResultOf::OpenSession(std::move(_client_end), std::move(trusted_app), std::move(parameter_set));
}

template <>
Device::UnownedResultOf::OpenSession_Impl<Device::OpenSessionResponse>::OpenSession_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < OpenSessionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<OpenSessionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, OpenSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<OpenSessionRequest*>(_request_buffer.data());
  _request.trusted_app = std::move(trusted_app);
  _request.parameter_set = std::move(parameter_set);
  _request_buffer.set_actual(sizeof(OpenSessionRequest));
  ::fidl::DecodedMessage<OpenSessionRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::OpenSession(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::OpenSession Device::SyncClient::OpenSession(::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(trusted_app), std::move(parameter_set), std::move(_response_buffer));
}

Device::UnownedResultOf::OpenSession Device::Call::OpenSession(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::llcpp::fuchsia::tee::Uuid trusted_app, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::OpenSession(std::move(_client_end), std::move(_request_buffer), std::move(trusted_app), std::move(parameter_set), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::OpenSessionResponse> Device::InPlace::OpenSession(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenSessionRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_OpenSession_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<OpenSessionRequest, OpenSessionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::OpenSessionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::InvokeCommand_Impl<Device::InvokeCommandResponse>::InvokeCommand_Impl(zx::unowned_channel _client_end, uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InvokeCommandRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, InvokeCommandRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InvokeCommandRequest*>(_write_bytes);
  _request.session_id = std::move(session_id);
  _request.command_id = std::move(command_id);
  _request.parameter_set = std::move(parameter_set);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(InvokeCommandRequest));
  ::fidl::DecodedMessage<InvokeCommandRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::InvokeCommand(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::InvokeCommand Device::SyncClient::InvokeCommand(uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  return ResultOf::InvokeCommand(zx::unowned_channel(this->channel_), std::move(session_id), std::move(command_id), std::move(parameter_set));
}

Device::ResultOf::InvokeCommand Device::Call::InvokeCommand(zx::unowned_channel _client_end, uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set) {
  return ResultOf::InvokeCommand(std::move(_client_end), std::move(session_id), std::move(command_id), std::move(parameter_set));
}

template <>
Device::UnownedResultOf::InvokeCommand_Impl<Device::InvokeCommandResponse>::InvokeCommand_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < InvokeCommandRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<InvokeCommandResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, InvokeCommandRequest::PrimarySize);
  auto& _request = *reinterpret_cast<InvokeCommandRequest*>(_request_buffer.data());
  _request.session_id = std::move(session_id);
  _request.command_id = std::move(command_id);
  _request.parameter_set = std::move(parameter_set);
  _request_buffer.set_actual(sizeof(InvokeCommandRequest));
  ::fidl::DecodedMessage<InvokeCommandRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::InvokeCommand(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::InvokeCommand Device::SyncClient::InvokeCommand(::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InvokeCommand(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(session_id), std::move(command_id), std::move(parameter_set), std::move(_response_buffer));
}

Device::UnownedResultOf::InvokeCommand Device::Call::InvokeCommand(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, uint32_t command_id, ::llcpp::fuchsia::tee::ParameterSet parameter_set, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::InvokeCommand(std::move(_client_end), std::move(_request_buffer), std::move(session_id), std::move(command_id), std::move(parameter_set), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::InvokeCommandResponse> Device::InPlace::InvokeCommand(zx::unowned_channel _client_end, ::fidl::DecodedMessage<InvokeCommandRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_InvokeCommand_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::InvokeCommandResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<InvokeCommandRequest, InvokeCommandResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::InvokeCommandResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Device::ResultOf::CloseSession_Impl<Device::CloseSessionResponse>::CloseSession_Impl(zx::unowned_channel _client_end, uint32_t session_id) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSessionRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSessionRequest*>(_write_bytes);
  _request.session_id = std::move(session_id);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSessionRequest));
  ::fidl::DecodedMessage<CloseSessionRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Device::InPlace::CloseSession(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Device::ResultOf::CloseSession Device::SyncClient::CloseSession(uint32_t session_id) {
  return ResultOf::CloseSession(zx::unowned_channel(this->channel_), std::move(session_id));
}

Device::ResultOf::CloseSession Device::Call::CloseSession(zx::unowned_channel _client_end, uint32_t session_id) {
  return ResultOf::CloseSession(std::move(_client_end), std::move(session_id));
}

template <>
Device::UnownedResultOf::CloseSession_Impl<Device::CloseSessionResponse>::CloseSession_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < CloseSessionRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<CloseSessionResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, CloseSessionRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloseSessionRequest*>(_request_buffer.data());
  _request.session_id = std::move(session_id);
  _request_buffer.set_actual(sizeof(CloseSessionRequest));
  ::fidl::DecodedMessage<CloseSessionRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Device::InPlace::CloseSession(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Device::UnownedResultOf::CloseSession Device::SyncClient::CloseSession(::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CloseSession(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(session_id), std::move(_response_buffer));
}

Device::UnownedResultOf::CloseSession Device::Call::CloseSession(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t session_id, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::CloseSession(std::move(_client_end), std::move(_request_buffer), std::move(session_id), std::move(_response_buffer));
}

::fidl::DecodeResult<Device::CloseSessionResponse> Device::InPlace::CloseSession(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloseSessionRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_CloseSession_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::CloseSessionResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseSessionRequest, CloseSessionResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Device::CloseSessionResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Device::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kDevice_GetOsInfo_Ordinal:
    case kDevice_GetOsInfo_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetOsInfoRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetOsInfo(
        Interface::GetOsInfoCompleter::Sync(txn));
      return true;
    }
    case kDevice_OpenSession_Ordinal:
    case kDevice_OpenSession_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenSessionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->OpenSession(std::move(message->trusted_app), std::move(message->parameter_set),
        Interface::OpenSessionCompleter::Sync(txn));
      return true;
    }
    case kDevice_InvokeCommand_Ordinal:
    case kDevice_InvokeCommand_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<InvokeCommandRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->InvokeCommand(std::move(message->session_id), std::move(message->command_id), std::move(message->parameter_set),
        Interface::InvokeCommandCompleter::Sync(txn));
      return true;
    }
    case kDevice_CloseSession_Ordinal:
    case kDevice_CloseSession_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseSessionRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->CloseSession(std::move(message->session_id),
        Interface::CloseSessionCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Device::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Device::Interface::GetOsInfoCompleterBase::Reply(::llcpp::fuchsia::tee::OsInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetOsInfoResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetOsInfoResponse*>(_write_bytes);
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_GetOsInfo_Ordinal;
  _response.info = std::move(info);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetOsInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetOsInfoResponse>(std::move(_response_bytes)));
}

void Device::Interface::GetOsInfoCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::tee::OsInfo info) {
  if (_buffer.capacity() < GetOsInfoResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetOsInfoResponse*>(_buffer.data());
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_GetOsInfo_Ordinal;
  _response.info = std::move(info);
  _buffer.set_actual(sizeof(GetOsInfoResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetOsInfoResponse>(std::move(_buffer)));
}

void Device::Interface::GetOsInfoCompleterBase::Reply(::fidl::DecodedMessage<GetOsInfoResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_GetOsInfo_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::OpenSessionCompleterBase::Reply(uint32_t session_id, ::llcpp::fuchsia::tee::OpResult op_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenSessionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OpenSessionResponse*>(_write_bytes);
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_OpenSession_Ordinal;
  _response.session_id = std::move(session_id);
  _response.op_result = std::move(op_result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OpenSessionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenSessionResponse>(std::move(_response_bytes)));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t session_id, ::llcpp::fuchsia::tee::OpResult op_result) {
  if (_buffer.capacity() < OpenSessionResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<OpenSessionResponse*>(_buffer.data());
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_OpenSession_Ordinal;
  _response.session_id = std::move(session_id);
  _response.op_result = std::move(op_result);
  _buffer.set_actual(sizeof(OpenSessionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<OpenSessionResponse>(std::move(_buffer)));
}

void Device::Interface::OpenSessionCompleterBase::Reply(::fidl::DecodedMessage<OpenSessionResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_OpenSession_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::InvokeCommandCompleterBase::Reply(::llcpp::fuchsia::tee::OpResult op_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<InvokeCommandResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<InvokeCommandResponse*>(_write_bytes);
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_InvokeCommand_Ordinal;
  _response.op_result = std::move(op_result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(InvokeCommandResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InvokeCommandResponse>(std::move(_response_bytes)));
}

void Device::Interface::InvokeCommandCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::tee::OpResult op_result) {
  if (_buffer.capacity() < InvokeCommandResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<InvokeCommandResponse*>(_buffer.data());
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_InvokeCommand_Ordinal;
  _response.op_result = std::move(op_result);
  _buffer.set_actual(sizeof(InvokeCommandResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<InvokeCommandResponse>(std::move(_buffer)));
}

void Device::Interface::InvokeCommandCompleterBase::Reply(::fidl::DecodedMessage<InvokeCommandResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.flags[0] = 0;
  params.message()->_hdr.flags[1] = 0;
  params.message()->_hdr.flags[2] = 0;
  params.message()->_hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  params.message()->_hdr.ordinal = kDevice_InvokeCommand_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void Device::Interface::CloseSessionCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseSessionResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseSessionResponse*>(_write_bytes);
  _response._hdr.flags[0] = 0;
  _response._hdr.flags[1] = 0;
  _response._hdr.flags[2] = 0;
  _response._hdr.magic_number = kFidlWireFormatMagicNumberInitial;
  _response._hdr.ordinal = kDevice_CloseSession_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseSessionResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseSessionResponse>(std::move(_response_bytes)));
}


}  // namespace tee
}  // namespace fuchsia
}  // namespace llcpp

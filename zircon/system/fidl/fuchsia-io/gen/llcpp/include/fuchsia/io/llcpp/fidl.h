// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/zx/channel.h>
#include <lib/zx/event.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>
#include <lib/zx/vmo.h>
#include <zircon/fidl.h>

#include <fuchsia/mem/llcpp/fidl.h>

namespace fuchsia {
namespace io {

struct WatchedEvent;
struct Vmofile;
struct Tty;
class DirectoryWatcher;
struct Service;
enum class SeekOrigin : uint32_t {
  START = 0,
  CURRENT = 1,
  END = 2,
};


struct Pipe;
struct NodeAttributes;
struct FilesystemInfo;
struct FileObject;
struct DirectoryObject;
struct Device;
struct NodeInfo;
class Node;
class File;
class Directory;
class DirectoryAdmin;

extern "C" const fidl_type_t fuchsia_io_WatchedEventTable;

// TODO(ZX-2645): Unused.
//
// WatchedEvent describes events returned from a DirectoryWatcher.
struct WatchedEvent {
  static constexpr const fidl_type_t* Type = &fuchsia_io_WatchedEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;

  uint8_t event{};

  uint8_t len{};

  ::fidl::VectorView<uint8_t> name{};
};

// Used by Directory::Watch. Requests transmission of WATCH_EVENT_REMOVED.
constexpr uint32_t WATCH_MASK_REMOVED = 0x00000004;

// Used by Directory::Watch. Requests transmission of WATCH_EVENT_IDLE.
constexpr uint32_t WATCH_MASK_IDLE = 0x00000010;

// Used by Directory::Watch. Requests transmission of WATCH_EVENT_EXISTING.
constexpr uint32_t WATCH_MASK_EXISTING = 0x00000008;

// Used by Directory::Watch. Requests transmission of WATCH_EVENT_DELETED.
constexpr uint32_t WATCH_MASK_DELETED = 0x00000001;

// Used by Directory::Watch. Requests transmission of all watcher events.
constexpr uint32_t WATCH_MASK_ALL = 0x0000001F;

// Used by Directory::Watch. Requests transmission of WATCH_EVENT_ADDED.
constexpr uint32_t WATCH_MASK_ADDED = 0x00000002;

// Identifies a node has been removed (either deleted or moved) from the directory.
constexpr uint8_t WATCH_EVENT_REMOVED = 2;

// Identifies that no more WATCH_EVENT_EXISTING events will be sent.
constexpr uint8_t WATCH_EVENT_IDLE = 4;

// Identifies a node already existed in the directory when watching started.
constexpr uint8_t WATCH_EVENT_EXISTING = 3;

// Indicates the directory being watched has been deleted.
constexpr uint8_t WATCH_EVENT_DELETED = 0;

// Indicates a node has been created (either new or moved) into a directory.
constexpr uint8_t WATCH_EVENT_ADDED = 1;

extern "C" const fidl_type_t fuchsia_io_VmofileTable;

// The object is a file which is represented as an immutable VMO.
// Although a VMO is returned as a part of this structure, this underlying object
// may represent multiple Vmofiles. To identify the logical portion of the VMO
// that represents the single file, an offset and length parameter are also supplied.
struct Vmofile {
  static constexpr const fidl_type_t* Type = &fuchsia_io_VmofileTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The VMO which backs this file.
  ::zx::vmo vmo{};

  // The index into |vmo| which represents the first byte of the file.
  uint64_t offset{};

  // The number of bytes, starting at |offset|, which may be used to represent this file.
  uint64_t length{};
};

// Requests that the VMO be writable.
constexpr uint32_t VMO_FLAG_WRITE = 0x00000002;

// Requests that the VMO be readable.
constexpr uint32_t VMO_FLAG_READ = 0x00000001;

// Require a copy-on-write clone of the underlying VMO.
// The request should fail if the VMO is not cloned.
// May not be supplied with fuchsia_io_VMO_FLAG_EXACT.
constexpr uint32_t VMO_FLAG_PRIVATE = 0x00010000;

// Requests that the VMO be executable.
constexpr uint32_t VMO_FLAG_EXEC = 0x00000004;

// Require an exact (non-cloned) handle to the underlying VMO.
// The request should fail if a handle to the exact VMO is not returned.
// May not be supplied with VMO_FLAG_PRIVATE.
constexpr uint32_t VMO_FLAG_EXACT = 0x00020000;

extern "C" const fidl_type_t fuchsia_io_TtyTable;

// The object may be cast to interface 'Tty'
struct Tty {
  static constexpr const fidl_type_t* Type = &fuchsia_io_TtyTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::event event{};
};

extern "C" const fidl_type_t fuchsia_io_DirectoryWatcherOnEventRequestTable;

// TODO(ZX-2645): Unused.
//
// DirectoryWatcher transmits messages from a filesystem server
// about events happening in the filesystem. Clients can register
// new watchers using the Directory "Watch" method, where they can
// filter which events they want to receive notifications for.
class DirectoryWatcher final {
 public:

  struct OnEventRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> events;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryWatcherOnEventRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 8192;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    zx_status_t OnEvent(::fidl::VectorView<uint8_t> events);

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t OnEvent(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events);

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    // Messages are encoded and decoded in-place.
    zx_status_t OnEvent(::fidl::DecodedMessage<OnEventRequest> params);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    static zx_status_t OnEvent(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> events);

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t OnEvent(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> events);

    // TODO(smklein): Convert this to a vector of WatchedEvents, when possible.
    // Messages are encoded and decoded in-place.
    static zx_status_t OnEvent(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OnEventRequest> params);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DirectoryWatcher;
    using _Base = ::fidl::CompleterBase;

    using OnEventCompleter = ::fidl::Completer<>;

    virtual void OnEvent(::fidl::VectorView<uint8_t> events, OnEventCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



// The default protocol, interface information must be acquired some
// other way.
struct Service {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved{};
};

extern "C" const fidl_type_t fuchsia_io_PipeTable;

// The object is accompanied by a pipe.
struct Pipe {
  static constexpr const fidl_type_t* Type = &fuchsia_io_PipeTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::zx::socket socket{};
};

// Can write to target object.
constexpr uint32_t OPEN_RIGHT_WRITABLE = 0x00000002;

// Can read from target object.
constexpr uint32_t OPEN_RIGHT_READABLE = 0x00000001;

// Connection can mount/umount filesystem.
constexpr uint32_t OPEN_RIGHT_ADMIN = 0x00000004;

// Truncate the object before usage.
constexpr uint32_t OPEN_FLAG_TRUNCATE = 0x00040000;

// Specify this flag to request POSIX-compatibility. Currently, it affects permission handling.
// During Open:
// - If the target path is a directory, the rights on the new connection expands to include
//   OPEN_RIGHT_WRITABLE if and only if the current connection and all intermediate mount points
//   are writable.
// - Otherwise, this flag is ignored. It is an access denied error to request more rights
//   than those on the current connection, or any intermediate mount points.
//
// If the posix compatibility flag is not specified, opening always uses the requested rights,
// failing the operation with access denied error if requested rights exceeds the rights attached
// to the current connection.
//
// If the requesting connection is read-only and the requested rights are read-only, the flag
// may be ignored by the server, and is not forwarded downstream. This is an implementation detail,
// necessary to enforce hierarchical permissions across mount points, and should have no effect
// on the expected behavior for clients.
constexpr uint32_t OPEN_FLAG_POSIX = 0x01000000;

// If the object is a mount point, open the local directory.
constexpr uint32_t OPEN_FLAG_NO_REMOTE = 0x00200000;

// Assert that the object to be opened is not a directory.
// Return an error if the target object is a directory.
constexpr uint32_t OPEN_FLAG_NOT_DIRECTORY = 0x02000000;

// Open a reference to the object, not the object itself.
// It is ONLY valid to pass the following flags together with OPEN_FLAG_NODE_REFERENCE:
// - OPEN_FLAG_DIRECTORY
// - OPEN_FLAG_NOT_DIRECTORY
// - OPEN_FLAG_DESCRIBE
// otherwise an error is returned.
// If an object is opened or cloned using this method, the resulting connection does not carry
// any permission flags.
// The resulting node allows a limited set of operations: |GetAttr|, |Clone|, |Close|, |Describe|,
// and, if the node is a file, these extra operations: |GetFlags|, |SetFlags|.
constexpr uint32_t OPEN_FLAG_NODE_REFERENCE = 0x00400000;

// Assert that the object to be opened is a directory.
// Return an error if the target object is not a directory.
constexpr uint32_t OPEN_FLAG_DIRECTORY = 0x00080000;

// Requests that an "OnOpen" event is sent to the interface request.
// The event will contain a non-null NodeInfo if the open/clone is successful.
constexpr uint32_t OPEN_FLAG_DESCRIBE = 0x00800000;

// (with Create) Fail if the object already exists.
constexpr uint32_t OPEN_FLAG_CREATE_IF_ABSENT = 0x00020000;

// Create the object if it doesn't exist.
constexpr uint32_t OPEN_FLAG_CREATE = 0x00010000;

// Seek to the end of the object before all writes.
constexpr uint32_t OPEN_FLAG_APPEND = 0x00100000;

// Binary OR of OPEN_FLAG_DIRECTORY, OPEN_FLAG_NOT_DIRECTORY, OPEN_FLAG_DESCRIBE, and
// OPEN_FLAG_NODE_REFERENCE. Flags used when opening a node reference must fall within this mask.
constexpr uint32_t OPEN_FLAGS_ALLOWED_WITH_NODE_REFERENCE = 0x02c80000;



// NodeAttributes defines generic information about a filesystem node.
struct NodeAttributes {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // Protection bits and node type information describe in 'mode'.
  uint32_t mode{};

  // A filesystem-unique ID.
  uint64_t id{};

  // Node size, in bytes.
  uint64_t content_size{};

  // Space needed to store node (possibly larger than size), in bytes.
  uint64_t storage_size{};

  // Hard link count.
  uint64_t link_count{};

  // Time of creation (may be updated manually after creation) in ns since Unix epoch, UTC.
  uint64_t creation_time{};

  // Time of last modification in ns since Unix epoch, UTC.
  uint64_t modification_time{};
};

constexpr uint32_t NODE_ATTRIBUTE_FLAG_MODIFICATION_TIME = 0x00000002;

// The fields of 'attributes' which are used to update the Node are indicated
// by the 'flags' argument.
constexpr uint32_t NODE_ATTRIBUTE_FLAG_CREATION_TIME = 0x00000001;

constexpr uint32_t MOUNT_CREATE_FLAG_REPLACE = 0x00000001;

constexpr uint32_t MODE_TYPE_SOCKET = 0x0C000;

constexpr uint32_t MODE_TYPE_SERVICE = 0x10000;

// Bits indicating node type. The canonical mechanism to check
// for a node type is to take 'mode', bitwise AND it with the
// MODE_TYPE_MASK, and check exact equality against a mode type.
constexpr uint32_t MODE_TYPE_MASK = 0xFF000;

constexpr uint32_t MODE_TYPE_FILE = 0x08000;

constexpr uint32_t MODE_TYPE_DIRECTORY = 0x04000;

constexpr uint32_t MODE_TYPE_BLOCK_DEVICE = 0x06000;

// Bits reserved for posix protections. Native fuchsia filesystems
// are not required to set bits contained within MODE_PROTECTION_MASK,
// but filesystems that wish to do so may refer to sys/stat.h for their
// definitions.
constexpr uint32_t MODE_PROTECTION_MASK = 0x00FFF;

// The maximum length, in bytes, of a filesystem string.
constexpr uint64_t MAX_PATH = 4096;

constexpr uint64_t MAX_IOCTL_HANDLES = 2;

constexpr uint64_t MAX_FS_NAME_BUFFER = 32;

// The maximum length, in bytes, of a single filesystem component.
constexpr uint64_t MAX_FILENAME = 255;

// The maximal buffer size which can be transmitted for buffered operations.
// This capacity is currently set somewhat arbitrarily.
constexpr uint64_t MAX_BUF = 8192;

// Nodes which do not have ino values should return this value
// from Readdir and GetAttr.
constexpr uint64_t INO_UNKNOWN = 0xFFFFFFFFFFFFFFFF;



struct FilesystemInfo {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 96;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The number of data bytes which may be stored in a filesystem.
  uint64_t total_bytes{};

  // The number of data bytes which are in use by the filesystem.
  uint64_t used_bytes{};

  // The number of nodes which may be stored in the filesystem.
  uint64_t total_nodes{};

  // The number of nodes used by the filesystem.
  uint64_t used_nodes{};

  // The amount of space which may be allocated from the underlying
  // volume manager. If unsupported, this will be zero.
  uint64_t free_shared_pool_bytes{};

  // A unique identifier for this filesystem instance. Will not be preserved
  // across reboots.
  uint64_t fs_id{};

  // The size of a single filesystem block.
  uint32_t block_size{};

  // The maximum length of a filesystem name.
  uint32_t max_filename_size{};

  // A unique identifier for the type of the underlying filesystem.
  uint32_t fs_type{};

  uint32_t padding{};

  // TODO(smklein): Replace this field with a string when supported
  // by the "Simple" interface. At the moment, name is a fixed-size,
  // null-terminated buffer.
  ::fidl::Array<int8_t, 32> name{};
};

extern "C" const fidl_type_t fuchsia_io_FileObjectTable;

// The object may be cast to interface 'File'.
struct FileObject {
  static constexpr const fidl_type_t* Type = &fuchsia_io_FileObjectTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // An optional event which transmits information about an object's readability
  // or writability. This event relays information about the underlying object, not
  // the capability granted to client: this event may be signalled "readable" on a
  // connection that does not have the capability to read.
  //
  // The "FILE_SIGNAL_" values may be observed on this event.
  ::zx::event event{};
};

// Indicates the file is ready for writing.
constexpr uint32_t FILE_SIGNAL_WRITABLE = 0x02000000;

// Indicates the file is ready for reading.
constexpr uint32_t FILE_SIGNAL_READABLE = 0x01000000;



// The object may be cast to interface 'Directory'.
struct DirectoryObject {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint8_t __reserved{};
};

extern "C" const fidl_type_t fuchsia_io_DeviceTable;

// The object may be cast to interface 'Device'.
struct Device {
  static constexpr const fidl_type_t* Type = &fuchsia_io_DeviceTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // An optional event which transmits information about a device's state.
  //
  // The "DEVICE_SIGNAL_" values may be observed on this event.
  ::zx::event event{};
};

extern "C" const fidl_type_t fuchsia_io_NodeInfoTable;

// Describes how the connection to an should be handled, as well as
// how to interpret the optional handle.
//
// Refer to |Node::Describe()| and |Node::OnOpen()| for usage.
struct NodeInfo {
  enum class Tag : fidl_union_tag_t {
    kService = 0,
    kFile = 1,
    kDirectory = 2,
    kPipe = 3,
    kVmofile = 4,
    kDevice = 5,
    kTty = 6,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NodeInfo();
  ~NodeInfo();

  NodeInfo(NodeInfo&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NodeInfo& operator=(NodeInfo&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_service() const { return tag_ == Tag::kService; }

  Service& mutable_service() {
    if (which() != Tag::kService) {
      Destroy();
    }
    tag_ = Tag::kService;
    return service_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Service>::value && std::is_copy_assignable<T>::value>
  set_service(const T& v) {
    mutable_service() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Service>::value && std::is_move_assignable<T>::value>
  set_service(T&& v) {
    mutable_service() = std::move(v);
  }

  Service const & service() const { return service_; }

  bool is_file() const { return tag_ == Tag::kFile; }

  FileObject& mutable_file() {
    if (which() != Tag::kFile) {
      Destroy();
    }
    tag_ = Tag::kFile;
    return file_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, FileObject>::value && std::is_copy_assignable<T>::value>
  set_file(const T& v) {
    mutable_file() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, FileObject>::value && std::is_move_assignable<T>::value>
  set_file(T&& v) {
    mutable_file() = std::move(v);
  }

  FileObject const & file() const { return file_; }

  bool is_directory() const { return tag_ == Tag::kDirectory; }

  DirectoryObject& mutable_directory() {
    if (which() != Tag::kDirectory) {
      Destroy();
    }
    tag_ = Tag::kDirectory;
    return directory_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, DirectoryObject>::value && std::is_copy_assignable<T>::value>
  set_directory(const T& v) {
    mutable_directory() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, DirectoryObject>::value && std::is_move_assignable<T>::value>
  set_directory(T&& v) {
    mutable_directory() = std::move(v);
  }

  DirectoryObject const & directory() const { return directory_; }

  bool is_pipe() const { return tag_ == Tag::kPipe; }

  Pipe& mutable_pipe() {
    if (which() != Tag::kPipe) {
      Destroy();
    }
    tag_ = Tag::kPipe;
    return pipe_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Pipe>::value && std::is_copy_assignable<T>::value>
  set_pipe(const T& v) {
    mutable_pipe() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Pipe>::value && std::is_move_assignable<T>::value>
  set_pipe(T&& v) {
    mutable_pipe() = std::move(v);
  }

  Pipe const & pipe() const { return pipe_; }

  bool is_vmofile() const { return tag_ == Tag::kVmofile; }

  Vmofile& mutable_vmofile() {
    if (which() != Tag::kVmofile) {
      Destroy();
    }
    tag_ = Tag::kVmofile;
    return vmofile_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Vmofile>::value && std::is_copy_assignable<T>::value>
  set_vmofile(const T& v) {
    mutable_vmofile() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Vmofile>::value && std::is_move_assignable<T>::value>
  set_vmofile(T&& v) {
    mutable_vmofile() = std::move(v);
  }

  Vmofile const & vmofile() const { return vmofile_; }

  bool is_device() const { return tag_ == Tag::kDevice; }

  Device& mutable_device() {
    if (which() != Tag::kDevice) {
      Destroy();
    }
    tag_ = Tag::kDevice;
    return device_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Device>::value && std::is_copy_assignable<T>::value>
  set_device(const T& v) {
    mutable_device() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Device>::value && std::is_move_assignable<T>::value>
  set_device(T&& v) {
    mutable_device() = std::move(v);
  }

  Device const & device() const { return device_; }

  bool is_tty() const { return tag_ == Tag::kTty; }

  Tty& mutable_tty() {
    if (which() != Tag::kTty) {
      Destroy();
    }
    tag_ = Tag::kTty;
    return tty_;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Tty>::value && std::is_copy_assignable<T>::value>
  set_tty(const T& v) {
    mutable_tty() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Tty>::value && std::is_move_assignable<T>::value>
  set_tty(T&& v) {
    mutable_tty() = std::move(v);
  }

  Tty const & tty() const { return tty_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_io_NodeInfoTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(NodeInfo&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    Service service_;
    FileObject file_;
    DirectoryObject directory_;
    Pipe pipe_;
    Vmofile vmofile_;
    Device device_;
    Tty tty_;
  };
};

extern "C" const fidl_type_t fuchsia_io_NodeCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_io_NodeOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_io_NodeIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_NodeIoctlResponseTable;

// Node defines the minimal interface for entities which can be accessed in a filesystem.
class Node final {
 public:

  struct CloneRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_NodeCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CloseResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_NodeDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_NodeOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
  };
  struct SyncResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetAttrRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_io_NodeIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
  };
  struct IoctlRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_io_NodeIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    using ResponseType = IoctlResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    zx_status_t Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    zx_status_t Clone(::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Close(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe(NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Sync(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr(int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    static zx_status_t Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe(zx::unowned_channel _client_end, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Node;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(NodeInfo info);
      void Reply(::fidl::BytePart _buffer, NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

extern "C" const fidl_type_t fuchsia_io_FileCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_io_FileOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_io_FileIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_io_FileReadResponseTable;
extern "C" const fidl_type_t fuchsia_io_FileReadAtResponseTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileWriteAtRequestTable;
extern "C" const fidl_type_t fuchsia_io_FileGetBufferResponseTable;

// File defines the interface of a node which contains a flat layout of data.
class File final {
 public:

  struct CloneRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CloseResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
  };
  struct SyncResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetAttrRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
  };
  struct IoctlRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    using ResponseType = IoctlResponse;
  };

  struct ReadResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileReadResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
  };
  struct ReadRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ReadResponse;
  };

  struct ReadAtResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileReadAtResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
  };
  struct ReadAtRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ReadAtResponse;
  };

  struct WriteResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t actual;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WriteRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileWriteRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = WriteResponse;
  };

  struct WriteAtResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t actual;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WriteAtRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileWriteAtRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = WriteAtResponse;
  };

  struct SeekResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SeekRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int64_t offset;
    SeekOrigin start;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SeekResponse;
  };

  struct TruncateResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct TruncateRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t length;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = TruncateResponse;
  };

  struct GetFlagsResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct SetFlagsResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetFlagsRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetFlagsResponse;
  };

  struct GetBufferResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fuchsia::mem::Buffer* buffer;

    static constexpr const fidl_type_t* Type = &fuchsia_io_FileGetBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 16;
  };
  struct GetBufferRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = GetBufferResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    zx_status_t Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    zx_status_t Clone(::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Close(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe(NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Sync(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr(int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);


    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ReadResponse> Read(::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer);


    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ReadAtResponse> ReadAt(::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Write(::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WriteResponse> Write(::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WriteAtResponse> WriteAt(::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    zx_status_t Seek(int64_t offset, SeekOrigin start, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Seek(::fidl::BytePart _request_buffer, int64_t offset, SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SeekResponse> Seek(::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Truncate(uint64_t length, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Truncate(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<TruncateResponse> Truncate(::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    zx_status_t GetFlags(int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetFlags(::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetFlagsResponse> GetFlags(::fidl::BytePart response_buffer);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    zx_status_t SetFlags(uint32_t flags, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetFlagsResponse> SetFlags(::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer);


    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // |flags| may be any of VMO_FLAG_*.
    //
    // This method requires following rights:
    // - OPEN_RIGHT_WRITABLE if |flags| includes VMO_FLAG_WRITE.
    // - OPEN_RIGHT_READABLE if |flags| includes VMO_FLAG_READ or VMO_FLAG_EXEC.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetBuffer(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fuchsia::mem::Buffer** out_buffer);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // |flags| may be any of VMO_FLAG_*.
    //
    // This method requires following rights:
    // - OPEN_RIGHT_WRITABLE if |flags| includes VMO_FLAG_WRITE.
    // - OPEN_RIGHT_READABLE if |flags| includes VMO_FLAG_READ or VMO_FLAG_EXEC.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetBufferResponse> GetBuffer(::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    static zx_status_t Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe(zx::unowned_channel _client_end, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);


    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Read(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ReadResponse> Read(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer);


    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t ReadAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_READABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ReadAtResponse> ReadAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Write(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Write(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WriteResponse> Write(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t WriteAt(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t WriteAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WriteAtResponse> WriteAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    static zx_status_t Seek(zx::unowned_channel _client_end, int64_t offset, SeekOrigin start, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Seek(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of |Read()| or |Write()| will
    // occur.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SeekResponse> Seek(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Truncate(zx::unowned_channel _client_end, uint64_t length, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Truncate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<TruncateResponse> Truncate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    static zx_status_t GetFlags(zx::unowned_channel _client_end, int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetFlagsResponse> GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    static zx_status_t SetFlags(zx::unowned_channel _client_end, uint32_t flags, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - OPEN_FLAG_APPEND
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetFlagsResponse> SetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer);


    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // |flags| may be any of VMO_FLAG_*.
    //
    // This method requires following rights:
    // - OPEN_RIGHT_WRITABLE if |flags| includes VMO_FLAG_WRITE.
    // - OPEN_RIGHT_READABLE if |flags| includes VMO_FLAG_READ or VMO_FLAG_EXEC.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fuchsia::mem::Buffer** out_buffer);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // |flags| may be any of VMO_FLAG_*.
    //
    // This method requires following rights:
    // - OPEN_RIGHT_WRITABLE if |flags| includes VMO_FLAG_WRITE.
    // - OPEN_RIGHT_READABLE if |flags| includes VMO_FLAG_READ or VMO_FLAG_EXEC.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetBufferResponse> GetBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = File;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(NodeInfo info);
      void Reply(::fidl::BytePart _buffer, NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    class ReadCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadCompleter = ::fidl::Completer<ReadCompleterBase>;

    virtual void Read(uint64_t count, ReadCompleter::Sync _completer) = 0;

    class ReadAtCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadAtCompleter = ::fidl::Completer<ReadAtCompleterBase>;

    virtual void ReadAt(uint64_t count, uint64_t offset, ReadAtCompleter::Sync _completer) = 0;

    class WriteCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t actual);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual);
      void Reply(::fidl::DecodedMessage<WriteResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteCompleter = ::fidl::Completer<WriteCompleterBase>;

    virtual void Write(::fidl::VectorView<uint8_t> data, WriteCompleter::Sync _completer) = 0;

    class WriteAtCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t actual);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual);
      void Reply(::fidl::DecodedMessage<WriteAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteAtCompleter = ::fidl::Completer<WriteAtCompleterBase>;

    virtual void WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset, WriteAtCompleter::Sync _completer) = 0;

    class SeekCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t offset);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t offset);
      void Reply(::fidl::DecodedMessage<SeekResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SeekCompleter = ::fidl::Completer<SeekCompleterBase>;

    virtual void Seek(int64_t offset, SeekOrigin start, SeekCompleter::Sync _completer) = 0;

    class TruncateCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<TruncateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using TruncateCompleter = ::fidl::Completer<TruncateCompleterBase>;

    virtual void Truncate(uint64_t length, TruncateCompleter::Sync _completer) = 0;

    class GetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<GetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetFlagsCompleter = ::fidl::Completer<GetFlagsCompleterBase>;

    virtual void GetFlags(GetFlagsCompleter::Sync _completer) = 0;

    class SetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetFlagsCompleter = ::fidl::Completer<SetFlagsCompleterBase>;

    virtual void SetFlags(uint32_t flags, SetFlagsCompleter::Sync _completer) = 0;

    class GetBufferCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fuchsia::mem::Buffer* buffer);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fuchsia::mem::Buffer* buffer);
      void Reply(::fidl::DecodedMessage<GetBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetBufferCompleter = ::fidl::Completer<GetBufferCompleterBase>;

    virtual void GetBuffer(uint32_t flags, GetBufferCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

extern "C" const fidl_type_t fuchsia_io_DirectoryCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryReadDirentsResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryGetTokenResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryWatchRequestTable;

// Directory defines a node which is capable of containing other Objects.
class Directory final {
 public:

  struct CloneRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CloseResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
  };
  struct SyncResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetAttrRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
  };
  struct IoctlRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    using ResponseType = IoctlResponse;
  };

  struct OpenRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    uint32_t mode;
    ::fidl::StringView path;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryOpenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4096;
  };

  struct UnlinkResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct UnlinkRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryUnlinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4096;
    using ResponseType = UnlinkResponse;
  };

  struct ReadDirentsResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> dirents;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryReadDirentsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
  };
  struct ReadDirentsRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t max_bytes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ReadDirentsResponse;
  };

  struct RewindResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using RewindRequest = ::fidl::AnyZeroArgMessage;

  struct GetTokenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::handle token;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct RenameResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct RenameRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryRenameRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = RenameResponse;
  };

  struct LinkResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct LinkRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryLinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = LinkResponse;
  };

  struct WatchResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WatchRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t mask;
    uint32_t options;
    ::zx::channel watcher;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryWatchRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = WatchResponse;
  };


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    zx_status_t Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    zx_status_t Clone(::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Close(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe(NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Sync(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr(int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    zx_status_t Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Messages are encoded and decoded in-place.
    zx_status_t Open(::fidl::DecodedMessage<OpenRequest> params);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Unlink(::fidl::StringView path, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<UnlinkResponse> Unlink(::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);


    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ReadDirentsResponse> ReadDirents(::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    zx_status_t Rewind(int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Rewind(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RewindResponse> Rewind(::fidl::BytePart response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t GetToken(int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetToken(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetTokenResponse> GetToken(::fidl::BytePart response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RenameResponse> Rename(::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<LinkResponse> Link(::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    zx_status_t Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WatchResponse> Watch(::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    static zx_status_t Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe(zx::unowned_channel _client_end, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    static zx_status_t Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Messages are encoded and decoded in-place.
    static zx_status_t Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Unlink(zx::unowned_channel _client_end, ::fidl::StringView path, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<UnlinkResponse> Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);


    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ReadDirentsResponse> ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    static zx_status_t Rewind(zx::unowned_channel _client_end, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RewindResponse> Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t GetToken(zx::unowned_channel _client_end, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RenameResponse> Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<LinkResponse> Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    static zx_status_t Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WatchResponse> Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Directory;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(NodeInfo info);
      void Reply(::fidl::BytePart _buffer, NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    using OpenCompleter = ::fidl::Completer<>;

    virtual void Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object, OpenCompleter::Sync _completer) = 0;

    class UnlinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<UnlinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnlinkCompleter = ::fidl::Completer<UnlinkCompleterBase>;

    virtual void Unlink(::fidl::StringView path, UnlinkCompleter::Sync _completer) = 0;

    class ReadDirentsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::DecodedMessage<ReadDirentsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadDirentsCompleter = ::fidl::Completer<ReadDirentsCompleterBase>;

    virtual void ReadDirents(uint64_t max_bytes, ReadDirentsCompleter::Sync _completer) = 0;

    class RewindCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RewindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RewindCompleter = ::fidl::Completer<RewindCompleterBase>;

    virtual void Rewind(RewindCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::handle token);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class RenameCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RenameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RenameCompleter = ::fidl::Completer<RenameCompleterBase>;

    virtual void Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, RenameCompleter::Sync _completer) = 0;

    class LinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<LinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LinkCompleter = ::fidl::Completer<LinkCompleterBase>;

    virtual void Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, LinkCompleter::Sync _completer) = 0;

    class WatchCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<WatchResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchCompleter = ::fidl::Completer<WatchCompleterBase>;

    virtual void Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, WatchCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

extern "C" const fidl_type_t fuchsia_io_DirectoryAdminCloneRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminOpenRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminReadDirentsResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetTokenResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminRenameRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminLinkRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminWatchRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminMountAndCreateRequestTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminUnmountNodeResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminQueryFilesystemResponseTable;
extern "C" const fidl_type_t fuchsia_io_DirectoryAdminGetDevicePathResponseTable;

// DirectoryAdmin defines a directory which is capable of handling
// administrator tasks within the filesystem.
class DirectoryAdmin final {
 public:

  struct CloneRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };

  struct CloseResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
  };
  struct SyncResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct SetAttrRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
  };
  struct IoctlRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    using ResponseType = IoctlResponse;
  };

  struct OpenRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    uint32_t mode;
    ::fidl::StringView path;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminOpenRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 4096;
  };

  struct UnlinkResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct UnlinkRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminUnlinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4096;
    using ResponseType = UnlinkResponse;
  };

  struct ReadDirentsResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> dirents;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminReadDirentsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
  };
  struct ReadDirentsRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t max_bytes;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = ReadDirentsResponse;
  };

  struct RewindResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using RewindRequest = ::fidl::AnyZeroArgMessage;

  struct GetTokenResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::handle token;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminGetTokenResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using GetTokenRequest = ::fidl::AnyZeroArgMessage;

  struct RenameResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct RenameRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminRenameRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = RenameResponse;
  };

  struct LinkResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct LinkRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView src;
    ::zx::handle dst_parent_token;
    ::fidl::StringView dst;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminLinkRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8192;
    using ResponseType = LinkResponse;
  };

  struct WatchResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct WatchRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t mask;
    uint32_t options;
    ::zx::channel watcher;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminWatchRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = WatchResponse;
  };

  struct MountResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct MountRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel remote;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminMountRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    using ResponseType = MountResponse;
  };

  struct MountAndCreateResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  struct MountAndCreateRequest {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::zx::channel remote;
    ::fidl::StringView name;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminMountAndCreateRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 256;
    using ResponseType = MountAndCreateResponse;
  };

  struct UnmountResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using UnmountRequest = ::fidl::AnyZeroArgMessage;

  struct UnmountNodeResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::zx::channel remote;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminUnmountNodeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
  };
  using UnmountNodeRequest = ::fidl::AnyZeroArgMessage;

  struct QueryFilesystemResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    FilesystemInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminQueryFilesystemResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 96;
  };
  using QueryFilesystemRequest = ::fidl::AnyZeroArgMessage;

  struct GetDevicePathResponse {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::StringView path;

    static constexpr const fidl_type_t* Type = &fuchsia_io_DirectoryAdminGetDevicePathResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4096;
  };
  using GetDevicePathRequest = ::fidl::AnyZeroArgMessage;


  class SyncClient final {
   public:
    SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}

    ~SyncClient() {}

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    zx_status_t Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    zx_status_t Clone(::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Close(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<CloseResponse> Close(::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe(NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Describe(::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<DescribeResponse> Describe(::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Sync(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SyncResponse> Sync(::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr(int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetAttr(::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr(::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t SetAttr(uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr(::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<IoctlResponse> Ioctl(::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    zx_status_t Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Messages are encoded and decoded in-place.
    zx_status_t Open(::fidl::DecodedMessage<OpenRequest> params);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Unlink(::fidl::StringView path, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<UnlinkResponse> Unlink(::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);


    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<ReadDirentsResponse> ReadDirents(::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    zx_status_t Rewind(int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Rewind(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RewindResponse> Rewind(::fidl::BytePart response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t GetToken(int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetToken(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetTokenResponse> GetToken(::fidl::BytePart response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<RenameResponse> Rename(::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    zx_status_t Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<LinkResponse> Link(::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    zx_status_t Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<WatchResponse> Watch(::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    zx_status_t Mount(::zx::channel remote, int32_t* out_s);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Mount(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<MountResponse> Mount(::fidl::DecodedMessage<MountRequest> params, ::fidl::BytePart response_buffer);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    zx_status_t MountAndCreate(::zx::channel remote, ::fidl::StringView name, uint32_t flags, int32_t* out_s);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t MountAndCreate(::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<MountAndCreateResponse> MountAndCreate(::fidl::DecodedMessage<MountAndCreateRequest> params, ::fidl::BytePart response_buffer);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    zx_status_t Unmount(int32_t* out_s);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Unmount(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<UnmountResponse> Unmount(::fidl::BytePart response_buffer);

    // Detach a node which was previously attached to this directory
    // with Mount.
    zx_status_t UnmountNode(int32_t* out_s, ::zx::channel* out_remote);

    // Detach a node which was previously attached to this directory
    // with Mount.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t UnmountNode(::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::channel* out_remote);

    // Detach a node which was previously attached to this directory
    // with Mount.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<UnmountNodeResponse> UnmountNode(::fidl::BytePart response_buffer);


    // Query the filesystem for filesystem-specific information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t QueryFilesystem(::fidl::BytePart _response_buffer, int32_t* out_s, FilesystemInfo** out_info);

    // Query the filesystem for filesystem-specific information.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<QueryFilesystemResponse> QueryFilesystem(::fidl::BytePart response_buffer);


    // Acquire the path to the device backing this filesystem, if there is one.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t GetDevicePath(::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::StringView* out_path);

    // Acquire the path to the device backing this filesystem, if there is one.
    // Messages are encoded and decoded in-place.
    ::fidl::DecodeResult<GetDevicePathResponse> GetDevicePath(::fidl::BytePart response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
   public:

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    static zx_status_t Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // |flags| may be any of:
    // - OPEN_RIGHT_*
    // - OPEN_FLAG_APPEND
    // - OPEN_FLAG_NO_REMOTE
    // - OPEN_FLAG_DESCRIBE
    // - CLONE_FLAG_SAME_RIGHTS
    //
    // All other flags are ignored.
    //
    // TODO(ZX-3676): |flags| should restrict the rights on the resulting cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Messages are encoded and decoded in-place.
    static zx_status_t Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe(zx::unowned_channel _client_end, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the |Describe| operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, uint32_t flags, NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Updates information about the node.
    // |flags| may be any of NODE_ATTRIBUTE_FLAG_*.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Deprecated. Only for use with compatibility with devhost.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    static zx_status_t Open(zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Open(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object);

    // Opens a new object relative to this directory object.
    //
    // |path| may contain multiple segments, separated by "/" characters,
    // and should never be empty i.e. "" is an invalid path.
    //
    // |flags| may be any of the OPEN_FLAG_* and OPEN_RIGHT_* values, bitwise ORed together.
    // The OPEN_FLAG_DESCRIBE flag may cause an |OnOpen| event to be transmitted
    // on the |object| handle, indicating the type of object opened.
    //
    // If an unknown value is sent for either flags or mode, the connection should
    // be closed.
    //
    // OPEN_RIGHTS_* flags provided in |flags| will restrict access rights on the |object| channel
    // which will be connected to the opened entity.
    //
    // Rights are never increased. When you open a nested entity within a directory, you may only
    // request the same rights as what the directory connection already has, or a subset of those.
    // Exceeding those rights causes an access denied error to be transmitted in the
    // |OnOpen| event if applicable, and the |object| connection closed.
    //
    // The caller must specify either one or more of the OPEN_RIGHT_* flags, or
    // the OPEN_FLAG_NODE_REFERENCE flag.
    // Messages are encoded and decoded in-place.
    static zx_status_t Open(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Unlink(zx::unowned_channel _client_end, ::fidl::StringView path, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Unlink(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Detaches an object from this directory object.
    //
    // The underlying object may or may not be deleted after this method
    // completes: although the link will be removed from the containing directory,
    // objects with multiple references (such as files which are still open)
    // will not actually be destroyed until all references are removed.
    //
    // If a directory is unlinked while it still has an open reference,
    // it must become read-only, preventing new entries from being created
    // until all references close and the directory is destroyed.
    //
    // |path| identifies the file which should be detached.
    // If |path| contains multiple segments, separated by "/" characters,
    // then the directory is traversed, one segment at a time, relative to the
    // originally accessed Directory.
    //
    // Returns:
    //   ZX_ERR_ACCESS_DENIED if the connection (or the underlying filesystem) does not
    //     allow writable access.
    //   ZX_ERR_INVALID_ARGS if |path| contains ".." segments.
    //   ZX_ERR_NOT_EMPTY if |path| refers to a non-empty directory.
    //   ZX_ERR_UNAVAILABLE if |path| refers to a mount point, containing a remote channel.
    //   ZX_ERR_UNAVAILABLE if |path| is ".".
    //
    // Other errors may be returned for filesystem-specific reasons.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<UnlinkResponse> Unlink(zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer);


    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t ReadDirents(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_dirents);

    // Reads a collection of variably sized dirents into a buffer.
    // The number of dirents in a directory may be very large: akin to
    // calling read multiple times on a file, directories have a seek
    // offset which is updated on subsequent calls to ReadDirents.
    //
    // These dirents are of the form:
    // struct dirent {
    //   // Describes the inode of the entry.
    //   uint64 ino;
    //   // Describes the length of the dirent name.
    //   uint8 size;
    //   // Describes the type of the entry. Aligned with the
    //   /// POSIX d_type values. Use DIRENT_TYPE_* constants.
    //   uint8 type;
    //   // Unterminated name of entry.
    //   char name[0];
    // }
    //
    // This method does not require any rights, since one could always probe for
    // directory contents by triggering name conflicts during file creation.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<ReadDirentsResponse> ReadDirents(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    static zx_status_t Rewind(zx::unowned_channel _client_end, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Rewind(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Resets the directory seek offset.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RewindResponse> Rewind(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t GetToken(zx::unowned_channel _client_end, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetToken(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::handle* out_token);

    // Acquires a token to a Directory which can be used to identify
    // access to it at a later point in time.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetTokenResponse> GetToken(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Rename(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Rename(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Renames an object named src to the name dst, in a directory represented by token.
    //
    // |src/dst| must be resolved object names. Including "/" in any position
    // other than the end of the string will return ZX_ERR_INVALID_ARGS.
    // Returning "/" at the end of either string implies that it must be a
    // directory, or else ZX_ERR_NOT_DIR should be returned.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<RenameResponse> Rename(zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    static zx_status_t Link(zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Link(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Creates a link to an object named src by the name dst, within a directory represented by
    // token.
    //
    // |src| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // |dst| must be a resolved object name. Including "/" in the string will
    // return ZX_ERR_INVALID_ARGS.
    //
    // This method requires following rights: OPEN_RIGHT_WRITABLE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<LinkResponse> Link(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    static zx_status_t Watch(zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Watch(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Watches a directory, receiving events of added messages on the
    // watcher request channel.
    //
    // The "watcher" handle will send messages of the form:
    // struct {
    //   uint8 event;
    //   uint8 len;
    //   char name[];
    // };
    // Where names are NOT null-terminated.
    //
    // TODO: This API is unstable; in the future, watcher will be a "DirectoryWatcher" client.
    //
    // Mask specifies a bitmask of events to observe.
    // Options must be zero; it is reserved.
    //
    // This method does not require any rights, similar to ReadDirents.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<WatchResponse> Watch(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    static zx_status_t Mount(zx::unowned_channel _client_end, ::zx::channel remote, int32_t* out_s);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Mount(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Mount a channel representing a remote filesystem onto this directory.
    // All future requests to this node will be forwarded to the remote filesystem.
    // To re-open a node without forwarding to the remote target, the node
    // should be opened with OPEN_FLAG_NO_REMOTE.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<MountResponse> Mount(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountRequest> params, ::fidl::BytePart response_buffer);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    static zx_status_t MountAndCreate(zx::unowned_channel _client_end, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, int32_t* out_s);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t MountAndCreate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel remote, ::fidl::StringView name, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Atomically create a directory with a provided path, and mount the
    // remote handle to the newly created directory.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<MountAndCreateResponse> MountAndCreate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MountAndCreateRequest> params, ::fidl::BytePart response_buffer);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    static zx_status_t Unmount(zx::unowned_channel _client_end, int32_t* out_s);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Unmount(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Unmount this filesystem. After this function returns successfully,
    // all connections to the filesystem will be terminated.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<UnmountResponse> Unmount(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Detach a node which was previously attached to this directory
    // with Mount.
    static zx_status_t UnmountNode(zx::unowned_channel _client_end, int32_t* out_s, ::zx::channel* out_remote);

    // Detach a node which was previously attached to this directory
    // with Mount.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::zx::channel* out_remote);

    // Detach a node which was previously attached to this directory
    // with Mount.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<UnmountNodeResponse> UnmountNode(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);


    // Query the filesystem for filesystem-specific information.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, FilesystemInfo** out_info);

    // Query the filesystem for filesystem-specific information.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<QueryFilesystemResponse> QueryFilesystem(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);


    // Acquire the path to the device backing this filesystem, if there is one.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::StringView* out_path);

    // Acquire the path to the device backing this filesystem, if there is one.
    // Messages are encoded and decoded in-place.
    static ::fidl::DecodeResult<GetDevicePathResponse> GetDevicePath(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = DirectoryAdmin;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(NodeInfo info);
      void Reply(::fidl::BytePart _buffer, NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    using OpenCompleter = ::fidl::Completer<>;

    virtual void Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object, OpenCompleter::Sync _completer) = 0;

    class UnlinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<UnlinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnlinkCompleter = ::fidl::Completer<UnlinkCompleterBase>;

    virtual void Unlink(::fidl::StringView path, UnlinkCompleter::Sync _completer) = 0;

    class ReadDirentsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents);
      void Reply(::fidl::DecodedMessage<ReadDirentsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadDirentsCompleter = ::fidl::Completer<ReadDirentsCompleterBase>;

    virtual void ReadDirents(uint64_t max_bytes, ReadDirentsCompleter::Sync _completer) = 0;

    class RewindCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RewindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RewindCompleter = ::fidl::Completer<RewindCompleterBase>;

    virtual void Rewind(RewindCompleter::Sync _completer) = 0;

    class GetTokenCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::handle token);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token);
      void Reply(::fidl::DecodedMessage<GetTokenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetTokenCompleter = ::fidl::Completer<GetTokenCompleterBase>;

    virtual void GetToken(GetTokenCompleter::Sync _completer) = 0;

    class RenameCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<RenameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using RenameCompleter = ::fidl::Completer<RenameCompleterBase>;

    virtual void Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, RenameCompleter::Sync _completer) = 0;

    class LinkCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<LinkResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LinkCompleter = ::fidl::Completer<LinkCompleterBase>;

    virtual void Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, LinkCompleter::Sync _completer) = 0;

    class WatchCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<WatchResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WatchCompleter = ::fidl::Completer<WatchCompleterBase>;

    virtual void Watch(uint32_t mask, uint32_t options, ::zx::channel watcher, WatchCompleter::Sync _completer) = 0;

    class MountCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<MountResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using MountCompleter = ::fidl::Completer<MountCompleterBase>;

    virtual void Mount(::zx::channel remote, MountCompleter::Sync _completer) = 0;

    class MountAndCreateCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<MountAndCreateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using MountAndCreateCompleter = ::fidl::Completer<MountAndCreateCompleterBase>;

    virtual void MountAndCreate(::zx::channel remote, ::fidl::StringView name, uint32_t flags, MountAndCreateCompleter::Sync _completer) = 0;

    class UnmountCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<UnmountResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnmountCompleter = ::fidl::Completer<UnmountCompleterBase>;

    virtual void Unmount(UnmountCompleter::Sync _completer) = 0;

    class UnmountNodeCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::zx::channel remote);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::zx::channel remote);
      void Reply(::fidl::DecodedMessage<UnmountNodeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using UnmountNodeCompleter = ::fidl::Completer<UnmountNodeCompleterBase>;

    virtual void UnmountNode(UnmountNodeCompleter::Sync _completer) = 0;

    class QueryFilesystemCompleterBase : public _Base {
     public:
      void Reply(int32_t s, FilesystemInfo* info);
      void Reply(::fidl::BytePart _buffer, int32_t s, FilesystemInfo* info);
      void Reply(::fidl::DecodedMessage<QueryFilesystemResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using QueryFilesystemCompleter = ::fidl::Completer<QueryFilesystemCompleterBase>;

    virtual void QueryFilesystem(QueryFilesystemCompleter::Sync _completer) = 0;

    class GetDevicePathCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::StringView path);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::StringView path);
      void Reply(::fidl::DecodedMessage<GetDevicePathResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDevicePathCompleter = ::fidl::Completer<GetDevicePathCompleterBase>;

    virtual void GetDevicePath(GetDevicePathCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by |OPEN_FLAG_DESCRIBE|.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is |ZX_OK|, |info| contains descriptive information about the object
  // (the same as would be returned by |Describe|).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

// A dirent with an unknown type.
constexpr uint8_t DIRENT_TYPE_UNKNOWN = 0;

// A dirent representing a socket object.
constexpr uint8_t DIRENT_TYPE_SOCKET = 12;

// A dirent representing a service object.
constexpr uint8_t DIRENT_TYPE_SERVICE = 16;

// A dirent representing a file object.
constexpr uint8_t DIRENT_TYPE_FILE = 8;

// A dirent representing a directory object.
constexpr uint8_t DIRENT_TYPE_DIRECTORY = 4;

// A dirent representing a block device object.
constexpr uint8_t DIRENT_TYPE_BLOCK_DEVICE = 6;

// Indicates the device is ready for writing.
constexpr uint32_t DEVICE_SIGNAL_WRITABLE = 0x02000000;

// Indicates the device is ready for reading.
constexpr uint32_t DEVICE_SIGNAL_READABLE = 0x01000000;

// Indicates an out-of-band state transition has occurred.
constexpr uint32_t DEVICE_SIGNAL_OOB = 0x10000000;

// Indicates the device has hung up on the current connection.
constexpr uint32_t DEVICE_SIGNAL_HANGUP = 0x08000000;

// Indicates the device has encountered an error state.
constexpr uint32_t DEVICE_SIGNAL_ERROR = 0x04000000;

// When used during clone, the new connection inherits the rights on the source connection,
// regardless if it is a file or directory. Otherwise, clone attempts to use the requested rights.
// It is invalid to pass any of the OPEN_RIGHT_* flags together with CLONE_FLAGS_SAME_RIGHTS.
constexpr uint32_t CLONE_FLAG_SAME_RIGHTS = 0x04000000;

}  // namespace io
}  // namespace fuchsia

namespace fidl {

template <>
struct IsFidlType<::fuchsia::io::WatchedEvent> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::WatchedEvent>);
static_assert(offsetof(::fuchsia::io::WatchedEvent, event) == 0);
static_assert(offsetof(::fuchsia::io::WatchedEvent, len) == 1);
static_assert(offsetof(::fuchsia::io::WatchedEvent, name) == 8);
static_assert(sizeof(::fuchsia::io::WatchedEvent) == ::fuchsia::io::WatchedEvent::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::Vmofile> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::Vmofile>);
static_assert(offsetof(::fuchsia::io::Vmofile, vmo) == 0);
static_assert(offsetof(::fuchsia::io::Vmofile, offset) == 8);
static_assert(offsetof(::fuchsia::io::Vmofile, length) == 16);
static_assert(sizeof(::fuchsia::io::Vmofile) == ::fuchsia::io::Vmofile::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::Tty> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::Tty>);
static_assert(offsetof(::fuchsia::io::Tty, event) == 0);
static_assert(sizeof(::fuchsia::io::Tty) == ::fuchsia::io::Tty::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::DirectoryWatcher::OnEventRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryWatcher::OnEventRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryWatcher::OnEventRequest)
    == ::fuchsia::io::DirectoryWatcher::OnEventRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryWatcher::OnEventRequest, events) == 16);

template <>
struct IsFidlType<::fuchsia::io::Service> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::Service>);
static_assert(offsetof(::fuchsia::io::Service, __reserved) == 0);
static_assert(sizeof(::fuchsia::io::Service) == ::fuchsia::io::Service::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::Pipe> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::Pipe>);
static_assert(offsetof(::fuchsia::io::Pipe, socket) == 0);
static_assert(sizeof(::fuchsia::io::Pipe) == ::fuchsia::io::Pipe::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::NodeAttributes> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::NodeAttributes>);
static_assert(offsetof(::fuchsia::io::NodeAttributes, mode) == 0);
static_assert(offsetof(::fuchsia::io::NodeAttributes, id) == 8);
static_assert(offsetof(::fuchsia::io::NodeAttributes, content_size) == 16);
static_assert(offsetof(::fuchsia::io::NodeAttributes, storage_size) == 24);
static_assert(offsetof(::fuchsia::io::NodeAttributes, link_count) == 32);
static_assert(offsetof(::fuchsia::io::NodeAttributes, creation_time) == 40);
static_assert(offsetof(::fuchsia::io::NodeAttributes, modification_time) == 48);
static_assert(sizeof(::fuchsia::io::NodeAttributes) == ::fuchsia::io::NodeAttributes::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::FilesystemInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::FilesystemInfo>);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, total_bytes) == 0);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, used_bytes) == 8);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, total_nodes) == 16);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, used_nodes) == 24);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, free_shared_pool_bytes) == 32);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, fs_id) == 40);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, block_size) == 48);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, max_filename_size) == 52);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, fs_type) == 56);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, padding) == 60);
static_assert(offsetof(::fuchsia::io::FilesystemInfo, name) == 64);
static_assert(sizeof(::fuchsia::io::FilesystemInfo) == ::fuchsia::io::FilesystemInfo::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::FileObject> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::FileObject>);
static_assert(offsetof(::fuchsia::io::FileObject, event) == 0);
static_assert(sizeof(::fuchsia::io::FileObject) == ::fuchsia::io::FileObject::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::DirectoryObject> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::DirectoryObject>);
static_assert(offsetof(::fuchsia::io::DirectoryObject, __reserved) == 0);
static_assert(sizeof(::fuchsia::io::DirectoryObject) == ::fuchsia::io::DirectoryObject::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::Device> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::Device>);
static_assert(offsetof(::fuchsia::io::Device, event) == 0);
static_assert(sizeof(::fuchsia::io::Device) == ::fuchsia::io::Device::PrimarySize);

template <>
struct IsFidlType<::fuchsia::io::NodeInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fuchsia::io::NodeInfo>);

template <>
struct IsFidlType<::fuchsia::io::Node::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::CloneRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::CloneRequest)
    == ::fuchsia::io::Node::CloneRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::CloneRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::Node::CloneRequest, object) == 20);

template <>
struct IsFidlType<::fuchsia::io::Node::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::CloseResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::CloseResponse)
    == ::fuchsia::io::Node::CloseResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::CloseResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Node::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::DescribeResponse)
    == ::fuchsia::io::Node::DescribeResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::fuchsia::io::Node::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::OnOpenResponse)
    == ::fuchsia::io::Node::OnOpenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::OnOpenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Node::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::fuchsia::io::Node::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::SyncResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::SyncResponse)
    == ::fuchsia::io::Node::SyncResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::SyncResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Node::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::GetAttrResponse)
    == ::fuchsia::io::Node::GetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::GetAttrResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Node::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::Node::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::SetAttrRequest)
    == ::fuchsia::io::Node::SetAttrRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::SetAttrRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::Node::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::Node::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::SetAttrResponse)
    == ::fuchsia::io::Node::SetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Node::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::IoctlRequest)
    == ::fuchsia::io::Node::IoctlRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::IoctlRequest, opcode) == 16);
static_assert(offsetof(::fuchsia::io::Node::IoctlRequest, max_out) == 24);
static_assert(offsetof(::fuchsia::io::Node::IoctlRequest, handles) == 32);
static_assert(offsetof(::fuchsia::io::Node::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::fuchsia::io::Node::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Node::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Node::IoctlResponse)
    == ::fuchsia::io::Node::IoctlResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Node::IoctlResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Node::IoctlResponse, handles) == 24);
static_assert(offsetof(::fuchsia::io::Node::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::fuchsia::io::File::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::CloneRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::CloneRequest)
    == ::fuchsia::io::File::CloneRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::CloneRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::File::CloneRequest, object) == 20);

template <>
struct IsFidlType<::fuchsia::io::File::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::CloseResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::CloseResponse)
    == ::fuchsia::io::File::CloseResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::CloseResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::DescribeResponse)
    == ::fuchsia::io::File::DescribeResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::OnOpenResponse)
    == ::fuchsia::io::File::OnOpenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::OnOpenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SyncResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SyncResponse)
    == ::fuchsia::io::File::SyncResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SyncResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::GetAttrResponse)
    == ::fuchsia::io::File::GetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::GetAttrResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SetAttrRequest)
    == ::fuchsia::io::File::SetAttrRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SetAttrRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::File::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SetAttrResponse)
    == ::fuchsia::io::File::SetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::IoctlRequest)
    == ::fuchsia::io::File::IoctlRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::IoctlRequest, opcode) == 16);
static_assert(offsetof(::fuchsia::io::File::IoctlRequest, max_out) == 24);
static_assert(offsetof(::fuchsia::io::File::IoctlRequest, handles) == 32);
static_assert(offsetof(::fuchsia::io::File::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::fuchsia::io::File::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::IoctlResponse)
    == ::fuchsia::io::File::IoctlResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::IoctlResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::IoctlResponse, handles) == 24);
static_assert(offsetof(::fuchsia::io::File::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::fuchsia::io::File::ReadRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::ReadRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::ReadRequest)
    == ::fuchsia::io::File::ReadRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::ReadRequest, count) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::ReadResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::ReadResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::ReadResponse)
    == ::fuchsia::io::File::ReadResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::ReadResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::ReadResponse, data) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::ReadAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::ReadAtRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::ReadAtRequest)
    == ::fuchsia::io::File::ReadAtRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::ReadAtRequest, count) == 16);
static_assert(offsetof(::fuchsia::io::File::ReadAtRequest, offset) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::ReadAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::ReadAtResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::ReadAtResponse)
    == ::fuchsia::io::File::ReadAtResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::ReadAtResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::ReadAtResponse, data) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::WriteRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::WriteRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::WriteRequest)
    == ::fuchsia::io::File::WriteRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::WriteRequest, data) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::WriteResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::WriteResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::WriteResponse)
    == ::fuchsia::io::File::WriteResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::WriteResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::WriteResponse, actual) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::WriteAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::WriteAtRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::WriteAtRequest)
    == ::fuchsia::io::File::WriteAtRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::WriteAtRequest, data) == 16);
static_assert(offsetof(::fuchsia::io::File::WriteAtRequest, offset) == 32);

template <>
struct IsFidlType<::fuchsia::io::File::WriteAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::WriteAtResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::WriteAtResponse)
    == ::fuchsia::io::File::WriteAtResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::WriteAtResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::WriteAtResponse, actual) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::SeekRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SeekRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SeekRequest)
    == ::fuchsia::io::File::SeekRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SeekRequest, offset) == 16);
static_assert(offsetof(::fuchsia::io::File::SeekRequest, start) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::SeekResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SeekResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SeekResponse)
    == ::fuchsia::io::File::SeekResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SeekResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::SeekResponse, offset) == 24);

template <>
struct IsFidlType<::fuchsia::io::File::TruncateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::TruncateRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::TruncateRequest)
    == ::fuchsia::io::File::TruncateRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::TruncateRequest, length) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::TruncateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::TruncateResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::TruncateResponse)
    == ::fuchsia::io::File::TruncateResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::TruncateResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::GetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::GetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::GetFlagsResponse)
    == ::fuchsia::io::File::GetFlagsResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::GetFlagsResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::GetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::fuchsia::io::File::SetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SetFlagsRequest)
    == ::fuchsia::io::File::SetFlagsRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::SetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::SetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::SetFlagsResponse)
    == ::fuchsia::io::File::SetFlagsResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::SetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::GetBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::GetBufferRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::GetBufferRequest)
    == ::fuchsia::io::File::GetBufferRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::GetBufferRequest, flags) == 16);

template <>
struct IsFidlType<::fuchsia::io::File::GetBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::File::GetBufferResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::File::GetBufferResponse)
    == ::fuchsia::io::File::GetBufferResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::File::GetBufferResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::File::GetBufferResponse, buffer) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::CloneRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::CloneRequest)
    == ::fuchsia::io::Directory::CloneRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::CloneRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::Directory::CloneRequest, object) == 20);

template <>
struct IsFidlType<::fuchsia::io::Directory::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::CloseResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::CloseResponse)
    == ::fuchsia::io::Directory::CloseResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::CloseResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::DescribeResponse)
    == ::fuchsia::io::Directory::DescribeResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::OnOpenResponse)
    == ::fuchsia::io::Directory::OnOpenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::OnOpenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Directory::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::SyncResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::SyncResponse)
    == ::fuchsia::io::Directory::SyncResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::SyncResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::GetAttrResponse)
    == ::fuchsia::io::Directory::GetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::GetAttrResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Directory::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::SetAttrRequest)
    == ::fuchsia::io::Directory::SetAttrRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::SetAttrRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::Directory::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::SetAttrResponse)
    == ::fuchsia::io::Directory::SetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::IoctlRequest)
    == ::fuchsia::io::Directory::IoctlRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::IoctlRequest, opcode) == 16);
static_assert(offsetof(::fuchsia::io::Directory::IoctlRequest, max_out) == 24);
static_assert(offsetof(::fuchsia::io::Directory::IoctlRequest, handles) == 32);
static_assert(offsetof(::fuchsia::io::Directory::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::fuchsia::io::Directory::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::IoctlResponse)
    == ::fuchsia::io::Directory::IoctlResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::IoctlResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Directory::IoctlResponse, handles) == 24);
static_assert(offsetof(::fuchsia::io::Directory::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::fuchsia::io::Directory::OpenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::OpenRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::OpenRequest)
    == ::fuchsia::io::Directory::OpenRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::OpenRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::Directory::OpenRequest, mode) == 20);
static_assert(offsetof(::fuchsia::io::Directory::OpenRequest, path) == 24);
static_assert(offsetof(::fuchsia::io::Directory::OpenRequest, object) == 40);

template <>
struct IsFidlType<::fuchsia::io::Directory::UnlinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::UnlinkRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::UnlinkRequest)
    == ::fuchsia::io::Directory::UnlinkRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::UnlinkRequest, path) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::UnlinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::UnlinkResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::UnlinkResponse)
    == ::fuchsia::io::Directory::UnlinkResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::UnlinkResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::ReadDirentsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::ReadDirentsRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::ReadDirentsRequest)
    == ::fuchsia::io::Directory::ReadDirentsRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::ReadDirentsRequest, max_bytes) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::ReadDirentsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::ReadDirentsResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::ReadDirentsResponse)
    == ::fuchsia::io::Directory::ReadDirentsResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::ReadDirentsResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Directory::ReadDirentsResponse, dirents) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::RewindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::RewindResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::RewindResponse)
    == ::fuchsia::io::Directory::RewindResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::RewindResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::GetTokenResponse)
    == ::fuchsia::io::Directory::GetTokenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::GetTokenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::Directory::GetTokenResponse, token) == 20);

template <>
struct IsFidlType<::fuchsia::io::Directory::RenameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::RenameRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::RenameRequest)
    == ::fuchsia::io::Directory::RenameRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::RenameRequest, src) == 16);
static_assert(offsetof(::fuchsia::io::Directory::RenameRequest, dst_parent_token) == 32);
static_assert(offsetof(::fuchsia::io::Directory::RenameRequest, dst) == 40);

template <>
struct IsFidlType<::fuchsia::io::Directory::RenameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::RenameResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::RenameResponse)
    == ::fuchsia::io::Directory::RenameResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::RenameResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::LinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::LinkRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::LinkRequest)
    == ::fuchsia::io::Directory::LinkRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::LinkRequest, src) == 16);
static_assert(offsetof(::fuchsia::io::Directory::LinkRequest, dst_parent_token) == 32);
static_assert(offsetof(::fuchsia::io::Directory::LinkRequest, dst) == 40);

template <>
struct IsFidlType<::fuchsia::io::Directory::LinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::LinkResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::LinkResponse)
    == ::fuchsia::io::Directory::LinkResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::LinkResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::Directory::WatchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::WatchRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::WatchRequest)
    == ::fuchsia::io::Directory::WatchRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::WatchRequest, mask) == 16);
static_assert(offsetof(::fuchsia::io::Directory::WatchRequest, options) == 20);
static_assert(offsetof(::fuchsia::io::Directory::WatchRequest, watcher) == 24);

template <>
struct IsFidlType<::fuchsia::io::Directory::WatchResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::Directory::WatchResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::Directory::WatchResponse)
    == ::fuchsia::io::Directory::WatchResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::Directory::WatchResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::CloneRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::CloneRequest)
    == ::fuchsia::io::DirectoryAdmin::CloneRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::CloneRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::CloneRequest, object) == 20);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::CloseResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::CloseResponse)
    == ::fuchsia::io::DirectoryAdmin::CloseResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::CloseResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::DescribeResponse)
    == ::fuchsia::io::DirectoryAdmin::DescribeResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::OnOpenResponse)
    == ::fuchsia::io::DirectoryAdmin::OnOpenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OnOpenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::SyncResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::SyncResponse)
    == ::fuchsia::io::DirectoryAdmin::SyncResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::SyncResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::GetAttrResponse)
    == ::fuchsia::io::DirectoryAdmin::GetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetAttrResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::SetAttrRequest)
    == ::fuchsia::io::DirectoryAdmin::SetAttrRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::SetAttrRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::SetAttrResponse)
    == ::fuchsia::io::DirectoryAdmin::SetAttrResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::IoctlRequest)
    == ::fuchsia::io::DirectoryAdmin::IoctlRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlRequest, opcode) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlRequest, max_out) == 24);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlRequest, handles) == 32);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::IoctlResponse)
    == ::fuchsia::io::DirectoryAdmin::IoctlResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlResponse, handles) == 24);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::OpenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::OpenRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::OpenRequest)
    == ::fuchsia::io::DirectoryAdmin::OpenRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OpenRequest, flags) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OpenRequest, mode) == 20);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OpenRequest, path) == 24);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::OpenRequest, object) == 40);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::UnlinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::UnlinkRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::UnlinkRequest)
    == ::fuchsia::io::DirectoryAdmin::UnlinkRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::UnlinkRequest, path) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::UnlinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::UnlinkResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::UnlinkResponse)
    == ::fuchsia::io::DirectoryAdmin::UnlinkResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::UnlinkResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::ReadDirentsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::ReadDirentsRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::ReadDirentsRequest)
    == ::fuchsia::io::DirectoryAdmin::ReadDirentsRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::ReadDirentsRequest, max_bytes) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::ReadDirentsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::ReadDirentsResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::ReadDirentsResponse)
    == ::fuchsia::io::DirectoryAdmin::ReadDirentsResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::ReadDirentsResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::ReadDirentsResponse, dirents) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::RewindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::RewindResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::RewindResponse)
    == ::fuchsia::io::DirectoryAdmin::RewindResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::RewindResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::GetTokenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::GetTokenResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::GetTokenResponse)
    == ::fuchsia::io::DirectoryAdmin::GetTokenResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetTokenResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetTokenResponse, token) == 20);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::RenameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::RenameRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::RenameRequest)
    == ::fuchsia::io::DirectoryAdmin::RenameRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::RenameRequest, src) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::RenameRequest, dst_parent_token) == 32);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::RenameRequest, dst) == 40);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::RenameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::RenameResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::RenameResponse)
    == ::fuchsia::io::DirectoryAdmin::RenameResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::RenameResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::LinkRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::LinkRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::LinkRequest)
    == ::fuchsia::io::DirectoryAdmin::LinkRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::LinkRequest, src) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::LinkRequest, dst_parent_token) == 32);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::LinkRequest, dst) == 40);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::LinkResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::LinkResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::LinkResponse)
    == ::fuchsia::io::DirectoryAdmin::LinkResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::LinkResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::WatchRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::WatchRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::WatchRequest)
    == ::fuchsia::io::DirectoryAdmin::WatchRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::WatchRequest, mask) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::WatchRequest, options) == 20);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::WatchRequest, watcher) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::WatchResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::WatchResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::WatchResponse)
    == ::fuchsia::io::DirectoryAdmin::WatchResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::WatchResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::MountRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::MountRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::MountRequest)
    == ::fuchsia::io::DirectoryAdmin::MountRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountRequest, remote) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::MountResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::MountResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::MountResponse)
    == ::fuchsia::io::DirectoryAdmin::MountResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::MountAndCreateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::MountAndCreateRequest> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::MountAndCreateRequest)
    == ::fuchsia::io::DirectoryAdmin::MountAndCreateRequest::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountAndCreateRequest, remote) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountAndCreateRequest, name) == 24);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountAndCreateRequest, flags) == 40);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::MountAndCreateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::MountAndCreateResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::MountAndCreateResponse)
    == ::fuchsia::io::DirectoryAdmin::MountAndCreateResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::MountAndCreateResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::UnmountResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::UnmountResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::UnmountResponse)
    == ::fuchsia::io::DirectoryAdmin::UnmountResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::UnmountResponse, s) == 16);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::UnmountNodeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::UnmountNodeResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::UnmountNodeResponse)
    == ::fuchsia::io::DirectoryAdmin::UnmountNodeResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::UnmountNodeResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::UnmountNodeResponse, remote) == 20);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse)
    == ::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::QueryFilesystemResponse, info) == 24);

template <>
struct IsFidlType<::fuchsia::io::DirectoryAdmin::GetDevicePathResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::fuchsia::io::DirectoryAdmin::GetDevicePathResponse> : public std::true_type {};
static_assert(sizeof(::fuchsia::io::DirectoryAdmin::GetDevicePathResponse)
    == ::fuchsia::io::DirectoryAdmin::GetDevicePathResponse::PrimarySize);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetDevicePathResponse, s) == 16);
static_assert(offsetof(::fuchsia::io::DirectoryAdmin::GetDevicePathResponse, path) == 24);

}  // namespace fidl

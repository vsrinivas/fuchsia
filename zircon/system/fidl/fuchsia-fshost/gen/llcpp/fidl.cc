// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/fshost/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace fshost {

namespace {

[[maybe_unused]]
constexpr uint64_t kFilesystems_Clone_Ordinal = 0x17fe6a4c00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Clone_GenOrdinal = 0x5a61678f293ce16flu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloneRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloneResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloneResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Close_Ordinal = 0x52b9568700000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Close_GenOrdinal = 0x5309c5bd1c33dc44lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloseRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsCloseResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsCloseResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Describe_Ordinal = 0x1f62df5e00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Describe_GenOrdinal = 0xffcec215078dea0lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsDescribeRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsDescribeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsDescribeResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_OnOpen_Ordinal = 0x4700a7bd00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_OnOpen_GenOrdinal = 0x7fc7bbb1dbfd1972lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOnOpenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOnOpenEventTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOnOpenEventTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Sync_Ordinal = 0x62423faa00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Sync_GenOrdinal = 0x189d88326c18b519lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSyncRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSyncResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSyncResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_GetAttr_Ordinal = 0x4585e7c800000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_GetAttr_GenOrdinal = 0x78985e216314dafdlu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_SetAttr_Ordinal = 0xbd5559a00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_SetAttr_GenOrdinal = 0x4186c0f40d938f46lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsSetAttrResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsSetAttrResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_NodeGetFlags_Ordinal = 0x3c24c22300000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_NodeGetFlags_GenOrdinal = 0x5b88fffb8eda3aa1lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeGetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeGetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_NodeSetFlags_Ordinal = 0x46940c1600000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_NodeSetFlags_GenOrdinal = 0x5295b76c71fde733lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsNodeSetFlagsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Open_Ordinal = 0x77e4cceb00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Open_GenOrdinal = 0x2c5044561d685ec0lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOpenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsOpenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsOpenResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Unlink_Ordinal = 0x2cbadb1900000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Unlink_GenOrdinal = 0x5a0ff90760a8bc23lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsUnlinkRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsUnlinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsUnlinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_ReadDirents_Ordinal = 0x2ea53c2d00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_ReadDirents_GenOrdinal = 0x3582806bf27faa0alu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsReadDirentsRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsReadDirentsResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsReadDirentsResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Rewind_Ordinal = 0x7072fd8700000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Rewind_GenOrdinal = 0x16b1202af0f34c71lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRewindRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRewindResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRewindResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_GetToken_Ordinal = 0x3217bced00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_GetToken_GenOrdinal = 0x26ae9d18763c8655lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetTokenRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsGetTokenResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsGetTokenResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Rename_Ordinal = 0x4a94b0ac00000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Rename_GenOrdinal = 0xa8e00a247f3c905lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRenameRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsRenameResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsRenameResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Link_Ordinal = 0x1b8a5e6400000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Link_GenOrdinal = 0x740604c0c7c930e7lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsLinkRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsLinkResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsLinkResponseTable;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Watch_Ordinal = 0x5ac28f3400000000lu;
[[maybe_unused]]
constexpr uint64_t kFilesystems_Watch_GenOrdinal = 0x5717193a59d66d91lu;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsWatchRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_FilesystemsWatchResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_FilesystemsWatchResponseTable;

}  // namespace

Filesystems::ResultOf::Clone_Impl::Clone_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloneRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      Filesystems::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Filesystems::ResultOf::Clone Filesystems::SyncClient::Clone(uint32_t flags, ::zx::channel object) {
    return ResultOf::Clone(::zx::unowned_channel(this->channel_), std::move(flags), std::move(object));
}

Filesystems::ResultOf::Clone Filesystems::Call::Clone(::zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object) {
  return ResultOf::Clone(std::move(_client_end), std::move(flags), std::move(object));
}


Filesystems::UnownedResultOf::Clone_Impl::Clone_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  if (_request_buffer.capacity() < CloneRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, CloneRequest::PrimarySize);
  auto& _request = *reinterpret_cast<CloneRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.object = std::move(object);
  _request_buffer.set_actual(sizeof(CloneRequest));
  ::fidl::DecodedMessage<CloneRequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      Filesystems::InPlace::Clone(std::move(_client_end), std::move(_decoded_request)));
}

Filesystems::UnownedResultOf::Clone Filesystems::SyncClient::Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(object));
}

Filesystems::UnownedResultOf::Clone Filesystems::Call::Clone(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object) {
  return UnownedResultOf::Clone(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(object));
}

::fidl::internal::StatusAndError Filesystems::InPlace::Clone(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params) {
  Filesystems::SetTransactionHeaderFor::CloneRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Filesystems::ResultOf::Close_Impl<Filesystems::CloseResponse>::Close_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, CloseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::Close(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::Close Filesystems::SyncClient::Close() {
    return ResultOf::Close(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::Close Filesystems::Call::Close(::zx::unowned_channel _client_end) {
  return ResultOf::Close(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::Close_Impl<Filesystems::CloseResponse>::Close_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(CloseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, CloseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(CloseRequest));
  ::fidl::DecodedMessage<CloseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::Close(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Close Filesystems::SyncClient::Close(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Close Filesystems::Call::Close(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Close(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::CloseResponse> Filesystems::InPlace::Close(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(CloseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<CloseRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::CloseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::CloseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<CloseRequest, CloseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::CloseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Describe_Impl<Filesystems::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, DescribeRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::Describe(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::Describe Filesystems::SyncClient::Describe() {
    return ResultOf::Describe(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::Describe Filesystems::Call::Describe(::zx::unowned_channel _client_end) {
  return ResultOf::Describe(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::Describe_Impl<Filesystems::DescribeResponse>::Describe_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(DescribeRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, DescribeRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(DescribeRequest));
  ::fidl::DecodedMessage<DescribeRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::Describe(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Describe Filesystems::SyncClient::Describe(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Describe Filesystems::Call::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Describe(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::DescribeResponse> Filesystems::InPlace::Describe(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(DescribeRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<DescribeRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::DescribeRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::DescribeResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<DescribeRequest, DescribeResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::DescribeResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Sync_Impl<Filesystems::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SyncRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::Sync(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::Sync Filesystems::SyncClient::Sync() {
    return ResultOf::Sync(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::Sync Filesystems::Call::Sync(::zx::unowned_channel _client_end) {
  return ResultOf::Sync(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::Sync_Impl<Filesystems::SyncResponse>::Sync_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(SyncRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, SyncRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(SyncRequest));
  ::fidl::DecodedMessage<SyncRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::Sync(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Sync Filesystems::SyncClient::Sync(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Sync Filesystems::Call::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Sync(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::SyncResponse> Filesystems::InPlace::Sync(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(SyncRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<SyncRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::SyncRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::SyncResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SyncRequest, SyncResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::SyncResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::GetAttr_Impl<Filesystems::GetAttrResponse>::GetAttr_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetAttrRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::GetAttr(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::GetAttr Filesystems::SyncClient::GetAttr() {
    return ResultOf::GetAttr(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::GetAttr Filesystems::Call::GetAttr(::zx::unowned_channel _client_end) {
  return ResultOf::GetAttr(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::GetAttr_Impl<Filesystems::GetAttrResponse>::GetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetAttrRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetAttrRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetAttrRequest));
  ::fidl::DecodedMessage<GetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::GetAttr(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::GetAttr Filesystems::SyncClient::GetAttr(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::GetAttr Filesystems::Call::GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetAttr(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::GetAttrResponse> Filesystems::InPlace::GetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetAttrRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetAttrRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::GetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::GetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetAttrRequest, GetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::GetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::SetAttr_Impl<Filesystems::SetAttrResponse>::SetAttr_Impl(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::SetAttr Filesystems::SyncClient::SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
    return ResultOf::SetAttr(::zx::unowned_channel(this->channel_), std::move(flags), std::move(attributes));
}

Filesystems::ResultOf::SetAttr Filesystems::Call::SetAttr(::zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  return ResultOf::SetAttr(std::move(_client_end), std::move(flags), std::move(attributes));
}

template <>
Filesystems::UnownedResultOf::SetAttr_Impl<Filesystems::SetAttrResponse>::SetAttr_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetAttrRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetAttrResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetAttrRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetAttrRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request.attributes = std::move(attributes);
  _request_buffer.set_actual(sizeof(SetAttrRequest));
  ::fidl::DecodedMessage<SetAttrRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::SetAttr(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::SetAttr Filesystems::SyncClient::SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::SetAttr Filesystems::Call::SetAttr(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetAttr(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(attributes), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::SetAttrResponse> Filesystems::InPlace::SetAttr(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::SetAttrRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::SetAttrResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetAttrRequest, SetAttrResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::SetAttrResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::NodeGetFlags_Impl<Filesystems::NodeGetFlagsResponse>::NodeGetFlags_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeGetFlagsRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::NodeGetFlags(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::NodeGetFlags Filesystems::SyncClient::NodeGetFlags() {
    return ResultOf::NodeGetFlags(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::NodeGetFlags Filesystems::Call::NodeGetFlags(::zx::unowned_channel _client_end) {
  return ResultOf::NodeGetFlags(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::NodeGetFlags_Impl<Filesystems::NodeGetFlagsResponse>::NodeGetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NodeGetFlagsRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NodeGetFlagsRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NodeGetFlagsRequest));
  ::fidl::DecodedMessage<NodeGetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::NodeGetFlags(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::NodeGetFlags Filesystems::SyncClient::NodeGetFlags(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::NodeGetFlags Filesystems::Call::NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeGetFlags(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::NodeGetFlagsResponse> Filesystems::InPlace::NodeGetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NodeGetFlagsRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NodeGetFlagsRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::NodeGetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::NodeGetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeGetFlagsRequest, NodeGetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::NodeGetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::NodeSetFlags_Impl<Filesystems::NodeSetFlagsResponse>::NodeSetFlags_Impl(::zx::unowned_channel _client_end, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_write_bytes);
  _request.flags = std::move(flags);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::NodeSetFlags Filesystems::SyncClient::NodeSetFlags(uint32_t flags) {
    return ResultOf::NodeSetFlags(::zx::unowned_channel(this->channel_), std::move(flags));
}

Filesystems::ResultOf::NodeSetFlags Filesystems::Call::NodeSetFlags(::zx::unowned_channel _client_end, uint32_t flags) {
  return ResultOf::NodeSetFlags(std::move(_client_end), std::move(flags));
}

template <>
Filesystems::UnownedResultOf::NodeSetFlags_Impl<Filesystems::NodeSetFlagsResponse>::NodeSetFlags_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < NodeSetFlagsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<NodeSetFlagsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, NodeSetFlagsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<NodeSetFlagsRequest*>(_request_buffer.data());
  _request.flags = std::move(flags);
  _request_buffer.set_actual(sizeof(NodeSetFlagsRequest));
  ::fidl::DecodedMessage<NodeSetFlagsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::NodeSetFlags(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::NodeSetFlags Filesystems::SyncClient::NodeSetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::NodeSetFlags Filesystems::Call::NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NodeSetFlags(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::NodeSetFlagsResponse> Filesystems::InPlace::NodeSetFlags(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<NodeSetFlagsRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::NodeSetFlagsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::NodeSetFlagsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NodeSetFlagsRequest, NodeSetFlagsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::NodeSetFlagsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


Filesystems::ResultOf::Open_Impl::Open_Impl(::zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OpenRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Filesystems::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Filesystems::ResultOf::Open Filesystems::SyncClient::Open(uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
    return ResultOf::Open(::zx::unowned_channel(this->channel_), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

Filesystems::ResultOf::Open Filesystems::Call::Open(::zx::unowned_channel _client_end, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return ResultOf::Open(std::move(_client_end), std::move(flags), std::move(mode), std::move(path), std::move(object));
}


Filesystems::UnownedResultOf::Open_Impl::Open_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  if (_request_buffer.capacity() < OpenRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  OpenRequest _request = {};
  _request.flags = std::move(flags);
  _request.mode = std::move(mode);
  _request.path = std::move(path);
  _request.object = std::move(object);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<OpenRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      Filesystems::InPlace::Open(std::move(_client_end), std::move(_decoded_request)));
}

Filesystems::UnownedResultOf::Open Filesystems::SyncClient::Open(::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

Filesystems::UnownedResultOf::Open Filesystems::Call::Open(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, uint32_t mode, ::fidl::StringView path, ::zx::channel object) {
  return UnownedResultOf::Open(std::move(_client_end), std::move(_request_buffer), std::move(flags), std::move(mode), std::move(path), std::move(object));
}

::fidl::internal::StatusAndError Filesystems::InPlace::Open(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenRequest> params) {
  Filesystems::SetTransactionHeaderFor::OpenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
Filesystems::ResultOf::Unlink_Impl<Filesystems::UnlinkResponse>::Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::StringView path) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::Unlink Filesystems::SyncClient::Unlink(::fidl::StringView path) {
    return ResultOf::Unlink(::zx::unowned_channel(this->channel_), std::move(path));
}

Filesystems::ResultOf::Unlink Filesystems::Call::Unlink(::zx::unowned_channel _client_end, ::fidl::StringView path) {
  return ResultOf::Unlink(std::move(_client_end), std::move(path));
}

template <>
Filesystems::UnownedResultOf::Unlink_Impl<Filesystems::UnlinkResponse>::Unlink_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < UnlinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<UnlinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  UnlinkRequest _request = {};
  _request.path = std::move(path);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<UnlinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Unlink(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Unlink Filesystems::SyncClient::Unlink(::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Unlink Filesystems::Call::Unlink(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView path, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Unlink(std::move(_client_end), std::move(_request_buffer), std::move(path), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::UnlinkResponse> Filesystems::InPlace::Unlink(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<UnlinkRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::UnlinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::UnlinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<UnlinkRequest, UnlinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::UnlinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::ReadDirents_Impl<Filesystems::ReadDirentsResponse>::ReadDirents_Impl(::zx::unowned_channel _client_end, uint64_t max_bytes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_write_bytes);
  _request.max_bytes = std::move(max_bytes);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::ReadDirents Filesystems::SyncClient::ReadDirents(uint64_t max_bytes) {
    return ResultOf::ReadDirents(::zx::unowned_channel(this->channel_), std::move(max_bytes));
}

Filesystems::ResultOf::ReadDirents Filesystems::Call::ReadDirents(::zx::unowned_channel _client_end, uint64_t max_bytes) {
  return ResultOf::ReadDirents(std::move(_client_end), std::move(max_bytes));
}

template <>
Filesystems::UnownedResultOf::ReadDirents_Impl<Filesystems::ReadDirentsResponse>::ReadDirents_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < ReadDirentsRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<ReadDirentsResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, ReadDirentsRequest::PrimarySize);
  auto& _request = *reinterpret_cast<ReadDirentsRequest*>(_request_buffer.data());
  _request.max_bytes = std::move(max_bytes);
  _request_buffer.set_actual(sizeof(ReadDirentsRequest));
  ::fidl::DecodedMessage<ReadDirentsRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::ReadDirents(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::ReadDirents Filesystems::SyncClient::ReadDirents(::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::ReadDirents Filesystems::Call::ReadDirents(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t max_bytes, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ReadDirents(std::move(_client_end), std::move(_request_buffer), std::move(max_bytes), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::ReadDirentsResponse> Filesystems::InPlace::ReadDirents(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadDirentsRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::ReadDirentsRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::ReadDirentsResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ReadDirentsRequest, ReadDirentsResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::ReadDirentsResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Rewind_Impl<Filesystems::RewindResponse>::Rewind_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RewindRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::Rewind(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::Rewind Filesystems::SyncClient::Rewind() {
    return ResultOf::Rewind(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::Rewind Filesystems::Call::Rewind(::zx::unowned_channel _client_end) {
  return ResultOf::Rewind(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::Rewind_Impl<Filesystems::RewindResponse>::Rewind_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(RewindRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, RewindRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(RewindRequest));
  ::fidl::DecodedMessage<RewindRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::Rewind(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Rewind Filesystems::SyncClient::Rewind(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Rewind Filesystems::Call::Rewind(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rewind(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::RewindResponse> Filesystems::InPlace::Rewind(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(RewindRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<RewindRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::RewindRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::RewindResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RewindRequest, RewindResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::RewindResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::GetToken_Impl<Filesystems::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetTokenRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::GetToken(std::move(_client_end), Super::response_buffer()));
}

Filesystems::ResultOf::GetToken Filesystems::SyncClient::GetToken() {
    return ResultOf::GetToken(::zx::unowned_channel(this->channel_));
}

Filesystems::ResultOf::GetToken Filesystems::Call::GetToken(::zx::unowned_channel _client_end) {
  return ResultOf::GetToken(std::move(_client_end));
}

template <>
Filesystems::UnownedResultOf::GetToken_Impl<Filesystems::GetTokenResponse>::GetToken_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetTokenRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetTokenRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetTokenRequest));
  ::fidl::DecodedMessage<GetTokenRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::GetToken(std::move(_client_end), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::GetToken Filesystems::SyncClient::GetToken(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::GetToken Filesystems::Call::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetToken(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::GetTokenResponse> Filesystems::InPlace::GetToken(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetTokenRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetTokenRequest> params(std::move(_request_buffer));
  Filesystems::SetTransactionHeaderFor::GetTokenRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::GetTokenResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetTokenRequest, GetTokenResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::GetTokenResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Rename_Impl<Filesystems::RenameResponse>::Rename_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::Rename Filesystems::SyncClient::Rename(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
    return ResultOf::Rename(::zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Filesystems::ResultOf::Rename Filesystems::Call::Rename(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Rename(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Filesystems::UnownedResultOf::Rename_Impl<Filesystems::RenameResponse>::Rename_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RenameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RenameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  RenameRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<RenameRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Rename(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Rename Filesystems::SyncClient::Rename(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Rename Filesystems::Call::Rename(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Rename(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::RenameResponse> Filesystems::InPlace::Rename(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RenameRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::RenameRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::RenameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RenameRequest, RenameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::RenameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Link_Impl<Filesystems::LinkResponse>::Link_Impl(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Link(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::Link Filesystems::SyncClient::Link(::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
    return ResultOf::Link(::zx::unowned_channel(this->channel_), std::move(src), std::move(dst_parent_token), std::move(dst));
}

Filesystems::ResultOf::Link Filesystems::Call::Link(::zx::unowned_channel _client_end, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst) {
  return ResultOf::Link(std::move(_client_end), std::move(src), std::move(dst_parent_token), std::move(dst));
}

template <>
Filesystems::UnownedResultOf::Link_Impl<Filesystems::LinkResponse>::Link_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < LinkRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<LinkResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  LinkRequest _request = {};
  _request.src = std::move(src);
  _request.dst_parent_token = std::move(dst_parent_token);
  _request.dst = std::move(dst);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<LinkRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      Filesystems::InPlace::Link(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Link Filesystems::SyncClient::Link(::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Link Filesystems::Call::Link(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView src, ::zx::handle dst_parent_token, ::fidl::StringView dst, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Link(std::move(_client_end), std::move(_request_buffer), std::move(src), std::move(dst_parent_token), std::move(dst), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::LinkResponse> Filesystems::InPlace::Link(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<LinkRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::LinkRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::LinkResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<LinkRequest, LinkResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::LinkResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Filesystems::ResultOf::Watch_Impl<Filesystems::WatchResponse>::Watch_Impl(::zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_write_bytes);
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Filesystems::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Filesystems::ResultOf::Watch Filesystems::SyncClient::Watch(uint32_t mask, uint32_t options, ::zx::channel watcher) {
    return ResultOf::Watch(::zx::unowned_channel(this->channel_), std::move(mask), std::move(options), std::move(watcher));
}

Filesystems::ResultOf::Watch Filesystems::Call::Watch(::zx::unowned_channel _client_end, uint32_t mask, uint32_t options, ::zx::channel watcher) {
  return ResultOf::Watch(std::move(_client_end), std::move(mask), std::move(options), std::move(watcher));
}

template <>
Filesystems::UnownedResultOf::Watch_Impl<Filesystems::WatchResponse>::Watch_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WatchRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WatchResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, WatchRequest::PrimarySize);
  auto& _request = *reinterpret_cast<WatchRequest*>(_request_buffer.data());
  _request.mask = std::move(mask);
  _request.options = std::move(options);
  _request.watcher = std::move(watcher);
  _request_buffer.set_actual(sizeof(WatchRequest));
  ::fidl::DecodedMessage<WatchRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Filesystems::InPlace::Watch(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Filesystems::UnownedResultOf::Watch Filesystems::SyncClient::Watch(::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

Filesystems::UnownedResultOf::Watch Filesystems::Call::Watch(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t mask, uint32_t options, ::zx::channel watcher, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Watch(std::move(_client_end), std::move(_request_buffer), std::move(mask), std::move(options), std::move(watcher), std::move(_response_buffer));
}

::fidl::DecodeResult<Filesystems::WatchResponse> Filesystems::InPlace::Watch(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WatchRequest> params, ::fidl::BytePart response_buffer) {
  Filesystems::SetTransactionHeaderFor::WatchRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::WatchResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WatchRequest, WatchResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Filesystems::WatchResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t Filesystems::SyncClient::HandleEvents(Filesystems::EventHandlers handlers) {
  return Filesystems::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t Filesystems::Call::HandleEvents(::zx::unowned_channel client_end, Filesystems::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnOpenResponse::MaxNumHandles >= x) {
      x = OnOpenResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kFilesystems_OnOpen_Ordinal:
    case kFilesystems_OnOpen_GenOrdinal:
    {
      constexpr uint32_t kTransformerDestSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kReceiving>();
      ::fidl::internal::ByteStorage<kTransformerDestSize> transformer_dest_storage(::fidl::internal::DelayAllocation);
      auto result = ::fidl::DecodeAs<OnOpenResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_open(std::move(message->s), std::move(message->info));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Filesystems::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kFilesystems_Clone_Ordinal:
    case kFilesystems_Clone_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloneRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Clone(std::move(message->flags), std::move(message->object),
          Interface::CloneCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Close_Ordinal:
    case kFilesystems_Close_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<CloseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Close(
          Interface::CloseCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Describe_Ordinal:
    case kFilesystems_Describe_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<DescribeRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Describe(
          Interface::DescribeCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Sync_Ordinal:
    case kFilesystems_Sync_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SyncRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Sync(
          Interface::SyncCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_GetAttr_Ordinal:
    case kFilesystems_GetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetAttr(
          Interface::GetAttrCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_SetAttr_Ordinal:
    case kFilesystems_SetAttr_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetAttrRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetAttr(std::move(message->flags), std::move(message->attributes),
          Interface::SetAttrCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_NodeGetFlags_Ordinal:
    case kFilesystems_NodeGetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeGetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NodeGetFlags(
          Interface::NodeGetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_NodeSetFlags_Ordinal:
    case kFilesystems_NodeSetFlags_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NodeSetFlagsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->NodeSetFlags(std::move(message->flags),
          Interface::NodeSetFlagsCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Open_Ordinal:
    case kFilesystems_Open_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OpenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Open(std::move(message->flags), std::move(message->mode), std::move(message->path), std::move(message->object),
          Interface::OpenCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Unlink_Ordinal:
    case kFilesystems_Unlink_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<UnlinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Unlink(std::move(message->path),
          Interface::UnlinkCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_ReadDirents_Ordinal:
    case kFilesystems_ReadDirents_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ReadDirentsRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->ReadDirents(std::move(message->max_bytes),
          Interface::ReadDirentsCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Rewind_Ordinal:
    case kFilesystems_Rewind_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RewindRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Rewind(
          Interface::RewindCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_GetToken_Ordinal:
    case kFilesystems_GetToken_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetTokenRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetToken(
          Interface::GetTokenCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Rename_Ordinal:
    case kFilesystems_Rename_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RenameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Rename(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::RenameCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Link_Ordinal:
    case kFilesystems_Link_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<LinkRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Link(std::move(message->src), std::move(message->dst_parent_token), std::move(message->dst),
          Interface::LinkCompleter::Sync(txn));
      return true;
    }
    case kFilesystems_Watch_Ordinal:
    case kFilesystems_Watch_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WatchRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->Watch(std::move(message->mask), std::move(message->options), std::move(message->watcher),
          Interface::WatchCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Filesystems::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Filesystems::Interface::CloseCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<CloseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<CloseResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::CloseCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < CloseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<CloseResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::CloseResponse(
      ::fidl::DecodedMessage<CloseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              CloseResponse::PrimarySize,
              CloseResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(CloseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<CloseResponse>(std::move(_buffer)));
}

void Filesystems::Interface::CloseCompleterBase::Reply(::fidl::DecodedMessage<CloseResponse> params) {
  Filesystems::SetTransactionHeaderFor::CloseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::DescribeCompleterBase::Reply(::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<DescribeResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  DescribeResponse _response = {};
  Filesystems::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Filesystems::Interface::DescribeCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < DescribeResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  DescribeResponse _response = {};
  Filesystems::SetTransactionHeaderFor::DescribeResponse(
      ::fidl::DecodedMessage<DescribeResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              DescribeResponse::PrimarySize,
              DescribeResponse::PrimarySize)));
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Filesystems::Interface::DescribeCompleterBase::Reply(::fidl::DecodedMessage<DescribeResponse> params) {
  Filesystems::SetTransactionHeaderFor::DescribeResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t Filesystems::SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo info) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnOpenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  OnOpenResponse _response = {};
  Filesystems::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Filesystems::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo info) {
  if (_buffer.capacity() < OnOpenResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnOpenResponse _response = {};
  Filesystems::SetTransactionHeaderFor::OnOpenResponse(
      ::fidl::DecodedMessage<OnOpenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnOpenResponse::PrimarySize,
              OnOpenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.info = std::move(info);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t Filesystems::SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params) {
  Filesystems::SetTransactionHeaderFor::OnOpenResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void Filesystems::Interface::SyncCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SyncResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SyncResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::SyncCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SyncResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SyncResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::SyncResponse(
      ::fidl::DecodedMessage<SyncResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SyncResponse::PrimarySize,
              SyncResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SyncResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SyncResponse>(std::move(_buffer)));
}

void Filesystems::Interface::SyncCompleterBase::Reply(::fidl::DecodedMessage<SyncResponse> params) {
  Filesystems::SetTransactionHeaderFor::SyncResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::GetAttrCompleterBase::Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::GetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes) {
  if (_buffer.capacity() < GetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetAttrResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::GetAttrResponse(
      ::fidl::DecodedMessage<GetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetAttrResponse::PrimarySize,
              GetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.attributes = std::move(attributes);
  _buffer.set_actual(sizeof(GetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetAttrResponse>(std::move(_buffer)));
}

void Filesystems::Interface::GetAttrCompleterBase::Reply(::fidl::DecodedMessage<GetAttrResponse> params) {
  Filesystems::SetTransactionHeaderFor::GetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::SetAttrCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetAttrResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::SetAttrCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < SetAttrResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetAttrResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::SetAttrResponse(
      ::fidl::DecodedMessage<SetAttrResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              SetAttrResponse::PrimarySize,
              SetAttrResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(SetAttrResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetAttrResponse>(std::move(_buffer)));
}

void Filesystems::Interface::SetAttrCompleterBase::Reply(::fidl::DecodedMessage<SetAttrResponse> params) {
  Filesystems::SetTransactionHeaderFor::SetAttrResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::NodeGetFlagsCompleterBase::Reply(int32_t s, uint32_t flags) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeGetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags) {
  if (_buffer.capacity() < NodeGetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeGetFlagsResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::NodeGetFlagsResponse(
      ::fidl::DecodedMessage<NodeGetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeGetFlagsResponse::PrimarySize,
              NodeGetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.flags = std::move(flags);
  _buffer.set_actual(sizeof(NodeGetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeGetFlagsResponse>(std::move(_buffer)));
}

void Filesystems::Interface::NodeGetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeGetFlagsResponse> params) {
  Filesystems::SetTransactionHeaderFor::NodeGetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::NodeSetFlagsCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NodeSetFlagsResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < NodeSetFlagsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<NodeSetFlagsResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::NodeSetFlagsResponse(
      ::fidl::DecodedMessage<NodeSetFlagsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NodeSetFlagsResponse::PrimarySize,
              NodeSetFlagsResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(NodeSetFlagsResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NodeSetFlagsResponse>(std::move(_buffer)));
}

void Filesystems::Interface::NodeSetFlagsCompleterBase::Reply(::fidl::DecodedMessage<NodeSetFlagsResponse> params) {
  Filesystems::SetTransactionHeaderFor::NodeSetFlagsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::UnlinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<UnlinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::UnlinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < UnlinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<UnlinkResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::UnlinkResponse(
      ::fidl::DecodedMessage<UnlinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              UnlinkResponse::PrimarySize,
              UnlinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(UnlinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<UnlinkResponse>(std::move(_buffer)));
}

void Filesystems::Interface::UnlinkCompleterBase::Reply(::fidl::DecodedMessage<UnlinkResponse> params) {
  Filesystems::SetTransactionHeaderFor::UnlinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::ReadDirentsCompleterBase::Reply(int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ReadDirentsResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  ReadDirentsResponse _response = {};
  Filesystems::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Filesystems::Interface::ReadDirentsCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> dirents) {
  if (_buffer.capacity() < ReadDirentsResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  ReadDirentsResponse _response = {};
  Filesystems::SetTransactionHeaderFor::ReadDirentsResponse(
      ::fidl::DecodedMessage<ReadDirentsResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ReadDirentsResponse::PrimarySize,
              ReadDirentsResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.dirents = std::move(dirents);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Filesystems::Interface::ReadDirentsCompleterBase::Reply(::fidl::DecodedMessage<ReadDirentsResponse> params) {
  Filesystems::SetTransactionHeaderFor::ReadDirentsResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::RewindCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RewindResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RewindResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::RewindCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RewindResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RewindResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::RewindResponse(
      ::fidl::DecodedMessage<RewindResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RewindResponse::PrimarySize,
              RewindResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RewindResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RewindResponse>(std::move(_buffer)));
}

void Filesystems::Interface::RewindCompleterBase::Reply(::fidl::DecodedMessage<RewindResponse> params) {
  Filesystems::SetTransactionHeaderFor::RewindResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::GetTokenCompleterBase::Reply(int32_t s, ::zx::handle token) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetTokenResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::GetTokenCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s, ::zx::handle token) {
  if (_buffer.capacity() < GetTokenResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetTokenResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::GetTokenResponse(
      ::fidl::DecodedMessage<GetTokenResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              GetTokenResponse::PrimarySize,
              GetTokenResponse::PrimarySize)));
  _response.s = std::move(s);
  _response.token = std::move(token);
  _buffer.set_actual(sizeof(GetTokenResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetTokenResponse>(std::move(_buffer)));
}

void Filesystems::Interface::GetTokenCompleterBase::Reply(::fidl::DecodedMessage<GetTokenResponse> params) {
  Filesystems::SetTransactionHeaderFor::GetTokenResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::RenameCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RenameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RenameResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::RenameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RenameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RenameResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::RenameResponse(
      ::fidl::DecodedMessage<RenameResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RenameResponse::PrimarySize,
              RenameResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RenameResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RenameResponse>(std::move(_buffer)));
}

void Filesystems::Interface::RenameCompleterBase::Reply(::fidl::DecodedMessage<RenameResponse> params) {
  Filesystems::SetTransactionHeaderFor::RenameResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::LinkCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<LinkResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<LinkResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::LinkCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < LinkResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<LinkResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::LinkResponse(
      ::fidl::DecodedMessage<LinkResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              LinkResponse::PrimarySize,
              LinkResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(LinkResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<LinkResponse>(std::move(_buffer)));
}

void Filesystems::Interface::LinkCompleterBase::Reply(::fidl::DecodedMessage<LinkResponse> params) {
  Filesystems::SetTransactionHeaderFor::LinkResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void Filesystems::Interface::WatchCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WatchResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WatchResponse*>(_write_bytes);
  Filesystems::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_response_bytes)));
}

void Filesystems::Interface::WatchCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < WatchResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<WatchResponse*>(_buffer.data());
  Filesystems::SetTransactionHeaderFor::WatchResponse(
      ::fidl::DecodedMessage<WatchResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WatchResponse::PrimarySize,
              WatchResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(WatchResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WatchResponse>(std::move(_buffer)));
}

void Filesystems::Interface::WatchCompleterBase::Reply(::fidl::DecodedMessage<WatchResponse> params) {
  Filesystems::SetTransactionHeaderFor::WatchResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Filesystems::SetTransactionHeaderFor::CloneRequest(const ::fidl::DecodedMessage<Filesystems::CloneRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Clone_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::CloseRequest(const ::fidl::DecodedMessage<Filesystems::CloseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::CloseResponse(const ::fidl::DecodedMessage<Filesystems::CloseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Close_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::DescribeRequest(const ::fidl::DecodedMessage<Filesystems::DescribeRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::DescribeResponse(const ::fidl::DecodedMessage<Filesystems::DescribeResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Describe_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::OnOpenResponse(const ::fidl::DecodedMessage<Filesystems::OnOpenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_OnOpen_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::SyncRequest(const ::fidl::DecodedMessage<Filesystems::SyncRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::SyncResponse(const ::fidl::DecodedMessage<Filesystems::SyncResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Sync_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::GetAttrRequest(const ::fidl::DecodedMessage<Filesystems::GetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_GetAttr_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::GetAttrResponse(const ::fidl::DecodedMessage<Filesystems::GetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_GetAttr_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::SetAttrRequest(const ::fidl::DecodedMessage<Filesystems::SetAttrRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_SetAttr_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::SetAttrResponse(const ::fidl::DecodedMessage<Filesystems::SetAttrResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_SetAttr_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::NodeGetFlagsRequest(const ::fidl::DecodedMessage<Filesystems::NodeGetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_NodeGetFlags_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::NodeGetFlagsResponse(const ::fidl::DecodedMessage<Filesystems::NodeGetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_NodeGetFlags_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::NodeSetFlagsRequest(const ::fidl::DecodedMessage<Filesystems::NodeSetFlagsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_NodeSetFlags_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::NodeSetFlagsResponse(const ::fidl::DecodedMessage<Filesystems::NodeSetFlagsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_NodeSetFlags_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::OpenRequest(const ::fidl::DecodedMessage<Filesystems::OpenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Open_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::UnlinkRequest(const ::fidl::DecodedMessage<Filesystems::UnlinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Unlink_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::UnlinkResponse(const ::fidl::DecodedMessage<Filesystems::UnlinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Unlink_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::ReadDirentsRequest(const ::fidl::DecodedMessage<Filesystems::ReadDirentsRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_ReadDirents_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::ReadDirentsResponse(const ::fidl::DecodedMessage<Filesystems::ReadDirentsResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_ReadDirents_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::RewindRequest(const ::fidl::DecodedMessage<Filesystems::RewindRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Rewind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::RewindResponse(const ::fidl::DecodedMessage<Filesystems::RewindResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Rewind_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::GetTokenRequest(const ::fidl::DecodedMessage<Filesystems::GetTokenRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::GetTokenResponse(const ::fidl::DecodedMessage<Filesystems::GetTokenResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_GetToken_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::RenameRequest(const ::fidl::DecodedMessage<Filesystems::RenameRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Rename_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::RenameResponse(const ::fidl::DecodedMessage<Filesystems::RenameResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Rename_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::LinkRequest(const ::fidl::DecodedMessage<Filesystems::LinkRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Link_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::LinkResponse(const ::fidl::DecodedMessage<Filesystems::LinkResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Link_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

void Filesystems::SetTransactionHeaderFor::WatchRequest(const ::fidl::DecodedMessage<Filesystems::WatchRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Watch_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Filesystems::SetTransactionHeaderFor::WatchResponse(const ::fidl::DecodedMessage<Filesystems::WatchResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kFilesystems_Watch_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kAdmin_Shutdown_Ordinal = 0x2e0baed000000000lu;
[[maybe_unused]]
constexpr uint64_t kAdmin_Shutdown_GenOrdinal = 0x7b8ebed9dd90dfbdlu;
extern "C" const fidl_type_t fuchsia_fshost_AdminShutdownRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_AdminShutdownResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_AdminShutdownResponseTable;

}  // namespace
template <>
Admin::ResultOf::Shutdown_Impl<Admin::ShutdownResponse>::Shutdown_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ShutdownRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ShutdownRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ShutdownRequest));
  ::fidl::DecodedMessage<ShutdownRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Admin::InPlace::Shutdown(std::move(_client_end), Super::response_buffer()));
}

Admin::ResultOf::Shutdown Admin::SyncClient::Shutdown() {
    return ResultOf::Shutdown(::zx::unowned_channel(this->channel_));
}

Admin::ResultOf::Shutdown Admin::Call::Shutdown(::zx::unowned_channel _client_end) {
  return ResultOf::Shutdown(std::move(_client_end));
}

::fidl::DecodeResult<Admin::ShutdownResponse> Admin::InPlace::Shutdown(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ShutdownRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ShutdownRequest> params(std::move(_request_buffer));
  Admin::SetTransactionHeaderFor::ShutdownRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Admin::ShutdownResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ShutdownRequest, ShutdownResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Admin::ShutdownResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Admin::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kAdmin_Shutdown_Ordinal:
    case kAdmin_Shutdown_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ShutdownRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->Shutdown(
          Interface::ShutdownCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Admin::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Admin::Interface::ShutdownCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ShutdownResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ShutdownResponse*>(_write_bytes);
  Admin::SetTransactionHeaderFor::ShutdownResponse(
      ::fidl::DecodedMessage<ShutdownResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ShutdownResponse::PrimarySize,
              ShutdownResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ShutdownResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ShutdownResponse>(std::move(_response_bytes)));
}



void Admin::SetTransactionHeaderFor::ShutdownRequest(const ::fidl::DecodedMessage<Admin::ShutdownRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kAdmin_Shutdown_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Admin::SetTransactionHeaderFor::ShutdownResponse(const ::fidl::DecodedMessage<Admin::ShutdownResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kAdmin_Shutdown_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

namespace {

[[maybe_unused]]
constexpr uint64_t kRegistry_RegisterFilesystem_Ordinal = 0x459f2e5100000000lu;
[[maybe_unused]]
constexpr uint64_t kRegistry_RegisterFilesystem_GenOrdinal = 0x3dcc95b02284c9a2lu;
extern "C" const fidl_type_t fuchsia_fshost_RegistryRegisterFilesystemRequestTable;
extern "C" const fidl_type_t fuchsia_fshost_RegistryRegisterFilesystemResponseTable;
extern "C" const fidl_type_t v1_fuchsia_fshost_RegistryRegisterFilesystemResponseTable;

}  // namespace
template <>
Registry::ResultOf::RegisterFilesystem_Impl<Registry::RegisterFilesystemResponse>::RegisterFilesystem_Impl(::zx::unowned_channel _client_end, ::zx::channel public_export) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RegisterFilesystemRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, RegisterFilesystemRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RegisterFilesystemRequest*>(_write_bytes);
  _request.public_export = std::move(public_export);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(RegisterFilesystemRequest));
  ::fidl::DecodedMessage<RegisterFilesystemRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Registry::InPlace::RegisterFilesystem(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Registry::ResultOf::RegisterFilesystem Registry::SyncClient::RegisterFilesystem(::zx::channel public_export) {
    return ResultOf::RegisterFilesystem(::zx::unowned_channel(this->channel_), std::move(public_export));
}

Registry::ResultOf::RegisterFilesystem Registry::Call::RegisterFilesystem(::zx::unowned_channel _client_end, ::zx::channel public_export) {
  return ResultOf::RegisterFilesystem(std::move(_client_end), std::move(public_export));
}

template <>
Registry::UnownedResultOf::RegisterFilesystem_Impl<Registry::RegisterFilesystemResponse>::RegisterFilesystem_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RegisterFilesystemRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RegisterFilesystemResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, RegisterFilesystemRequest::PrimarySize);
  auto& _request = *reinterpret_cast<RegisterFilesystemRequest*>(_request_buffer.data());
  _request.public_export = std::move(public_export);
  _request_buffer.set_actual(sizeof(RegisterFilesystemRequest));
  ::fidl::DecodedMessage<RegisterFilesystemRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Registry::InPlace::RegisterFilesystem(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Registry::UnownedResultOf::RegisterFilesystem Registry::SyncClient::RegisterFilesystem(::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RegisterFilesystem(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(public_export), std::move(_response_buffer));
}

Registry::UnownedResultOf::RegisterFilesystem Registry::Call::RegisterFilesystem(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::channel public_export, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::RegisterFilesystem(std::move(_client_end), std::move(_request_buffer), std::move(public_export), std::move(_response_buffer));
}

::fidl::DecodeResult<Registry::RegisterFilesystemResponse> Registry::InPlace::RegisterFilesystem(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<RegisterFilesystemRequest> params, ::fidl::BytePart response_buffer) {
  Registry::SetTransactionHeaderFor::RegisterFilesystemRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Registry::RegisterFilesystemResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<RegisterFilesystemRequest, RegisterFilesystemResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Registry::RegisterFilesystemResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Registry::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kRegistry_RegisterFilesystem_Ordinal:
    case kRegistry_RegisterFilesystem_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<RegisterFilesystemRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->RegisterFilesystem(std::move(message->public_export),
          Interface::RegisterFilesystemCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Registry::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Registry::Interface::RegisterFilesystemCompleterBase::Reply(int32_t s) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<RegisterFilesystemResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<RegisterFilesystemResponse*>(_write_bytes);
  Registry::SetTransactionHeaderFor::RegisterFilesystemResponse(
      ::fidl::DecodedMessage<RegisterFilesystemResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RegisterFilesystemResponse::PrimarySize,
              RegisterFilesystemResponse::PrimarySize)));
  _response.s = std::move(s);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(RegisterFilesystemResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RegisterFilesystemResponse>(std::move(_response_bytes)));
}

void Registry::Interface::RegisterFilesystemCompleterBase::Reply(::fidl::BytePart _buffer, int32_t s) {
  if (_buffer.capacity() < RegisterFilesystemResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<RegisterFilesystemResponse*>(_buffer.data());
  Registry::SetTransactionHeaderFor::RegisterFilesystemResponse(
      ::fidl::DecodedMessage<RegisterFilesystemResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              RegisterFilesystemResponse::PrimarySize,
              RegisterFilesystemResponse::PrimarySize)));
  _response.s = std::move(s);
  _buffer.set_actual(sizeof(RegisterFilesystemResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<RegisterFilesystemResponse>(std::move(_buffer)));
}

void Registry::Interface::RegisterFilesystemCompleterBase::Reply(::fidl::DecodedMessage<RegisterFilesystemResponse> params) {
  Registry::SetTransactionHeaderFor::RegisterFilesystemResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void Registry::SetTransactionHeaderFor::RegisterFilesystemRequest(const ::fidl::DecodedMessage<Registry::RegisterFilesystemRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kRegistry_RegisterFilesystem_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}
void Registry::SetTransactionHeaderFor::RegisterFilesystemResponse(const ::fidl::DecodedMessage<Registry::RegisterFilesystemResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kRegistry_RegisterFilesystem_GenOrdinal);
  _msg.message()->_hdr.flags[0] |= FIDL_TXN_HEADER_UNION_FROM_XUNION_FLAG;
}

}  // namespace fshost
}  // namespace fuchsia
}  // namespace llcpp

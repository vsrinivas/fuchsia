// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace usb {
namespace device {

class Device;

extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceSpeedRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceSpeedResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceDescriptorRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceDescriptorResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorSizeRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorSizeResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetStringDescriptorRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetStringDescriptorResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceSetInterfaceRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceSetInterfaceResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetDeviceIdResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetHubDeviceIdRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetHubDeviceIdResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceGetConfigurationResponseTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceSetConfigurationRequestTable;
extern "C" const fidl_type_t v1_fuchsia_hardware_usb_device_DeviceSetConfigurationResponseTable;

class Device final {
  Device() = delete;
 public:

  struct GetDeviceSpeedResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t speed;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetDeviceSpeedResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetDeviceSpeedRequest = ::fidl::AnyZeroArgMessage;

  struct GetDeviceDescriptorResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::Array<uint8_t, 18> desc;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetDeviceDescriptorResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetDeviceDescriptorRequest = ::fidl::AnyZeroArgMessage;

  struct GetConfigurationDescriptorSizeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint16_t size;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorSizeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetConfigurationDescriptorSizeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t config;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorSizeRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetConfigurationDescriptorSizeResponse;
  };

  struct GetConfigurationDescriptorResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> desc;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 65536;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetConfigurationDescriptorRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t config;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetConfigurationDescriptorRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetConfigurationDescriptorResponse;
  };

  struct GetStringDescriptorResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::StringView desc;
    uint16_t actual_lang_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetStringDescriptorResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 384;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetStringDescriptorRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t desc_id;
    uint16_t lang_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetStringDescriptorRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetStringDescriptorResponse;
  };

  struct SetInterfaceResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceSetInterfaceResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetInterfaceRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t interface_number;
    uint8_t alt_setting;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceSetInterfaceRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetInterfaceResponse;
  };

  struct GetDeviceIdResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t device_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetDeviceIdResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetDeviceIdRequest = ::fidl::AnyZeroArgMessage;

  struct GetHubDeviceIdResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t hub_device_id;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetHubDeviceIdResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetHubDeviceIdRequest = ::fidl::AnyZeroArgMessage;

  struct GetConfigurationResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t configuration;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceGetConfigurationResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetConfigurationRequest = ::fidl::AnyZeroArgMessage;

  struct SetConfigurationResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceSetConfigurationResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetConfigurationRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint8_t configuration;

    static constexpr const fidl_type_t* Type = &v1_fuchsia_hardware_usb_device_DeviceSetConfigurationRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr uint32_t AltPrimarySize = 24;
    static constexpr uint32_t AltMaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr bool ContainsUnion = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetConfigurationResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetDeviceSpeed_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDeviceSpeed_Impl(::zx::unowned_channel _client_end);
      ~GetDeviceSpeed_Impl() = default;
      GetDeviceSpeed_Impl(GetDeviceSpeed_Impl&& other) = default;
      GetDeviceSpeed_Impl& operator=(GetDeviceSpeed_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceDescriptor_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDeviceDescriptor_Impl(::zx::unowned_channel _client_end);
      ~GetDeviceDescriptor_Impl() = default;
      GetDeviceDescriptor_Impl(GetDeviceDescriptor_Impl&& other) = default;
      GetDeviceDescriptor_Impl& operator=(GetDeviceDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfigurationDescriptorSize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetConfigurationDescriptorSize_Impl(::zx::unowned_channel _client_end, uint8_t config);
      ~GetConfigurationDescriptorSize_Impl() = default;
      GetConfigurationDescriptorSize_Impl(GetConfigurationDescriptorSize_Impl&& other) = default;
      GetConfigurationDescriptorSize_Impl& operator=(GetConfigurationDescriptorSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfigurationDescriptor_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetConfigurationDescriptor_Impl(::zx::unowned_channel _client_end, uint8_t config);
      ~GetConfigurationDescriptor_Impl() = default;
      GetConfigurationDescriptor_Impl(GetConfigurationDescriptor_Impl&& other) = default;
      GetConfigurationDescriptor_Impl& operator=(GetConfigurationDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStringDescriptor_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetStringDescriptor_Impl(::zx::unowned_channel _client_end, uint8_t desc_id, uint16_t lang_id);
      ~GetStringDescriptor_Impl() = default;
      GetStringDescriptor_Impl(GetStringDescriptor_Impl&& other) = default;
      GetStringDescriptor_Impl& operator=(GetStringDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetInterface_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetInterface_Impl(::zx::unowned_channel _client_end, uint8_t interface_number, uint8_t alt_setting);
      ~SetInterface_Impl() = default;
      SetInterface_Impl(SetInterface_Impl&& other) = default;
      SetInterface_Impl& operator=(SetInterface_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceId_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetDeviceId_Impl(::zx::unowned_channel _client_end);
      ~GetDeviceId_Impl() = default;
      GetDeviceId_Impl(GetDeviceId_Impl&& other) = default;
      GetDeviceId_Impl& operator=(GetDeviceId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetHubDeviceId_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetHubDeviceId_Impl(::zx::unowned_channel _client_end);
      ~GetHubDeviceId_Impl() = default;
      GetHubDeviceId_Impl(GetHubDeviceId_Impl&& other) = default;
      GetHubDeviceId_Impl& operator=(GetHubDeviceId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfiguration_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetConfiguration_Impl(::zx::unowned_channel _client_end);
      ~GetConfiguration_Impl() = default;
      GetConfiguration_Impl(GetConfiguration_Impl&& other) = default;
      GetConfiguration_Impl& operator=(GetConfiguration_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetConfiguration_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetConfiguration_Impl(::zx::unowned_channel _client_end, uint8_t configuration);
      ~SetConfiguration_Impl() = default;
      SetConfiguration_Impl(SetConfiguration_Impl&& other) = default;
      SetConfiguration_Impl& operator=(SetConfiguration_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetDeviceSpeed = GetDeviceSpeed_Impl<GetDeviceSpeedResponse>;
    using GetDeviceDescriptor = GetDeviceDescriptor_Impl<GetDeviceDescriptorResponse>;
    using GetConfigurationDescriptorSize = GetConfigurationDescriptorSize_Impl<GetConfigurationDescriptorSizeResponse>;
    using GetConfigurationDescriptor = GetConfigurationDescriptor_Impl<GetConfigurationDescriptorResponse>;
    using GetStringDescriptor = GetStringDescriptor_Impl<GetStringDescriptorResponse>;
    using SetInterface = SetInterface_Impl<SetInterfaceResponse>;
    using GetDeviceId = GetDeviceId_Impl<GetDeviceIdResponse>;
    using GetHubDeviceId = GetHubDeviceId_Impl<GetHubDeviceIdResponse>;
    using GetConfiguration = GetConfiguration_Impl<GetConfigurationResponse>;
    using SetConfiguration = SetConfiguration_Impl<SetConfigurationResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetDeviceSpeed_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDeviceSpeed_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetDeviceSpeed_Impl() = default;
      GetDeviceSpeed_Impl(GetDeviceSpeed_Impl&& other) = default;
      GetDeviceSpeed_Impl& operator=(GetDeviceSpeed_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceDescriptor_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDeviceDescriptor_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetDeviceDescriptor_Impl() = default;
      GetDeviceDescriptor_Impl(GetDeviceDescriptor_Impl&& other) = default;
      GetDeviceDescriptor_Impl& operator=(GetDeviceDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfigurationDescriptorSize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetConfigurationDescriptorSize_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);
      ~GetConfigurationDescriptorSize_Impl() = default;
      GetConfigurationDescriptorSize_Impl(GetConfigurationDescriptorSize_Impl&& other) = default;
      GetConfigurationDescriptorSize_Impl& operator=(GetConfigurationDescriptorSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfigurationDescriptor_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetConfigurationDescriptor_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);
      ~GetConfigurationDescriptor_Impl() = default;
      GetConfigurationDescriptor_Impl(GetConfigurationDescriptor_Impl&& other) = default;
      GetConfigurationDescriptor_Impl& operator=(GetConfigurationDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetStringDescriptor_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetStringDescriptor_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t desc_id, uint16_t lang_id, ::fidl::BytePart _response_buffer);
      ~GetStringDescriptor_Impl() = default;
      GetStringDescriptor_Impl(GetStringDescriptor_Impl&& other) = default;
      GetStringDescriptor_Impl& operator=(GetStringDescriptor_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetInterface_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetInterface_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t interface_number, uint8_t alt_setting, ::fidl::BytePart _response_buffer);
      ~SetInterface_Impl() = default;
      SetInterface_Impl(SetInterface_Impl&& other) = default;
      SetInterface_Impl& operator=(SetInterface_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetDeviceId_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetDeviceId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetDeviceId_Impl() = default;
      GetDeviceId_Impl(GetDeviceId_Impl&& other) = default;
      GetDeviceId_Impl& operator=(GetDeviceId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetHubDeviceId_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetHubDeviceId_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetHubDeviceId_Impl() = default;
      GetHubDeviceId_Impl(GetHubDeviceId_Impl&& other) = default;
      GetHubDeviceId_Impl& operator=(GetHubDeviceId_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetConfiguration_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetConfiguration_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetConfiguration_Impl() = default;
      GetConfiguration_Impl(GetConfiguration_Impl&& other) = default;
      GetConfiguration_Impl& operator=(GetConfiguration_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetConfiguration_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetConfiguration_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t configuration, ::fidl::BytePart _response_buffer);
      ~SetConfiguration_Impl() = default;
      SetConfiguration_Impl(SetConfiguration_Impl&& other) = default;
      SetConfiguration_Impl& operator=(SetConfiguration_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetDeviceSpeed = GetDeviceSpeed_Impl<GetDeviceSpeedResponse>;
    using GetDeviceDescriptor = GetDeviceDescriptor_Impl<GetDeviceDescriptorResponse>;
    using GetConfigurationDescriptorSize = GetConfigurationDescriptorSize_Impl<GetConfigurationDescriptorSizeResponse>;
    using GetConfigurationDescriptor = GetConfigurationDescriptor_Impl<GetConfigurationDescriptorResponse>;
    using GetStringDescriptor = GetStringDescriptor_Impl<GetStringDescriptorResponse>;
    using SetInterface = SetInterface_Impl<SetInterfaceResponse>;
    using GetDeviceId = GetDeviceId_Impl<GetDeviceIdResponse>;
    using GetHubDeviceId = GetHubDeviceId_Impl<GetHubDeviceIdResponse>;
    using GetConfiguration = GetConfiguration_Impl<GetConfigurationResponse>;
    using SetConfiguration = SetConfiguration_Impl<SetConfigurationResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Returns the speed of the USB device as a usb_speed_t value.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDeviceSpeed GetDeviceSpeed();

    // Returns the speed of the USB device as a usb_speed_t value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDeviceSpeed GetDeviceSpeed(::fidl::BytePart _response_buffer);

    // Returns the device's USB device descriptor.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDeviceDescriptor GetDeviceDescriptor();

    // Returns the device's USB device descriptor.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDeviceDescriptor GetDeviceDescriptor(::fidl::BytePart _response_buffer);

    // Returns the total size of the USB configuration descriptor for the given configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetConfigurationDescriptorSize GetConfigurationDescriptorSize(uint8_t config);

    // Returns the total size of the USB configuration descriptor for the given configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetConfigurationDescriptorSize GetConfigurationDescriptorSize(::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);

    // Returns the device's USB configuration descriptor for the given configuration.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetConfigurationDescriptor GetConfigurationDescriptor(uint8_t config);

    // Returns the device's USB configuration descriptor for the given configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetConfigurationDescriptor GetConfigurationDescriptor(::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);

    // Fetches a string descriptor from the USB device.
    //
    // desc_id          :   The ID of the string descriptor to fetch, or 0 to fetch
    //                      the language table instead.
    //
    // lang_id          :   The language ID of the string descriptor to fetch.
    //                      If no matching language ID is present in the device's language
    //                      ID table, the first entry of the language ID table will
    //                      be substituted.
    // actual_lang_id   :   The actual language ID of the string fetched, or 0 for
    //                      the language ID table.
    //
    // The worst case size for the payload of a language ID table should be 252
    // bytes, meaning that a 256 byte buffer should always be enough to hold any
    // language ID table.
    //
    // The worst case size for a UTF-8 encoded string descriptor payload should be
    // 378 bytes (126 UTF-16 code units with a worst case expansion factor of 3)
    // Allocates 456 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetStringDescriptor GetStringDescriptor(uint8_t desc_id, uint16_t lang_id);

    // Fetches a string descriptor from the USB device.
    //
    // desc_id          :   The ID of the string descriptor to fetch, or 0 to fetch
    //                      the language table instead.
    //
    // lang_id          :   The language ID of the string descriptor to fetch.
    //                      If no matching language ID is present in the device's language
    //                      ID table, the first entry of the language ID table will
    //                      be substituted.
    // actual_lang_id   :   The actual language ID of the string fetched, or 0 for
    //                      the language ID table.
    //
    // The worst case size for the payload of a language ID table should be 252
    // bytes, meaning that a 256 byte buffer should always be enough to hold any
    // language ID table.
    //
    // The worst case size for a UTF-8 encoded string descriptor payload should be
    // 378 bytes (126 UTF-16 code units with a worst case expansion factor of 3)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetStringDescriptor GetStringDescriptor(::fidl::BytePart _request_buffer, uint8_t desc_id, uint16_t lang_id, ::fidl::BytePart _response_buffer);

    // Selects an alternate setting for an interface on a USB device.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetInterface SetInterface(uint8_t interface_number, uint8_t alt_setting);

    // Selects an alternate setting for an interface on a USB device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetInterface SetInterface(::fidl::BytePart _request_buffer, uint8_t interface_number, uint8_t alt_setting, ::fidl::BytePart _response_buffer);

    // Returns an implementation specific device ID for a USB device.
    // For informational purposes only.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetDeviceId GetDeviceId();

    // Returns an implementation specific device ID for a USB device.
    // For informational purposes only.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetDeviceId GetDeviceId(::fidl::BytePart _response_buffer);

    // Returns the implementation specific device ID for the hub that a USB device is connected to.
    // For informational purposes only.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetHubDeviceId GetHubDeviceId();

    // Returns the implementation specific device ID for the hub that a USB device is connected to.
    // For informational purposes only.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetHubDeviceId GetHubDeviceId(::fidl::BytePart _response_buffer);

    // Returns the device's current configuration.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetConfiguration GetConfiguration();

    // Returns the device's current configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetConfiguration GetConfiguration(::fidl::BytePart _response_buffer);

    // Sets the device's current configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetConfiguration SetConfiguration(uint8_t configuration);

    // Sets the device's current configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetConfiguration SetConfiguration(::fidl::BytePart _request_buffer, uint8_t configuration, ::fidl::BytePart _response_buffer);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Returns the speed of the USB device as a usb_speed_t value.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDeviceSpeed GetDeviceSpeed(::zx::unowned_channel _client_end);

    // Returns the speed of the USB device as a usb_speed_t value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDeviceSpeed GetDeviceSpeed(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns the device's USB device descriptor.
    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDeviceDescriptor GetDeviceDescriptor(::zx::unowned_channel _client_end);

    // Returns the device's USB device descriptor.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDeviceDescriptor GetDeviceDescriptor(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns the total size of the USB configuration descriptor for the given configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetConfigurationDescriptorSize GetConfigurationDescriptorSize(::zx::unowned_channel _client_end, uint8_t config);

    // Returns the total size of the USB configuration descriptor for the given configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetConfigurationDescriptorSize GetConfigurationDescriptorSize(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);

    // Returns the device's USB configuration descriptor for the given configuration.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetConfigurationDescriptor GetConfigurationDescriptor(::zx::unowned_channel _client_end, uint8_t config);

    // Returns the device's USB configuration descriptor for the given configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetConfigurationDescriptor GetConfigurationDescriptor(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t config, ::fidl::BytePart _response_buffer);

    // Fetches a string descriptor from the USB device.
    //
    // desc_id          :   The ID of the string descriptor to fetch, or 0 to fetch
    //                      the language table instead.
    //
    // lang_id          :   The language ID of the string descriptor to fetch.
    //                      If no matching language ID is present in the device's language
    //                      ID table, the first entry of the language ID table will
    //                      be substituted.
    // actual_lang_id   :   The actual language ID of the string fetched, or 0 for
    //                      the language ID table.
    //
    // The worst case size for the payload of a language ID table should be 252
    // bytes, meaning that a 256 byte buffer should always be enough to hold any
    // language ID table.
    //
    // The worst case size for a UTF-8 encoded string descriptor payload should be
    // 378 bytes (126 UTF-16 code units with a worst case expansion factor of 3)
    // Allocates 456 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetStringDescriptor GetStringDescriptor(::zx::unowned_channel _client_end, uint8_t desc_id, uint16_t lang_id);

    // Fetches a string descriptor from the USB device.
    //
    // desc_id          :   The ID of the string descriptor to fetch, or 0 to fetch
    //                      the language table instead.
    //
    // lang_id          :   The language ID of the string descriptor to fetch.
    //                      If no matching language ID is present in the device's language
    //                      ID table, the first entry of the language ID table will
    //                      be substituted.
    // actual_lang_id   :   The actual language ID of the string fetched, or 0 for
    //                      the language ID table.
    //
    // The worst case size for the payload of a language ID table should be 252
    // bytes, meaning that a 256 byte buffer should always be enough to hold any
    // language ID table.
    //
    // The worst case size for a UTF-8 encoded string descriptor payload should be
    // 378 bytes (126 UTF-16 code units with a worst case expansion factor of 3)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetStringDescriptor GetStringDescriptor(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t desc_id, uint16_t lang_id, ::fidl::BytePart _response_buffer);

    // Selects an alternate setting for an interface on a USB device.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetInterface SetInterface(::zx::unowned_channel _client_end, uint8_t interface_number, uint8_t alt_setting);

    // Selects an alternate setting for an interface on a USB device.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetInterface SetInterface(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t interface_number, uint8_t alt_setting, ::fidl::BytePart _response_buffer);

    // Returns an implementation specific device ID for a USB device.
    // For informational purposes only.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetDeviceId GetDeviceId(::zx::unowned_channel _client_end);

    // Returns an implementation specific device ID for a USB device.
    // For informational purposes only.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetDeviceId GetDeviceId(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns the implementation specific device ID for the hub that a USB device is connected to.
    // For informational purposes only.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetHubDeviceId GetHubDeviceId(::zx::unowned_channel _client_end);

    // Returns the implementation specific device ID for the hub that a USB device is connected to.
    // For informational purposes only.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetHubDeviceId GetHubDeviceId(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns the device's current configuration.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetConfiguration GetConfiguration(::zx::unowned_channel _client_end);

    // Returns the device's current configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetConfiguration GetConfiguration(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Sets the device's current configuration.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetConfiguration SetConfiguration(::zx::unowned_channel _client_end, uint8_t configuration);

    // Sets the device's current configuration.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetConfiguration SetConfiguration(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint8_t configuration, ::fidl::BytePart _response_buffer);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Returns the speed of the USB device as a usb_speed_t value.
    static ::fidl::DecodeResult<GetDeviceSpeedResponse> GetDeviceSpeed(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns the device's USB device descriptor.
    static ::fidl::DecodeResult<GetDeviceDescriptorResponse> GetDeviceDescriptor(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns the total size of the USB configuration descriptor for the given configuration.
    static ::fidl::DecodeResult<GetConfigurationDescriptorSizeResponse> GetConfigurationDescriptorSize(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetConfigurationDescriptorSizeRequest> params, ::fidl::BytePart response_buffer);

    // Returns the device's USB configuration descriptor for the given configuration.
    static ::fidl::DecodeResult<GetConfigurationDescriptorResponse> GetConfigurationDescriptor(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetConfigurationDescriptorRequest> params, ::fidl::BytePart response_buffer);

    // Fetches a string descriptor from the USB device.
    //
    // desc_id          :   The ID of the string descriptor to fetch, or 0 to fetch
    //                      the language table instead.
    //
    // lang_id          :   The language ID of the string descriptor to fetch.
    //                      If no matching language ID is present in the device's language
    //                      ID table, the first entry of the language ID table will
    //                      be substituted.
    // actual_lang_id   :   The actual language ID of the string fetched, or 0 for
    //                      the language ID table.
    //
    // The worst case size for the payload of a language ID table should be 252
    // bytes, meaning that a 256 byte buffer should always be enough to hold any
    // language ID table.
    //
    // The worst case size for a UTF-8 encoded string descriptor payload should be
    // 378 bytes (126 UTF-16 code units with a worst case expansion factor of 3)
    static ::fidl::DecodeResult<GetStringDescriptorResponse> GetStringDescriptor(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetStringDescriptorRequest> params, ::fidl::BytePart response_buffer);

    // Selects an alternate setting for an interface on a USB device.
    static ::fidl::DecodeResult<SetInterfaceResponse> SetInterface(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetInterfaceRequest> params, ::fidl::BytePart response_buffer);

    // Returns an implementation specific device ID for a USB device.
    // For informational purposes only.
    static ::fidl::DecodeResult<GetDeviceIdResponse> GetDeviceId(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns the implementation specific device ID for the hub that a USB device is connected to.
    // For informational purposes only.
    static ::fidl::DecodeResult<GetHubDeviceIdResponse> GetHubDeviceId(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns the device's current configuration.
    static ::fidl::DecodeResult<GetConfigurationResponse> GetConfiguration(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets the device's current configuration.
    static ::fidl::DecodeResult<SetConfigurationResponse> SetConfiguration(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetConfigurationRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    class GetDeviceSpeedCompleterBase : public _Base {
     public:
      void Reply(uint32_t speed);
      void Reply(::fidl::BytePart _buffer, uint32_t speed);
      void Reply(::fidl::DecodedMessage<GetDeviceSpeedResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDeviceSpeedCompleter = ::fidl::Completer<GetDeviceSpeedCompleterBase>;

    virtual void GetDeviceSpeed(GetDeviceSpeedCompleter::Sync _completer) = 0;

    class GetDeviceDescriptorCompleterBase : public _Base {
     public:
      void Reply(::fidl::Array<uint8_t, 18> desc);
      void Reply(::fidl::BytePart _buffer, ::fidl::Array<uint8_t, 18> desc);
      void Reply(::fidl::DecodedMessage<GetDeviceDescriptorResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDeviceDescriptorCompleter = ::fidl::Completer<GetDeviceDescriptorCompleterBase>;

    virtual void GetDeviceDescriptor(GetDeviceDescriptorCompleter::Sync _completer) = 0;

    class GetConfigurationDescriptorSizeCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint16_t size);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint16_t size);
      void Reply(::fidl::DecodedMessage<GetConfigurationDescriptorSizeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetConfigurationDescriptorSizeCompleter = ::fidl::Completer<GetConfigurationDescriptorSizeCompleterBase>;

    virtual void GetConfigurationDescriptorSize(uint8_t config, GetConfigurationDescriptorSizeCompleter::Sync _completer) = 0;

    class GetConfigurationDescriptorCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> desc);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> desc);
      void Reply(::fidl::DecodedMessage<GetConfigurationDescriptorResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetConfigurationDescriptorCompleter = ::fidl::Completer<GetConfigurationDescriptorCompleterBase>;

    virtual void GetConfigurationDescriptor(uint8_t config, GetConfigurationDescriptorCompleter::Sync _completer) = 0;

    class GetStringDescriptorCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::StringView desc, uint16_t actual_lang_id);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::StringView desc, uint16_t actual_lang_id);
      void Reply(::fidl::DecodedMessage<GetStringDescriptorResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetStringDescriptorCompleter = ::fidl::Completer<GetStringDescriptorCompleterBase>;

    virtual void GetStringDescriptor(uint8_t desc_id, uint16_t lang_id, GetStringDescriptorCompleter::Sync _completer) = 0;

    class SetInterfaceCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetInterfaceResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetInterfaceCompleter = ::fidl::Completer<SetInterfaceCompleterBase>;

    virtual void SetInterface(uint8_t interface_number, uint8_t alt_setting, SetInterfaceCompleter::Sync _completer) = 0;

    class GetDeviceIdCompleterBase : public _Base {
     public:
      void Reply(uint32_t device_id);
      void Reply(::fidl::BytePart _buffer, uint32_t device_id);
      void Reply(::fidl::DecodedMessage<GetDeviceIdResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetDeviceIdCompleter = ::fidl::Completer<GetDeviceIdCompleterBase>;

    virtual void GetDeviceId(GetDeviceIdCompleter::Sync _completer) = 0;

    class GetHubDeviceIdCompleterBase : public _Base {
     public:
      void Reply(uint32_t hub_device_id);
      void Reply(::fidl::BytePart _buffer, uint32_t hub_device_id);
      void Reply(::fidl::DecodedMessage<GetHubDeviceIdResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetHubDeviceIdCompleter = ::fidl::Completer<GetHubDeviceIdCompleterBase>;

    virtual void GetHubDeviceId(GetHubDeviceIdCompleter::Sync _completer) = 0;

    class GetConfigurationCompleterBase : public _Base {
     public:
      void Reply(uint8_t configuration);
      void Reply(::fidl::BytePart _buffer, uint8_t configuration);
      void Reply(::fidl::DecodedMessage<GetConfigurationResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetConfigurationCompleter = ::fidl::Completer<GetConfigurationCompleterBase>;

    virtual void GetConfiguration(GetConfigurationCompleter::Sync _completer) = 0;

    class SetConfigurationCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetConfigurationResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetConfigurationCompleter = ::fidl::Completer<SetConfigurationCompleterBase>;

    virtual void SetConfiguration(uint8_t configuration, SetConfigurationCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }


  // Helper functions to fill in the transaction header in a |DecodedMessage<TransactionalMessage>|.
  class SetTransactionHeaderFor final {
    SetTransactionHeaderFor() = delete;
   public:
    static void GetDeviceSpeedRequest(const ::fidl::DecodedMessage<Device::GetDeviceSpeedRequest>& _msg);
    static void GetDeviceSpeedResponse(const ::fidl::DecodedMessage<Device::GetDeviceSpeedResponse>& _msg);
    static void GetDeviceDescriptorRequest(const ::fidl::DecodedMessage<Device::GetDeviceDescriptorRequest>& _msg);
    static void GetDeviceDescriptorResponse(const ::fidl::DecodedMessage<Device::GetDeviceDescriptorResponse>& _msg);
    static void GetConfigurationDescriptorSizeRequest(const ::fidl::DecodedMessage<Device::GetConfigurationDescriptorSizeRequest>& _msg);
    static void GetConfigurationDescriptorSizeResponse(const ::fidl::DecodedMessage<Device::GetConfigurationDescriptorSizeResponse>& _msg);
    static void GetConfigurationDescriptorRequest(const ::fidl::DecodedMessage<Device::GetConfigurationDescriptorRequest>& _msg);
    static void GetConfigurationDescriptorResponse(const ::fidl::DecodedMessage<Device::GetConfigurationDescriptorResponse>& _msg);
    static void GetStringDescriptorRequest(const ::fidl::DecodedMessage<Device::GetStringDescriptorRequest>& _msg);
    static void GetStringDescriptorResponse(const ::fidl::DecodedMessage<Device::GetStringDescriptorResponse>& _msg);
    static void SetInterfaceRequest(const ::fidl::DecodedMessage<Device::SetInterfaceRequest>& _msg);
    static void SetInterfaceResponse(const ::fidl::DecodedMessage<Device::SetInterfaceResponse>& _msg);
    static void GetDeviceIdRequest(const ::fidl::DecodedMessage<Device::GetDeviceIdRequest>& _msg);
    static void GetDeviceIdResponse(const ::fidl::DecodedMessage<Device::GetDeviceIdResponse>& _msg);
    static void GetHubDeviceIdRequest(const ::fidl::DecodedMessage<Device::GetHubDeviceIdRequest>& _msg);
    static void GetHubDeviceIdResponse(const ::fidl::DecodedMessage<Device::GetHubDeviceIdResponse>& _msg);
    static void GetConfigurationRequest(const ::fidl::DecodedMessage<Device::GetConfigurationRequest>& _msg);
    static void GetConfigurationResponse(const ::fidl::DecodedMessage<Device::GetConfigurationResponse>& _msg);
    static void SetConfigurationRequest(const ::fidl::DecodedMessage<Device::SetConfigurationRequest>& _msg);
    static void SetConfigurationResponse(const ::fidl::DecodedMessage<Device::SetConfigurationResponse>& _msg);
  };
};

// See GetStringDescriptor description below
constexpr uint32_t MAX_STRING_DESC_SIZE = 384u;

// UINT16_MAX
constexpr uint32_t MAX_CONFIG_DESC_SIZE = 65536u;

// sizeof(usb_device_descriptor_t)
constexpr uint32_t DEVICE_DESC_SIZE = 18u;

}  // namespace device
}  // namespace usb
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceSpeedResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceSpeedResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceSpeedResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceSpeedResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceSpeedResponse, speed) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceDescriptorResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceDescriptorResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceDescriptorResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceDescriptorResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceDescriptorResponse, desc) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeRequest)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeRequest, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorSizeResponse, size) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorRequest)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorRequest, config) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationDescriptorResponse, desc) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest, desc_id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorRequest, lang_id) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse, desc) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetStringDescriptorResponse, actual_lang_id) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest)
    == ::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest, interface_number) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceRequest, alt_setting) == 17);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::SetInterfaceResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceIdResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceIdResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceIdResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceIdResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetDeviceIdResponse, device_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetHubDeviceIdResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetHubDeviceIdResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetHubDeviceIdResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetHubDeviceIdResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetHubDeviceIdResponse, hub_device_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::GetConfigurationResponse, configuration) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationRequest)
    == ::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationRequest, configuration) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationResponse)
    == ::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::usb::device::Device::SetConfigurationResponse, s) == 16);

}  // namespace fidl

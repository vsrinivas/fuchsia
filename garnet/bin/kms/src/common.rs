// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use std::str;

use fidl_fuchsia_kms::{AsymmetricPrivateKeyRequest, Status};
use serde_derive::{Deserialize, Serialize};

pub enum KeyRequestType {
    AsymmetricPrivateKeyRequest(AsymmetricPrivateKeyRequest),
}

/// The key types.
#[derive(Serialize, Deserialize, PartialEq)]
pub enum KeyType {
    /// A type of key used to seal and unseal data. This type of key is generated by KMS and not the
    /// user.
    SealingKey,
    /// A type of key representing an asymmetric private key. It could be used to sign data.
    AsymmetricPrivateKey,
}

/// A key object in memory.
///
/// Each key stored in KMS should have a singleton of key object in memory when used. The user are
/// given a handler associated with this unique in memory key object. If a key object does not exist
/// KMS would read from storage and create the key object. After all the handles to this key object
/// is dropped, the key object would be removed from memory. This ensures that all the operations
/// are synchronized based on lock to use this Key object.
pub trait KmsKey: Send {
    /// Whether this key is already deleted. A key may be deleted while there are other channels
    /// associated with that key. In this case, any operation on the deleted key would return
    /// key_not_found.
    fn is_deleted(&self) -> bool;
    /// Delete the key. This would include telling the crypto provider to delete key (If provider
    /// keeps some resource for the key) and set the deleted to true.
    fn delete(&mut self) -> Result<(), Status>;
    /// Get the name for the current key.
    fn get_key_name(&self) -> &str;
    /// Handle a request from user. Note that a key should only handle the request for that key
    /// and this is enforced by key_manager.
    ///
    /// # Panics
    ///
    /// Panics if request type is invalid.
    fn handle_request(&self, req: KeyRequestType) -> Result<(), fidl::Error>;
    /// The the type for the current key.
    fn get_key_type(&self) -> KeyType;
    /// Get the provider's name.
    fn get_provider_name(&self) -> &str;
    /// Get the key data.
    fn get_key_data(&self) -> Vec<u8>;
}

#[cfg(test)]
use fidl_fuchsia_kms::AsymmetricKeyAlgorithm;
/// A list of all the supported asymmetric key algorithms.
#[cfg(test)]
pub const ASYMMETRIC_KEY_ALGORITHMS: &[AsymmetricKeyAlgorithm] = &[
    AsymmetricKeyAlgorithm::EcdsaSha256P256,
    AsymmetricKeyAlgorithm::EcdsaSha512P384,
    AsymmetricKeyAlgorithm::EcdsaSha512P521,
    AsymmetricKeyAlgorithm::RsaSsaPssSha2562048,
    AsymmetricKeyAlgorithm::RsaSsaPssSha2563072,
    AsymmetricKeyAlgorithm::RsaSsaPssSha2564096,
    AsymmetricKeyAlgorithm::RsaSsaPkcs1Sha2562048,
    AsymmetricKeyAlgorithm::RsaSsaPkcs1Sha2563072,
    AsymmetricKeyAlgorithm::RsaSsaPkcs1Sha2564096,
];

#[cfg(test)]
pub fn generate_random_data(size: u32) -> Vec<u8> {
    use rand::Rng;
    let mut random_data = Vec::new();
    let mut rng = rand::thread_rng();
    for _i in 0..size {
        let byte: u8 = rng.gen();
        random_data.push(byte);
    }
    random_data
}

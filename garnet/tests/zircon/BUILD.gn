# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/fuchsia/zircon_images.gni")
import("//build/fuzzing/fuzzer.gni")
import("//build/package.gni")

zircon_extras_manifest("zircon_test_manifest") {
  manifest = "tests"
  patterns = [ "*" ]
}

package("zircon_tests") {
  deprecated_system_image = true
  deps = [
    ":zircon_test_manifest",
    ":zircon_test_metadata",
  ]
  extra = get_target_outputs(":zircon_test_manifest")
}

zircon_extras_manifest("zircon_fuzzers_manifest") {
  manifest = "tests"
  patterns = [
    "bin/*-fuzzer.*",
    "meta/*-fuzzer.*.cmx",
  ]
}

group("zircon_test_metadata") {
  test_specs = read_file("$zircon_root_build_dir/tests.json", "json")
  target_test_specs = []
  foreach(spec, test_specs) {
    _test = {
    }
    _test = spec.test

    # Note: zircon host tests are surfaced separately as
    # //src:zircon_host_tests; this is done separately as we want to run host
    # tests - bringup or otherwise - together, and the same can't be said of
    # zircon tests.
    if (_test.os == "fuchsia") {
      target_test_specs += [
        {
          test = {
            forward_variables_from(_test, "*")
            label = string_replace(label, "//", "//zircon/")
          }
        },
      ]
    }
  }
  metadata = {
    tests = target_test_specs
  }
}

# When migrating Zircon fuzzers to the Fuchsia build, add them to this list.
_migrated_fuzzers = [
  "//zircon/system/dev/ethernet/usb-cdc-ecm:usb-cdc-ecm-descriptor-fuzzer",
]

# Emits a JSON manifest similar to the one used to incorporate Zircon fuzzers into the Fuchsia GN
# build pre-unification. This is used to validate that the list of Zircon fuzzers is the unchanged
# as fuzzers are being migrated. Post-unification, this target can be removed.
generated_file("migrated_fuzzers_manifest") {
  outputs = [ "$root_build_dir/migrated_zircon_fuzzers.json" ]
  contents = []
  foreach(fuzzer, _migrated_fuzzers) {
    fuzzer_name = get_label_info(fuzzer, "name")
    foreach(variant,
            [
              "asan",
              "asan-ubsan",
              "ubsan",
            ]) {
      contents += [ "$fuzzer_name.$variant" ]
    }
  }
  output_conversion = "json"
}

fuzzers_package("zircon_fuzzers") {
  # Zircon fuzzers built using Zircon GN.
  fuzzers_manifest = {
    target = ":zircon_fuzzers_manifest"
    output = "$zircon_root_build_dir/legacy_fuzzers-$target_cpu.json"
  }

  # Zircon fuzzers built using Fuchsia GN.
  fuzzers = _migrated_fuzzers
  deps = [ ":migrated_fuzzers_manifest" ]
}

# This tells the infra recipes how to run ZBI tests.  These are defined in
# the Zircon build with zbi_test().  Bringing the packages from this file
# into the build causes this file to be written, so a build including one
# of these packages is a build whose bots will run the ZBI tests.
#
# The schema produced here matches images.json with the addition of the
# `success_string` key.
generated_file("zbi_tests") {
  outputs = [ "$root_build_dir/zbi_tests.json" ]
  output_conversion = "json"

  zbi_test_success_string =
      read_file("$zircon_root_build_dir/zbi_test_success_string.json", "json")

  contents = []
  foreach(image, zircon_images) {
    if (image.type == "zbi" && defined(image.tags) &&
        image.tags + [ "zbi-test" ] - [ "zbi-test" ] != image.tags &&
        image.tags + [ "disabled" ] - [ "disabled" ] == image.tags &&
        image.cpu == current_cpu) {
      contents += [
        {
          cpu = image.cpu
          name = image.name
          path = rebase_path(image.path, root_build_dir, zircon_root_build_dir)
          label = image.label
          type = "zbi"
          bootserver_netboot = [ "--boot" ]
          success_string = zbi_test_success_string
        },
      ]
    }
  }
}

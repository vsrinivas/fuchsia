// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GARNET_LIB_RUST_WLAN_MLME_C_BINDINGS_H_
#define GARNET_LIB_RUST_WLAN_MLME_C_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Manages all SNS for a STA.
 */
typedef struct mlme_sequence_manager_t mlme_sequence_manager_t;

typedef struct {
  void *device;
  int32_t (*deliver_ethernet)(void *device, const uint8_t *data, uintptr_t len);
} mlme_device_ops_t;

/**
 * An input buffer will always be returned to its original owner when no longer
 * being used. An input buffer is used for every buffer handed from C++ to Rust.
 */
typedef struct {
  /**
   * Returns the buffer's ownership and free it.
   */
  void (*free_buffer)(void *raw);
  /**
   * Pointer to the buffer's underlying data structure.
   */
  void *raw;
  /**
   * Pointer to the start of the buffer's data portion and its length.
   */
  uint8_t *data;
  uintptr_t len;
} mlme_in_buf_t;

typedef struct {
  /**
   * Acquire a `InBuf` with a given minimum length from the provider.
   * The provider must release the underlying buffer's ownership and transfer it
   * to this crate. The buffer will be returned via the `free_buffer` callback
   * when it's no longer used.
   */
  mlme_in_buf_t (*get_buffer)(uintptr_t min_len);
} mlme_buffer_provider_ops_t;

/**
 * An output buffer requires its owner to manage the underlying buffer's memory
 * themselves. An output buffer is used for every buffer handed from Rust to
 * C++.
 */
typedef struct {
  /**
   * Pointer to the buffer's underlying data structure.
   */
  void *raw;
  /**
   * Pointer to the start of the buffer's data portion and the amount of bytes
   * written.
   */
  uint8_t *data;
  uintptr_t written_bytes;
} mlme_out_buf_t;

extern "C" int32_t mlme_handle_data_frame(const mlme_device_ops_t *device,
                                          const uint8_t *data_frame,
                                          uintptr_t data_frame_len,
                                          bool has_padding);

extern "C" int32_t mlme_is_valid_open_auth_resp(const uint8_t *data,
                                                uintptr_t len);

extern "C" void mlme_sequence_manager_delete(mlme_sequence_manager_t *mgr);

extern "C" mlme_sequence_manager_t *mlme_sequence_manager_new(void);

extern "C" uint32_t mlme_sequence_manager_next_sns1(
    mlme_sequence_manager_t *mgr, const uint8_t (*sta_addr)[6]);

extern "C" uint32_t mlme_sequence_manager_next_sns2(
    mlme_sequence_manager_t *mgr, const uint8_t (*sta_addr)[6], uint16_t tid);

extern "C" int32_t mlme_write_deauth_frame(mlme_buffer_provider_ops_t provider,
                                           mlme_sequence_manager_t *seq_mgr,
                                           const uint8_t (*bssid)[6],
                                           const uint8_t (*client_addr)[6],
                                           uint16_t reason_code,
                                           mlme_out_buf_t *out_buf);

extern "C" int32_t mlme_write_eapol_data_frame(
    mlme_buffer_provider_ops_t provider, mlme_sequence_manager_t *seq_mgr,
    const uint8_t (*bssid)[6], const uint8_t (*src)[6],
    const uint8_t (*dest)[6], bool is_protected, const uint8_t *eapol_frame_ptr,
    uintptr_t eapol_frame_len, mlme_out_buf_t *out_buf);

extern "C" int32_t mlme_write_keep_alive_resp_frame(
    mlme_buffer_provider_ops_t provider, mlme_sequence_manager_t *seq_mgr,
    const uint8_t (*bssid)[6], const uint8_t (*client_addr)[6],
    mlme_out_buf_t *out_buf);

extern "C" int32_t mlme_write_open_auth_frame(
    mlme_buffer_provider_ops_t provider, mlme_sequence_manager_t *seq_mgr,
    const uint8_t (*bssid)[6], const uint8_t (*client_addr)[6],
    mlme_out_buf_t *out_buf);

#endif /* GARNET_LIB_RUST_WLAN_MLME_C_BINDINGS_H_ */

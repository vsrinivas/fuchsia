// Code generated by fidlgen; DO NOT EDIT.

package top


import (
	bottom "fidl/bottom"
	middle "fidl/middle"
	_zx "syscall/zx"
	_bindings "syscall/zx/fidl"
)





type topWithCtxGetFooResponse struct {
	_ struct{} `fidl:"s" fidl_size_v1:"8" fidl_alignment_v1:"8"`
	Foo bottom.Foo`fidl:"0" fidl_offset_v1:"0"`
}

var _mtopWithCtxGetFooResponse = _bindings.CreateLazyMarshaler(topWithCtxGetFooResponse{})

func (msg *topWithCtxGetFooResponse) Marshaler() _bindings.Marshaler {
	return _mtopWithCtxGetFooResponse
}
const (
	TopGetFooOrdinal uint64 = 0xb3385a000000000
	TopGetFooGenOrdinal uint64 = 0x6ae8d19bc98f3d92
)

type TopWithCtxInterface _bindings.ChannelProxy


func (p *TopWithCtxInterface) GetFoo(ctx_ _bindings.Context) (bottom.Foo, error) {
	var req_ _bindings.Message
	resp_ := &topWithCtxGetFooResponse{}
	err_ := ((*_bindings.ChannelProxy)(p)).Call(TopGetFooGenOrdinal, req_, resp_, TopGetFooOrdinal, TopGetFooGenOrdinal)
	return resp_.Foo, err_
}


type TopWithCtx interface {
	GetFoo(ctx_ _bindings.Context) (bottom.Foo, error)
}



type TopWithCtxTransitionalBase struct {}


type TopWithCtxInterfaceRequest _bindings.InterfaceRequest

func NewTopWithCtxInterfaceRequest() (TopWithCtxInterfaceRequest, *TopWithCtxInterface, error) {
	req, cli, err := _bindings.NewInterfaceRequest()
	return TopWithCtxInterfaceRequest(req), (*TopWithCtxInterface)(cli), err
}

type TopWithCtxStub struct {
	Impl TopWithCtx
}

func (s_ *TopWithCtxStub) Dispatch(args_ _bindings.DispatchArgs) (_bindings.Message, bool, error) {
	switch args_.Ordinal {
	case TopGetFooOrdinal:
		fallthrough
	case TopGetFooGenOrdinal:
		foo, err_ := s_.Impl.GetFoo(args_.Ctx)
		out_ := topWithCtxGetFooResponse{}
		out_.Foo = foo
		return &out_, true, err_
	}
	return nil, false, _bindings.ErrUnknownOrdinal
}
type TopService struct {
	_bindings.BindingSet
}

func (s *TopService) AddWithCtx(impl TopWithCtx, c _zx.Channel, onError func(error)) (_bindings.BindingKey, error) {
	return s.BindingSet.Add(&TopWithCtxStub{Impl: impl}, c, onError)
}

func (s *TopService) EventProxyFor(key _bindings.BindingKey) (*TopEventProxy, bool) {
	pxy, err := s.BindingSet.ProxyFor(key)
	return (*TopEventProxy)(pxy), err
}

type TopEventProxy _bindings.ChannelProxy




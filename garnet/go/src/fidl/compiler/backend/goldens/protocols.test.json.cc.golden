// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

extern "C" const fidl_type_t
    test_name_WithErrorSyntax_ResponseAsStruct_ResponseTable;
const fidl_type_t* WithErrorSyntax_ResponseAsStruct_Response::FidlType =
    &test_name_WithErrorSyntax_ResponseAsStruct_ResponseTable;

void WithErrorSyntax_ResponseAsStruct_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ResponseAsStruct_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ResponseAsStruct_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ResponseAsStruct_Response));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
    ::fidl::Encode(_encoder, &c, _offset + 16);
  }
}

void WithErrorSyntax_ResponseAsStruct_Response::Decode(
    ::fidl::Decoder* _decoder,
    WithErrorSyntax_ResponseAsStruct_Response* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ResponseAsStruct_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ResponseAsStruct_Response>(
               _offset),
           sizeof(WithErrorSyntax_ResponseAsStruct_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
    ::fidl::Decode(_decoder, &_value->c, _offset + 16);
  }
}

zx_status_t WithErrorSyntax_ResponseAsStruct_Response::Clone(
    WithErrorSyntax_ResponseAsStruct_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t
    test_name_WithErrorSyntax_ResponseAsStruct_ResultTable;
const fidl_type_t* WithErrorSyntax_ResponseAsStruct_Result::FidlType =
    &test_name_WithErrorSyntax_ResponseAsStruct_ResultTable;

WithErrorSyntax_ResponseAsStruct_Result::
    WithErrorSyntax_ResponseAsStruct_Result() {}

WithErrorSyntax_ResponseAsStruct_Result::
    ~WithErrorSyntax_ResponseAsStruct_Result() {
  Destroy();
}

WithErrorSyntax_ResponseAsStruct_Result::
    WithErrorSyntax_ResponseAsStruct_Result(
        WithErrorSyntax_ResponseAsStruct_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kResponse:
      new (&response_) class WithErrorSyntax_ResponseAsStruct_Response();
      response_ = std::move(other.response_);
      break;
    case Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::operator=(
    WithErrorSyntax_ResponseAsStruct_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ResponseAsStruct_Response();
        response_ = std::move(other.response_);
        break;
      case Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ResponseAsStruct_Result
WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
    class WithErrorSyntax_ResponseAsStruct_Response&& val) {
  WithErrorSyntax_ResponseAsStruct_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ResponseAsStruct_Result
WithErrorSyntax_ResponseAsStruct_Result::WithErr(uint32_t&& val) {
  WithErrorSyntax_ResponseAsStruct_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ResponseAsStruct_Result::Encode(::fidl::Encoder* encoder,
                                                     size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kResponse: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<
              class WithErrorSyntax_ResponseAsStruct_Response, ::fidl::Encoder>(
              encoder));
      ::fidl::Encode(encoder, &response_, envelope_offset);
      break;
    }
    case Tag::kErr: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &err_, envelope_offset);
      break;
    }
    default:
      break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles =
        encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void WithErrorSyntax_ResponseAsStruct_Result::Decode(
    ::fidl::Decoder* decoder, WithErrorSyntax_ResponseAsStruct_Result* value,
    size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(
        static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kResponse:
      new (&value->response_) class WithErrorSyntax_ResponseAsStruct_Response();
      ::fidl::Decode(decoder, &value->response_, envelope_offset);
      break;
    case Tag::kErr:
      ::fidl::Decode(decoder, &value->err_, envelope_offset);
      break;
  }
}

zx_status_t WithErrorSyntax_ResponseAsStruct_Result::Clone(
    WithErrorSyntax_ResponseAsStruct_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::Invalid:
      return ZX_OK;
    case Tag::kResponse:
      new (
          &result->response_) class WithErrorSyntax_ResponseAsStruct_Response();
      return ::fidl::Clone(response_, &result->response_);
    case Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::set_response(
    class WithErrorSyntax_ResponseAsStruct_Response value) {
  EnsureStorageInitialized(Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ResponseAsStruct_Result&
WithErrorSyntax_ResponseAsStruct_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ResponseAsStruct_Result::Destroy() {
  switch (tag_) {
    case Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case Tag::kErr:
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void WithErrorSyntax_ResponseAsStruct_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ResponseAsStruct_Response();
        break;
      case Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t
    test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Response::FidlType =
    &test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

void WithErrorSyntax_ErrorAsPrimitive_Response::Encode(
    ::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ErrorAsPrimitive_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ErrorAsPrimitive_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ErrorAsPrimitive_Response));
  } else {
    ::fidl::Encode(_encoder, &__reserved, _offset + 0);
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Response::Decode(
    ::fidl::Decoder* _decoder,
    WithErrorSyntax_ErrorAsPrimitive_Response* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<
          WithErrorSyntax_ErrorAsPrimitive_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ErrorAsPrimitive_Response>(
               _offset),
           sizeof(WithErrorSyntax_ErrorAsPrimitive_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Response::Clone(
    WithErrorSyntax_ErrorAsPrimitive_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t
    test_name_WithErrorSyntax_ErrorAsPrimitive_ResultTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Result::FidlType =
    &test_name_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

WithErrorSyntax_ErrorAsPrimitive_Result::
    WithErrorSyntax_ErrorAsPrimitive_Result() {}

WithErrorSyntax_ErrorAsPrimitive_Result::
    ~WithErrorSyntax_ErrorAsPrimitive_Result() {
  Destroy();
}

WithErrorSyntax_ErrorAsPrimitive_Result::
    WithErrorSyntax_ErrorAsPrimitive_Result(
        WithErrorSyntax_ErrorAsPrimitive_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kResponse:
      new (&response_) class WithErrorSyntax_ErrorAsPrimitive_Response();
      response_ = std::move(other.response_);
      break;
    case Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::operator=(
    WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ErrorAsPrimitive_Response();
        response_ = std::move(other.response_);
        break;
      case Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ErrorAsPrimitive_Result
WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
    class WithErrorSyntax_ErrorAsPrimitive_Response&& val) {
  WithErrorSyntax_ErrorAsPrimitive_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ErrorAsPrimitive_Result
WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(uint32_t&& val) {
  WithErrorSyntax_ErrorAsPrimitive_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Encode(::fidl::Encoder* encoder,
                                                     size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kResponse: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<
              class WithErrorSyntax_ErrorAsPrimitive_Response, ::fidl::Encoder>(
              encoder));
      ::fidl::Encode(encoder, &response_, envelope_offset);
      break;
    }
    case Tag::kErr: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &err_, envelope_offset);
      break;
    }
    default:
      break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles =
        encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Decode(
    ::fidl::Decoder* decoder, WithErrorSyntax_ErrorAsPrimitive_Result* value,
    size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(
        static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kResponse:
      new (&value->response_) class WithErrorSyntax_ErrorAsPrimitive_Response();
      ::fidl::Decode(decoder, &value->response_, envelope_offset);
      break;
    case Tag::kErr:
      ::fidl::Decode(decoder, &value->err_, envelope_offset);
      break;
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Result::Clone(
    WithErrorSyntax_ErrorAsPrimitive_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::Invalid:
      return ZX_OK;
    case Tag::kResponse:
      new (
          &result->response_) class WithErrorSyntax_ErrorAsPrimitive_Response();
      return ::fidl::Clone(response_, &result->response_);
    case Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::set_response(
    class WithErrorSyntax_ErrorAsPrimitive_Response value) {
  EnsureStorageInitialized(Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ErrorAsPrimitive_Result&
WithErrorSyntax_ErrorAsPrimitive_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Destroy() {
  switch (tag_) {
    case Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case Tag::kErr:
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void WithErrorSyntax_ErrorAsPrimitive_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ErrorAsPrimitive_Response();
        break;
      case Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t
    test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Response::FidlType =
    &test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;

void WithErrorSyntax_ErrorAsEnum_Response::Encode(::fidl::Encoder* _encoder,
                                                  size_t _offset) {
  if (::fidl::IsMemcpyCompatible<WithErrorSyntax_ErrorAsEnum_Response>::value) {
    memcpy(_encoder->template GetPtr<WithErrorSyntax_ErrorAsEnum_Response>(
               _offset),
           this, sizeof(WithErrorSyntax_ErrorAsEnum_Response));
  } else {
    ::fidl::Encode(_encoder, &__reserved, _offset + 0);
  }
}

void WithErrorSyntax_ErrorAsEnum_Response::Decode(
    ::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* _value,
    size_t _offset) {
  if (::fidl::IsMemcpyCompatible<WithErrorSyntax_ErrorAsEnum_Response>::value) {
    memcpy(_value,
           _decoder->template GetPtr<WithErrorSyntax_ErrorAsEnum_Response>(
               _offset),
           sizeof(WithErrorSyntax_ErrorAsEnum_Response));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Response::Clone(
    WithErrorSyntax_ErrorAsEnum_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
#ifdef __Fuchsia__
namespace {

extern "C" const fidl_type_t test_name_TransitionalRequestRequestTable;
extern "C" const fidl_type_t test_name_TransitionalRequestResponseTable;

extern "C" const fidl_type_t test_name_TransitionalOneWayRequestTable;

extern "C" const fidl_type_t test_name_TransitionalEventEventTable;

}  // namespace

Transitional::~Transitional() = default;

const fidl_type_t* Transitional_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  switch (ordinal) {
    case internal::kTransitional_Request_Ordinal:
      *out_needs_response = true;
      return &test_name_TransitionalRequestRequestTable;
    case internal::kTransitional_OneWay_Ordinal:
      *out_needs_response = false;
      return &test_name_TransitionalOneWayRequestTable;
    default:
      *out_needs_response = false;
      return nullptr;
  }
}

const fidl_type_t* Transitional_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case internal::kTransitional_Request_Ordinal:
      return &test_name_TransitionalRequestResponseTable;
    case internal::kTransitional_Event_Ordinal:
      return &test_name_TransitionalEventEventTable;
    default:
      return nullptr;
  }
}

Transitional_EventSender::~Transitional_EventSender() = default;

Transitional_Sync::~Transitional_Sync() = default;

Transitional_Proxy::Transitional_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

Transitional_Proxy::~Transitional_Proxy() = default;

zx_status_t Transitional_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case internal::kTransitional_Event_Ordinal: {
      if (!Event) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status =
          message.Decode(&test_name_TransitionalEventEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message, &test_name_TransitionalEventEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      Event(::fidl::DecodeAs<int64_t>(&decoder, 16));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Transitional_Request_ResponseHandler(Transitional::RequestCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Transitional::Request\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<int64_t>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_TransitionalRequestResponseTable);
}

}  // namespace
void Transitional_Proxy::Request(int64_t x, RequestCallback callback) {
  ::fidl::Encoder _encoder(internal::kTransitional_Request_Ordinal);
  controller_->Send(&test_name_TransitionalRequestRequestTable,
                    Transitional_RequestEncoder::Request(&_encoder, &x),
                    Transitional_Request_ResponseHandler(std::move(callback)));
}
void Transitional_Proxy::OneWay(int64_t x) {
  ::fidl::Encoder _encoder(internal::kTransitional_OneWay_Ordinal);
  controller_->Send(&test_name_TransitionalOneWayRequestTable,
                    Transitional_RequestEncoder::OneWay(&_encoder, &x),
                    nullptr);
}

Transitional_Stub::Transitional_Stub(Transitional_clazz* impl) : impl_(impl) {
  (void)impl_;
}

Transitional_Stub::~Transitional_Stub() = default;

namespace {

class Transitional_Request_Responder final {
 public:
  Transitional_Request_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(int64_t y) {
    ::fidl::Encoder _encoder(internal::kTransitional_Request_Ordinal);
    response_.Send(&test_name_TransitionalRequestResponseTable,
                   Transitional_ResponseEncoder::Request(&_encoder, &y));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t Transitional_Stub::Dispatch_(
    ::fidl::Message message, ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      Transitional_RequestDecoder::GetType(message.ordinal(), &needs_response);
  if (request_type == nullptr) {
    return ZX_ERR_NOT_SUPPORTED;
  }
  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }
  const char* error_msg = nullptr;
  zx_status_t status = message.Decode(request_type, &error_msg);
  if (status != ZX_OK) {
    FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
    return status;
  }
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case internal::kTransitional_Request_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->Request(::fidl::DecodeAs<int64_t>(&decoder, 16),
                     Transitional_Request_Responder(std::move(response)));
      break;
    }
    case internal::kTransitional_OneWay_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWay(::fidl::DecodeAs<int64_t>(&decoder, 16));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void Transitional_Stub::Event(int64_t x) {
  ::fidl::Encoder _encoder(internal::kTransitional_Event_Ordinal);
  sender_()->Send(&test_name_TransitionalEventEventTable,
                  Transitional_ResponseEncoder::Event(&_encoder, &x));
}

Transitional_SyncProxy::Transitional_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

Transitional_SyncProxy::~Transitional_SyncProxy() = default;

zx_status_t Transitional_SyncProxy::Request(int64_t x, int64_t* out_y) {
  ::fidl::Encoder _encoder(internal::kTransitional_Request_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_TransitionalRequestRequestTable,
      &test_name_TransitionalRequestResponseTable,
      Transitional_RequestEncoder::Request(&_encoder, &x), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_y = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}

zx_status_t Transitional_SyncProxy::OneWay(int64_t x) {
  ::fidl::Encoder _encoder(internal::kTransitional_OneWay_Ordinal);
  return proxy_.Send(&test_name_TransitionalOneWayRequestTable,
                     Transitional_RequestEncoder::OneWay(&_encoder, &x));
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__
namespace {

extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;

extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;

extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;

extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace

ChannelProtocol::~ChannelProtocol() = default;

const fidl_type_t* ChannelProtocol_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  switch (ordinal) {
    case internal::kChannelProtocol_MethodA_Ordinal:
      *out_needs_response = false;
      return &test_name_ChannelProtocolMethodARequestTable;
    case internal::kChannelProtocol_MethodB_Ordinal:
      *out_needs_response = true;
      return &test_name_ChannelProtocolMethodBRequestTable;
    case internal::kChannelProtocol_MutateSocket_Ordinal:
      *out_needs_response = true;
      return &test_name_ChannelProtocolMutateSocketRequestTable;
    default:
      *out_needs_response = false;
      return nullptr;
  }
}

const fidl_type_t* ChannelProtocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case internal::kChannelProtocol_EventA_Ordinal:
      return &test_name_ChannelProtocolEventAEventTable;
    case internal::kChannelProtocol_MethodB_Ordinal:
      return &test_name_ChannelProtocolMethodBResponseTable;
    case internal::kChannelProtocol_MutateSocket_Ordinal:
      return &test_name_ChannelProtocolMutateSocketResponseTable;
    default:
      return nullptr;
  }
}

ChannelProtocol_EventSender::~ChannelProtocol_EventSender() = default;

ChannelProtocol_Sync::~ChannelProtocol_Sync() = default;

ChannelProtocol_Proxy::ChannelProtocol_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

ChannelProtocol_Proxy::~ChannelProtocol_Proxy() = default;

zx_status_t ChannelProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case internal::kChannelProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolEventAEventTable,
                              &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message, &test_name_ChannelProtocolEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventA(::fidl::DecodeAs<int64_t>(&decoder, 16),
             ::fidl::DecodeAs<int64_t>(&decoder, 24));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void ChannelProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MethodA_Ordinal);
  controller_->Send(&test_name_ChannelProtocolMethodARequestTable,
                    ChannelProtocol_RequestEncoder::MethodA(&_encoder, &a, &b),
                    nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
ChannelProtocol_MethodB_ResponseHandler(
    ChannelProtocol::MethodBCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback, "Callback must not be empty for ChannelProtocol::MethodB\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<int64_t>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_ChannelProtocolMethodBResponseTable);
}

}  // namespace
void ChannelProtocol_Proxy::MethodB(int64_t a, int64_t b,
                                    MethodBCallback callback) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MethodB_Ordinal);
  controller_->Send(
      &test_name_ChannelProtocolMethodBRequestTable,
      ChannelProtocol_RequestEncoder::MethodB(&_encoder, &a, &b),
      ChannelProtocol_MethodB_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
ChannelProtocol_MutateSocket_ResponseHandler(
    ChannelProtocol::MutateSocketCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for ChannelProtocol::MutateSocket\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::zx::socket>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_ChannelProtocolMutateSocketResponseTable);
}

}  // namespace
void ChannelProtocol_Proxy::MutateSocket(::zx::socket a,
                                         MutateSocketCallback callback) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MutateSocket_Ordinal);
  controller_->Send(
      &test_name_ChannelProtocolMutateSocketRequestTable,
      ChannelProtocol_RequestEncoder::MutateSocket(&_encoder, &a),
      ChannelProtocol_MutateSocket_ResponseHandler(std::move(callback)));
}

ChannelProtocol_Stub::ChannelProtocol_Stub(ChannelProtocol_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

ChannelProtocol_Stub::~ChannelProtocol_Stub() = default;

namespace {

class ChannelProtocol_MethodB_Responder final {
 public:
  ChannelProtocol_MethodB_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(internal::kChannelProtocol_MethodB_Ordinal);
    response_.Send(
        &test_name_ChannelProtocolMethodBResponseTable,
        ChannelProtocol_ResponseEncoder::MethodB(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class ChannelProtocol_MutateSocket_Responder final {
 public:
  ChannelProtocol_MutateSocket_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::zx::socket b) {
    ::fidl::Encoder _encoder(internal::kChannelProtocol_MutateSocket_Ordinal);
    response_.Send(
        &test_name_ChannelProtocolMutateSocketResponseTable,
        ChannelProtocol_ResponseEncoder::MutateSocket(&_encoder, &b));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t ChannelProtocol_Stub::Dispatch_(
    ::fidl::Message message, ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type = ChannelProtocol_RequestDecoder::GetType(
      message.ordinal(), &needs_response);
  if (request_type == nullptr) {
    return ZX_ERR_NOT_SUPPORTED;
  }
  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }
  const char* error_msg = nullptr;
  zx_status_t status = message.Decode(request_type, &error_msg);
  if (status != ZX_OK) {
    FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
    return status;
  }
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case internal::kChannelProtocol_MethodA_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MethodA(::fidl::DecodeAs<int64_t>(&decoder, 16),
                     ::fidl::DecodeAs<int64_t>(&decoder, 24));
      break;
    }
    case internal::kChannelProtocol_MethodB_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MethodB(::fidl::DecodeAs<int64_t>(&decoder, 16),
                     ::fidl::DecodeAs<int64_t>(&decoder, 24),
                     ChannelProtocol_MethodB_Responder(std::move(response)));
      break;
    }
    case internal::kChannelProtocol_MutateSocket_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->MutateSocket(
          ::fidl::DecodeAs<::zx::socket>(&decoder, 16),
          ChannelProtocol_MutateSocket_Responder(std::move(response)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void ChannelProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_EventA_Ordinal);
  sender_()->Send(&test_name_ChannelProtocolEventAEventTable,
                  ChannelProtocol_ResponseEncoder::EventA(&_encoder, &a, &b));
}

ChannelProtocol_SyncProxy::ChannelProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

ChannelProtocol_SyncProxy::~ChannelProtocol_SyncProxy() = default;

zx_status_t ChannelProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MethodA_Ordinal);
  return proxy_.Send(
      &test_name_ChannelProtocolMethodARequestTable,
      ChannelProtocol_RequestEncoder::MethodA(&_encoder, &a, &b));
}

zx_status_t ChannelProtocol_SyncProxy::MethodB(int64_t a, int64_t b,
                                               int64_t* out_result) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MethodB_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_ChannelProtocolMethodBRequestTable,
      &test_name_ChannelProtocolMethodBResponseTable,
      ChannelProtocol_RequestEncoder::MethodB(&_encoder, &a, &b), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}

zx_status_t ChannelProtocol_SyncProxy::MutateSocket(::zx::socket a,
                                                    ::zx::socket* out_b) {
  ::fidl::Encoder _encoder(internal::kChannelProtocol_MutateSocket_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_ChannelProtocolMutateSocketRequestTable,
      &test_name_ChannelProtocolMutateSocketResponseTable,
      ChannelProtocol_RequestEncoder::MutateSocket(&_encoder, &a), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_, 16);
  return ZX_OK;
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__
namespace {

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;

extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace

WithAndWithoutRequestResponse::~WithAndWithoutRequestResponse() = default;

const fidl_type_t* WithAndWithoutRequestResponse_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  switch (ordinal) {
    case internal::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal:
      *out_needs_response = false;
      return &test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;
    case internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
      *out_needs_response = true;
      return &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
    case internal::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
      *out_needs_response = true;
      return &test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
    case internal::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal:
      *out_needs_response = false;
      return &test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
    case internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
      *out_needs_response = true;
      return &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
    case internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
      *out_needs_response = true;
      return &test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
    default:
      *out_needs_response = false;
      return nullptr;
  }
}

const fidl_type_t* WithAndWithoutRequestResponse_ResponseDecoder::GetType(
    uint64_t ordinal) {
  switch (ordinal) {
    case internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
    case internal::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
    case internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
    case internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
    case internal::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
    case internal::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
      return &test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;
    default:
      return nullptr;
  }
}

WithAndWithoutRequestResponse_EventSender::
    ~WithAndWithoutRequestResponse_EventSender() = default;

WithAndWithoutRequestResponse_Sync::~WithAndWithoutRequestResponse_Sync() =
    default;

WithAndWithoutRequestResponse_Proxy::WithAndWithoutRequestResponse_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithAndWithoutRequestResponse_Proxy::~WithAndWithoutRequestResponse_Proxy() =
    default;

zx_status_t WithAndWithoutRequestResponse_Proxy::Dispatch_(
    ::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case internal::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      if (!OnEmptyResponse) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(
          &test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable,
          &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable,
            error_msg);
        break;
      }
      OnEmptyResponse();
      break;
    }
    case internal::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      if (!OnWithResponse) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(
          &test_name_WithAndWithoutRequestResponseOnWithResponseEventTable,
          &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(
            message,
            &test_name_WithAndWithoutRequestResponseOnWithResponseEventTable,
            error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnWithResponse(::fidl::DecodeAs<::std::string>(&decoder, 16));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void WithAndWithoutRequestResponse_Proxy::NoRequestNoResponse() {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestNoResponse(
          &_encoder),
      nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(
    WithAndWithoutRequestResponse::NoRequestEmptyResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::NoRequestEmptyResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        callback_();
        return ZX_OK;
      },
      &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestEmptyResponse(
    NoRequestEmptyResponseCallback callback) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestEmptyResponse(
          &_encoder),
      WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(
          std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(
    WithAndWithoutRequestResponse::NoRequestWithResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for "
                      "WithAndWithoutRequestResponse::NoRequestWithResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::string>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestWithResponse(
    NoRequestWithResponseCallback callback) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestWithResponse(
          &_encoder),
      WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(
          std::move(callback)));
}
void WithAndWithoutRequestResponse_Proxy::WithRequestNoResponse(
    ::std::string arg) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestNoResponse(
          &_encoder, &arg),
      nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(
    WithAndWithoutRequestResponse::WithRequestEmptyResponseCallback&&
        callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::WithRequestEmptyResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        callback_();
        return ZX_OK;
      },
      &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestEmptyResponse(
    ::std::string arg, WithRequestEmptyResponseCallback callback) {
  ::fidl::Encoder _encoder(
      internal::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestEmptyResponse(
          &_encoder, &arg),
      WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(
          std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(
    WithAndWithoutRequestResponse::WithRequestWithResponseCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for "
      "WithAndWithoutRequestResponse::WithRequestWithResponse\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::string>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable);
}

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestWithResponse(
    ::std::string arg, WithRequestWithResponseCallback callback) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  controller_->Send(
      &test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestWithResponse(
          &_encoder, &arg),
      WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(
          std::move(callback)));
}

WithAndWithoutRequestResponse_Stub::WithAndWithoutRequestResponse_Stub(
    WithAndWithoutRequestResponse_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

WithAndWithoutRequestResponse_Stub::~WithAndWithoutRequestResponse_Stub() =
    default;

namespace {

class WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()() {
    ::fidl::Encoder _encoder(
        internal::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
    response_.Send(
        &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable,
        WithAndWithoutRequestResponse_ResponseEncoder::NoRequestEmptyResponse(
            &_encoder));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_NoRequestWithResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::string ret) {
    ::fidl::Encoder _encoder(
        internal::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
    response_.Send(
        &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable,
        WithAndWithoutRequestResponse_ResponseEncoder::NoRequestWithResponse(
            &_encoder, &ret));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()() {
    ::fidl::Encoder _encoder(
        internal::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
    response_.Send(
        &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable,
        WithAndWithoutRequestResponse_ResponseEncoder::WithRequestEmptyResponse(
            &_encoder));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithAndWithoutRequestResponse_WithRequestWithResponse_Responder final {
 public:
  WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::string ret) {
    ::fidl::Encoder _encoder(
        internal::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
    response_.Send(
        &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable,
        WithAndWithoutRequestResponse_ResponseEncoder::WithRequestWithResponse(
            &_encoder, &ret));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t WithAndWithoutRequestResponse_Stub::Dispatch_(
    ::fidl::Message message, ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type =
      WithAndWithoutRequestResponse_RequestDecoder::GetType(message.ordinal(),
                                                            &needs_response);
  if (request_type == nullptr) {
    return ZX_ERR_NOT_SUPPORTED;
  }
  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }
  const char* error_msg = nullptr;
  zx_status_t status = message.Decode(request_type, &error_msg);
  if (status != ZX_OK) {
    FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
    return status;
  }
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case internal::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      impl_->NoRequestNoResponse();
      break;
    }
    case internal::
        kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      impl_->NoRequestEmptyResponse(
          WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(
              std::move(response)));
      break;
    }
    case internal::
        kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      impl_->NoRequestWithResponse(
          WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(
              std::move(response)));
      break;
    }
    case internal::
        kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestNoResponse(
          ::fidl::DecodeAs<::std::string>(&decoder, 16));
      break;
    }
    case internal::
        kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestEmptyResponse(
          ::fidl::DecodeAs<::std::string>(&decoder, 16),
          WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(
              std::move(response)));
      break;
    }
    case internal::
        kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->WithRequestWithResponse(
          ::fidl::DecodeAs<::std::string>(&decoder, 16),
          WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(
              std::move(response)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void WithAndWithoutRequestResponse_Stub::OnEmptyResponse() {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
  sender_()->Send(
      &test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable,
      WithAndWithoutRequestResponse_ResponseEncoder::OnEmptyResponse(
          &_encoder));
}
void WithAndWithoutRequestResponse_Stub::OnWithResponse(::std::string ret) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
  sender_()->Send(
      &test_name_WithAndWithoutRequestResponseOnWithResponseEventTable,
      WithAndWithoutRequestResponse_ResponseEncoder::OnWithResponse(&_encoder,
                                                                    &ret));
}

WithAndWithoutRequestResponse_SyncProxy::
    WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithAndWithoutRequestResponse_SyncProxy::
    ~WithAndWithoutRequestResponse_SyncProxy() = default;

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestNoResponse() {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  return proxy_.Send(
      &test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestNoResponse(
          &_encoder));
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestEmptyResponse() {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable,
      &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestEmptyResponse(
          &_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestWithResponse(
    ::std::string* out_ret) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable,
      &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable,
      WithAndWithoutRequestResponse_RequestEncoder::NoRequestWithResponse(
          &_encoder),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_, 16);
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestNoResponse(
    ::std::string arg) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  return proxy_.Send(
      &test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestNoResponse(
          &_encoder, &arg));
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestEmptyResponse(
    ::std::string arg) {
  ::fidl::Encoder _encoder(
      internal::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
      &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestEmptyResponse(
          &_encoder, &arg),
      &response_);
  if (status_ != ZX_OK) return status_;
  return ZX_OK;
}

zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestWithResponse(
    ::std::string arg, ::std::string* out_ret) {
  ::fidl::Encoder _encoder(
      internal::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
      &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable,
      WithAndWithoutRequestResponse_RequestEncoder::WithRequestWithResponse(
          &_encoder, &arg),
      &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_, 16);
  return ZX_OK;
}

#endif  // __Fuchsia__

extern "C" const fidl_type_t test_name_WithErrorSyntax_ErrorAsEnum_ResultTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Result::FidlType =
    &test_name_WithErrorSyntax_ErrorAsEnum_ResultTable;

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() {}

WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
  Destroy();
}

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result(
    WithErrorSyntax_ErrorAsEnum_Result&& other)
    : tag_(other.tag_) {
  switch (tag_) {
    case Tag::kResponse:
      new (&response_) class WithErrorSyntax_ErrorAsEnum_Response();
      response_ = std::move(other.response_);
      break;
    case Tag::kErr:
      new (&err_) ErrorEnun();
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
      break;
  }
}

WithErrorSyntax_ErrorAsEnum_Result&
WithErrorSyntax_ErrorAsEnum_Result::operator=(
    WithErrorSyntax_ErrorAsEnum_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ErrorAsEnum_Response();
        response_ = std::move(other.response_);
        break;
      case Tag::kErr:
        new (&err_) ErrorEnun();
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
    }
  }
  return *this;
}

WithErrorSyntax_ErrorAsEnum_Result
WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
    class WithErrorSyntax_ErrorAsEnum_Response&& val) {
  WithErrorSyntax_ErrorAsEnum_Result result;
  result.set_response(std::move(val));
  return result;
}
WithErrorSyntax_ErrorAsEnum_Result WithErrorSyntax_ErrorAsEnum_Result::WithErr(
    ErrorEnun&& val) {
  WithErrorSyntax_ErrorAsEnum_Result result;
  result.set_err(std::move(val));
  return result;
}

void WithErrorSyntax_ErrorAsEnum_Result::Encode(::fidl::Encoder* encoder,
                                                size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kResponse: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<class WithErrorSyntax_ErrorAsEnum_Response,
                                     ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &response_, envelope_offset);
      break;
    }
    case Tag::kErr: {
      envelope_offset = encoder->Alloc(
          ::fidl::EncodingInlineSize<ErrorEnun, ::fidl::Encoder>(encoder));
      ::fidl::Encode(encoder, &err_, envelope_offset);
      break;
    }
    default:
      break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles =
        encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void WithErrorSyntax_ErrorAsEnum_Result::Decode(
    ::fidl::Decoder* decoder, WithErrorSyntax_ErrorAsEnum_Result* value,
    size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(
        static_cast<fidl_xunion_tag_t>(Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
    case Tag::kResponse:
      new (&value->response_) class WithErrorSyntax_ErrorAsEnum_Response();
      ::fidl::Decode(decoder, &value->response_, envelope_offset);
      break;
    case Tag::kErr:
      new (&value->err_) ErrorEnun();
      ::fidl::Decode(decoder, &value->err_, envelope_offset);
      break;
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Result::Clone(
    WithErrorSyntax_ErrorAsEnum_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::Invalid:
      return ZX_OK;
    case Tag::kResponse:
      new (&result->response_) class WithErrorSyntax_ErrorAsEnum_Response();
      return ::fidl::Clone(response_, &result->response_);
    case Tag::kErr:
      new (&result->err_) ErrorEnun();
      return ::fidl::Clone(err_, &result->err_);
    default:
      return ZX_OK;
  }
}

WithErrorSyntax_ErrorAsEnum_Result&
WithErrorSyntax_ErrorAsEnum_Result::set_response(
    class WithErrorSyntax_ErrorAsEnum_Response value) {
  EnsureStorageInitialized(Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

WithErrorSyntax_ErrorAsEnum_Result& WithErrorSyntax_ErrorAsEnum_Result::set_err(
    ErrorEnun value) {
  EnsureStorageInitialized(Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void WithErrorSyntax_ErrorAsEnum_Result::Destroy() {
  switch (tag_) {
    case Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case Tag::kErr:
      err_.~decltype(err_)();
      break;

    default:
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(Tag::Invalid);
}

void WithErrorSyntax_ErrorAsEnum_Result::EnsureStorageInitialized(
    ::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(Tag::Invalid):
        break;
      case Tag::kResponse:
        new (&response_) class WithErrorSyntax_ErrorAsEnum_Response();
        break;
      case Tag::kErr:
        new (&err_) ErrorEnun();
        break;
      default:
        break;
    }
  }
}
#ifdef __Fuchsia__
namespace {

extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructResponseTable;

extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;

extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace

WithErrorSyntax::~WithErrorSyntax() = default;

const fidl_type_t* WithErrorSyntax_RequestDecoder::GetType(
    uint64_t ordinal, bool* out_needs_response) {
  switch (ordinal) {
    case internal::kWithErrorSyntax_ResponseAsStruct_Ordinal:
      *out_needs_response = true;
      return &test_name_WithErrorSyntaxResponseAsStructRequestTable;
    case internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
      *out_needs_response = true;
      return &test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
    case internal::kWithErrorSyntax_ErrorAsEnum_Ordinal:
      *out_needs_response = true;
      return &test_name_WithErrorSyntaxErrorAsEnumRequestTable;
    default:
      *out_needs_response = false;
      return nullptr;
  }
}

const fidl_type_t* WithErrorSyntax_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case internal::kWithErrorSyntax_ResponseAsStruct_Ordinal:
      return &test_name_WithErrorSyntaxResponseAsStructResponseTable;
    case internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
      return &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
    case internal::kWithErrorSyntax_ErrorAsEnum_Ordinal:
      return &test_name_WithErrorSyntaxErrorAsEnumResponseTable;
    default:
      return nullptr;
  }
}

WithErrorSyntax_EventSender::~WithErrorSyntax_EventSender() = default;

WithErrorSyntax_Sync::~WithErrorSyntax_Sync() = default;

WithErrorSyntax_Proxy::WithErrorSyntax_Proxy(
    ::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithErrorSyntax_Proxy::~WithErrorSyntax_Proxy() = default;

zx_status_t WithErrorSyntax_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ResponseAsStruct_ResponseHandler(
    WithErrorSyntax::ResponseAsStructCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ResponseAsStruct\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<WithErrorSyntax_ResponseAsStruct_Result>(
            &decoder, 16));
        return ZX_OK;
      },
      &test_name_WithErrorSyntaxResponseAsStructResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ResponseAsStruct(
    ResponseAsStructCallback callback) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
  controller_->Send(
      &test_name_WithErrorSyntaxResponseAsStructRequestTable,
      WithErrorSyntax_RequestEncoder::ResponseAsStruct(&_encoder),
      WithErrorSyntax_ResponseAsStruct_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(
    WithErrorSyntax::ErrorAsPrimitiveCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ErrorAsPrimitive\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<WithErrorSyntax_ErrorAsPrimitive_Result>(
            &decoder, 16));
        return ZX_OK;
      },
      &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsPrimitive(
    ErrorAsPrimitiveCallback callback) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  controller_->Send(
      &test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable,
      WithErrorSyntax_RequestEncoder::ErrorAsPrimitive(&_encoder),
      WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
WithErrorSyntax_ErrorAsEnum_ResponseHandler(
    WithErrorSyntax::ErrorAsEnumCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(
      callback,
      "Callback must not be empty for WithErrorSyntax::ErrorAsEnum\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::Message&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(
            ::fidl::DecodeAs<WithErrorSyntax_ErrorAsEnum_Result>(&decoder, 16));
        return ZX_OK;
      },
      &test_name_WithErrorSyntaxErrorAsEnumResponseTable);
}

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsEnum(ErrorAsEnumCallback callback) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
  controller_->Send(
      &test_name_WithErrorSyntaxErrorAsEnumRequestTable,
      WithErrorSyntax_RequestEncoder::ErrorAsEnum(&_encoder),
      WithErrorSyntax_ErrorAsEnum_ResponseHandler(std::move(callback)));
}

WithErrorSyntax_Stub::WithErrorSyntax_Stub(WithErrorSyntax_clazz* impl)
    : impl_(impl) {
  (void)impl_;
}

WithErrorSyntax_Stub::~WithErrorSyntax_Stub() = default;

namespace {

class WithErrorSyntax_ResponseAsStruct_Responder final {
 public:
  WithErrorSyntax_ResponseAsStruct_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(WithErrorSyntax_ResponseAsStruct_Result result) {
    ::fidl::Encoder _encoder(
        internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
    response_.Send(
        &test_name_WithErrorSyntaxResponseAsStructResponseTable,
        WithErrorSyntax_ResponseEncoder::ResponseAsStruct(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithErrorSyntax_ErrorAsPrimitive_Responder final {
 public:
  WithErrorSyntax_ErrorAsPrimitive_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(WithErrorSyntax_ErrorAsPrimitive_Result result) {
    ::fidl::Encoder _encoder(
        internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
    response_.Send(
        &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable,
        WithErrorSyntax_ResponseEncoder::ErrorAsPrimitive(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class WithErrorSyntax_ErrorAsEnum_Responder final {
 public:
  WithErrorSyntax_ErrorAsEnum_Responder(
      ::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(WithErrorSyntax_ErrorAsEnum_Result result) {
    ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
    response_.Send(
        &test_name_WithErrorSyntaxErrorAsEnumResponseTable,
        WithErrorSyntax_ResponseEncoder::ErrorAsEnum(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t WithErrorSyntax_Stub::Dispatch_(
    ::fidl::Message message, ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type = WithErrorSyntax_RequestDecoder::GetType(
      message.ordinal(), &needs_response);
  if (request_type == nullptr) {
    return ZX_ERR_NOT_SUPPORTED;
  }
  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type,
                                 "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }
  const char* error_msg = nullptr;
  zx_status_t status = message.Decode(request_type, &error_msg);
  if (status != ZX_OK) {
    FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
    return status;
  }
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case internal::kWithErrorSyntax_ResponseAsStruct_Ordinal: {
      impl_->ResponseAsStruct(
          WithErrorSyntax_ResponseAsStruct_Responder(std::move(response)));
      break;
    }
    case internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      impl_->ErrorAsPrimitive(
          WithErrorSyntax_ErrorAsPrimitive_Responder(std::move(response)));
      break;
    }
    case internal::kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      impl_->ErrorAsEnum(
          WithErrorSyntax_ErrorAsEnum_Responder(std::move(response)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

WithErrorSyntax_SyncProxy::WithErrorSyntax_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithErrorSyntax_SyncProxy::~WithErrorSyntax_SyncProxy() = default;

zx_status_t WithErrorSyntax_SyncProxy::ResponseAsStruct(
    WithErrorSyntax_ResponseAsStruct_Result* out_result) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ResponseAsStruct_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithErrorSyntaxResponseAsStructRequestTable,
      &test_name_WithErrorSyntaxResponseAsStructResponseTable,
      WithErrorSyntax_RequestEncoder::ResponseAsStruct(&_encoder), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result =
      ::fidl::DecodeAs<WithErrorSyntax_ResponseAsStruct_Result>(&decoder_, 16);
  return ZX_OK;
}

zx_status_t WithErrorSyntax_SyncProxy::ErrorAsPrimitive(
    WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable,
      &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable,
      WithErrorSyntax_RequestEncoder::ErrorAsPrimitive(&_encoder), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result =
      ::fidl::DecodeAs<WithErrorSyntax_ErrorAsPrimitive_Result>(&decoder_, 16);
  return ZX_OK;
}

zx_status_t WithErrorSyntax_SyncProxy::ErrorAsEnum(
    WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  ::fidl::Encoder _encoder(internal::kWithErrorSyntax_ErrorAsEnum_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(
      &test_name_WithErrorSyntaxErrorAsEnumRequestTable,
      &test_name_WithErrorSyntaxErrorAsEnumResponseTable,
      WithErrorSyntax_RequestEncoder::ErrorAsEnum(&_encoder), &response_);
  if (status_ != ZX_OK) return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result =
      ::fidl::DecodeAs<WithErrorSyntax_ErrorAsEnum_Result>(&decoder_, 16);
  return ZX_OK;
}

#endif  // __Fuchsia__

}  // namespace name
}  // namespace test

// WARNING: This file is machine generated by fidlgen.

#include <byte_and_bytes.test.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace example {

extern "C" const fidl_type_t v1_example_ByteAndBytesTable;
const fidl_type_t* ByteAndBytes::FidlType = &v1_example_ByteAndBytesTable;

void ByteAndBytes::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &single_byte, _offset + 0);
  ::fidl::Encode(_encoder, &many_bytes, _offset + 8);
  ::fidl::Encode(_encoder, &only_one_k_bytes, _offset + 24);
  ::fidl::Encode(_encoder, &opt_only_one_k_bytes, _offset + 40);
}

void ByteAndBytes::Decode(::fidl::Decoder* _decoder, ByteAndBytes* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->single_byte, _offset + 0);
  ::fidl::Decode(_decoder, &value->many_bytes, _offset + 8);
  ::fidl::Decode(_decoder, &value->only_one_k_bytes, _offset + 24);
  ::fidl::Decode(_decoder, &value->opt_only_one_k_bytes, _offset + 40);
}

zx_status_t ByteAndBytes::Clone(ByteAndBytes* _result) const {
  zx_status_t _status = ::fidl::Clone(single_byte, &_result->single_byte);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(many_bytes, &_result->many_bytes);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(only_one_k_bytes, &_result->only_one_k_bytes);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_only_one_k_bytes, &_result->opt_only_one_k_bytes);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
}  // namespace example


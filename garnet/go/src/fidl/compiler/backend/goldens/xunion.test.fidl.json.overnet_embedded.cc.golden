// WARNING: This file is machine generated by fidlgen.

#include <xunion.test.fidl.json.overnet_embedded.h>

#include "src/connectivity/overnet/lib/embedded/implementation.h"
namespace test {
namespace name {
namespace embedded {

extern "C" const fidl_type_t test_name_OlderSimpleUnionTable;
const fidl_type_t* OlderSimpleUnion::FidlType = &test_name_OlderSimpleUnionTable;

OlderSimpleUnion::OlderSimpleUnion() {}

OlderSimpleUnion::~OlderSimpleUnion() {
  Destroy();
}

OlderSimpleUnion::OlderSimpleUnion(OlderSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kI:
    i_ = std::move(other.i_);
    break;
   case Tag::kF:
    f_ = std::move(other.f_);
    break;
   default:
    break;
  }
}

OlderSimpleUnion& OlderSimpleUnion::operator=(OlderSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     case Tag::kI:
      i_ = std::move(other.i_);
      break;
     case Tag::kF:
      f_ = std::move(other.f_);
      break;
     default:
      break;
    }
  }
  return *this;
}

void OlderSimpleUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kI: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case Tag::kF: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<float>::encoded_size);
      ::fidl::Encode(encoder, &f_, envelope_offset);
      break;
    }
    case Tag::Empty:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void OlderSimpleUnion::Decode(::overnet::internal::Decoder* decoder, OlderSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(Tag::Empty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kI:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case Tag::kF:
    ::fidl::Decode(decoder, &value->f_, envelope_offset);
    break;
   default:
    break;
  }

}

zx_status_t OlderSimpleUnion::Clone(OlderSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kI:
      return ::fidl::Clone(i_, &result->i_);
    case Tag::kF:
      return ::fidl::Clone(f_, &result->f_);
    default:
      return ZX_OK;
  }
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const OlderSimpleUnion& lhs, const OlderSimpleUnion& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }

  switch (lhs.tag_) {
    case OlderSimpleUnion::Tag::kI:
      return ::fidl::Equals(lhs.i_, rhs.i_);
    case OlderSimpleUnion::Tag::kF:
      return ::fidl::Equals(lhs.f_, rhs.f_);
    case OlderSimpleUnion::Tag::Empty:
      return true;
    default:
      return false;
  }
  }
#endif

void OlderSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(Tag::kI);
  i_ = std::move(value);
}

void OlderSimpleUnion::set_f(float value) {
  EnsureStorageInitialized(Tag::kF);
  f_ = std::move(value);
}

void OlderSimpleUnion::Destroy() {
  switch (tag_) {
   case Tag::kI:
    break;
   case Tag::kF:
    break;
   default:
    break;
  }
  tag_ = Tag::Empty;
}

void OlderSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_NewerSimpleUnionTable;
const fidl_type_t* NewerSimpleUnion::FidlType = &test_name_NewerSimpleUnionTable;

NewerSimpleUnion::NewerSimpleUnion() {}

NewerSimpleUnion::~NewerSimpleUnion() {
  Destroy();
}

NewerSimpleUnion::NewerSimpleUnion(NewerSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kI:
    i_ = std::move(other.i_);
    break;
   case Tag::kS:
    new (&s_) ::std::string();
    s_ = std::move(other.s_);
    break;
   case Tag::kV:
    new (&v_) ::std::vector<::std::string>();
    v_ = std::move(other.v_);
    break;
   default:
    break;
  }
}

NewerSimpleUnion& NewerSimpleUnion::operator=(NewerSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
     case Tag::kI:
      i_ = std::move(other.i_);
      break;
     case Tag::kS:
      new (&s_) ::std::string();
      s_ = std::move(other.s_);
      break;
     case Tag::kV:
      new (&v_) ::std::vector<::std::string>();
      v_ = std::move(other.v_);
      break;
     default:
      break;
    }
  }
  return *this;
}

void NewerSimpleUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kI: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case Tag::kS: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::string>::encoded_size);
      ::fidl::Encode(encoder, &s_, envelope_offset);
      break;
    }
    case Tag::kV: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::vector<::std::string>>::encoded_size);
      ::fidl::Encode(encoder, &v_, envelope_offset);
      break;
    }
    case Tag::Empty:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void NewerSimpleUnion::Decode(::overnet::internal::Decoder* decoder, NewerSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(Tag::Empty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kI:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case Tag::kS:
    new (&value->s_) ::std::string();
    ::fidl::Decode(decoder, &value->s_, envelope_offset);
    break;
   case Tag::kV:
    new (&value->v_) ::std::vector<::std::string>();
    ::fidl::Decode(decoder, &value->v_, envelope_offset);
    break;
   default:
    break;
  }

}

zx_status_t NewerSimpleUnion::Clone(NewerSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kI:
      return ::fidl::Clone(i_, &result->i_);
    case Tag::kS:
      new (&result->s_) ::std::string();
      return ::fidl::Clone(s_, &result->s_);
    case Tag::kV:
      new (&result->v_) ::std::vector<::std::string>();
      return ::fidl::Clone(v_, &result->v_);
    default:
      return ZX_OK;
  }
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const NewerSimpleUnion& lhs, const NewerSimpleUnion& rhs) {
  if (lhs.tag_ != rhs.tag_) {
    return false;
  }

  switch (lhs.tag_) {
    case NewerSimpleUnion::Tag::kI:
      return ::fidl::Equals(lhs.i_, rhs.i_);
    case NewerSimpleUnion::Tag::kS:
      return ::fidl::Equals(lhs.s_, rhs.s_);
    case NewerSimpleUnion::Tag::kV:
      return ::fidl::Equals(lhs.v_, rhs.v_);
    case NewerSimpleUnion::Tag::Empty:
      return true;
    default:
      return false;
  }
  }
#endif

void NewerSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(Tag::kI);
  i_ = std::move(value);
}

void NewerSimpleUnion::set_s(::std::string value) {
  EnsureStorageInitialized(Tag::kS);
  s_ = std::move(value);
}

void NewerSimpleUnion::set_v(::std::vector<::std::string> value) {
  EnsureStorageInitialized(Tag::kV);
  v_ = std::move(value);
}

void NewerSimpleUnion::Destroy() {
  switch (tag_) {
   case Tag::kI:
    break;
   case Tag::kS:
    s_.~basic_string();
    break;
   case Tag::kV:
    v_.~vector();
    break;
   default:
    break;
  }
  tag_ = Tag::Empty;
}

void NewerSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case Tag::kS:
        new (&s_) ::std::string();
        break;
      case Tag::kV:
        new (&v_) ::std::vector<::std::string>();
        break;
      default:
        break;
    }
  }
}

}  // namespace embedded
}  // namespace name
}  // namespace test

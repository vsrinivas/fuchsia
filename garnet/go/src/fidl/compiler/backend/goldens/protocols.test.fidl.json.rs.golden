// WARNING: This file is machine generated by fidlgen.

#![allow(
	deprecated, // FIDL Impl struct pattern is referenced internally
	unused_parens, // one-element-tuple-case is not a tuple
	unused_mut, // not all args require mutation, but many do
	nonstandard_style, // auto-caps does its best, but is not always successful
)]

#[cfg(target_os = "fuchsia")]
#[allow(unused_imports)]
use fuchsia_zircon as zx;
#[allow(unused_imports)]
use fuchsia_zircon_status as zx_status;
#[allow(unused_imports)]
use fidl::{
	fidl_bits,
	fidl_enum,
	fidl_empty_struct,
	fidl_struct,
	fidl_table,
	fidl_union,
	fidl_xunion,
};


fidl_enum! {
  ErrorEnun(u32) {
    ErrFoo = 1,
    ErrBar = 2,
  }
}


pub type WithErrorSyntaxResponseAsStructResult = std::result::Result< (
      i64,
      i64,
      i64,
), u32 >;

pub type WithErrorSyntaxErrorAsPrimitiveResult = std::result::Result< (
), u32 >;

pub type WithErrorSyntaxErrorAsEnumResult = std::result::Result< (
), ErrorEnun >;

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WithErrorSyntaxResponseAsStructResponse {
  pub a: i64,
  pub b: i64,
  pub c: i64,
}

fidl_struct! {
  name: WithErrorSyntaxResponseAsStructResponse,
  members: [
    a {
      ty: i64,
      offset_old: 0,
      offset_v1: 0,
    },
    b {
      ty: i64,
      offset_old: 8,
      offset_v1: 8,
    },
    c {
      ty: i64,
      offset_old: 16,
      offset_v1: 16,
    },
  ],
  size_old: 24,
  align_old: 8,
  size_v1: 24,
  align_v1: 8,
}


fidl_empty_struct!(
	WithErrorSyntaxErrorAsPrimitiveResponse
);


fidl_empty_struct!(
	WithErrorSyntaxErrorAsEnumResponse
);


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WithAndWithoutRequestResponseMarker;

impl fidl::endpoints::ServiceMarker for WithAndWithoutRequestResponseMarker {
	type Proxy = WithAndWithoutRequestResponseProxy;
	type RequestStream = WithAndWithoutRequestResponseRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) WithAndWithoutRequestResponse";
}

pub trait WithAndWithoutRequestResponseProxyInterface: Send + Sync {
	fn no_request_no_response(&self,
	)-> Result<(), fidl::Error>;
	type NoRequestEmptyResponseResponseFut: std::future::Future<Output = Result<(), fidl::Error>> + Send;
	fn no_request_empty_response(&self,
	)-> Self::NoRequestEmptyResponseResponseFut;
	type NoRequestWithResponseResponseFut: std::future::Future<Output = Result<(String), fidl::Error>> + Send;
	fn no_request_with_response(&self,
	)-> Self::NoRequestWithResponseResponseFut;
	fn with_request_no_response(&self,
		arg: &str,
	)-> Result<(), fidl::Error>;
	type WithRequestEmptyResponseResponseFut: std::future::Future<Output = Result<(), fidl::Error>> + Send;
	fn with_request_empty_response(&self,
		arg: &str,
	)-> Self::WithRequestEmptyResponseResponseFut;
	type WithRequestWithResponseResponseFut: std::future::Future<Output = Result<(String), fidl::Error>> + Send;
	fn with_request_with_response(&self,
		arg: &str,
	)-> Self::WithRequestWithResponseResponseFut;
	type OnEmptyResponseResponseFut: std::future::Future<Output = Result<(), fidl::Error>> + Send;
	type OnWithResponseResponseFut: std::future::Future<Output = Result<(String), fidl::Error>> + Send;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct WithAndWithoutRequestResponseSynchronousProxy {
	client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl WithAndWithoutRequestResponseSynchronousProxy {
	pub fn new(channel: ::fidl::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> ::fidl::Channel {
		self.client.into_channel()
	}
	pub fn no_request_no_response(&mut self,) -> Result<(), fidl::Error> {self.client.send(&mut (),
				0x1e03f87500000000,
			)}
	pub fn no_request_empty_response(&mut self,___deadline: zx::Time,) -> Result<(), fidl::Error> {self.client.send_query(&mut (),
				0x4df6dbd500000000,
				___deadline,
			)}
	pub fn no_request_with_response(&mut self,___deadline: zx::Time,) -> Result<(String), fidl::Error> {self.client.send_query(&mut (),
				0x668d7f800000000,
				___deadline,
			)}
	pub fn with_request_no_response(&mut self,
		mut arg: &str,) -> Result<(), fidl::Error> {self.client.send(&mut (arg),
				0x19c2137100000000,
			)}
	pub fn with_request_empty_response(&mut self,
		mut arg: &str,___deadline: zx::Time,) -> Result<(), fidl::Error> {self.client.send_query(&mut (arg),
				0x76f2397300000000,
				___deadline,
			)}
	pub fn with_request_with_response(&mut self,
		mut arg: &str,___deadline: zx::Time,) -> Result<(String), fidl::Error> {self.client.send_query(&mut (arg),
				0x1973292000000000,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct WithAndWithoutRequestResponseProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for WithAndWithoutRequestResponseProxy {
	type Service = WithAndWithoutRequestResponseMarker;
	fn from_channel(inner: ::fidl::AsyncChannel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for WithAndWithoutRequestResponseProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

impl WithAndWithoutRequestResponseProxy {
	/// Create a new Proxy for WithAndWithoutRequestResponse
	pub fn new(channel: ::fidl::AsyncChannel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the WithAndWithoutRequestResponse interface
	pub fn take_event_stream(&self) -> WithAndWithoutRequestResponseEventStream {
		WithAndWithoutRequestResponseEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn no_request_no_response(&self,
	)-> Result<(), fidl::Error> {
		WithAndWithoutRequestResponseProxyInterface::no_request_no_response(self,
		)
	}
	pub fn no_request_empty_response(&self,
	)-> fidl::client::QueryResponseFut<()> {
		WithAndWithoutRequestResponseProxyInterface::no_request_empty_response(self,
		)
	}
	pub fn no_request_with_response(&self,
	)-> fidl::client::QueryResponseFut<(String)> {
		WithAndWithoutRequestResponseProxyInterface::no_request_with_response(self,
		)
	}
	pub fn with_request_no_response(&self,
		mut arg: &str,
	)-> Result<(), fidl::Error> {
		WithAndWithoutRequestResponseProxyInterface::with_request_no_response(self,
		arg,
		)
	}
	pub fn with_request_empty_response(&self,
		mut arg: &str,
	)-> fidl::client::QueryResponseFut<()> {
		WithAndWithoutRequestResponseProxyInterface::with_request_empty_response(self,
		arg,
		)
	}
	pub fn with_request_with_response(&self,
		mut arg: &str,
	)-> fidl::client::QueryResponseFut<(String)> {
		WithAndWithoutRequestResponseProxyInterface::with_request_with_response(self,
		arg,
		)
	}
}

impl WithAndWithoutRequestResponseProxyInterface for WithAndWithoutRequestResponseProxy {
	fn no_request_no_response(&self,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (), 0x1e03f87500000000)
	}
	type NoRequestEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	fn no_request_empty_response(&self,
	)-> Self::NoRequestEmptyResponseResponseFut {
		self.client.send_query(&mut (), 0x4df6dbd500000000)
	}
	type NoRequestWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;
	fn no_request_with_response(&self,
	)-> Self::NoRequestWithResponseResponseFut {
		self.client.send_query(&mut (), 0x668d7f800000000)
	}
	fn with_request_no_response(&self,
		mut arg: &str,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (arg), 0x19c2137100000000)
	}
	type WithRequestEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	fn with_request_empty_response(&self,
		mut arg: &str,
	)-> Self::WithRequestEmptyResponseResponseFut {
		self.client.send_query(&mut (arg), 0x76f2397300000000)
	}
	type WithRequestWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;
	fn with_request_with_response(&self,
		mut arg: &str,
	)-> Self::WithRequestWithResponseResponseFut {
		self.client.send_query(&mut (arg), 0x1973292000000000)
	}
	type OnEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	type OnWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;}

pub struct WithAndWithoutRequestResponseEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for WithAndWithoutRequestResponseEventStream {}

impl futures::stream::FusedStream for WithAndWithoutRequestResponseEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for WithAndWithoutRequestResponseEventStream {
	type Item = Result<WithAndWithoutRequestResponseEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return std::task::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		std::task::Poll::Ready(Some(match tx_header.ordinal() {
			0x697fd73200000000 | 0x42e90e9a86944b3 => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&tx_header, _body_bytes, _handles, &mut out_tuple)?;
				Ok((
					WithAndWithoutRequestResponseEvent::OnEmptyResponse {}
				))
			}
			0x7a47120700000000 | 0x2a9767b3ae6c2b09 => {
				let mut out_tuple: (String) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&tx_header, _body_bytes, _handles, &mut out_tuple)?;
				Ok((
					WithAndWithoutRequestResponseEvent::OnWithResponse {ret: out_tuple,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal(),
				service_name: <WithAndWithoutRequestResponseMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum WithAndWithoutRequestResponseEvent {
	
	
	
	
	
	
	
	
	OnEmptyResponse {
		
	},
	
	OnWithResponse {
		
		ret: String,
		
	},}

impl WithAndWithoutRequestResponseEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_on_empty_response(self) -> Option<(
	)> {
		if let WithAndWithoutRequestResponseEvent::OnEmptyResponse {
		} = self {
			Some(())
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_on_with_response(self) -> Option<(String
	)> {
		if let WithAndWithoutRequestResponseEvent::OnWithResponse {
			ret,
			
		} = self {
			Some((ret))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send responses and events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
#[deprecated(note = "Use WithAndWithoutRequestResponseRequestStream / Responder instead")]
pub struct WithAndWithoutRequestResponseServerSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a ::fidl::Channel,
}

impl <'a> WithAndWithoutRequestResponseServerSender<'a> {
	pub fn new(channel: &'a ::fidl::Channel) -> Self {
		Self { channel }
	}
	pub fn send_no_request_empty_response_response(&self,
		txid: fidl::client::Txid) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_no_request_empty_response_response(
				bytes, handles,
				txid.as_raw_id(),)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_no_request_with_response_response(&self,
		txid: fidl::client::Txid,
		mut ret: &str) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_no_request_with_response_response(
				bytes, handles,
				txid.as_raw_id(),ret,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_with_request_empty_response_response(&self,
		txid: fidl::client::Txid) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_with_request_empty_response_response(
				bytes, handles,
				txid.as_raw_id(),)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_with_request_with_response_response(&self,
		txid: fidl::client::Txid,
		mut ret: &str) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_with_request_with_response_response(
				bytes, handles,
				txid.as_raw_id(),ret,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_on_empty_response(&self) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_on_empty_response_response(
				bytes, handles,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_on_with_response(&self,
		mut ret: &str) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_on_with_response_response(
				bytes, handles,ret,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}

/// A Stream of incoming requests for WithAndWithoutRequestResponse
pub struct WithAndWithoutRequestResponseRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for WithAndWithoutRequestResponseRequestStream {}

impl futures::stream::FusedStream for WithAndWithoutRequestResponseRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for WithAndWithoutRequestResponseRequestStream {
	type Service = WithAndWithoutRequestResponseMarker;

	/// Consume a channel to make a WithAndWithoutRequestResponseRequestStream
	fn from_channel(channel: ::fidl::AsyncChannel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = WithAndWithoutRequestResponseControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		WithAndWithoutRequestResponseControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for WithAndWithoutRequestResponseRequestStream {
	type Item = Result<WithAndWithoutRequestResponseRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return std::task::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled WithAndWithoutRequestResponseRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				std::task::Poll::Ready(Ok(())) => {},
				std::task::Poll::Pending => return std::task::Poll::Pending,
				std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return std::task::Poll::Ready(None);
				}
				std::task::Poll::Ready(Err(e)) => return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
			if !header.is_compatible() {
				return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(header.magic_number()))));
			}

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			std::task::Poll::Ready(Some(match header.ordinal() {
				0x1e03f87500000000 | 0x3931f96bc77fba8 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestNoResponse {control_handle,})
				}
				0x4df6dbd500000000 | 0x706ec7bd335005f9 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse {responder:WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x668d7f800000000 | 0x4625ad5934067a48 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestWithResponse {responder:WithAndWithoutRequestResponseNoRequestWithResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x19c2137100000000 | 0x46e5095902913025 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestNoResponse {arg: req,control_handle,})
				}
				0x76f2397300000000 | 0x180c481d4a15967 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse {arg: req,responder:WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x1973292000000000 | 0x553860267eceec0 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestWithResponse {arg: req,responder:WithAndWithoutRequestResponseWithRequestWithResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal(),
					service_name: <WithAndWithoutRequestResponseMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}

/// Represents a single request.
/// RequestMessages should only be used for manual deserialization when higher level
/// structs such as RequestStream cannot be used. One usually would only encounter
/// such scenarios when working with legacy FIDL code (prior to FIDL generated client/server bindings).
#[derive(Debug)]
#[deprecated(note = "Use WithAndWithoutRequestResponseRequest instead")]
pub enum WithAndWithoutRequestResponseRequestMessage {
	NoRequestNoResponse {
		},
	NoRequestEmptyResponse {
		tx_id: fidl::client::Txid,},
	NoRequestWithResponse {
		tx_id: fidl::client::Txid,},
	WithRequestNoResponse {
		
		arg: String,
		},
	WithRequestEmptyResponse {
		
		arg: String,
		tx_id: fidl::client::Txid,},
	WithRequestWithResponse {
		
		arg: String,
		tx_id: fidl::client::Txid,},
}

impl WithAndWithoutRequestResponseRequestMessage {
	pub fn decode(bytes: &[u8], _handles: &mut [fidl::Handle]) -> Result<WithAndWithoutRequestResponseRequestMessage, fidl::Error> {
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		match header.ordinal() {
			0x1e03f87500000000 | 0x3931f96bc77fba8 => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::NoRequestNoResponse {})
			}
			0x4df6dbd500000000 | 0x706ec7bd335005f9 => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::NoRequestEmptyResponse {tx_id: header.tx_id().into(),})
			}
			0x668d7f800000000 | 0x4625ad5934067a48 => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::NoRequestWithResponse {tx_id: header.tx_id().into(),})
			}
			0x19c2137100000000 | 0x46e5095902913025 => {
				let mut out_tuple: (String) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::WithRequestNoResponse {arg: out_tuple,})
			}
			0x76f2397300000000 | 0x180c481d4a15967 => {
				let mut out_tuple: (String) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::WithRequestEmptyResponse {arg: out_tuple,tx_id: header.tx_id().into(),})
			}
			0x1973292000000000 | 0x553860267eceec0 => {
				let mut out_tuple: (String) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithAndWithoutRequestResponseRequestMessage::WithRequestWithResponse {arg: out_tuple,tx_id: header.tx_id().into(),})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal(),
				service_name: <WithAndWithoutRequestResponseMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			}),
		}
	}


}
#[derive(Debug)]
pub enum WithAndWithoutRequestResponseRequest {
	NoRequestNoResponse {
		control_handle: WithAndWithoutRequestResponseControlHandle,},
	NoRequestEmptyResponse {
		responder: WithAndWithoutRequestResponseNoRequestEmptyResponseResponder,},
	NoRequestWithResponse {
		responder: WithAndWithoutRequestResponseNoRequestWithResponseResponder,},
	WithRequestNoResponse {
		
		arg: String,
		control_handle: WithAndWithoutRequestResponseControlHandle,},
	WithRequestEmptyResponse {
		
		arg: String,
		responder: WithAndWithoutRequestResponseWithRequestEmptyResponseResponder,},
	WithRequestWithResponse {
		
		arg: String,
		responder: WithAndWithoutRequestResponseWithRequestWithResponseResponder,},
}

impl WithAndWithoutRequestResponseRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_no_response(self) -> Option<(WithAndWithoutRequestResponseControlHandle
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestNoResponse {control_handle,
		} = self {
			Some((control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_empty_response(self) -> Option<(WithAndWithoutRequestResponseNoRequestEmptyResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_with_response(self) -> Option<(WithAndWithoutRequestResponseNoRequestWithResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestWithResponse {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_no_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseControlHandle
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestNoResponse {
			arg,
			control_handle,
		} = self {
			Some((arg,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_empty_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseWithRequestEmptyResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse {
			arg,
			responder,
		} = self {
			Some((arg,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_with_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseWithRequestWithResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestWithResponse {
			arg,
			responder,
		} = self {
			Some((arg,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                WithAndWithoutRequestResponseRequest::NoRequestNoResponse{..} => "no_request_no_response",
                WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse{..} => "no_request_empty_response",
                WithAndWithoutRequestResponseRequest::NoRequestWithResponse{..} => "no_request_with_response",
                WithAndWithoutRequestResponseRequest::WithRequestNoResponse{..} => "with_request_no_response",
                WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse{..} => "with_request_empty_response",
                WithAndWithoutRequestResponseRequest::WithRequestWithResponse{..} => "with_request_with_response",
          }
        }
}

pub struct WithAndWithoutRequestResponseEncoder;

impl WithAndWithoutRequestResponseEncoder {
	pub fn encode_no_request_no_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x1e03f87500000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_empty_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4df6dbd500000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4df6dbd500000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_with_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x668d7f800000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x668d7f800000000);
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_no_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x19c2137100000000);
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_empty_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x76f2397300000000);
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x76f2397300000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_with_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x1973292000000000);
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x1973292000000000);
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_on_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x697fd73200000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_on_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x7a47120700000000);
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct WithAndWithoutRequestResponseControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for WithAndWithoutRequestResponseControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl WithAndWithoutRequestResponseControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}

	pub fn shutdown_with_epitaph(&self, status: zx_status::Status) {
		self.inner.shutdown_with_epitaph(status)
	}
	pub fn send_on_empty_response(&self) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			0, 0x697fd73200000000);

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	
	pub fn send_on_with_response(&self,
		mut ret: &str) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			0, 0x7a47120700000000);

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WithErrorSyntaxMarker;

impl fidl::endpoints::ServiceMarker for WithErrorSyntaxMarker {
	type Proxy = WithErrorSyntaxProxy;
	type RequestStream = WithErrorSyntaxRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) WithErrorSyntax";
}

pub trait WithErrorSyntaxProxyInterface: Send + Sync {
	type ResponseAsStructResponseFut: std::future::Future<Output = Result<(WithErrorSyntaxResponseAsStructResult), fidl::Error>> + Send;
	fn response_as_struct(&self,
	)-> Self::ResponseAsStructResponseFut;
	type ErrorAsPrimitiveResponseFut: std::future::Future<Output = Result<(WithErrorSyntaxErrorAsPrimitiveResult), fidl::Error>> + Send;
	fn error_as_primitive(&self,
	)-> Self::ErrorAsPrimitiveResponseFut;
	type ErrorAsEnumResponseFut: std::future::Future<Output = Result<(WithErrorSyntaxErrorAsEnumResult), fidl::Error>> + Send;
	fn error_as_enum(&self,
	)-> Self::ErrorAsEnumResponseFut;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct WithErrorSyntaxSynchronousProxy {
	client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl WithErrorSyntaxSynchronousProxy {
	pub fn new(channel: ::fidl::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> ::fidl::Channel {
		self.client.into_channel()
	}
	pub fn response_as_struct(&mut self,___deadline: zx::Time,) -> Result<(WithErrorSyntaxResponseAsStructResult), fidl::Error> {self.client.send_query(&mut (),
				0x4f3c32be00000000,
				___deadline,
			)}
	pub fn error_as_primitive(&mut self,___deadline: zx::Time,) -> Result<(WithErrorSyntaxErrorAsPrimitiveResult), fidl::Error> {self.client.send_query(&mut (),
				0x7b58113900000000,
				___deadline,
			)}
	pub fn error_as_enum(&mut self,___deadline: zx::Time,) -> Result<(WithErrorSyntaxErrorAsEnumResult), fidl::Error> {self.client.send_query(&mut (),
				0x4c95de1f00000000,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct WithErrorSyntaxProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for WithErrorSyntaxProxy {
	type Service = WithErrorSyntaxMarker;
	fn from_channel(inner: ::fidl::AsyncChannel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for WithErrorSyntaxProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

impl WithErrorSyntaxProxy {
	/// Create a new Proxy for WithErrorSyntax
	pub fn new(channel: ::fidl::AsyncChannel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the WithErrorSyntax interface
	pub fn take_event_stream(&self) -> WithErrorSyntaxEventStream {
		WithErrorSyntaxEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn response_as_struct(&self,
	)-> fidl::client::QueryResponseFut<(WithErrorSyntaxResponseAsStructResult)> {
		WithErrorSyntaxProxyInterface::response_as_struct(self,
		)
	}
	pub fn error_as_primitive(&self,
	)-> fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsPrimitiveResult)> {
		WithErrorSyntaxProxyInterface::error_as_primitive(self,
		)
	}
	pub fn error_as_enum(&self,
	)-> fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsEnumResult)> {
		WithErrorSyntaxProxyInterface::error_as_enum(self,
		)
	}
}

impl WithErrorSyntaxProxyInterface for WithErrorSyntaxProxy {
	type ResponseAsStructResponseFut = fidl::client::QueryResponseFut<(WithErrorSyntaxResponseAsStructResult)>;
	fn response_as_struct(&self,
	)-> Self::ResponseAsStructResponseFut {
		self.client.send_query(&mut (), 0x4f3c32be00000000)
	}
	type ErrorAsPrimitiveResponseFut = fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsPrimitiveResult)>;
	fn error_as_primitive(&self,
	)-> Self::ErrorAsPrimitiveResponseFut {
		self.client.send_query(&mut (), 0x7b58113900000000)
	}
	type ErrorAsEnumResponseFut = fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsEnumResult)>;
	fn error_as_enum(&self,
	)-> Self::ErrorAsEnumResponseFut {
		self.client.send_query(&mut (), 0x4c95de1f00000000)
	}}

pub struct WithErrorSyntaxEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for WithErrorSyntaxEventStream {}

impl futures::stream::FusedStream for WithErrorSyntaxEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for WithErrorSyntaxEventStream {
	type Item = Result<WithErrorSyntaxEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return std::task::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		std::task::Poll::Ready(Some(match tx_header.ordinal() {
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal(),
				service_name: <WithErrorSyntaxMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum WithErrorSyntaxEvent {
	
	
	
	}

impl WithErrorSyntaxEvent {
}

/// A type which can be used to send responses and events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
#[deprecated(note = "Use WithErrorSyntaxRequestStream / Responder instead")]
pub struct WithErrorSyntaxServerSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a ::fidl::Channel,
}

impl <'a> WithErrorSyntaxServerSender<'a> {
	pub fn new(channel: &'a ::fidl::Channel) -> Self {
		Self { channel }
	}
	pub fn send_response_as_struct_response(&self,
		txid: fidl::client::Txid,
		mut result: &mut WithErrorSyntaxResponseAsStructResult) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithErrorSyntaxEncoder::encode_response_as_struct_response(
				bytes, handles,
				txid.as_raw_id(),result,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_error_as_primitive_response(&self,
		txid: fidl::client::Txid,
		mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithErrorSyntaxEncoder::encode_error_as_primitive_response(
				bytes, handles,
				txid.as_raw_id(),result,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_error_as_enum_response(&self,
		txid: fidl::client::Txid,
		mut result: &mut WithErrorSyntaxErrorAsEnumResult) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithErrorSyntaxEncoder::encode_error_as_enum_response(
				bytes, handles,
				txid.as_raw_id(),result,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}

/// A Stream of incoming requests for WithErrorSyntax
pub struct WithErrorSyntaxRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for WithErrorSyntaxRequestStream {}

impl futures::stream::FusedStream for WithErrorSyntaxRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for WithErrorSyntaxRequestStream {
	type Service = WithErrorSyntaxMarker;

	/// Consume a channel to make a WithErrorSyntaxRequestStream
	fn from_channel(channel: ::fidl::AsyncChannel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = WithErrorSyntaxControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		WithErrorSyntaxControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for WithErrorSyntaxRequestStream {
	type Item = Result<WithErrorSyntaxRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return std::task::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled WithErrorSyntaxRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				std::task::Poll::Ready(Ok(())) => {},
				std::task::Poll::Pending => return std::task::Poll::Pending,
				std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return std::task::Poll::Ready(None);
				}
				std::task::Poll::Ready(Err(e)) => return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
			if !header.is_compatible() {
				return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(header.magic_number()))));
			}

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			std::task::Poll::Ready(Some(match header.ordinal() {
				0x4f3c32be00000000 | 0x592157d505db2bcf => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithErrorSyntaxControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithErrorSyntaxRequest::ResponseAsStruct {responder:WithErrorSyntaxResponseAsStructResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x7b58113900000000 | 0x20cf80ad7d9b60be => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithErrorSyntaxControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithErrorSyntaxRequest::ErrorAsPrimitive {responder:WithErrorSyntaxErrorAsPrimitiveResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x4c95de1f00000000 | 0x3fcd36560f812e7f => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = WithErrorSyntaxControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithErrorSyntaxRequest::ErrorAsEnum {responder:WithErrorSyntaxErrorAsEnumResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal(),
					service_name: <WithErrorSyntaxMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}

/// Represents a single request.
/// RequestMessages should only be used for manual deserialization when higher level
/// structs such as RequestStream cannot be used. One usually would only encounter
/// such scenarios when working with legacy FIDL code (prior to FIDL generated client/server bindings).
#[derive(Debug)]
#[deprecated(note = "Use WithErrorSyntaxRequest instead")]
pub enum WithErrorSyntaxRequestMessage {
	ResponseAsStruct {
		tx_id: fidl::client::Txid,},
	ErrorAsPrimitive {
		tx_id: fidl::client::Txid,},
	ErrorAsEnum {
		tx_id: fidl::client::Txid,},
}

impl WithErrorSyntaxRequestMessage {
	pub fn decode(bytes: &[u8], _handles: &mut [fidl::Handle]) -> Result<WithErrorSyntaxRequestMessage, fidl::Error> {
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		match header.ordinal() {
			0x4f3c32be00000000 | 0x592157d505db2bcf => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithErrorSyntaxRequestMessage::ResponseAsStruct {tx_id: header.tx_id().into(),})
			}
			0x7b58113900000000 | 0x20cf80ad7d9b60be => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithErrorSyntaxRequestMessage::ErrorAsPrimitive {tx_id: header.tx_id().into(),})
			}
			0x4c95de1f00000000 | 0x3fcd36560f812e7f => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(WithErrorSyntaxRequestMessage::ErrorAsEnum {tx_id: header.tx_id().into(),})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal(),
				service_name: <WithErrorSyntaxMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			}),
		}
	}


}
#[derive(Debug)]
pub enum WithErrorSyntaxRequest {
	ResponseAsStruct {
		responder: WithErrorSyntaxResponseAsStructResponder,},
	ErrorAsPrimitive {
		responder: WithErrorSyntaxErrorAsPrimitiveResponder,},
	ErrorAsEnum {
		responder: WithErrorSyntaxErrorAsEnumResponder,},
}

impl WithErrorSyntaxRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_response_as_struct(self) -> Option<(WithErrorSyntaxResponseAsStructResponder
	)> {
		if let WithErrorSyntaxRequest::ResponseAsStruct {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_error_as_primitive(self) -> Option<(WithErrorSyntaxErrorAsPrimitiveResponder
	)> {
		if let WithErrorSyntaxRequest::ErrorAsPrimitive {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_error_as_enum(self) -> Option<(WithErrorSyntaxErrorAsEnumResponder
	)> {
		if let WithErrorSyntaxRequest::ErrorAsEnum {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                WithErrorSyntaxRequest::ResponseAsStruct{..} => "response_as_struct",
                WithErrorSyntaxRequest::ErrorAsPrimitive{..} => "error_as_primitive",
                WithErrorSyntaxRequest::ErrorAsEnum{..} => "error_as_enum",
          }
        }
}

pub struct WithErrorSyntaxEncoder;

impl WithErrorSyntaxEncoder {
	pub fn encode_response_as_struct_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4f3c32be00000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_response_as_struct_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_result: &mut WithErrorSyntaxResponseAsStructResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4f3c32be00000000);
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_primitive_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x7b58113900000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_primitive_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x7b58113900000000);
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_enum_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4c95de1f00000000);
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_enum_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4c95de1f00000000);
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct WithErrorSyntaxControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for WithErrorSyntaxControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl WithErrorSyntaxControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}

	pub fn shutdown_with_epitaph(&self, status: zx_status::Status) {
		self.inner.shutdown_with_epitaph(status)
	}}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithErrorSyntaxResponseAsStructResponder {
	control_handle: ::std::mem::ManuallyDrop<WithErrorSyntaxControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithErrorSyntaxResponseAsStructResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithErrorSyntaxResponseAsStructResponder {
	pub fn control_handle(&self) -> &WithErrorSyntaxControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: &mut WithErrorSyntaxResponseAsStructResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: &mut WithErrorSyntaxResponseAsStructResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: &mut WithErrorSyntaxResponseAsStructResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithErrorSyntaxErrorAsPrimitiveResponder {
	control_handle: ::std::mem::ManuallyDrop<WithErrorSyntaxControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithErrorSyntaxErrorAsPrimitiveResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithErrorSyntaxErrorAsPrimitiveResponder {
	pub fn control_handle(&self) -> &WithErrorSyntaxControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithErrorSyntaxErrorAsEnumResponder {
	control_handle: ::std::mem::ManuallyDrop<WithErrorSyntaxControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for WithErrorSyntaxErrorAsEnumResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithErrorSyntaxErrorAsEnumResponder {
	pub fn control_handle(&self) -> &WithErrorSyntaxControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChannelProtocolMarker;

impl fidl::endpoints::ServiceMarker for ChannelProtocolMarker {
	type Proxy = ChannelProtocolProxy;
	type RequestStream = ChannelProtocolRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) ChannelProtocol";
}

pub trait ChannelProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: std::future::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: std::future::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
	type MutateSocketResponseFut: std::future::Future<Output = Result<(fidl::Socket), fidl::Error>> + Send;
	fn mutate_socket(&self,
		a: fidl::Socket,
	)-> Self::MutateSocketResponseFut;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct ChannelProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl ChannelProtocolSynchronousProxy {
	pub fn new(channel: ::fidl::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> ::fidl::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				0x556693d200000000,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				0xac6551b00000000,
				___deadline,
			)}
	pub fn mutate_socket(&mut self,
		mut a: fidl::Socket,___deadline: zx::Time,) -> Result<(fidl::Socket), fidl::Error> {self.client.send_query(&mut (a),
				0x4b02e28600000000,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct ChannelProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ChannelProtocolProxy {
	type Service = ChannelProtocolMarker;
	fn from_channel(inner: ::fidl::AsyncChannel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for ChannelProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

impl ChannelProtocolProxy {
	/// Create a new Proxy for ChannelProtocol
	pub fn new(channel: ::fidl::AsyncChannel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the ChannelProtocol interface
	pub fn take_event_stream(&self) -> ChannelProtocolEventStream {
		ChannelProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		ChannelProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		ChannelProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
	pub fn mutate_socket(&self,
		mut a: fidl::Socket,
	)-> fidl::client::QueryResponseFut<(fidl::Socket)> {
		ChannelProtocolProxyInterface::mutate_socket(self,
		a,
		)
	}
}

impl ChannelProtocolProxyInterface for ChannelProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 0x556693d200000000)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 0xac6551b00000000)
	}
	type MutateSocketResponseFut = fidl::client::QueryResponseFut<(fidl::Socket)>;
	fn mutate_socket(&self,
		mut a: fidl::Socket,
	)-> Self::MutateSocketResponseFut {
		self.client.send_query(&mut (a), 0x4b02e28600000000)
	}}

pub struct ChannelProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for ChannelProtocolEventStream {}

impl futures::stream::FusedStream for ChannelProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for ChannelProtocolEventStream {
	type Item = Result<ChannelProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return std::task::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		std::task::Poll::Ready(Some(match tx_header.ordinal() {
			0x1c78c20200000000 | 0x2558b206a254d8a0 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&tx_header, _body_bytes, _handles, &mut out_tuple)?;
				Ok((
					ChannelProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal(),
				service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum ChannelProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	
	}

impl ChannelProtocolEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_event_a(self) -> Option<(i64, i64
	)> {
		if let ChannelProtocolEvent::EventA {
			a,
			
			b,
			
		} = self {
			Some((a, b))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send responses and events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
#[deprecated(note = "Use ChannelProtocolRequestStream / Responder instead")]
pub struct ChannelProtocolServerSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a ::fidl::Channel,
}

impl <'a> ChannelProtocolServerSender<'a> {
	pub fn new(channel: &'a ::fidl::Channel) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			ChannelProtocolEncoder::encode_event_a_response(
				bytes, handles,a,b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_method_b_response(&self,
		txid: fidl::client::Txid,
		mut result: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			ChannelProtocolEncoder::encode_method_b_response(
				bytes, handles,
				txid.as_raw_id(),result,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	pub fn send_mutate_socket_response(&self,
		txid: fidl::client::Txid,
		mut b: fidl::Socket) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			ChannelProtocolEncoder::encode_mutate_socket_response(
				bytes, handles,
				txid.as_raw_id(),b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}

/// A Stream of incoming requests for ChannelProtocol
pub struct ChannelProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for ChannelProtocolRequestStream {}

impl futures::stream::FusedStream for ChannelProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for ChannelProtocolRequestStream {
	type Service = ChannelProtocolMarker;

	/// Consume a channel to make a ChannelProtocolRequestStream
	fn from_channel(channel: ::fidl::AsyncChannel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = ChannelProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		ChannelProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for ChannelProtocolRequestStream {
	type Item = Result<ChannelProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> std::task::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return std::task::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled ChannelProtocolRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				std::task::Poll::Ready(Ok(())) => {},
				std::task::Poll::Pending => return std::task::Poll::Pending,
				std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return std::task::Poll::Ready(None);
				}
				std::task::Poll::Ready(Err(e)) => return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
			if !header.is_compatible() {
				return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(header.magic_number()))));
			}

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			std::task::Poll::Ready(Some(match header.ordinal() {
				0x556693d200000000 | 0x1b1e059b3f02bffc => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
				}
				0xac6551b00000000 | 0x5db17a61464744a3 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MethodB {a: req.0,b: req.1,responder:ChannelProtocolMethodBResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				0x4b02e28600000000 | 0x36caa6fff7569577 => {
					let mut req: (fidl::Socket) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(&header, _body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MutateSocket {a: req,responder:ChannelProtocolMutateSocketResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id(),
								ordinal: header.ordinal(),
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal(),
					service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}

/// Represents a single request.
/// RequestMessages should only be used for manual deserialization when higher level
/// structs such as RequestStream cannot be used. One usually would only encounter
/// such scenarios when working with legacy FIDL code (prior to FIDL generated client/server bindings).
#[derive(Debug)]
#[deprecated(note = "Use ChannelProtocolRequest instead")]
pub enum ChannelProtocolRequestMessage {
	MethodA {
		
		a: i64,
		
		b: i64,
		},
	MethodB {
		
		a: i64,
		
		b: i64,
		tx_id: fidl::client::Txid,},
	MutateSocket {
		
		a: fidl::Socket,
		tx_id: fidl::client::Txid,},
}

impl ChannelProtocolRequestMessage {
	pub fn decode(bytes: &[u8], _handles: &mut [fidl::Handle]) -> Result<ChannelProtocolRequestMessage, fidl::Error> {
		let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		match header.ordinal() {
			0x556693d200000000 | 0x1b1e059b3f02bffc => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(ChannelProtocolRequestMessage::MethodA {a: out_tuple.0,b: out_tuple.1,})
			}
			0xac6551b00000000 | 0x5db17a61464744a3 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(ChannelProtocolRequestMessage::MethodB {a: out_tuple.0,b: out_tuple.1,tx_id: header.tx_id().into(),})
			}
			0x4b02e28600000000 | 0x36caa6fff7569577 => {
				let mut out_tuple: (fidl::Socket) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(&header, _body_bytes, _handles, &mut out_tuple)?;

				Ok(ChannelProtocolRequestMessage::MutateSocket {a: out_tuple,tx_id: header.tx_id().into(),})
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: header.ordinal(),
				service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			}),
		}
	}


}
#[derive(Debug)]
pub enum ChannelProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: ChannelProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: ChannelProtocolMethodBResponder,},
	MutateSocket {
		
		a: fidl::Socket,
		responder: ChannelProtocolMutateSocketResponder,},
}

impl ChannelProtocolRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_a(self) -> Option<(
		i64,
		
		i64,
		ChannelProtocolControlHandle
	)> {
		if let ChannelProtocolRequest::MethodA {
			a,
			
			b,
			control_handle,
		} = self {
			Some((a,b,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_b(self) -> Option<(
		i64,
		
		i64,
		ChannelProtocolMethodBResponder
	)> {
		if let ChannelProtocolRequest::MethodB {
			a,
			
			b,
			responder,
		} = self {
			Some((a,b,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_mutate_socket(self) -> Option<(
		fidl::Socket,
		ChannelProtocolMutateSocketResponder
	)> {
		if let ChannelProtocolRequest::MutateSocket {
			a,
			responder,
		} = self {
			Some((a,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                ChannelProtocolRequest::MethodA{..} => "method_a",
                ChannelProtocolRequest::MethodB{..} => "method_b",
                ChannelProtocolRequest::MutateSocket{..} => "mutate_socket",
          }
        }
}

pub struct ChannelProtocolEncoder;

impl ChannelProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x556693d200000000);
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(0,0x1c78c20200000000);
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0xac6551b00000000);
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0xac6551b00000000);
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_a: fidl::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4b02e28600000000);
		let mut body = (in_a,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<fidl::Handle>,
		tx_id: u32,mut in_b: fidl::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			tx_id,0x4b02e28600000000);
		let mut body = (in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct ChannelProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for ChannelProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl ChannelProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}

	pub fn shutdown_with_epitaph(&self, status: zx_status::Status) {
		self.inner.shutdown_with_epitaph(status)
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(
			0, 0x1c78c20200000000);

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ChannelProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<ChannelProtocolControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for ChannelProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl ChannelProtocolMethodBResponder {
	pub fn control_handle(&self) -> &ChannelProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ChannelProtocolMutateSocketResponder {
	control_handle: ::std::mem::ManuallyDrop<ChannelProtocolControlHandle>,
	tx_id: u32,
	ordinal: u64,
}

impl ::std::ops::Drop for ChannelProtocolMutateSocketResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl ChannelProtocolMutateSocketResponder {
	pub fn control_handle(&self) -> &ChannelProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut b: fidl::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut b: fidl::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut b: fidl::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader::new(self.tx_id, self.ordinal);

		let mut response = (b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}

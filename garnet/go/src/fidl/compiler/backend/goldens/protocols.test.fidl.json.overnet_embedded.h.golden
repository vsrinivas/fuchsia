// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "src/connectivity/overnet/lib/embedded/header.h"

#include <test/name/cpp/fidl.h>

namespace test {
namespace name {
namespace embedded {

class WithErrorSyntax_ErrorAsPrimitive_Response;
class WithErrorSyntax_ErrorAsPrimitive_Result;
class WithErrorSyntax_ErrorAsEnum_Response;
enum class ErrorEnun : uint32_t {
  ERR_FOO = 1,
  ERR_BAR = 2,
};

inline zx_status_t Clone(::test::name::embedded::ErrorEnun value,
                         ::test::name::embedded::ErrorEnun* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_ErrorAsEnum_Result;

class WithErrorSyntax_ErrorAsPrimitive_Response  {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved = 0;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Response>(); }

  void Encode(::overnet::internal::Encoder* _encoder, size_t _offset);
  static void Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Response* value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Response* result) const;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Response& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Response& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response& _value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResponsePtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>;

class WithErrorSyntax_ErrorAsPrimitive_Result {
 public:
  WithErrorSyntax_ErrorAsPrimitive_Result();
  ~WithErrorSyntax_ErrorAsPrimitive_Result();

  WithErrorSyntax_ErrorAsPrimitive_Result(WithErrorSyntax_ErrorAsPrimitive_Result&&);
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(WithErrorSyntax_ErrorAsPrimitive_Result&&);

  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Result>(); }

  void Encode(::overnet::internal::Encoder* _encoder, size_t _offset);
  static void Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Result* _value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Result* result) const;

  bool has_invalid_tag() const { return Which() == Tag::Invalid; }

  bool is_response() const { return Which() == Tag(0); }
  
  WithErrorSyntax_ErrorAsPrimitive_Response& response() {
    if (!is_response()) {
      value_.emplace<0 + 1>();
    }
    return value_.template get<0 + 1>();
  }
  
  const WithErrorSyntax_ErrorAsPrimitive_Response& response() const { return value_.template get<0 + 1>(); }
  void set_response(WithErrorSyntax_ErrorAsPrimitive_Response value);

  bool is_err() const { return Which() == Tag(1); }
  
  uint32_t& err() {
    if (!is_err()) {
      value_.emplace<1 + 1>();
    }
    return value_.template get<1 + 1>();
  }
  
  const uint32_t& err() const { return value_.template get<1 + 1>(); }
  void set_err(uint32_t value);

  Tag Which() const {
    size_t index = value_.index();
    if (index == 0) {
      return Tag::Invalid;
    } else {
      return Tag(index - 1);
    }
  }

 private:
#ifdef FIDL_OPERATOR_EQUALS
  friend bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs);
#endif

  using Variant = fit::internal::variant<fit::internal::monostate, WithErrorSyntax_ErrorAsPrimitive_Response, uint32_t>;
  Variant value_;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResultPtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>;

class WithErrorSyntax_ErrorAsEnum_Response  {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved = 0;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Response>(); }

  void Encode(::overnet::internal::Encoder* _encoder, size_t _offset);
  static void Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Response* result) const;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Response& _lhs, const WithErrorSyntax_ErrorAsEnum_Response& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsEnum_Response& _lhs, const WithErrorSyntax_ErrorAsEnum_Response& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response& _value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsEnum_ResponsePtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response>;

class WithErrorSyntax_ErrorAsEnum_Result {
 public:
  WithErrorSyntax_ErrorAsEnum_Result();
  ~WithErrorSyntax_ErrorAsEnum_Result();

  WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&&);
  WithErrorSyntax_ErrorAsEnum_Result& operator=(WithErrorSyntax_ErrorAsEnum_Result&&);

  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Result>(); }

  void Encode(::overnet::internal::Encoder* _encoder, size_t _offset);
  static void Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Result* _value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Result* result) const;

  bool has_invalid_tag() const { return Which() == Tag::Invalid; }

  bool is_response() const { return Which() == Tag(0); }
  
  WithErrorSyntax_ErrorAsEnum_Response& response() {
    if (!is_response()) {
      value_.emplace<0 + 1>();
    }
    return value_.template get<0 + 1>();
  }
  
  const WithErrorSyntax_ErrorAsEnum_Response& response() const { return value_.template get<0 + 1>(); }
  void set_response(WithErrorSyntax_ErrorAsEnum_Response value);

  bool is_err() const { return Which() == Tag(1); }
  
  ErrorEnun& err() {
    if (!is_err()) {
      value_.emplace<1 + 1>();
    }
    return value_.template get<1 + 1>();
  }
  
  const ErrorEnun& err() const { return value_.template get<1 + 1>(); }
  void set_err(ErrorEnun value);

  Tag Which() const {
    size_t index = value_.index();
    if (index == 0) {
      return Tag::Invalid;
    } else {
      return Tag(index - 1);
    }
  }

 private:
#ifdef FIDL_OPERATOR_EQUALS
  friend bool operator==(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs);
#endif

  using Variant = fit::internal::variant<fit::internal::monostate, WithErrorSyntax_ErrorAsEnum_Response, ErrorEnun>;
  Variant value_;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsEnum_ResultPtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result>;

}  // namespace embedded
}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public EncodableCodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response, 1> {};

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response* result) {
  return ::test::name::embedded::Clone(value, result);
}

template <>
struct ToEmbeddedTraits<::test::name::WithErrorSyntax_ErrorAsPrimitive_Response> {
  static ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response Lift(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& _value) {
    return ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response {
      ToEmbedded(_value.__reserved),
    };
  }
};

template<>
struct Equality<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response> {
  static inline bool Equals(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Response& _rhs) {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public EncodableCodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result, 8> {};

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return ::test::name::embedded::Clone(value, result);
}

template<>
struct Equality<::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result> {
  static inline bool Equals(const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const ::test::name::embedded::WithErrorSyntax_ErrorAsPrimitive_Result& _rhs) {
    if (_lhs.Which() != _rhs.Which()) {
      return false;
    }
    switch (_lhs.Which()) {
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kResponse:
	return ::fidl::Equals(_lhs.response(), _rhs.response());
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
	return ::fidl::Equals(_lhs.err(), _rhs.err());
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::Invalid:
	return true;
      default:
	return false;
    }
  }
};
template <>
struct CodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response>
    : public EncodableCodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response, 1> {};

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response* result) {
  return ::test::name::embedded::Clone(value, result);
}

template <>
struct ToEmbeddedTraits<::test::name::WithErrorSyntax_ErrorAsEnum_Response> {
  static ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response Lift(const ::test::name::WithErrorSyntax_ErrorAsEnum_Response& _value) {
    return ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response {
      ToEmbedded(_value.__reserved),
    };
  }
};

template<>
struct Equality<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response> {
  static inline bool Equals(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response& _lhs, const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Response& _rhs) {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::name::embedded::ErrorEnun> {
  static constexpr size_t encoded_size = sizeof(::test::name::embedded::ErrorEnun);
  static void Encode(::overnet::internal::Encoder* encoder, ::test::name::embedded::ErrorEnun* value, size_t offset) {
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(::overnet::internal::Decoder* decoder, ::test::name::embedded::ErrorEnun* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::name::embedded::ErrorEnun>(underlying);
  }
};

inline zx_status_t Clone(::test::name::embedded::ErrorEnun value,
                         ::test::name::embedded::ErrorEnun* result) {
  return ::test::name::embedded::Clone(value, result);
}
template <>
struct CodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result>
    : public EncodableCodingTraits<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result, 8> {};

inline zx_status_t Clone(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result& value,
                         ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return ::test::name::embedded::Clone(value, result);
}

template<>
struct Equality<::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result> {
  static inline bool Equals(const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result& _lhs, const ::test::name::embedded::WithErrorSyntax_ErrorAsEnum_Result& _rhs) {
    if (_lhs.Which() != _rhs.Which()) {
      return false;
    }
    switch (_lhs.Which()) {
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
	return ::fidl::Equals(_lhs.response(), _rhs.response());
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
	return ::fidl::Equals(_lhs.err(), _rhs.err());
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid:
	return true;
      default:
	return false;
    }
  }
};}  // namespace fidl

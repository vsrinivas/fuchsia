// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/tracking_ptr.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

struct Union;
struct StrictUnion;
struct ReverseOrdinalUnion;
struct Pizza;
struct Pasta;
struct StrictPizzaOrPasta;
struct PizzaOrPasta;
struct FlexiblePizzaOrPasta;
struct ExplicitPizzaOrPasta;
struct NullableUnionStruct;
struct FlexibleUnion;
struct FieldCollision;
struct ExplicitUnion;

extern "C" const fidl_type_t v1_fidl_test_json_UnionTable;

struct Union {
  Union() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static Union WithPrimitive(int32_t* val) {
    Union result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static Union WithStringNeedsConstructor(::fidl::StringView* val) {
    Union result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static Union WithVectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* val) {
    Union result;
    result.set_VectorStringAlsoNeedsConstructor(val);
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_StrictUnionTable;

struct StrictUnion {
  StrictUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static StrictUnion WithPrimitive(int32_t* val) {
    StrictUnion result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static StrictUnion WithStringNeedsConstructor(::fidl::StringView* val) {
    StrictUnion result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* val) {
    StrictUnion result;
    result.set_VectorStringAlsoNeedsConstructor(val);
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_StrictUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ReverseOrdinalUnionTable;

struct ReverseOrdinalUnion {
  ReverseOrdinalUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_first() const { return ordinal() == Ordinal::kFirst; }

  static ReverseOrdinalUnion WithFirst(uint32_t* val) {
    ReverseOrdinalUnion result;
    result.set_first(val);
    return result;
  }

  void set_first(uint32_t* elem) {
    ordinal_ = Ordinal::kFirst;
    envelope_.data = static_cast<void*>(elem);
  }

  uint32_t& mutable_first() {
    ZX_ASSERT(ordinal() == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal() == Ordinal::kFirst);
    return *static_cast<uint32_t*>(envelope_.data);
  }

  bool is_second() const { return ordinal() == Ordinal::kSecond; }

  static ReverseOrdinalUnion WithSecond(uint32_t* val) {
    ReverseOrdinalUnion result;
    result.set_second(val);
    return result;
  }

  void set_second(uint32_t* elem) {
    ordinal_ = Ordinal::kSecond;
    envelope_.data = static_cast<void*>(elem);
  }

  uint32_t& mutable_second() {
    ZX_ASSERT(ordinal() == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal() == Ordinal::kSecond);
    return *static_cast<uint32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ReverseOrdinalUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFirst = 1,  // 0x1
    kSecond = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_StrictPizzaOrPastaTable;

struct StrictPizzaOrPasta {
  StrictPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal() == Ordinal::kPizza; }

  static StrictPizzaOrPasta WithPizza(::llcpp::fidl::test::json::Pizza* val) {
    StrictPizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  void set_pizza(::llcpp::fidl::test::json::Pizza* elem) {
    ordinal_ = Ordinal::kPizza;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }

  bool is_pasta() const { return ordinal() == Ordinal::kPasta; }

  static StrictPizzaOrPasta WithPasta(::llcpp::fidl::test::json::Pasta* val) {
    StrictPizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  void set_pasta(::llcpp::fidl::test::json::Pasta* elem) {
    ordinal_ = Ordinal::kPasta;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_StrictPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_PizzaOrPastaTable;

struct PizzaOrPasta {
  PizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal() == Ordinal::kPizza; }

  static PizzaOrPasta WithPizza(::llcpp::fidl::test::json::Pizza* val) {
    PizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  void set_pizza(::llcpp::fidl::test::json::Pizza* elem) {
    ordinal_ = Ordinal::kPizza;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }

  bool is_pasta() const { return ordinal() == Ordinal::kPasta; }

  static PizzaOrPasta WithPasta(::llcpp::fidl::test::json::Pasta* val) {
    PizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  void set_pasta(::llcpp::fidl::test::json::Pasta* elem) {
    ordinal_ = Ordinal::kPasta;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FlexiblePizzaOrPastaTable;

struct FlexiblePizzaOrPasta {
  FlexiblePizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal() == Ordinal::kPizza; }

  static FlexiblePizzaOrPasta WithPizza(::llcpp::fidl::test::json::Pizza* val) {
    FlexiblePizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  void set_pizza(::llcpp::fidl::test::json::Pizza* elem) {
    ordinal_ = Ordinal::kPizza;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }

  bool is_pasta() const { return ordinal() == Ordinal::kPasta; }

  static FlexiblePizzaOrPasta WithPasta(::llcpp::fidl::test::json::Pasta* val) {
    FlexiblePizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  void set_pasta(::llcpp::fidl::test::json::Pasta* elem) {
    ordinal_ = Ordinal::kPasta;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FlexiblePizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ExplicitPizzaOrPastaTable;

struct ExplicitPizzaOrPasta {
  ExplicitPizzaOrPasta() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_pizza() const { return ordinal() == Ordinal::kPizza; }

  static ExplicitPizzaOrPasta WithPizza(::llcpp::fidl::test::json::Pizza* val) {
    ExplicitPizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  void set_pizza(::llcpp::fidl::test::json::Pizza* elem) {
    ordinal_ = Ordinal::kPizza;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pizza& pizza() const {
    ZX_ASSERT(ordinal() == Ordinal::kPizza);
    return *static_cast<::llcpp::fidl::test::json::Pizza*>(envelope_.data);
  }

  bool is_pasta() const { return ordinal() == Ordinal::kPasta; }

  static ExplicitPizzaOrPasta WithPasta(::llcpp::fidl::test::json::Pasta* val) {
    ExplicitPizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  void set_pasta(::llcpp::fidl::test::json::Pasta* elem) {
    ordinal_ = Ordinal::kPasta;
    envelope_.data = static_cast<void*>(elem);
  }

  ::llcpp::fidl::test::json::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  const ::llcpp::fidl::test::json::Pasta& pasta() const {
    ZX_ASSERT(ordinal() == Ordinal::kPasta);
    return *static_cast<::llcpp::fidl::test::json::Pasta*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ExplicitPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FlexibleUnionTable;

struct FlexibleUnion {
  FlexibleUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static FlexibleUnion WithPrimitive(int32_t* val) {
    FlexibleUnion result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static FlexibleUnion WithStringNeedsConstructor(::fidl::StringView* val) {
    FlexibleUnion result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_VectorStringAlsoNeedsConstructor() const { return ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor; }

  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* val) {
    FlexibleUnion result;
    result.set_VectorStringAlsoNeedsConstructor(val);
    return result;
  }

  void set_VectorStringAlsoNeedsConstructor(::fidl::VectorView<::fidl::StringView>* elem) {
    ordinal_ = Ordinal::kVectorStringAlsoNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_VectorStringAlsoNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  const ::fidl::VectorView<::fidl::StringView>& VectorStringAlsoNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kVectorStringAlsoNeedsConstructor);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FlexibleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_FieldCollisionTable;

struct FieldCollision {
  FieldCollision() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_field_collision_tag() const { return ordinal() == Ordinal::kFieldCollisionTag; }

  static FieldCollision WithFieldCollisionTag(int32_t* val) {
    FieldCollision result;
    result.set_field_collision_tag(val);
    return result;
  }

  void set_field_collision_tag(int32_t* elem) {
    ordinal_ = Ordinal::kFieldCollisionTag;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_field_collision_tag() {
    ZX_ASSERT(ordinal() == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(ordinal() == Ordinal::kFieldCollisionTag);
    return *static_cast<int32_t*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_FieldCollisionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_ExplicitUnionTable;

struct ExplicitUnion {
  ExplicitUnion() : ordinal_(Ordinal::Invalid), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_Primitive() const { return ordinal() == Ordinal::kPrimitive; }

  static ExplicitUnion WithPrimitive(int32_t* val) {
    ExplicitUnion result;
    result.set_Primitive(val);
    return result;
  }

  void set_Primitive(int32_t* elem) {
    ordinal_ = Ordinal::kPrimitive;
    envelope_.data = static_cast<void*>(elem);
  }

  int32_t& mutable_Primitive() {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }
  const int32_t& Primitive() const {
    ZX_ASSERT(ordinal() == Ordinal::kPrimitive);
    return *static_cast<int32_t*>(envelope_.data);
  }

  bool is_StringNeedsConstructor() const { return ordinal() == Ordinal::kStringNeedsConstructor; }

  static ExplicitUnion WithStringNeedsConstructor(::fidl::StringView* val) {
    ExplicitUnion result;
    result.set_StringNeedsConstructor(val);
    return result;
  }

  void set_StringNeedsConstructor(::fidl::StringView* elem) {
    ordinal_ = Ordinal::kStringNeedsConstructor;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& mutable_StringNeedsConstructor() {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  const ::fidl::StringView& StringNeedsConstructor() const {
    ZX_ASSERT(ordinal() == Ordinal::kStringNeedsConstructor);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal());
  }

  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_ExplicitUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  Ordinal ordinal() const {
    return ordinal_;
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t v1_fidl_test_json_PizzaTable;

struct Pizza {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PizzaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<::fidl::StringView> toppings = {};
};

extern "C" const fidl_type_t v1_fidl_test_json_PastaTable;

struct Pasta {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_PastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

  ::fidl::StringView sauce = {};
};

extern "C" const fidl_type_t v1_fidl_test_json_NullableUnionStructTable;

struct NullableUnionStruct {
  static constexpr const fidl_type_t* Type = &v1_fidl_test_json_NullableUnionStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::llcpp::fidl::test::json::Union the_union = {};
};

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fidl::test::json::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Union>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::StrictUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ReverseOrdinalUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ReverseOrdinalUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pizza> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pizza>);
static_assert(offsetof(::llcpp::fidl::test::json::Pizza, toppings) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pizza) == ::llcpp::fidl::test::json::Pizza::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::Pasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::Pasta>);
static_assert(offsetof(::llcpp::fidl::test::json::Pasta, sauce) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::Pasta) == ::llcpp::fidl::test::json::Pasta::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StrictPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::StrictPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::PizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::PizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexiblePizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FlexiblePizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitPizzaOrPasta>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::NullableUnionStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::NullableUnionStruct>);
static_assert(offsetof(::llcpp::fidl::test::json::NullableUnionStruct, the_union) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::NullableUnionStruct) == ::llcpp::fidl::test::json::NullableUnionStruct::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FlexibleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FlexibleUnion>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::FieldCollision> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::FieldCollision>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::ExplicitUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fidl::test::json::ExplicitUnion>);

}  // namespace fidl

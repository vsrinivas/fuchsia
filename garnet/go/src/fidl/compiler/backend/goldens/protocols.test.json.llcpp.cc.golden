// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.json.llcpp.h>

#include <memory>

namespace llcpp {

namespace test {
namespace name {

void ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ResponseAsStruct_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ResponseAsStruct_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ResponseAsStruct_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ErrorAsPrimitive_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ErrorAsPrimitive_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ErrorAsPrimitive_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]] constexpr uint64_t kTransitional_Request_Ordinal =
    8417059970765918690lu;
extern "C" const fidl_type_t test_name_TransitionalRequestRequestTable;
extern "C" const fidl_type_t test_name_TransitionalRequestResponseTable;
[[maybe_unused]] constexpr uint64_t kTransitional_OneWay_Ordinal =
    4736529736500432226lu;
extern "C" const fidl_type_t test_name_TransitionalOneWayRequestTable;
extern "C" const fidl_type_t test_name_TransitionalOneWayResponseTable;
[[maybe_unused]] constexpr uint64_t kTransitional_Event_Ordinal =
    1744293851714922796lu;
extern "C" const fidl_type_t test_name_TransitionalEventRequestTable;
extern "C" const fidl_type_t test_name_TransitionalEventEventTable;

}  // namespace
template <>
Transitional::ResultOf::Request_Impl<Transitional::RequestResponse>::
    Request_Impl(::zx::unowned_channel _client_end, int64_t x) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(RequestRequest)];
  auto& _request = *new (_request_buffer) RequestRequest(0, x);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<RequestRequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<RequestRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(Transitional::InPlace::Request(std::move(_client_end),
                                                  std::move(_encoded_request),
                                                  Super::response_buffer()));
}

Transitional::ResultOf::Request Transitional::SyncClient::Request(int64_t x) {
  return ResultOf::Request(::zx::unowned_channel(this->channel_), x);
}

Transitional::ResultOf::Request Transitional::Call::Request(
    ::zx::unowned_channel _client_end, int64_t x) {
  return ResultOf::Request(std::move(_client_end), x);
}

template <>
Transitional::UnownedResultOf::Request_Impl<Transitional::RequestResponse>::
    Request_Impl(::zx::unowned_channel _client_end,
                 ::fidl::BytePart _request_buffer, int64_t x,
                 ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < RequestRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<RequestResponse>(
        ZX_ERR_BUFFER_TOO_SMALL, ::fidl::kErrorRequestBufferTooSmall));
    return;
  }
  new (_request_buffer.data()) RequestRequest(0, x);
  _request_buffer.set_actual(sizeof(RequestRequest));
  ::fidl::DecodedMessage<RequestRequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<RequestRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<RequestRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(Transitional::InPlace::Request(std::move(_client_end),
                                                  std::move(_encoded_request),
                                                  std::move(_response_buffer)));
}

Transitional::UnownedResultOf::Request Transitional::SyncClient::Request(
    ::fidl::BytePart _request_buffer, int64_t x,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Request(::zx::unowned_channel(this->channel_),
                                  std::move(_request_buffer), std::move(x),
                                  std::move(_response_buffer));
}

Transitional::UnownedResultOf::Request Transitional::Call::Request(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t x, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::Request(std::move(_client_end),
                                  std::move(_request_buffer), std::move(x),
                                  std::move(_response_buffer));
}

::fidl::DecodeResult<Transitional::RequestResponse>
Transitional::InPlace::Request(::zx::unowned_channel _client_end,
                               ::fidl::DecodedMessage<RequestRequest> params,
                               ::fidl::BytePart response_buffer) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Transitional::RequestResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  return Request(std::move(_client_end),
                 std::move(_encode_request_result.message),
                 std::move(response_buffer));
}

::fidl::DecodeResult<Transitional::RequestResponse>
Transitional::InPlace::Request(::zx::unowned_channel _client_end,
                               ::fidl::EncodedMessage<RequestRequest> params,
                               ::fidl::BytePart response_buffer) {
  RequestRequest* request =
      reinterpret_cast<RequestRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0, kTransitional_Request_Ordinal);
  auto _call_result = ::fidl::Call<RequestRequest, RequestResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Transitional::RequestResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

Transitional::ResultOf::OneWay_Impl::OneWay_Impl(
    ::zx::unowned_channel _client_end, int64_t x) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(OneWayRequest)];
  auto& _request = *new (_request_buffer) OneWayRequest(0, x);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<OneWayRequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<OneWayRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(Transitional::InPlace::OneWay(std::move(_client_end),
                                                 std::move(_encoded_request)));
}

Transitional::ResultOf::OneWay Transitional::SyncClient::OneWay(int64_t x) {
  return ResultOf::OneWay(::zx::unowned_channel(this->channel_), x);
}

Transitional::ResultOf::OneWay Transitional::Call::OneWay(
    ::zx::unowned_channel _client_end, int64_t x) {
  return ResultOf::OneWay(std::move(_client_end), x);
}

Transitional::UnownedResultOf::OneWay_Impl::OneWay_Impl(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t x) {
  if (_request_buffer.capacity() < OneWayRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::kErrorRequestBufferTooSmall;
    return;
  }
  new (_request_buffer.data()) OneWayRequest(0, x);
  _request_buffer.set_actual(sizeof(OneWayRequest));
  ::fidl::DecodedMessage<OneWayRequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<OneWayRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<OneWayRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(Transitional::InPlace::OneWay(std::move(_client_end),
                                                 std::move(_encoded_request)));
}

Transitional::UnownedResultOf::OneWay Transitional::SyncClient::OneWay(
    ::fidl::BytePart _request_buffer, int64_t x) {
  return UnownedResultOf::OneWay(::zx::unowned_channel(this->channel_),
                                 std::move(_request_buffer), std::move(x));
}

Transitional::UnownedResultOf::OneWay Transitional::Call::OneWay(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t x) {
  return UnownedResultOf::OneWay(std::move(_client_end),
                                 std::move(_request_buffer), std::move(x));
}

::fidl::internal::StatusAndError Transitional::InPlace::OneWay(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<OneWayRequest> params) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  return OneWay(std::move(_client_end),
                std::move(_encode_request_result.message));
}

::fidl::internal::StatusAndError Transitional::InPlace::OneWay(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<OneWayRequest> params) {
  OneWayRequest* request =
      reinterpret_cast<OneWayRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0, kTransitional_OneWay_Ordinal);
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(params));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status,
                                            ::fidl::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

Transitional::ResultOf::Request Transitional::ClientImpl::Request_Sync(
    int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::Request(_binding->channel(), x);
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

Transitional::UnownedResultOf::Request Transitional::ClientImpl::Request_Sync(
    ::fidl::BytePart _request_buffer, int64_t x,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::Request(_binding->channel(),
                                    std::move(_request_buffer), std::move(x),
                                    std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError Transitional::ClientImpl::Request(
    int64_t x, ::fit::callback<void(int64_t y)> _cb) {
  class ManagedResponseContext : public RequestResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void(int64_t y)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(::fidl::DecodedMessage<RequestResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->y));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(int64_t y)> cb_;
  };
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<
      RequestRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error =
      Request(_write_bytes_array.view(), std::move(x), _context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError Transitional::ClientImpl::Request(
    ::fidl::BytePart _request_buffer, int64_t x,
    RequestResponseContext* _context) {
  if (_request_buffer.capacity() < RequestRequest::PrimarySize) {
    return ::fidl::StatusAndError(ZX_ERR_BUFFER_TOO_SMALL,
                                  ::fidl::kErrorRequestBufferTooSmall);
  }

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) RequestRequest(_context->Txid(), x);
  _request_buffer.set_actual(sizeof(RequestRequest));
  ::fidl::DecodedMessage<RequestRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<RequestResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError Transitional::ClientImpl::OneWay(int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::OneWay(_binding->channel(), x);
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError Transitional::ClientImpl::OneWay(
    ::fidl::BytePart _request_buffer, int64_t x) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = UnownedResultOf::OneWay(
        _binding->channel(), std::move(_request_buffer), std::move(x));
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

std::optional<::fidl::UnbindInfo> Transitional::ClientImpl::Dispatch(
    fidl_msg_t* msg, ::fidl::internal::ResponseContext* context) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kTransitional_Request_Ordinal: {
      auto result = ::fidl::DecodeAs<RequestResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<RequestResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kTransitional_Event_Ordinal: {
      auto result = ::fidl::DecodeAs<EventResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.event)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->x));
      } else {
        std::get<1>(handlers_.event)(std::move(result.message));
      }
      break;
    }
    case kFidlOrdinalEpitaph:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_INVALID_ARGS};
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kPeerClosed,
                                reinterpret_cast<fidl_epitaph_t*>(hdr)->error};
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context) context->OnError();
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

zx_status_t Transitional::SyncClient::HandleEvents(
    Transitional::EventHandlers handlers) {
  return Transitional::Call::HandleEvents(::zx::unowned_channel(channel_),
                                          std::move(handlers));
}

zx_status_t Transitional::Call::HandleEvents(
    ::zx::unowned_channel client_end, Transitional::EventHandlers handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            EventResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<
          EventResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventResponse::MaxNumHandles >= x) {
      x = EventResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t{.bytes = read_bytes,
                        .handles = read_handles,
                        .num_bytes = actual_bytes,
                        .num_handles = actual_handles};
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kTransitional_Event_Ordinal: {
      auto result = ::fidl::DecodeAs<EventResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event(std::move(message->x));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool Transitional::TryDispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kTransitional_Request_Ordinal: {
      auto result = ::fidl::DecodeAs<RequestRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->Request(std::move(message->x),
                    Interface::RequestCompleter::Sync(txn));
      return true;
    }
    case kTransitional_OneWay_Ordinal: {
      auto result = ::fidl::DecodeAs<OneWayRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->OneWay(std::move(message->x),
                   Interface::OneWayCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Transitional::Dispatch(Interface* impl, fidl_msg_t* msg,
                            ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

zx_status_t Transitional::Interface::RequestCompleterBase::ReplyWithStatus(
    int64_t y) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(RequestResponse)];
  auto& _response = *new (_response_buffer) RequestResponse{y};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<RequestResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void Transitional::Interface::RequestCompleterBase::Reply(int64_t y) {
  ReplyWithStatus(std::move(y));
}

zx_status_t Transitional::Interface::RequestCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer, int64_t y) {
  if (_buffer.capacity() < RequestResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) RequestResponse{y};
  _buffer.set_actual(sizeof(RequestResponse));
  return CompleterBase::SendReply(
      ::fidl::DecodedMessage<RequestResponse>(std::move(_buffer)));
}

void Transitional::Interface::RequestCompleterBase::Reply(
    ::fidl::BytePart _buffer, int64_t y) {
  ReplyWithStatus(std::move(_buffer), std::move(y));
}

zx_status_t Transitional::Interface::RequestCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<RequestResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kTransitional_Request_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void Transitional::Interface::RequestCompleterBase::Reply(
    ::fidl::DecodedMessage<RequestResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t Transitional::SendEventEvent(::zx::unowned_channel _chan,
                                         int64_t x) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(EventResponse)];
  auto& _response = *new (_response_buffer) EventResponse{x};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<EventResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t Transitional::SendEventEvent(::zx::unowned_channel _chan,
                                         ::fidl::BytePart _buffer, int64_t x) {
  if (_buffer.capacity() < EventResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) EventResponse{x};
  _buffer.set_actual(sizeof(EventResponse));
  return ::fidl::Write(
      ::zx::unowned_channel(_chan),
      ::fidl::DecodedMessage<EventResponse>(std::move(_buffer)));
}

zx_status_t Transitional::SendEventEvent(
    ::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal == kTransitional_Event_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

void Transitional::RequestRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kTransitional_Request_Ordinal);
}

void Transitional::RequestResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kTransitional_Request_Ordinal);
}

void Transitional::OneWayRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kTransitional_OneWay_Ordinal);
}

void Transitional::EventResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kTransitional_Event_Ordinal);
}

namespace {

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodA_Ordinal =
    1954005452660588540lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodAResponseTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_EventA_Ordinal =
    2691096518916888736lu;
extern "C" const fidl_type_t test_name_ChannelProtocolEventARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodB_Ordinal =
    6751311874614576291lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal =
    3948151641640179063lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace

ChannelProtocol::ResultOf::MethodA_Impl::MethodA_Impl(
    ::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(MethodARequest)];
  auto& _request = *new (_request_buffer) MethodARequest(0, a, b);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<MethodARequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MethodARequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(ChannelProtocol::InPlace::MethodA(
      std::move(_client_end), std::move(_encoded_request)));
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::SyncClient::MethodA(
    int64_t a, int64_t b) {
  return ResultOf::MethodA(::zx::unowned_channel(this->channel_), a, b);
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::Call::MethodA(
    ::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodA(std::move(_client_end), a, b);
}

ChannelProtocol::UnownedResultOf::MethodA_Impl::MethodA_Impl(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::kErrorRequestBufferTooSmall;
    return;
  }
  new (_request_buffer.data()) MethodARequest(0, a, b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<MethodARequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MethodARequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(ChannelProtocol::InPlace::MethodA(
      std::move(_client_end), std::move(_encoded_request)));
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::SyncClient::MethodA(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(::zx::unowned_channel(this->channel_),
                                  std::move(_request_buffer), std::move(a),
                                  std::move(b));
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::Call::MethodA(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(std::move(_client_end),
                                  std::move(_request_buffer), std::move(a),
                                  std::move(b));
}

::fidl::internal::StatusAndError ChannelProtocol::InPlace::MethodA(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<MethodARequest> params) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  return MethodA(std::move(_client_end),
                 std::move(_encode_request_result.message));
}

::fidl::internal::StatusAndError ChannelProtocol::InPlace::MethodA(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<MethodARequest> params) {
  MethodARequest* request =
      reinterpret_cast<MethodARequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0, kChannelProtocol_MethodA_Ordinal);
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(params));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status,
                                            ::fidl::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
ChannelProtocol::ResultOf::MethodB_Impl<ChannelProtocol::MethodBResponse>::
    MethodB_Impl(::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(MethodBRequest)];
  auto& _request = *new (_request_buffer) MethodBRequest(0, a, b);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<MethodBRequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MethodBRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(ChannelProtocol::InPlace::MethodB(
      std::move(_client_end), std::move(_encoded_request),
      Super::response_buffer()));
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::SyncClient::MethodB(
    int64_t a, int64_t b) {
  return ResultOf::MethodB(::zx::unowned_channel(this->channel_), a, b);
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::Call::MethodB(
    ::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodB(std::move(_client_end), a, b);
}

template <>
ChannelProtocol::UnownedResultOf::
    MethodB_Impl<ChannelProtocol::MethodBResponse>::MethodB_Impl(
        ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
        int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MethodBResponse>(
        ZX_ERR_BUFFER_TOO_SMALL, ::fidl::kErrorRequestBufferTooSmall));
    return;
  }
  new (_request_buffer.data()) MethodBRequest(0, a, b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<MethodBRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MethodBRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(ChannelProtocol::InPlace::MethodB(
      std::move(_client_end), std::move(_encoded_request),
      std::move(_response_buffer)));
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::SyncClient::MethodB(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(::zx::unowned_channel(this->channel_),
                                  std::move(_request_buffer), std::move(a),
                                  std::move(b), std::move(_response_buffer));
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::Call::MethodB(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(std::move(_client_end),
                                  std::move(_request_buffer), std::move(a),
                                  std::move(b), std::move(_response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse>
ChannelProtocol::InPlace::MethodB(::zx::unowned_channel _client_end,
                                  ::fidl::DecodedMessage<MethodBRequest> params,
                                  ::fidl::BytePart response_buffer) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  return MethodB(std::move(_client_end),
                 std::move(_encode_request_result.message),
                 std::move(response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse>
ChannelProtocol::InPlace::MethodB(::zx::unowned_channel _client_end,
                                  ::fidl::EncodedMessage<MethodBRequest> params,
                                  ::fidl::BytePart response_buffer) {
  MethodBRequest* request =
      reinterpret_cast<MethodBRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0, kChannelProtocol_MethodB_Ordinal);
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
ChannelProtocol::ResultOf::
    MutateSocket_Impl<ChannelProtocol::MutateSocketResponse>::MutateSocket_Impl(
        ::zx::unowned_channel _client_end, ::zx::socket& a) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(MutateSocketRequest)];
  auto& _request = *new (_request_buffer) MutateSocketRequest(0, a);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<MutateSocketRequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MutateSocketRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(ChannelProtocol::InPlace::MutateSocket(
      std::move(_client_end), std::move(_encoded_request),
      Super::response_buffer()));
}

ChannelProtocol::ResultOf::MutateSocket
ChannelProtocol::SyncClient::MutateSocket(::zx::socket a) {
  return ResultOf::MutateSocket(::zx::unowned_channel(this->channel_), a);
}

ChannelProtocol::ResultOf::MutateSocket ChannelProtocol::Call::MutateSocket(
    ::zx::unowned_channel _client_end, ::zx::socket a) {
  return ResultOf::MutateSocket(std::move(_client_end), a);
}

template <>
ChannelProtocol::UnownedResultOf::
    MutateSocket_Impl<ChannelProtocol::MutateSocketResponse>::MutateSocket_Impl(
        ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
        ::zx::socket a, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MutateSocketResponse>(
        ZX_ERR_BUFFER_TOO_SMALL, ::fidl::kErrorRequestBufferTooSmall));
    return;
  }
  new (_request_buffer.data()) MutateSocketRequest(0, a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<MutateSocketRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<MutateSocketRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(ChannelProtocol::InPlace::MutateSocket(
      std::move(_client_end), std::move(_encoded_request),
      std::move(_response_buffer)));
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer,
                                          ::zx::socket a,
                                          ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(::zx::unowned_channel(this->channel_),
                                       std::move(_request_buffer), std::move(a),
                                       std::move(_response_buffer));
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::Call::MutateSocket(::zx::unowned_channel _client_end,
                                    ::fidl::BytePart _request_buffer,
                                    ::zx::socket a,
                                    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(std::move(_client_end),
                                       std::move(_request_buffer), std::move(a),
                                       std::move(_response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>
ChannelProtocol::InPlace::MutateSocket(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<MutateSocketRequest> params,
    ::fidl::BytePart response_buffer) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>::
        FromFailure(std::move(_encode_request_result));
  }
  return MutateSocket(std::move(_client_end),
                      std::move(_encode_request_result.message),
                      std::move(response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>
ChannelProtocol::InPlace::MutateSocket(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<MutateSocketRequest> params,
    ::fidl::BytePart response_buffer) {
  MutateSocketRequest* request =
      reinterpret_cast<MutateSocketRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0,
                       kChannelProtocol_MutateSocket_Ordinal);
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MethodA(int64_t a,
                                                            int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::MethodA(_binding->channel(), a, b);
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MethodA(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = UnownedResultOf::MethodA(_binding->channel(),
                                         std::move(_request_buffer),
                                         std::move(a), std::move(b));
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::ClientImpl::MethodB_Sync(
    int64_t a, int64_t b) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::MethodB(_binding->channel(), a, b);
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

ChannelProtocol::UnownedResultOf::MethodB
ChannelProtocol::ClientImpl::MethodB_Sync(::fidl::BytePart _request_buffer,
                                          int64_t a, int64_t b,
                                          ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::MethodB(_binding->channel(),
                                    std::move(_request_buffer), std::move(a),
                                    std::move(b), std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MethodB(
    int64_t a, int64_t b, ::fit::callback<void(int64_t result)> _cb) {
  class ManagedResponseContext : public MethodBResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void(int64_t result)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(::fidl::DecodedMessage<MethodBResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->result));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(int64_t result)> cb_;
  };
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<
      MethodBRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error =
      MethodB(_write_bytes_array.view(), std::move(a), std::move(b), _context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MethodB(
    ::fidl::BytePart _request_buffer, int64_t a, int64_t b,
    MethodBResponseContext* _context) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    return ::fidl::StatusAndError(ZX_ERR_BUFFER_TOO_SMALL,
                                  ::fidl::kErrorRequestBufferTooSmall);
  }

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) MethodBRequest(_context->Txid(), a, b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<MethodBResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

ChannelProtocol::ResultOf::MutateSocket
ChannelProtocol::ClientImpl::MutateSocket_Sync(::zx::socket a) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::MutateSocket(_binding->channel(), a);
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

ChannelProtocol::UnownedResultOf::MutateSocket
ChannelProtocol::ClientImpl::MutateSocket_Sync(
    ::fidl::BytePart _request_buffer, ::zx::socket a,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::MutateSocket(
        _binding->channel(), std::move(_request_buffer), std::move(a),
        std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MutateSocket(
    ::zx::socket a, ::fit::callback<void(::zx::socket b)> _cb) {
  class ManagedResponseContext : public MutateSocketResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void(::zx::socket b)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(::fidl::DecodedMessage<MutateSocketResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->b));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(::zx::socket b)> cb_;
  };
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<
      MutateSocketRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error =
      MutateSocket(_write_bytes_array.view(), std::move(a), _context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError ChannelProtocol::ClientImpl::MutateSocket(
    ::fidl::BytePart _request_buffer, ::zx::socket a,
    MutateSocketResponseContext* _context) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    return ::fidl::StatusAndError(ZX_ERR_BUFFER_TOO_SMALL,
                                  ::fidl::kErrorRequestBufferTooSmall);
  }

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) MutateSocketRequest(_context->Txid(), a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<MutateSocketResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

std::optional<::fidl::UnbindInfo> ChannelProtocol::ClientImpl::Dispatch(
    fidl_msg_t* msg, ::fidl::internal::ResponseContext* context) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.event_a)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->a), std::move(message->b));
      } else {
        std::get<1>(handlers_.event_a)(std::move(result.message));
      }
      break;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<MethodBResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kChannelProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<MutateSocketResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kFidlOrdinalEpitaph:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_INVALID_ARGS};
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kPeerClosed,
                                reinterpret_cast<fidl_epitaph_t*>(hdr)->error};
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context) context->OnError();
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

zx_status_t ChannelProtocol::SyncClient::HandleEvents(
    ChannelProtocol::EventHandlers handlers) {
  return ChannelProtocol::Call::HandleEvents(::zx::unowned_channel(channel_),
                                             std::move(handlers));
}

zx_status_t ChannelProtocol::Call::HandleEvents(
    ::zx::unowned_channel client_end, ChannelProtocol::EventHandlers handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            EventAResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<
          EventAResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t{.bytes = read_bytes,
                        .handles = read_handles,
                        .num_bytes = actual_bytes,
                        .num_handles = actual_handles};
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool ChannelProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg,
                                  ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
                    Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
                    Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
                         Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool ChannelProtocol::Dispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan,
                                             int64_t a, int64_t b) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(EventAResponse)];
  auto& _response = *new (_response_buffer) EventAResponse{a, b};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<EventAResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan,
                                             ::fidl::BytePart _buffer,
                                             int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) EventAResponse{a, b};
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(
      ::zx::unowned_channel(_chan),
      ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t ChannelProtocol::SendEventAEvent(
    ::zx::unowned_channel _chan,
    ::fidl::DecodedMessage<EventAResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal == kChannelProtocol_EventA_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

zx_status_t ChannelProtocol::Interface::MethodBCompleterBase::ReplyWithStatus(
    int64_t result) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(MethodBResponse)];
  auto& _response = *new (_response_buffer) MethodBResponse{result};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<MethodBResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(int64_t result) {
  ReplyWithStatus(std::move(result));
}

zx_status_t ChannelProtocol::Interface::MethodBCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) MethodBResponse{result};
  _buffer.set_actual(sizeof(MethodBResponse));
  return CompleterBase::SendReply(
      ::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(
    ::fidl::BytePart _buffer, int64_t result) {
  ReplyWithStatus(std::move(_buffer), std::move(result));
}

zx_status_t ChannelProtocol::Interface::MethodBCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<MethodBResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kChannelProtocol_MethodB_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(
    ::fidl::DecodedMessage<MethodBResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t
ChannelProtocol::Interface::MutateSocketCompleterBase::ReplyWithStatus(
    ::zx::socket b) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(MutateSocketResponse)];
  auto& _response = *new (_response_buffer) MutateSocketResponse{b};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<MutateSocketResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(
    ::zx::socket b) {
  ReplyWithStatus(std::move(b));
}

zx_status_t
ChannelProtocol::Interface::MutateSocketCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  new (_buffer.data()) MutateSocketResponse{b};
  _buffer.set_actual(sizeof(MutateSocketResponse));
  return CompleterBase::SendReply(
      ::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(
    ::fidl::BytePart _buffer, ::zx::socket b) {
  ReplyWithStatus(std::move(_buffer), std::move(b));
}

zx_status_t
ChannelProtocol::Interface::MutateSocketCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<MutateSocketResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kChannelProtocol_MutateSocket_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(
    ::fidl::DecodedMessage<MutateSocketResponse> params) {
  ReplyWithStatus(std::move(params));
}

void ChannelProtocol::MethodARequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MethodA_Ordinal);
}

void ChannelProtocol::EventAResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_EventA_Ordinal);
}

void ChannelProtocol::MethodBRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MethodB_Ordinal);
}

void ChannelProtocol::MethodBResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_MethodB_Ordinal);
}

void ChannelProtocol::MutateSocketRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kChannelProtocol_MutateSocket_Ordinal);
}

void ChannelProtocol::MutateSocketResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kChannelProtocol_MutateSocket_Ordinal);
}

namespace {

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        257584335957785512lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        8101632395109729785lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        5054636755429784136lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        5108499630221504549lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        108302452954061159lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        383797738148261568lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        301337558307652787lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnEmptyResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        3069035692499413769lu;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnWithResponseRequestTable;
extern "C" const fidl_type_t
    test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse_Impl::
    NoRequestNoResponse_Impl(::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(NoRequestNoResponseRequest)];
  auto& _request = *new (_request_buffer) NoRequestNoResponseRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<NoRequestNoResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<NoRequestNoResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(WithAndWithoutRequestResponse::InPlace::NoRequestNoResponse(
      std::move(_client_end)));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestNoResponse() {
  return ResultOf::NoRequestNoResponse(::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse
WithAndWithoutRequestResponse::Call::NoRequestNoResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestNoResponse(std::move(_client_end));
}

::fidl::internal::StatusAndError
WithAndWithoutRequestResponse::InPlace::NoRequestNoResponse(
    ::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestNoResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<NoRequestNoResponseRequest> params(
      std::move(_request_buffer));
  NoRequestNoResponseRequest* request =
      reinterpret_cast<NoRequestNoResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(params));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status,
                                            ::fidl::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse_Impl<
    WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>::
    NoRequestEmptyResponse_Impl(::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(NoRequestEmptyResponseRequest)];
  auto& _request = *new (_request_buffer) NoRequestEmptyResponseRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<NoRequestEmptyResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<NoRequestEmptyResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestEmptyResponse(
          std::move(_client_end), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestEmptyResponse() {
  return ResultOf::NoRequestEmptyResponse(
      ::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::Call::NoRequestEmptyResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestEmptyResponse(std::move(_client_end));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>
WithAndWithoutRequestResponse::InPlace::NoRequestEmptyResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestEmptyResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<NoRequestEmptyResponseRequest> params(
      std::move(_request_buffer));
  NoRequestEmptyResponseRequest* request =
      reinterpret_cast<NoRequestEmptyResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  auto _call_result = ::fidl::Call<NoRequestEmptyResponseRequest,
                                   NoRequestEmptyResponseResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse_Impl<
    WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::
    NoRequestWithResponse_Impl(::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(NoRequestWithResponseRequest)];
  auto& _request = *new (_request_buffer) NoRequestWithResponseRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<NoRequestWithResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<NoRequestWithResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(
          std::move(_client_end), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse() {
  return ResultOf::NoRequestWithResponse(::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::Call::NoRequestWithResponse(
    ::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestWithResponse(std::move(_client_end));
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse_Impl<
    WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::
    NoRequestWithResponse_Impl(::zx::unowned_channel _client_end,
                               ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t
      _write_bytes[sizeof(NoRequestWithResponseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  new (_request_buffer.data()) NoRequestWithResponseRequest(0);
  _request_buffer.set_actual(sizeof(NoRequestWithResponseRequest));
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> _msg(
      std::move(_request_buffer));
  auto _encode_result =
      ::fidl::Encode<NoRequestWithResponseRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<NoRequestWithResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(
          std::move(_client_end), std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(
      ::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::Call::NoRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(std::move(_client_end),
                                                std::move(_response_buffer));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::NoRequestWithResponseResponse>
WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestWithResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<NoRequestWithResponseRequest> params(
      std::move(_request_buffer));
  NoRequestWithResponseRequest* request =
      reinterpret_cast<NoRequestWithResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  auto _call_result =
      ::fidl::Call<NoRequestWithResponseRequest, NoRequestWithResponseResponse>(
          std::move(_client_end), std::move(params),
          std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse_Impl::
    WithRequestNoResponse_Impl(::zx::unowned_channel _client_end,
                               const ::fidl::StringView& arg) {
  WithRequestNoResponseRequest _request(0, arg);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<WithRequestNoResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestNoResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(
      WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(
          std::move(_client_end), std::move(_encoded_request)));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestNoResponse(::zx::unowned_channel(this->channel_),
                                         arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::Call::WithRequestNoResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestNoResponse(std::move(_client_end), arg);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse_Impl::
    WithRequestNoResponse_Impl(::zx::unowned_channel _client_end,
                               ::fidl::BytePart _request_buffer,
                               ::fidl::StringView arg) {
  if (_request_buffer.capacity() < WithRequestNoResponseRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::kErrorRequestBufferTooSmall;
    return;
  }
  WithRequestNoResponseRequest _request(0, arg);
  auto _encode_result =
      ::fidl::LinearizeAndEncode<WithRequestNoResponseRequest>(
          &_request, std::move(_request_buffer));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestNoResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::operator=(
      WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(
          std::move(_client_end), std::move(_encoded_request)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(
      ::zx::unowned_channel(this->channel_), std::move(_request_buffer),
      std::move(arg));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse
WithAndWithoutRequestResponse::Call::WithRequestNoResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(
      std::move(_client_end), std::move(_request_buffer), std::move(arg));
}

::fidl::internal::StatusAndError
WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<WithRequestNoResponseRequest> params) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  return WithRequestNoResponse(std::move(_client_end),
                               std::move(_encode_request_result.message));
}

::fidl::internal::StatusAndError
WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<WithRequestNoResponseRequest> params) {
  WithRequestNoResponseRequest* request =
      reinterpret_cast<WithRequestNoResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(params));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status,
                                            ::fidl::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse_Impl<
    WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::
    WithRequestEmptyResponse_Impl(::zx::unowned_channel _client_end,
                                  const ::fidl::StringView& arg) {
  WithRequestEmptyResponseRequest _request(0, arg);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<WithRequestEmptyResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestEmptyResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(
          std::move(_client_end), std::move(_encoded_request),
          Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestEmptyResponse(
      ::zx::unowned_channel(this->channel_), arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestEmptyResponse(std::move(_client_end), arg);
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse_Impl<
    WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::
    WithRequestEmptyResponse_Impl(::zx::unowned_channel _client_end,
                                  ::fidl::BytePart _request_buffer,
                                  ::fidl::StringView arg,
                                  ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() <
      WithRequestEmptyResponseRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WithRequestEmptyResponseResponse>(
        ZX_ERR_BUFFER_TOO_SMALL, ::fidl::kErrorRequestBufferTooSmall));
    return;
  }
  WithRequestEmptyResponseRequest _request(0, arg);
  auto _encode_result =
      ::fidl::LinearizeAndEncode<WithRequestEmptyResponseRequest>(
          &_request, std::move(_request_buffer));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestEmptyResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(
          std::move(_client_end), std::move(_encoded_request),
          std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(
      ::zx::unowned_channel(this->channel_), std::move(_request_buffer),
      std::move(arg), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(
      std::move(_client_end), std::move(_request_buffer), std::move(arg),
      std::move(_response_buffer));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>
WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> params,
    ::fidl::BytePart response_buffer) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::
        FromFailure(std::move(_encode_request_result));
  }
  return WithRequestEmptyResponse(std::move(_client_end),
                                  std::move(_encode_request_result.message),
                                  std::move(response_buffer));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>
WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<WithRequestEmptyResponseRequest> params,
    ::fidl::BytePart response_buffer) {
  WithRequestEmptyResponseRequest* request =
      reinterpret_cast<WithRequestEmptyResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  auto _call_result = ::fidl::Call<WithRequestEmptyResponseRequest,
                                   WithRequestEmptyResponseResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse_Impl<
    WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::
    WithRequestWithResponse_Impl(::zx::unowned_channel _client_end,
                                 const ::fidl::StringView& arg) {
  WithRequestWithResponseRequest _request(0, arg);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<WithRequestWithResponseRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestWithResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(
          std::move(_client_end), std::move(_encoded_request),
          Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(
    ::fidl::StringView arg) {
  return ResultOf::WithRequestWithResponse(
      ::zx::unowned_channel(this->channel_), arg);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::Call::WithRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestWithResponse(std::move(_client_end), arg);
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse_Impl<
    WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::
    WithRequestWithResponse_Impl(::zx::unowned_channel _client_end,
                                 ::fidl::BytePart _request_buffer,
                                 ::fidl::StringView arg,
                                 ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() <
      WithRequestWithResponseRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WithRequestWithResponseResponse>(
        ZX_ERR_BUFFER_TOO_SMALL, ::fidl::kErrorRequestBufferTooSmall));
    return;
  }
  WithRequestWithResponseRequest _request(0, arg);
  auto _encode_result =
      ::fidl::LinearizeAndEncode<WithRequestWithResponseRequest>(
          &_request, std::move(_request_buffer));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<WithRequestWithResponseRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(
          std::move(_client_end), std::move(_encoded_request),
          std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(
      ::zx::unowned_channel(this->channel_), std::move(_request_buffer),
      std::move(arg), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::Call::WithRequestWithResponse(
    ::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer,
    ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(
      std::move(_client_end), std::move(_request_buffer), std::move(arg),
      std::move(_response_buffer));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::WithRequestWithResponseResponse>
WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::DecodedMessage<WithRequestWithResponseRequest> params,
    ::fidl::BytePart response_buffer) {
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::
        FromFailure(std::move(_encode_request_result));
  }
  return WithRequestWithResponse(std::move(_client_end),
                                 std::move(_encode_request_result.message),
                                 std::move(response_buffer));
}

::fidl::DecodeResult<
    WithAndWithoutRequestResponse::WithRequestWithResponseResponse>
WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(
    ::zx::unowned_channel _client_end,
    ::fidl::EncodedMessage<WithRequestWithResponseRequest> params,
    ::fidl::BytePart response_buffer) {
  WithRequestWithResponseRequest* request =
      reinterpret_cast<WithRequestWithResponseRequest*>(params.bytes().data());
  fidl_init_txn_header(
      &request->_hdr, 0,
      kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  auto _call_result = ::fidl::Call<WithRequestWithResponseRequest,
                                   WithRequestWithResponseResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<
        WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::NoRequestNoResponse() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::NoRequestNoResponse(_binding->channel());
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::NoRequestEmptyResponse(_binding->channel());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse(
    ::fit::callback<void()> _cb) {
  class ManagedResponseContext : public NoRequestEmptyResponseResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void()> cb) : cb_(std::move(cb)) {}

    void OnReply() override {
      cb_();
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void()> cb_;
  };

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = NoRequestEmptyResponse(_context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::NoRequestEmptyResponse(
    NoRequestEmptyResponseResponseContext* _context) {
  FIDL_ALIGNDECL uint8_t
      _write_bytes[sizeof(NoRequestEmptyResponseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) NoRequestEmptyResponseRequest(_context->Txid());
  _request_buffer.set_actual(sizeof(NoRequestEmptyResponseRequest));
  ::fidl::DecodedMessage<NoRequestEmptyResponseRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<NoRequestEmptyResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::NoRequestWithResponse(_binding->channel());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::NoRequestWithResponse(_binding->channel(),
                                                  std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse(
    ::fit::callback<void(::fidl::StringView ret)> _cb) {
  class ManagedResponseContext : public NoRequestWithResponseResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void(::fidl::StringView ret)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(
        ::fidl::DecodedMessage<NoRequestWithResponseResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->ret));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(::fidl::StringView ret)> cb_;
  };

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = NoRequestWithResponse(_context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::NoRequestWithResponse(
    NoRequestWithResponseResponseContext* _context) {
  FIDL_ALIGNDECL uint8_t
      _write_bytes[sizeof(NoRequestWithResponseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) NoRequestWithResponseRequest(_context->Txid());
  _request_buffer.set_actual(sizeof(NoRequestWithResponseRequest));
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<NoRequestWithResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestNoResponse(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = ResultOf::WithRequestNoResponse(_binding->channel(), arg);
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestNoResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    auto _res = UnownedResultOf::WithRequestNoResponse(
        _binding->channel(), std::move(_request_buffer), std::move(arg));
    return ::fidl::StatusAndError(_res.status(), _res.error());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse_Sync(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::WithRequestEmptyResponse(_binding->channel(), arg);
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse_Sync(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::WithRequestEmptyResponse(
        _binding->channel(), std::move(_request_buffer), std::move(arg),
        std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse(
    ::fidl::StringView arg, ::fit::callback<void()> _cb) {
  class ManagedResponseContext
      : public WithRequestEmptyResponseResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void()> cb) : cb_(std::move(cb)) {}

    void OnReply() override {
      cb_();
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void()> cb_;
  };
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<
      WithRequestEmptyResponseRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed =
      std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = WithRequestEmptyResponse(_write_bytes_array.view(),
                                                   std::move(arg), _context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestEmptyResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    WithRequestEmptyResponseResponseContext* _context) {
  if (_request_buffer.capacity() <
      WithRequestEmptyResponseRequest::PrimarySize) {
    return ::fidl::StatusAndError(ZX_ERR_BUFFER_TOO_SMALL,
                                  ::fidl::kErrorRequestBufferTooSmall);
  }

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  WithRequestEmptyResponseRequest _request(_context->Txid(), arg);
  auto _encode_request_result =
      ::fidl::LinearizeAndEncode<WithRequestEmptyResponseRequest>(
          &_request, std::move(_request_buffer));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return std::move(_encode_request_result);
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse_Sync(
    ::fidl::StringView arg) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::WithRequestWithResponse(_binding->channel(), arg);
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse_Sync(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::WithRequestWithResponse(
        _binding->channel(), std::move(_request_buffer), std::move(arg),
        std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse(
    ::fidl::StringView arg, ::fit::callback<void(::fidl::StringView ret)> _cb) {
  class ManagedResponseContext : public WithRequestWithResponseResponseContext {
   public:
    ManagedResponseContext(::fit::callback<void(::fidl::StringView ret)> cb)
        : cb_(std::move(cb)) {}

    void OnReply(
        ::fidl::DecodedMessage<WithRequestWithResponseResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->ret));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(::fidl::StringView ret)> cb_;
  };
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<
      WithRequestWithResponseRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed =
      std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = WithRequestWithResponse(_write_bytes_array.view(),
                                                  std::move(arg), _context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError
WithAndWithoutRequestResponse::ClientImpl::WithRequestWithResponse(
    ::fidl::BytePart _request_buffer, ::fidl::StringView arg,
    WithRequestWithResponseResponseContext* _context) {
  if (_request_buffer.capacity() <
      WithRequestWithResponseRequest::PrimarySize) {
    return ::fidl::StatusAndError(ZX_ERR_BUFFER_TOO_SMALL,
                                  ::fidl::kErrorRequestBufferTooSmall);
  }

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  WithRequestWithResponseRequest _request(_context->Txid(), arg);
  auto _encode_request_result =
      ::fidl::LinearizeAndEncode<WithRequestWithResponseRequest>(
          &_request, std::move(_request_buffer));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return std::move(_encode_request_result);
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

std::optional<::fidl::UnbindInfo>
WithAndWithoutRequestResponse::ClientImpl::Dispatch(
    fidl_msg_t* msg, ::fidl::internal::ResponseContext* context) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestEmptyResponseResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<NoRequestEmptyResponseResponseContext*>(context)->OnReply();
      break;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestWithResponseResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<NoRequestWithResponseResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestEmptyResponseResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<WithRequestEmptyResponseResponseContext*>(context)->OnReply();
      break;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestWithResponseResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<WithRequestWithResponseResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnEmptyResponseResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (!handlers_.on_empty_response)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_NOT_SUPPORTED};
      handlers_.on_empty_response();
      break;
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnWithResponseResponse>(msg);
      if (result.status != ZX_OK) {
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      if (auto* managed = std::get_if<0>(&handlers_.on_with_response)) {
        if (!(*managed))
          return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                    ZX_ERR_NOT_SUPPORTED};
        auto message = result.message.message();
        (*managed)(std::move(message->ret));
      } else {
        std::get<1>(handlers_.on_with_response)(std::move(result.message));
      }
      break;
    }
    case kFidlOrdinalEpitaph:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_INVALID_ARGS};
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kPeerClosed,
                                reinterpret_cast<fidl_epitaph_t*>(hdr)->error};
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context) context->OnError();
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::HandleEvents(
    WithAndWithoutRequestResponse::EventHandlers handlers) {
  return WithAndWithoutRequestResponse::Call::HandleEvents(
      ::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t WithAndWithoutRequestResponse::Call::HandleEvents(
    ::zx::unowned_channel client_end,
    WithAndWithoutRequestResponse::EventHandlers handlers) {
  zx_status_t status =
      client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                           ::zx::time::infinite(), nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<
            OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>() >=
        x) {
      x = ::fidl::internal::ClampedMessageSize<
          OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<
            OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>() >=
        x) {
      x = ::fidl::internal::ClampedMessageSize<
          OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnEmptyResponseResponse::MaxNumHandles >= x) {
      x = OnEmptyResponseResponse::MaxNumHandles;
    }
    if (OnWithResponseResponse::MaxNumHandles >= x) {
      x = OnWithResponseResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD, read_bytes,
                            read_handles, kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t{.bytes = read_bytes,
                        .handles = read_handles,
                        .num_bytes = actual_bytes,
                        .num_handles = actual_handles};
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnEmptyResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      return handlers.on_empty_response();
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnWithResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_with_response(std::move(message->ret));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool WithAndWithoutRequestResponse::TryDispatch(Interface* impl,
                                                fidl_msg_t* msg,
                                                ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestNoResponse(
          Interface::NoRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestEmptyResponse(
          Interface::NoRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->NoRequestWithResponse(
          Interface::NoRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestNoResponse(
          std::move(message->arg),
          Interface::WithRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestEmptyResponse(
          std::move(message->arg),
          Interface::WithRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestWithResponse(
          std::move(message->arg),
          Interface::WithRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithAndWithoutRequestResponse::Dispatch(Interface* impl, fidl_msg_t* msg,
                                             ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    NoRequestEmptyResponseCompleterBase::ReplyWithStatus() {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t
      _response_buffer[sizeof(NoRequestEmptyResponseResponse)];
  auto& _response = *new (_response_buffer) NoRequestEmptyResponseResponse{};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<NoRequestEmptyResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    NoRequestEmptyResponseCompleterBase::Reply() {
  ReplyWithStatus();
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::StringView ret) {
  NoRequestWithResponseResponse _response{ret};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<NoRequestWithResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  ReplyWithStatus(std::move(ret));
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < NoRequestWithResponseResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  NoRequestWithResponseResponse _response{ret};
  auto _encode_result =
      ::fidl::LinearizeAndEncode<NoRequestWithResponseResponse>(
          &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer,
                                              ::fidl::StringView ret) {
  ReplyWithStatus(std::move(_buffer), std::move(ret));
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::DecodedMessage<NoRequestWithResponseResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void WithAndWithoutRequestResponse::Interface::
    NoRequestWithResponseCompleterBase::Reply(
        ::fidl::DecodedMessage<NoRequestWithResponseResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    WithRequestEmptyResponseCompleterBase::ReplyWithStatus() {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t
      _response_buffer[sizeof(WithRequestEmptyResponseResponse)];
  auto& _response = *new (_response_buffer) WithRequestEmptyResponseResponse{};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<WithRequestEmptyResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    WithRequestEmptyResponseCompleterBase::Reply() {
  ReplyWithStatus();
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::StringView ret) {
  WithRequestWithResponseResponse _response{ret};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<WithRequestWithResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  ReplyWithStatus(std::move(ret));
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < WithRequestWithResponseResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  WithRequestWithResponseResponse _response{ret};
  auto _encode_result =
      ::fidl::LinearizeAndEncode<WithRequestWithResponseResponse>(
          &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer,
                                                ::fidl::StringView ret) {
  ReplyWithStatus(std::move(_buffer), std::move(ret));
}

zx_status_t WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::ReplyWithStatus(
        ::fidl::DecodedMessage<WithRequestWithResponseResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(
      params.message()->_hdr.ordinal ==
      kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void WithAndWithoutRequestResponse::Interface::
    WithRequestWithResponseCompleterBase::Reply(
        ::fidl::DecodedMessage<WithRequestWithResponseResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t WithAndWithoutRequestResponse::SendOnEmptyResponseEvent(
    ::zx::unowned_channel _chan) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _response_buffer[sizeof(OnEmptyResponseResponse)];
  auto& _response = *new (_response_buffer) OnEmptyResponseResponse{};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<OnEmptyResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan, ::fidl::StringView ret) {
  OnWithResponseResponse _response{ret};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<OnWithResponseResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan, ::fidl::BytePart _buffer,
    ::fidl::StringView ret) {
  if (_buffer.capacity() < OnWithResponseResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnWithResponseResponse _response{ret};
  auto _encode_result = ::fidl::LinearizeAndEncode<OnWithResponseResponse>(
      &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    return _encode_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan),
                       std::move(_encode_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(
    ::zx::unowned_channel _chan,
    ::fidl::DecodedMessage<OnWithResponseResponse> params) {
  ZX_ASSERT(params.message()->_hdr.magic_number ==
            kFidlWireFormatMagicNumberInitial);
  ZX_ASSERT(params.message()->_hdr.ordinal ==
            kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}

void WithAndWithoutRequestResponse::NoRequestNoResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid, kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestEmptyResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestWithResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::NoRequestWithResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestNoResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestEmptyResponseRequest::
    _InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0,
      kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestWithResponseRequest::_InitHeader(
    zx_txid_t _txid) {
  fidl_init_txn_header(
      &_hdr, _txid,
      kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::WithRequestWithResponseResponse::
    _InitHeader() {
  fidl_init_txn_header(
      &_hdr, 0, kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
}

void WithAndWithoutRequestResponse::OnEmptyResponseResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0,
                       kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
}

void WithAndWithoutRequestResponse::OnWithResponseResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0,
                       kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::
    SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(WithErrorSyntax_ErrorAsEnum_Result) ==
                sizeof(fidl_xunion_t));
  static_assert(offsetof(WithErrorSyntax_ErrorAsEnum_Result, ordinal_) ==
                offsetof(fidl_xunion_t, tag));
  static_assert(offsetof(WithErrorSyntax_ErrorAsEnum_Result, envelope_) ==
                offsetof(fidl_xunion_t, envelope));
}

namespace {

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    6422511116044938191lu;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxResponseAsStructResponseTable;
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    2364249812017832126lu;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
extern "C" const fidl_type_t
    test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal =
    4597390537870356095lu;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace
template <>
WithErrorSyntax::ResultOf::ResponseAsStruct_Impl<
    WithErrorSyntax::ResponseAsStructResponse>::
    ResponseAsStruct_Impl(::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(ResponseAsStructRequest)];
  auto& _request = *new (_request_buffer) ResponseAsStructRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ResponseAsStructRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ResponseAsStructRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ResponseAsStruct(
      std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::SyncClient::ResponseAsStruct() {
  return ResultOf::ResponseAsStruct(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end) {
  return ResultOf::ResponseAsStruct(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::ResponseAsStruct_Impl<
    WithErrorSyntax::ResponseAsStructResponse>::
    ResponseAsStruct_Impl(::zx::unowned_channel _client_end,
                          ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ResponseAsStructRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  new (_request_buffer.data()) ResponseAsStructRequest(0);
  _request_buffer.set_actual(sizeof(ResponseAsStructRequest));
  ::fidl::DecodedMessage<ResponseAsStructRequest> _msg(
      std::move(_request_buffer));
  auto _encode_result =
      ::fidl::Encode<ResponseAsStructRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ResponseAsStructRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ResponseAsStruct(
      std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::SyncClient::ResponseAsStruct(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(
      ::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end,
                                        ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(std::move(_client_end),
                                           std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ResponseAsStructResponse>
WithErrorSyntax::InPlace::ResponseAsStruct(::zx::unowned_channel _client_end,
                                           ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ResponseAsStructRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<ResponseAsStructRequest> params(
      std::move(_request_buffer));
  ResponseAsStructRequest* request =
      reinterpret_cast<ResponseAsStructRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0,
                       kWithErrorSyntax_ResponseAsStruct_Ordinal);
  auto _call_result =
      ::fidl::Call<ResponseAsStructRequest, ResponseAsStructResponse>(
          std::move(_client_end), std::move(params),
          std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ResponseAsStructResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithErrorSyntax::ResultOf::ErrorAsPrimitive_Impl<
    WithErrorSyntax::ErrorAsPrimitiveResponse>::
    ErrorAsPrimitive_Impl(::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(ErrorAsPrimitiveRequest)];
  auto& _request = *new (_request_buffer) ErrorAsPrimitiveRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ErrorAsPrimitiveRequest>(
          &_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ErrorAsPrimitiveRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ErrorAsPrimitive(
      std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::SyncClient::ErrorAsPrimitive() {
  return ResultOf::ErrorAsPrimitive(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsPrimitive(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive_Impl<
    WithErrorSyntax::ErrorAsPrimitiveResponse>::
    ErrorAsPrimitive_Impl(::zx::unowned_channel _client_end,
                          ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsPrimitiveRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  new (_request_buffer.data()) ErrorAsPrimitiveRequest(0);
  _request_buffer.set_actual(sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _msg(
      std::move(_request_buffer));
  auto _encode_result =
      ::fidl::Encode<ErrorAsPrimitiveRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ErrorAsPrimitiveRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ErrorAsPrimitive(
      std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::SyncClient::ErrorAsPrimitive(
    ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(
      ::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end,
                                        ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(std::move(_client_end),
                                           std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>
WithErrorSyntax::InPlace::ErrorAsPrimitive(::zx::unowned_channel _client_end,
                                           ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsPrimitiveRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<ErrorAsPrimitiveRequest> params(
      std::move(_request_buffer));
  ErrorAsPrimitiveRequest* request =
      reinterpret_cast<ErrorAsPrimitiveRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0,
                       kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  auto _call_result =
      ::fidl::Call<ErrorAsPrimitiveRequest, ErrorAsPrimitiveResponse>(
          std::move(_client_end), std::move(params),
          std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithErrorSyntax::ResultOf::
    ErrorAsEnum_Impl<WithErrorSyntax::ErrorAsEnumResponse>::ErrorAsEnum_Impl(
        ::zx::unowned_channel _client_end) {
  // Destructors can't be called because it will lead to handle double close
  // (here and in fidl::Encode).
  FIDL_ALIGNDECL uint8_t _request_buffer[sizeof(ErrorAsEnumRequest)];
  auto& _request = *new (_request_buffer) ErrorAsEnumRequest(0);

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ErrorAsEnumRequest>(&_request);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ErrorAsEnumRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ErrorAsEnum(
      std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ErrorAsEnum
WithErrorSyntax::SyncClient::ErrorAsEnum() {
  return ResultOf::ErrorAsEnum(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ErrorAsEnum WithErrorSyntax::Call::ErrorAsEnum(
    ::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsEnum(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::
    ErrorAsEnum_Impl<WithErrorSyntax::ErrorAsEnumResponse>::ErrorAsEnum_Impl(
        ::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsEnumRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  new (_request_buffer.data()) ErrorAsEnumRequest(0);
  _request_buffer.set_actual(sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _msg(std::move(_request_buffer));
  auto _encode_result = ::fidl::Encode<ErrorAsEnumRequest>(std::move(_msg));
  if (_encode_result.status != ZX_OK) {
    Super::SetFailure(std::move(_encode_result));
    return;
  }
  ::fidl::EncodedMessage<ErrorAsEnumRequest> _encoded_request =
      std::move(_encode_result.message);
  Super::SetResult(WithErrorSyntax::InPlace::ErrorAsEnum(
      std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::SyncClient::ErrorAsEnum(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(::zx::unowned_channel(this->channel_),
                                      std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::Call::ErrorAsEnum(::zx::unowned_channel _client_end,
                                   ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(std::move(_client_end),
                                      std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>
WithErrorSyntax::InPlace::ErrorAsEnum(::zx::unowned_channel _client_end,
                                      ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsEnumRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::EncodedMessage<ErrorAsEnumRequest> params(std::move(_request_buffer));
  ErrorAsEnumRequest* request =
      reinterpret_cast<ErrorAsEnumRequest*>(params.bytes().data());
  fidl_init_txn_header(&request->_hdr, 0, kWithErrorSyntax_ErrorAsEnum_Ordinal);
  auto _call_result = ::fidl::Call<ErrorAsEnumRequest, ErrorAsEnumResponse>(
      std::move(_client_end), std::move(params), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>::
        FromFailure(std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

WithErrorSyntax::ResultOf::ResponseAsStruct
WithErrorSyntax::ClientImpl::ResponseAsStruct_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ResponseAsStruct(_binding->channel());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct
WithErrorSyntax::ClientImpl::ResponseAsStruct_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ResponseAsStruct(_binding->channel(),
                                             std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ResponseAsStruct(
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result)>
        _cb) {
  class ManagedResponseContext : public ResponseAsStructResponseContext {
   public:
    ManagedResponseContext(
        ::fit::callback<
            void(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result
                     result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(
        ::fidl::DecodedMessage<ResponseAsStructResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->result));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result)>
        cb_;
  };

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = ResponseAsStruct(_context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ResponseAsStruct(
    ResponseAsStructResponseContext* _context) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ResponseAsStructRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) ResponseAsStructRequest(_context->Txid());
  _request_buffer.set_actual(sizeof(ResponseAsStructRequest));
  ::fidl::DecodedMessage<ResponseAsStructRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<ResponseAsStructResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive
WithErrorSyntax::ClientImpl::ErrorAsPrimitive_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ErrorAsPrimitive(_binding->channel());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive
WithErrorSyntax::ClientImpl::ErrorAsPrimitive_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ErrorAsPrimitive(_binding->channel(),
                                             std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ErrorAsPrimitive(
    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result)>
        _cb) {
  class ManagedResponseContext : public ErrorAsPrimitiveResponseContext {
   public:
    ManagedResponseContext(
        ::fit::callback<
            void(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result
                     result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(
        ::fidl::DecodedMessage<ErrorAsPrimitiveResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->result));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result)>
        cb_;
  };

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = ErrorAsPrimitive(_context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ErrorAsPrimitive(
    ErrorAsPrimitiveResponseContext* _context) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsPrimitiveRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) ErrorAsPrimitiveRequest(_context->Txid());
  _request_buffer.set_actual(sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<ErrorAsPrimitiveResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithErrorSyntax::ResultOf::ErrorAsEnum
WithErrorSyntax::ClientImpl::ErrorAsEnum_Sync() {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return ResultOf::ErrorAsEnum(_binding->channel());
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum
WithErrorSyntax::ClientImpl::ErrorAsEnum_Sync(
    ::fidl::BytePart _response_buffer) {
  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    return UnownedResultOf::ErrorAsEnum(_binding->channel(),
                                        std::move(_response_buffer));
  }
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ErrorAsEnum(
    ::fit::callback<
        void(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
        _cb) {
  class ManagedResponseContext : public ErrorAsEnumResponseContext {
   public:
    ManagedResponseContext(
        ::fit::callback<void(
            ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
            cb)
        : cb_(std::move(cb)) {}

    void OnReply(::fidl::DecodedMessage<ErrorAsEnumResponse> msg) override {
      auto message = msg.message();
      cb_(std::move(message->result));
      delete this;
    }

    void OnError() override { delete this; }

    ::fit::callback<void(
        ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result)>
        cb_;
  };

  auto* _context = new ManagedResponseContext(std::move(_cb));
  auto status_and_error = ErrorAsEnum(_context);
  if (!status_and_error.ok()) {
    delete _context;
  }
  return status_and_error;
}

::fidl::StatusAndError WithErrorSyntax::ClientImpl::ErrorAsEnum(
    ErrorAsEnumResponseContext* _context) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsEnumRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));

  ::fidl::internal::ClientBase::PrepareAsyncTxn(_context);
  new (_request_buffer.data()) ErrorAsEnumRequest(_context->Txid());
  _request_buffer.set_actual(sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _decoded_request(
      std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
    return ::fidl::DecodeResult<ErrorAsEnumResponse>::FromFailure(
        std::move(_encode_request_result));
  }

  if (auto _binding = ::fidl::internal::ClientBase::GetBinding()) {
    zx_status_t _write_status = ::fidl::Write(
        _binding->channel(), std::move(_encode_request_result.message));
    if (_write_status != ZX_OK) {
      ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
      return ::fidl::StatusAndError(_write_status, ::fidl::kErrorWriteFailed);
    }
    return ::fidl::StatusAndError(ZX_OK, nullptr);
  }
  ::fidl::internal::ClientBase::ForgetAsyncTxn(_context);
  return ::fidl::StatusAndError(ZX_ERR_CANCELED, ::fidl::kErrorChannelUnbound);
}

std::optional<::fidl::UnbindInfo> WithErrorSyntax::ClientImpl::Dispatch(
    fidl_msg_t* msg, ::fidl::internal::ResponseContext* context) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithErrorSyntax_ResponseAsStruct_Ordinal: {
      auto result = ::fidl::DecodeAs<ResponseAsStructResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<ResponseAsStructResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsPrimitiveResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<ErrorAsPrimitiveResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsEnumResponse>(msg);
      if (result.status != ZX_OK) {
        context->OnError();
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kDecodeError,
                                  result.status};
      }
      static_cast<ErrorAsEnumResponseContext*>(context)->OnReply(
          std::move(result.message));
      break;
    }
    case kFidlOrdinalEpitaph:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context)
        return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                  ZX_ERR_INVALID_ARGS};
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kPeerClosed,
                                reinterpret_cast<fidl_epitaph_t*>(hdr)->error};
    default:
      zx_handle_close_many(msg->handles, msg->num_handles);
      if (context) context->OnError();
      return ::fidl::UnbindInfo{::fidl::UnbindInfo::kUnexpectedMessage,
                                ZX_ERR_NOT_SUPPORTED};
  }
  return {};
}

bool WithErrorSyntax::TryDispatch(Interface* impl, fidl_msg_t* msg,
                                  ::fidl::Transaction* txn) {
  fidl_message_header_t* hdr =
      reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithErrorSyntax_ResponseAsStruct_Ordinal: {
      auto result = ::fidl::DecodeAs<ResponseAsStructRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ResponseAsStruct(Interface::ResponseAsStructCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsPrimitiveRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ErrorAsPrimitive(Interface::ErrorAsPrimitiveCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsEnumRequest>(msg);
      if (result.status != ZX_OK) {
        txn->InternalError({::fidl::UnbindInfo::kDecodeError, result.status});
        return true;
      }
      impl->ErrorAsEnum(Interface::ErrorAsEnumCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithErrorSyntax::Dispatch(Interface* impl, fidl_msg_t* msg,
                               ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->InternalError(
        {::fidl::UnbindInfo::kUnexpectedMessage, ZX_ERR_NOT_SUPPORTED});
  }
  return found;
}

zx_status_t
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyWithStatus(
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  ResponseAsStructResponse _response{result};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ResponseAsStructResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  ReplyWithStatus(std::move(result));
}
zx_status_t WithErrorSyntax::Interface::ResponseAsStructCompleterBase::
    ReplySuccessWithStatus(int64_t a, int64_t b, int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  return ReplyWithStatus(WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(
    int64_t a, int64_t b, int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  ReplyWithStatus(WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
zx_status_t
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyErrorWithStatus(
    uint32_t error) {
  return ReplyWithStatus(WithErrorSyntax_ResponseAsStruct_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyError(
    uint32_t error) {
  ReplyWithStatus(WithErrorSyntax_ResponseAsStruct_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

zx_status_t
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  if (_buffer.capacity() < ResponseAsStructResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  ResponseAsStructResponse _response{result};
  auto _encode_result = ::fidl::LinearizeAndEncode<ResponseAsStructResponse>(
      &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  ReplyWithStatus(std::move(_buffer), std::move(result));
}
zx_status_t WithErrorSyntax::Interface::ResponseAsStructCompleterBase::
    ReplySuccessWithStatus(::fidl::BytePart _buffer, int64_t a, int64_t b,
                           int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  return ReplyWithStatus(std::move(_buffer),
                         WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
                             ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer, int64_t a, int64_t b, int64_t c) {
  ::fidl::aligned<WithErrorSyntax_ResponseAsStruct_Response> response;
  response.value.a = std::move(a);
  response.value.b = std::move(b);
  response.value.c = std::move(c);

  ReplyWithStatus(std::move(_buffer),
                  WithErrorSyntax_ResponseAsStruct_Result::WithResponse(
                      ::fidl::unowned_ptr(&response)));
}

zx_status_t
WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<ResponseAsStructResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kWithErrorSyntax_ResponseAsStruct_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(
    ::fidl::DecodedMessage<ResponseAsStructResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyWithStatus(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  ErrorAsPrimitiveResponse _response{result};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ErrorAsPrimitiveResponse>(
          &_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  ReplyWithStatus(std::move(result));
}
zx_status_t WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::
    ReplySuccessWithStatus() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  return ReplyWithStatus(WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  ReplyWithStatus(WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
zx_status_t
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyErrorWithStatus(
    uint32_t error) {
  return ReplyWithStatus(WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyError(
    uint32_t error) {
  ReplyWithStatus(WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(
      ::fidl::unowned_ptr(&error)));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  if (_buffer.capacity() < ErrorAsPrimitiveResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  ErrorAsPrimitiveResponse _response{result};
  auto _encode_result = ::fidl::LinearizeAndEncode<ErrorAsPrimitiveResponse>(
      &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  ReplyWithStatus(std::move(_buffer), std::move(result));
}
zx_status_t WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::
    ReplySuccessWithStatus(::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  return ReplyWithStatus(std::move(_buffer),
                         WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
                             ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsPrimitive_Response> response;

  ReplyWithStatus(std::move(_buffer),
                  WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(
                      ::fidl::unowned_ptr(&response)));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<ErrorAsPrimitiveResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(
    ::fidl::DecodedMessage<ErrorAsPrimitiveResponse> params) {
  ReplyWithStatus(std::move(params));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyWithStatus(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  ErrorAsEnumResponse _response{result};

  auto _encoded =
      ::fidl::internal::LinearizedAndEncoded<ErrorAsEnumResponse>(&_response);
  auto& _encode_result = _encoded.result();
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  ReplyWithStatus(std::move(result));
}
zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccessWithStatus() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  return ReplyWithStatus(WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess() {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  ReplyWithStatus(WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
      ::fidl::unowned_ptr(&response)));
}
zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyErrorWithStatus(
    ErrorEnun error) {
  return ReplyWithStatus(
      WithErrorSyntax_ErrorAsEnum_Result::WithErr(::fidl::unowned_ptr(&error)));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyError(
    ErrorEnun error) {
  ReplyWithStatus(
      WithErrorSyntax_ErrorAsEnum_Result::WithErr(::fidl::unowned_ptr(&error)));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyWithStatus(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  if (_buffer.capacity() < ErrorAsEnumResponse::PrimarySize) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, ZX_ERR_BUFFER_TOO_SMALL});
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  ErrorAsEnumResponse _response{result};
  auto _encode_result = ::fidl::LinearizeAndEncode<ErrorAsEnumResponse>(
      &_response, std::move(_buffer));
  if (_encode_result.status != ZX_OK) {
    CompleterBase::InternalError(
        {::fidl::UnbindInfo::kEncodeError, _encode_result.status});
    return _encode_result.status;
  }
  return CompleterBase::SendReply(std::move(_encode_result.message));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(
    ::fidl::BytePart _buffer,
    ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  ReplyWithStatus(std::move(_buffer), std::move(result));
}
zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccessWithStatus(
    ::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  return ReplyWithStatus(std::move(_buffer),
                         WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
                             ::fidl::unowned_ptr(&response)));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess(
    ::fidl::BytePart _buffer) {
  ::fidl::aligned<WithErrorSyntax_ErrorAsEnum_Response> response;

  ReplyWithStatus(std::move(_buffer),
                  WithErrorSyntax_ErrorAsEnum_Result::WithResponse(
                      ::fidl::unowned_ptr(&response)));
}

zx_status_t
WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyWithStatus(
    ::fidl::DecodedMessage<ErrorAsEnumResponse> params) {
  ZX_DEBUG_ASSERT(params.message()->_hdr.magic_number ==
                  kFidlWireFormatMagicNumberInitial);
  ZX_DEBUG_ASSERT(params.message()->_hdr.ordinal ==
                  kWithErrorSyntax_ErrorAsEnum_Ordinal);
  return CompleterBase::SendReply(std::move(params));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(
    ::fidl::DecodedMessage<ErrorAsEnumResponse> params) {
  ReplyWithStatus(std::move(params));
}

void WithErrorSyntax::ResponseAsStructRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void WithErrorSyntax::ResponseAsStructResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ResponseAsStruct_Ordinal);
}

void WithErrorSyntax::ErrorAsPrimitiveRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void WithErrorSyntax::ErrorAsPrimitiveResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
}

void WithErrorSyntax::ErrorAsEnumRequest::_InitHeader(zx_txid_t _txid) {
  fidl_init_txn_header(&_hdr, _txid, kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

void WithErrorSyntax::ErrorAsEnumResponse::_InitHeader() {
  fidl_init_txn_header(&_hdr, 0, kWithErrorSyntax_ErrorAsEnum_Ordinal);
}

}  // namespace name
}  // namespace test
}  // namespace llcpp

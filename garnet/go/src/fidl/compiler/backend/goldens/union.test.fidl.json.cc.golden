// WARNING: This file is machine generated by fidlgen.

#include <union.test.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

Union::Union() : value_() {}

Union::~Union() {
}

Union::Union(Union&& other) : value_(std::move(other.value_)) {
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void Union::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (_encoder->ShouldEncodeUnionAsXUnion()) {
    EncodeAsXUnionBytes(_encoder, _offset);
    return;
  }

  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &Primitive(), _offset + 8);
    break;
   case 1:
    ::fidl::Encode(_encoder, &StringNeedsConstructor(), _offset + 8);
    break;
   case 2:
    ::fidl::Encode(_encoder, &VectorStringAlsoNeedsConstructor(), _offset + 8);
    break;
   default:
    break;
  }
}

void Union::EncodeAsXUnionBytes(::fidl::Encoder* _encoder, size_t _offset) {
  const size_t length_before = _encoder->CurrentLength();
  const size_t handles_before = _encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kPrimitive: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &Primitive(), envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &StringNeedsConstructor(), envelope_offset);
      break;
    }
    case Tag::kVectorStringAlsoNeedsConstructor: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<::std::string>, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &VectorStringAlsoNeedsConstructor(), envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = _encoder->GetPtr<fidl_xunion_t>(_offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = WhichXUnionTag();
    xunion->envelope.num_bytes = _encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = _encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void Union::Decode(::fidl::Decoder* _decoder, Union* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      int32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 8);
      _value->set_Primitive(std::move(_member));
      break;
    }
   case 1:
    {
      ::std::string _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 8);
      _value->set_StringNeedsConstructor(std::move(_member));
      break;
    }
   case 2:
    {
      ::std::vector<::std::string> _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 8);
      _value->set_VectorStringAlsoNeedsConstructor(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t Union::Clone(Union* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kPrimitive:
      {
        int32_t _member{};
        _status = ::fidl::Clone(Primitive(), &_member);
        if (_status == ZX_OK) {
          _result->set_Primitive(std::move(_member));
        }
      }
      break;
    case Tag::kStringNeedsConstructor:
      {
        ::std::string _member{};
        _status = ::fidl::Clone(StringNeedsConstructor(), &_member);
        if (_status == ZX_OK) {
          _result->set_StringNeedsConstructor(std::move(_member));
        }
      }
      break;
    case Tag::kVectorStringAlsoNeedsConstructor:
      {
        ::std::vector<::std::string> _member{};
        _status = ::fidl::Clone(VectorStringAlsoNeedsConstructor(), &_member);
        if (_status == ZX_OK) {
          _result->set_VectorStringAlsoNeedsConstructor(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void Union::set_Primitive(int32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kPrimitive) + 1>(std::move(value));
}

void Union::set_StringNeedsConstructor(::std::string value) {
  value_.emplace<static_cast<size_t>(Tag::kStringNeedsConstructor) + 1>(std::move(value));
}

void Union::set_VectorStringAlsoNeedsConstructor(::std::vector<::std::string> value) {
  value_.emplace<static_cast<size_t>(Tag::kVectorStringAlsoNeedsConstructor) + 1>(std::move(value));
}
ReverseOrdinalUnion::ReverseOrdinalUnion() : value_() {}

ReverseOrdinalUnion::~ReverseOrdinalUnion() {
}

ReverseOrdinalUnion::ReverseOrdinalUnion(ReverseOrdinalUnion&& other) : value_(std::move(other.value_)) {
}

ReverseOrdinalUnion& ReverseOrdinalUnion::operator=(ReverseOrdinalUnion&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void ReverseOrdinalUnion::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (_encoder->ShouldEncodeUnionAsXUnion()) {
    EncodeAsXUnionBytes(_encoder, _offset);
    return;
  }

  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &first(), _offset + 4);
    break;
   case 1:
    ::fidl::Encode(_encoder, &second(), _offset + 4);
    break;
   default:
    break;
  }
}

void ReverseOrdinalUnion::EncodeAsXUnionBytes(::fidl::Encoder* _encoder, size_t _offset) {
  const size_t length_before = _encoder->CurrentLength();
  const size_t handles_before = _encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kFirst: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &first(), envelope_offset);
      break;
    }
    case Tag::kSecond: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &second(), envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = _encoder->GetPtr<fidl_xunion_t>(_offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = WhichXUnionTag();
    xunion->envelope.num_bytes = _encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = _encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void ReverseOrdinalUnion::Decode(::fidl::Decoder* _decoder, ReverseOrdinalUnion* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      uint32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_first(std::move(_member));
      break;
    }
   case 1:
    {
      uint32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_second(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t ReverseOrdinalUnion::Clone(ReverseOrdinalUnion* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kFirst:
      {
        uint32_t _member{};
        _status = ::fidl::Clone(first(), &_member);
        if (_status == ZX_OK) {
          _result->set_first(std::move(_member));
        }
      }
      break;
    case Tag::kSecond:
      {
        uint32_t _member{};
        _status = ::fidl::Clone(second(), &_member);
        if (_status == ZX_OK) {
          _result->set_second(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void ReverseOrdinalUnion::set_first(uint32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kFirst) + 1>(std::move(value));
}

void ReverseOrdinalUnion::set_second(uint32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kSecond) + 1>(std::move(value));
}
extern "C" const fidl_type_t test_name_NullableUnionStructTable;
const fidl_type_t* NullableUnionStruct::FidlType = &test_name_NullableUnionStructTable;
extern "C" const fidl_type_t v1_test_name_NullableUnionStructTable;
const fidl_type_t* NullableUnionStruct::FidlTypeV1 = &v1_test_name_NullableUnionStructTable;

void NullableUnionStruct::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (_encoder->ShouldEncodeUnionAsXUnion()) {
    ::fidl::Encode(_encoder, &the_union, _offset + 0);
  } else {
    ::fidl::Encode(_encoder, &the_union, _offset + 0);
  }
}

void NullableUnionStruct::Decode(::fidl::Decoder* _decoder, NullableUnionStruct* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->the_union, _offset + 0);
}

zx_status_t NullableUnionStruct::Clone(NullableUnionStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(the_union, &_result->the_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
FieldCollision::FieldCollision() : value_() {}

FieldCollision::~FieldCollision() {
}

FieldCollision::FieldCollision(FieldCollision&& other) : value_(std::move(other.value_)) {
}

FieldCollision& FieldCollision::operator=(FieldCollision&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void FieldCollision::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (_encoder->ShouldEncodeUnionAsXUnion()) {
    EncodeAsXUnionBytes(_encoder, _offset);
    return;
  }

  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &field_collision_tag(), _offset + 4);
    break;
   default:
    break;
  }
}

void FieldCollision::EncodeAsXUnionBytes(::fidl::Encoder* _encoder, size_t _offset) {
  const size_t length_before = _encoder->CurrentLength();
  const size_t handles_before = _encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kFieldCollisionTag: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &field_collision_tag(), envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = _encoder->GetPtr<fidl_xunion_t>(_offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = WhichXUnionTag();
    xunion->envelope.num_bytes = _encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = _encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void FieldCollision::Decode(::fidl::Decoder* _decoder, FieldCollision* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      int32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_field_collision_tag(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t FieldCollision::Clone(FieldCollision* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kFieldCollisionTag:
      {
        int32_t _member{};
        _status = ::fidl::Clone(field_collision_tag(), &_member);
        if (_status == ZX_OK) {
          _result->set_field_collision_tag(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void FieldCollision::set_field_collision_tag(int32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kFieldCollisionTag) + 1>(std::move(value));
}
ExplicitUnion::ExplicitUnion() : value_() {}

ExplicitUnion::~ExplicitUnion() {
}

ExplicitUnion::ExplicitUnion(ExplicitUnion&& other) : value_(std::move(other.value_)) {
}

ExplicitUnion& ExplicitUnion::operator=(ExplicitUnion&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void ExplicitUnion::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (_encoder->ShouldEncodeUnionAsXUnion()) {
    EncodeAsXUnionBytes(_encoder, _offset);
    return;
  }

  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &Primitive(), _offset + 8);
    break;
   case 1:
    ::fidl::Encode(_encoder, &StringNeedsConstructor(), _offset + 8);
    break;
   default:
    break;
  }
}

void ExplicitUnion::EncodeAsXUnionBytes(::fidl::Encoder* _encoder, size_t _offset) {
  const size_t length_before = _encoder->CurrentLength();
  const size_t handles_before = _encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (Which()) {
    case Tag::kPrimitive: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<int32_t, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &Primitive(), envelope_offset);
      break;
    }
    case Tag::kStringNeedsConstructor: {
      envelope_offset = _encoder->Alloc(::fidl::EncodingInlineSize<::std::string, ::fidl::Encoder>(_encoder));
      ::fidl::Encode(_encoder, &StringNeedsConstructor(), envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = _encoder->GetPtr<fidl_xunion_t>(_offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = WhichXUnionTag();
    xunion->envelope.num_bytes = _encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = _encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void ExplicitUnion::Decode(::fidl::Decoder* _decoder, ExplicitUnion* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      int32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 8);
      _value->set_Primitive(std::move(_member));
      break;
    }
   case 1:
    {
      ::std::string _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 8);
      _value->set_StringNeedsConstructor(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t ExplicitUnion::Clone(ExplicitUnion* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kPrimitive:
      {
        int32_t _member{};
        _status = ::fidl::Clone(Primitive(), &_member);
        if (_status == ZX_OK) {
          _result->set_Primitive(std::move(_member));
        }
      }
      break;
    case Tag::kStringNeedsConstructor:
      {
        ::std::string _member{};
        _status = ::fidl::Clone(StringNeedsConstructor(), &_member);
        if (_status == ZX_OK) {
          _result->set_StringNeedsConstructor(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void ExplicitUnion::set_Primitive(int32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kPrimitive) + 1>(std::move(value));
}

void ExplicitUnion::set_StringNeedsConstructor(::std::string value) {
  value_.emplace<static_cast<size_t>(Tag::kStringNeedsConstructor) + 1>(std::move(value));
}
}  // namespace name
}  // namespace test


// WARNING: This file is machine generated by fidlgen.

#include <handles.test.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

extern "C" const fidl_type_t v1_test_name_HandlesTable;
const fidl_type_t* Handles::FidlType = &v1_test_name_HandlesTable;

void Handles::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &plain_handle, _offset + 0);
  ::fidl::Encode(_encoder, &bti_handle, _offset + 4);
  ::fidl::Encode(_encoder, &channel_handle, _offset + 8);
  ::fidl::Encode(_encoder, &debuglog_handle, _offset + 12);
  ::fidl::Encode(_encoder, &event_handle, _offset + 16);
  ::fidl::Encode(_encoder, &eventpair_handle, _offset + 20);
  ::fidl::Encode(_encoder, &exception_handle, _offset + 24);
  ::fidl::Encode(_encoder, &fifo_handle, _offset + 28);
  ::fidl::Encode(_encoder, &guest_handle, _offset + 32);
  ::fidl::Encode(_encoder, &interrupt_handle, _offset + 36);
  ::fidl::Encode(_encoder, &iommu_handle, _offset + 40);
  ::fidl::Encode(_encoder, &job_handle, _offset + 44);
  ::fidl::Encode(_encoder, &pager_handle, _offset + 48);
  ::fidl::Encode(_encoder, &pcidevice_handle, _offset + 52);
  ::fidl::Encode(_encoder, &pmt_handle, _offset + 56);
  ::fidl::Encode(_encoder, &port_handle, _offset + 60);
  ::fidl::Encode(_encoder, &process_handle, _offset + 64);
  ::fidl::Encode(_encoder, &profile_handle, _offset + 68);
  ::fidl::Encode(_encoder, &resource_handle, _offset + 72);
  ::fidl::Encode(_encoder, &socket_handle, _offset + 76);
  ::fidl::Encode(_encoder, &suspendtoken_handle, _offset + 80);
  ::fidl::Encode(_encoder, &thread_handle, _offset + 84);
  ::fidl::Encode(_encoder, &timer_handle, _offset + 88);
  ::fidl::Encode(_encoder, &vcpu_handle, _offset + 92);
  ::fidl::Encode(_encoder, &vmar_handle, _offset + 96);
  ::fidl::Encode(_encoder, &vmo_handle, _offset + 100);
}

void Handles::Decode(::fidl::Decoder* _decoder, Handles* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->plain_handle, _offset + 0);
  ::fidl::Decode(_decoder, &value->bti_handle, _offset + 4);
  ::fidl::Decode(_decoder, &value->channel_handle, _offset + 8);
  ::fidl::Decode(_decoder, &value->debuglog_handle, _offset + 12);
  ::fidl::Decode(_decoder, &value->event_handle, _offset + 16);
  ::fidl::Decode(_decoder, &value->eventpair_handle, _offset + 20);
  ::fidl::Decode(_decoder, &value->exception_handle, _offset + 24);
  ::fidl::Decode(_decoder, &value->fifo_handle, _offset + 28);
  ::fidl::Decode(_decoder, &value->guest_handle, _offset + 32);
  ::fidl::Decode(_decoder, &value->interrupt_handle, _offset + 36);
  ::fidl::Decode(_decoder, &value->iommu_handle, _offset + 40);
  ::fidl::Decode(_decoder, &value->job_handle, _offset + 44);
  ::fidl::Decode(_decoder, &value->pager_handle, _offset + 48);
  ::fidl::Decode(_decoder, &value->pcidevice_handle, _offset + 52);
  ::fidl::Decode(_decoder, &value->pmt_handle, _offset + 56);
  ::fidl::Decode(_decoder, &value->port_handle, _offset + 60);
  ::fidl::Decode(_decoder, &value->process_handle, _offset + 64);
  ::fidl::Decode(_decoder, &value->profile_handle, _offset + 68);
  ::fidl::Decode(_decoder, &value->resource_handle, _offset + 72);
  ::fidl::Decode(_decoder, &value->socket_handle, _offset + 76);
  ::fidl::Decode(_decoder, &value->suspendtoken_handle, _offset + 80);
  ::fidl::Decode(_decoder, &value->thread_handle, _offset + 84);
  ::fidl::Decode(_decoder, &value->timer_handle, _offset + 88);
  ::fidl::Decode(_decoder, &value->vcpu_handle, _offset + 92);
  ::fidl::Decode(_decoder, &value->vmar_handle, _offset + 96);
  ::fidl::Decode(_decoder, &value->vmo_handle, _offset + 100);
}

zx_status_t Handles::Clone(Handles* _result) const {
  zx_status_t _status = ::fidl::Clone(plain_handle, &_result->plain_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(bti_handle, &_result->bti_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(channel_handle, &_result->channel_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(debuglog_handle, &_result->debuglog_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(event_handle, &_result->event_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(eventpair_handle, &_result->eventpair_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(exception_handle, &_result->exception_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(fifo_handle, &_result->fifo_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(guest_handle, &_result->guest_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(interrupt_handle, &_result->interrupt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(iommu_handle, &_result->iommu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(job_handle, &_result->job_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pager_handle, &_result->pager_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pcidevice_handle, &_result->pcidevice_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pmt_handle, &_result->pmt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(port_handle, &_result->port_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(process_handle, &_result->process_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(profile_handle, &_result->profile_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(resource_handle, &_result->resource_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(socket_handle, &_result->socket_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(suspendtoken_handle, &_result->suspendtoken_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(thread_handle, &_result->thread_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(timer_handle, &_result->timer_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vcpu_handle, &_result->vcpu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmar_handle, &_result->vmar_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmo_handle, &_result->vmo_handle);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
}  // namespace name
}  // namespace test


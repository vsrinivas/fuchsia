// WARNING: This file is machine generated by fidlgen.

#include <handles.test.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

#ifdef __Fuchsia__
namespace {

extern "C" const fidl_type_t v1_test_name_SomeProtocolSomeMethodRequestTable;

}  // namespace

SomeProtocol::~SomeProtocol() = default;

const fidl_type_t* SomeProtocol_RequestDecoder::GetType(uint64_t ordinal, bool* out_needs_response) {
  switch (ordinal) {
    case internal::kSomeProtocol_SomeMethod_Ordinal:
    case internal::kSomeProtocol_SomeMethod_GenOrdinal:
      *out_needs_response = false;
      return &v1_test_name_SomeProtocolSomeMethodRequestTable;
    default:
      *out_needs_response = false;
      return nullptr;
  }
}

const fidl_type_t* SomeProtocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    default:
      return nullptr;
  }
}

SomeProtocol_EventSender::~SomeProtocol_EventSender() = default;

SomeProtocol_Sync::~SomeProtocol_Sync() = default;

SomeProtocol_Proxy::SomeProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

SomeProtocol_Proxy::~SomeProtocol_Proxy() = default;

zx_status_t SomeProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void SomeProtocol_Proxy::SomeMethod() {
  ::fidl::Encoder _encoder(internal::kSomeProtocol_SomeMethod_GenOrdinal);
  controller_->Send(&v1_test_name_SomeProtocolSomeMethodRequestTable, SomeProtocol_RequestEncoder::SomeMethod(&_encoder), nullptr);
}

SomeProtocol_Stub::SomeProtocol_Stub(SomeProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

SomeProtocol_Stub::~SomeProtocol_Stub() = default;

namespace {

}  // namespace

zx_status_t SomeProtocol_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  const fidl_type_t* request_type = SomeProtocol_RequestDecoder::GetType(message.ordinal(), &needs_response);
  if (request_type == nullptr) {
    return ZX_ERR_NOT_SUPPORTED;
  }
  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }
  const char* error_msg = nullptr;
  zx_status_t status = message.Decode(request_type, &error_msg);
  if (status != ZX_OK) {
    FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
    return status;
  }
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case internal::kSomeProtocol_SomeMethod_Ordinal:
    case internal::kSomeProtocol_SomeMethod_GenOrdinal:
    {
      impl_->SomeMethod();
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

SomeProtocol_SyncProxy::SomeProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

SomeProtocol_SyncProxy::~SomeProtocol_SyncProxy() = default;

zx_status_t SomeProtocol_SyncProxy::SomeMethod() {
  ::fidl::Encoder _encoder(internal::kSomeProtocol_SomeMethod_GenOrdinal);
  return proxy_.Send(&v1_test_name_SomeProtocolSomeMethodRequestTable, SomeProtocol_RequestEncoder::SomeMethod(&_encoder));
}

#endif // __Fuchsia__

extern "C" const fidl_type_t v1_test_name_HandlesTable;
const fidl_type_t* Handles::FidlType = &v1_test_name_HandlesTable;

void Handles::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &plain_handle, _offset + 0);
  ::fidl::Encode(_encoder, &bti_handle, _offset + 4);
  ::fidl::Encode(_encoder, &channel_handle, _offset + 8);
  ::fidl::Encode(_encoder, &debuglog_handle, _offset + 12);
  ::fidl::Encode(_encoder, &event_handle, _offset + 16);
  ::fidl::Encode(_encoder, &eventpair_handle, _offset + 20);
  ::fidl::Encode(_encoder, &exception_handle, _offset + 24);
  ::fidl::Encode(_encoder, &fifo_handle, _offset + 28);
  ::fidl::Encode(_encoder, &guest_handle, _offset + 32);
  ::fidl::Encode(_encoder, &interrupt_handle, _offset + 36);
  ::fidl::Encode(_encoder, &iommu_handle, _offset + 40);
  ::fidl::Encode(_encoder, &job_handle, _offset + 44);
  ::fidl::Encode(_encoder, &pager_handle, _offset + 48);
  ::fidl::Encode(_encoder, &pcidevice_handle, _offset + 52);
  ::fidl::Encode(_encoder, &pmt_handle, _offset + 56);
  ::fidl::Encode(_encoder, &port_handle, _offset + 60);
  ::fidl::Encode(_encoder, &process_handle, _offset + 64);
  ::fidl::Encode(_encoder, &profile_handle, _offset + 68);
  ::fidl::Encode(_encoder, &resource_handle, _offset + 72);
  ::fidl::Encode(_encoder, &socket_handle, _offset + 76);
  ::fidl::Encode(_encoder, &suspendtoken_handle, _offset + 80);
  ::fidl::Encode(_encoder, &thread_handle, _offset + 84);
  ::fidl::Encode(_encoder, &timer_handle, _offset + 88);
  ::fidl::Encode(_encoder, &vcpu_handle, _offset + 92);
  ::fidl::Encode(_encoder, &vmar_handle, _offset + 96);
  ::fidl::Encode(_encoder, &vmo_handle, _offset + 100);
  ::fidl::Encode(_encoder, &some_protocol, _offset + 104);
  ::fidl::Encode(_encoder, &request_some_protocol, _offset + 108);
}

void Handles::Decode(::fidl::Decoder* _decoder, Handles* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->plain_handle, _offset + 0);
  ::fidl::Decode(_decoder, &value->bti_handle, _offset + 4);
  ::fidl::Decode(_decoder, &value->channel_handle, _offset + 8);
  ::fidl::Decode(_decoder, &value->debuglog_handle, _offset + 12);
  ::fidl::Decode(_decoder, &value->event_handle, _offset + 16);
  ::fidl::Decode(_decoder, &value->eventpair_handle, _offset + 20);
  ::fidl::Decode(_decoder, &value->exception_handle, _offset + 24);
  ::fidl::Decode(_decoder, &value->fifo_handle, _offset + 28);
  ::fidl::Decode(_decoder, &value->guest_handle, _offset + 32);
  ::fidl::Decode(_decoder, &value->interrupt_handle, _offset + 36);
  ::fidl::Decode(_decoder, &value->iommu_handle, _offset + 40);
  ::fidl::Decode(_decoder, &value->job_handle, _offset + 44);
  ::fidl::Decode(_decoder, &value->pager_handle, _offset + 48);
  ::fidl::Decode(_decoder, &value->pcidevice_handle, _offset + 52);
  ::fidl::Decode(_decoder, &value->pmt_handle, _offset + 56);
  ::fidl::Decode(_decoder, &value->port_handle, _offset + 60);
  ::fidl::Decode(_decoder, &value->process_handle, _offset + 64);
  ::fidl::Decode(_decoder, &value->profile_handle, _offset + 68);
  ::fidl::Decode(_decoder, &value->resource_handle, _offset + 72);
  ::fidl::Decode(_decoder, &value->socket_handle, _offset + 76);
  ::fidl::Decode(_decoder, &value->suspendtoken_handle, _offset + 80);
  ::fidl::Decode(_decoder, &value->thread_handle, _offset + 84);
  ::fidl::Decode(_decoder, &value->timer_handle, _offset + 88);
  ::fidl::Decode(_decoder, &value->vcpu_handle, _offset + 92);
  ::fidl::Decode(_decoder, &value->vmar_handle, _offset + 96);
  ::fidl::Decode(_decoder, &value->vmo_handle, _offset + 100);
  ::fidl::Decode(_decoder, &value->some_protocol, _offset + 104);
  ::fidl::Decode(_decoder, &value->request_some_protocol, _offset + 108);
}

zx_status_t Handles::Clone(Handles* _result) const {
  zx_status_t _status = ::fidl::Clone(plain_handle, &_result->plain_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(bti_handle, &_result->bti_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(channel_handle, &_result->channel_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(debuglog_handle, &_result->debuglog_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(event_handle, &_result->event_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(eventpair_handle, &_result->eventpair_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(exception_handle, &_result->exception_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(fifo_handle, &_result->fifo_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(guest_handle, &_result->guest_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(interrupt_handle, &_result->interrupt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(iommu_handle, &_result->iommu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(job_handle, &_result->job_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pager_handle, &_result->pager_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pcidevice_handle, &_result->pcidevice_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pmt_handle, &_result->pmt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(port_handle, &_result->port_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(process_handle, &_result->process_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(profile_handle, &_result->profile_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(resource_handle, &_result->resource_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(socket_handle, &_result->socket_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(suspendtoken_handle, &_result->suspendtoken_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(thread_handle, &_result->thread_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(timer_handle, &_result->timer_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vcpu_handle, &_result->vcpu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmar_handle, &_result->vmar_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmo_handle, &_result->vmo_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(some_protocol, &_result->some_protocol);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(request_some_protocol, &_result->request_some_protocol);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
}  // namespace name
}  // namespace test


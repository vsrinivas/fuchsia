// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/buffer_allocator.h>
#include <lib/fidl/llcpp/buffer_then_heap_allocator.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/errors.h>
#include <lib/fidl/llcpp/linearized_and_encoded.h>
#include <lib/fidl/llcpp/memory.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/tracking_ptr.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <lib/fit/optional.h>

#include <variant>
#ifdef __Fuchsia__
#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/result.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/txn_header.h>
#endif  // __Fuchsia__
#include <zircon/fidl.h>

namespace llcpp {

namespace fidl {
namespace test {
namespace json {

class UnionSmallArray;
class UnionLargeArray;
class TableSmallArray;
class TableLargeArray;
struct StructSmallArray;
struct StructLargeArray;

extern "C" const fidl_type_t fidl_test_json_UnionSmallArrayTable;

class UnionSmallArray {
 public:
  UnionSmallArray() : ordinal_(Ordinal::Invalid), envelope_{} {}

  UnionSmallArray(UnionSmallArray&&) = default;
  UnionSmallArray& operator=(UnionSmallArray&&) = default;

  ~UnionSmallArray() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kA = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_a() const { return ordinal_ == Ordinal::kA; }

  static UnionSmallArray WithA(
      ::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>>&& val) {
    UnionSmallArray result;
    result.set_a(std::move(val));
    return result;
  }

  void set_a(::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>>&& elem) {
    ordinal_ = Ordinal::kA;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::Array<uint32_t, 2>& mutable_a() {
    ZX_ASSERT(ordinal_ == Ordinal::kA);
    return *static_cast<::fidl::Array<uint32_t, 2>*>(envelope_.data.get());
  }
  const ::fidl::Array<uint32_t, 2>& a() const {
    ZX_ASSERT(ordinal_ == Ordinal::kA);
    return *static_cast<::fidl::Array<uint32_t, 2>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_UnionSmallArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kA = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_UnionLargeArrayTable;

class UnionLargeArray {
 public:
  UnionLargeArray() : ordinal_(Ordinal::Invalid), envelope_{} {}

  UnionLargeArray(UnionLargeArray&&) = default;
  UnionLargeArray& operator=(UnionLargeArray&&) = default;

  ~UnionLargeArray() { reset_ptr(nullptr); }

  enum class Tag : fidl_xunion_tag_t {
    kA = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == Ordinal::Invalid; }

  bool is_a() const { return ordinal_ == Ordinal::kA; }

  static UnionLargeArray WithA(
      ::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>>&& val) {
    UnionLargeArray result;
    result.set_a(std::move(val));
    return result;
  }

  void set_a(::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>>&& elem) {
    ordinal_ = Ordinal::kA;
    reset_ptr(static_cast<::fidl::tracking_ptr<void>>(std::move(elem)));
  }

  ::fidl::Array<uint32_t, 100>& mutable_a() {
    ZX_ASSERT(ordinal_ == Ordinal::kA);
    return *static_cast<::fidl::Array<uint32_t, 100>*>(envelope_.data.get());
  }
  const ::fidl::Array<uint32_t, 100>& a() const {
    ZX_ASSERT(ordinal_ == Ordinal::kA);
    return *static_cast<::fidl::Array<uint32_t, 100>*>(envelope_.data.get());
  }
  Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_UnionLargeArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 400;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kA = 1,  // 0x1
  };

  void reset_ptr(::fidl::tracking_ptr<void>&& new_ptr) {
    // To clear the existing value, std::move it and let it go out of scope.
    switch (static_cast<fidl_xunion_tag_t>(ordinal_)) {
      case 1: {
        ::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>> to_destroy =
            static_cast<::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>>>(
                std::move(envelope_.data));
        break;
      }
    }

    envelope_.data = std::move(new_ptr);
  }

  static void SizeAndOffsetAssertionHelper();
  Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_json_TableSmallArrayTable;

class TableSmallArray final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  const ::fidl::Array<uint32_t, 2>& a() const {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  ::fidl::Array<uint32_t, 2>& a() {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  bool has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.data != nullptr;
  }

  TableSmallArray() = default;
  ~TableSmallArray() = default;
  TableSmallArray(TableSmallArray&& other) noexcept = default;
  TableSmallArray& operator=(TableSmallArray&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_TableSmallArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  void _CloseHandles();

  class Builder;
  class UnownedBuilder;

  class Frame final {
   public:
    Frame() = default;
    // In its intended usage, Frame will be referenced by a tracking_ptr. If the
    // tracking_ptr is assigned before a move or copy, then it will reference
    // the old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame(const Frame&) = delete;
    Frame& operator=(const Frame&) = delete;

   private:
    Frame(Frame&&) noexcept = default;
    Frame& operator=(Frame&&) noexcept = default;
    ::fidl::Envelope<::fidl::Array<uint32_t, 2>> a_;

    friend class TableSmallArray;
    friend class TableSmallArray::Builder;
    friend class TableSmallArray::UnownedBuilder;
  };

 private:
  TableSmallArray(uint64_t max_ordinal, ::fidl::tracking_ptr<Frame>&& frame_ptr)
      : max_ordinal_(max_ordinal), frame_ptr_(std::move(frame_ptr)) {}
  uint64_t max_ordinal_ = 0;
  ::fidl::tracking_ptr<Frame> frame_ptr_;
};

// TableSmallArray::Builder builds TableSmallArray.
// Usage:
// TableSmallArray val =
// TableSmallArray::Builder(std::make_unique<TableSmallArray::Frame>())
// .set_a(ptr)
// .build();
class TableSmallArray::Builder final {
 public:
  ~Builder() = default;
  Builder() = delete;
  Builder(::fidl::tracking_ptr<TableSmallArray::Frame>&& frame_ptr)
      : max_ordinal_(0), frame_ptr_(std::move(frame_ptr)) {}

  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder(const Builder& other) = delete;
  Builder& operator=(const Builder& other) = delete;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  Builder&& set_a(::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>> elem) {
    frame_ptr_->a_.data = std::move(elem);
    if (max_ordinal_ < 1) {
      // Note: the table size is not currently reduced if nullptr is set.
      // This is possible to reconsider in the future.
      max_ordinal_ = 1;
    }
    return std::move(*this);
  }
  const ::fidl::Array<uint32_t, 2>& a() const {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  ::fidl::Array<uint32_t, 2>& a() {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  bool has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.data != nullptr;
  }

  TableSmallArray build() {
    return TableSmallArray(max_ordinal_, std::move(frame_ptr_));
  }

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::tracking_ptr<TableSmallArray::Frame> frame_ptr_;
};

// UnownedBuilder acts like Builder but directly owns its Frame, simplifying
// working with unowned data.
class TableSmallArray::UnownedBuilder final {
 public:
  ~UnownedBuilder() = default;
  UnownedBuilder() noexcept = default;
  UnownedBuilder(UnownedBuilder&& other) noexcept = default;
  UnownedBuilder& operator=(UnownedBuilder&& other) noexcept = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  UnownedBuilder&& set_a(
      ::fidl::tracking_ptr<::fidl::Array<uint32_t, 2>> elem) {
    ZX_ASSERT(elem);
    frame_.a_.data = std::move(elem);
    if (max_ordinal_ < 1) {
      max_ordinal_ = 1;
    }
    return std::move(*this);
  }
  const ::fidl::Array<uint32_t, 2>& a() const {
    ZX_ASSERT(has_a());
    return *frame_.a_.data;
  }
  ::fidl::Array<uint32_t, 2>& a() {
    ZX_ASSERT(has_a());
    return *frame_.a_.data;
  }
  bool has_a() const { return max_ordinal_ >= 1 && frame_.a_.data != nullptr; }

  TableSmallArray build() {
    return TableSmallArray(max_ordinal_, ::fidl::unowned_ptr(&frame_));
  }

 private:
  uint64_t max_ordinal_ = 0;
  TableSmallArray::Frame frame_;
};

extern "C" const fidl_type_t fidl_test_json_TableLargeArrayTable;

class TableLargeArray final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  const ::fidl::Array<uint32_t, 100>& a() const {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  ::fidl::Array<uint32_t, 100>& a() {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  bool has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.data != nullptr;
  }

  TableLargeArray() = default;
  ~TableLargeArray() = default;
  TableLargeArray(TableLargeArray&& other) noexcept = default;
  TableLargeArray& operator=(TableLargeArray&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_json_TableLargeArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 416;
  static constexpr bool HasPointer = true;
  static constexpr bool IsResource = false;

  void _CloseHandles();

  class Builder;
  class UnownedBuilder;

  class Frame final {
   public:
    Frame() = default;
    // In its intended usage, Frame will be referenced by a tracking_ptr. If the
    // tracking_ptr is assigned before a move or copy, then it will reference
    // the old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame(const Frame&) = delete;
    Frame& operator=(const Frame&) = delete;

   private:
    Frame(Frame&&) noexcept = default;
    Frame& operator=(Frame&&) noexcept = default;
    ::fidl::Envelope<::fidl::Array<uint32_t, 100>> a_;

    friend class TableLargeArray;
    friend class TableLargeArray::Builder;
    friend class TableLargeArray::UnownedBuilder;
  };

 private:
  TableLargeArray(uint64_t max_ordinal, ::fidl::tracking_ptr<Frame>&& frame_ptr)
      : max_ordinal_(max_ordinal), frame_ptr_(std::move(frame_ptr)) {}
  uint64_t max_ordinal_ = 0;
  ::fidl::tracking_ptr<Frame> frame_ptr_;
};

// TableLargeArray::Builder builds TableLargeArray.
// Usage:
// TableLargeArray val =
// TableLargeArray::Builder(std::make_unique<TableLargeArray::Frame>())
// .set_a(ptr)
// .build();
class TableLargeArray::Builder final {
 public:
  ~Builder() = default;
  Builder() = delete;
  Builder(::fidl::tracking_ptr<TableLargeArray::Frame>&& frame_ptr)
      : max_ordinal_(0), frame_ptr_(std::move(frame_ptr)) {}

  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder(const Builder& other) = delete;
  Builder& operator=(const Builder& other) = delete;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  Builder&& set_a(::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>> elem) {
    frame_ptr_->a_.data = std::move(elem);
    if (max_ordinal_ < 1) {
      // Note: the table size is not currently reduced if nullptr is set.
      // This is possible to reconsider in the future.
      max_ordinal_ = 1;
    }
    return std::move(*this);
  }
  const ::fidl::Array<uint32_t, 100>& a() const {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  ::fidl::Array<uint32_t, 100>& a() {
    ZX_ASSERT(has_a());
    return *frame_ptr_->a_.data;
  }
  bool has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.data != nullptr;
  }

  TableLargeArray build() {
    return TableLargeArray(max_ordinal_, std::move(frame_ptr_));
  }

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::tracking_ptr<TableLargeArray::Frame> frame_ptr_;
};

// UnownedBuilder acts like Builder but directly owns its Frame, simplifying
// working with unowned data.
class TableLargeArray::UnownedBuilder final {
 public:
  ~UnownedBuilder() = default;
  UnownedBuilder() noexcept = default;
  UnownedBuilder(UnownedBuilder&& other) noexcept = default;
  UnownedBuilder& operator=(UnownedBuilder&& other) noexcept = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  UnownedBuilder&& set_a(
      ::fidl::tracking_ptr<::fidl::Array<uint32_t, 100>> elem) {
    ZX_ASSERT(elem);
    frame_.a_.data = std::move(elem);
    if (max_ordinal_ < 1) {
      max_ordinal_ = 1;
    }
    return std::move(*this);
  }
  const ::fidl::Array<uint32_t, 100>& a() const {
    ZX_ASSERT(has_a());
    return *frame_.a_.data;
  }
  ::fidl::Array<uint32_t, 100>& a() {
    ZX_ASSERT(has_a());
    return *frame_.a_.data;
  }
  bool has_a() const { return max_ordinal_ >= 1 && frame_.a_.data != nullptr; }

  TableLargeArray build() {
    return TableLargeArray(max_ordinal_, ::fidl::unowned_ptr(&frame_));
  }

 private:
  uint64_t max_ordinal_ = 0;
  TableLargeArray::Frame frame_;
};

extern "C" const fidl_type_t fidl_test_json_StructSmallArrayTable;

struct StructSmallArray {
  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StructSmallArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;
  static constexpr bool IsResource = false;

  ::fidl::Array<uint32_t, 2> a = {};
  void _CloseHandles();

  class UnownedOutgoingMessage final {
   public:
    UnownedOutgoingMessage(uint8_t* bytes, uint32_t byte_size,
                           StructSmallArray* value)
        : message_(bytes, byte_size, sizeof(StructSmallArray), nullptr, 0, 0) {
      message_.LinearizeAndEncode<StructSmallArray>(value);
    }
    UnownedOutgoingMessage(const UnownedOutgoingMessage&) = delete;
    UnownedOutgoingMessage(UnownedOutgoingMessage&&) = delete;
    UnownedOutgoingMessage* operator=(const UnownedOutgoingMessage&) = delete;
    UnownedOutgoingMessage* operator=(UnownedOutgoingMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    bool ok() const { return message_.status() == ZX_OK; }
    const char* error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::OutgoingMessage message_;
  };

  class OwnedOutgoingMessage final {
   public:
    explicit OwnedOutgoingMessage(StructSmallArray* value)
        : message_(bytes_, sizeof(bytes_), value) {}
    OwnedOutgoingMessage(const OwnedOutgoingMessage&) = delete;
    OwnedOutgoingMessage(OwnedOutgoingMessage&&) = delete;
    OwnedOutgoingMessage* operator=(const OwnedOutgoingMessage&) = delete;
    OwnedOutgoingMessage* operator=(OwnedOutgoingMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    bool ok() const { return message_.ok(); }
    const char* error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    FIDL_ALIGNDECL
    uint8_t bytes_[PrimarySize + MaxOutOfLine];
    UnownedOutgoingMessage message_;
  };
};

extern "C" const fidl_type_t fidl_test_json_StructLargeArrayTable;

struct StructLargeArray {
  static constexpr const fidl_type_t* Type =
      &fidl_test_json_StructLargeArrayTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 400;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;
  static constexpr bool IsResource = false;

  ::fidl::Array<uint32_t, 100> a = {};
  void _CloseHandles();

  class UnownedOutgoingMessage final {
   public:
    UnownedOutgoingMessage(uint8_t* bytes, uint32_t byte_size,
                           StructLargeArray* value)
        : message_(bytes, byte_size, sizeof(StructLargeArray), nullptr, 0, 0) {
      message_.LinearizeAndEncode<StructLargeArray>(value);
    }
    UnownedOutgoingMessage(const UnownedOutgoingMessage&) = delete;
    UnownedOutgoingMessage(UnownedOutgoingMessage&&) = delete;
    UnownedOutgoingMessage* operator=(const UnownedOutgoingMessage&) = delete;
    UnownedOutgoingMessage* operator=(UnownedOutgoingMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    bool ok() const { return message_.status() == ZX_OK; }
    const char* error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::OutgoingMessage message_;
  };

  class OwnedOutgoingMessage final {
   public:
    explicit OwnedOutgoingMessage(StructLargeArray* value)
        : message_(bytes_, sizeof(bytes_), value) {}
    OwnedOutgoingMessage(const OwnedOutgoingMessage&) = delete;
    OwnedOutgoingMessage(OwnedOutgoingMessage&&) = delete;
    OwnedOutgoingMessage* operator=(const OwnedOutgoingMessage&) = delete;
    OwnedOutgoingMessage* operator=(OwnedOutgoingMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    bool ok() const { return message_.ok(); }
    const char* error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    FIDL_ALIGNDECL
    uint8_t bytes_[PrimarySize + MaxOutOfLine];
    UnownedOutgoingMessage message_;
  };
};

}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fidl::test::json::UnionSmallArray>
    : public std::true_type {};
template <>
struct IsUnion<::llcpp::fidl::test::json::UnionSmallArray>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::UnionSmallArray>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::UnionLargeArray>
    : public std::true_type {};
template <>
struct IsUnion<::llcpp::fidl::test::json::UnionLargeArray>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::UnionLargeArray>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::TableSmallArray>
    : public std::true_type {};
template <>
struct IsTable<::llcpp::fidl::test::json::TableSmallArray>
    : public std::true_type {};
template <>
struct IsTableBuilder<::llcpp::fidl::test::json::TableSmallArray::Builder>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::TableSmallArray>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::TableLargeArray>
    : public std::true_type {};
template <>
struct IsTable<::llcpp::fidl::test::json::TableLargeArray>
    : public std::true_type {};
template <>
struct IsTableBuilder<::llcpp::fidl::test::json::TableLargeArray::Builder>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::TableLargeArray>);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StructSmallArray>
    : public std::true_type {};
template <>
struct IsStruct<::llcpp::fidl::test::json::StructSmallArray>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StructSmallArray>);
static_assert(offsetof(::llcpp::fidl::test::json::StructSmallArray, a) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::StructSmallArray) ==
              ::llcpp::fidl::test::json::StructSmallArray::PrimarySize);

template <>
struct IsFidlType<::llcpp::fidl::test::json::StructLargeArray>
    : public std::true_type {};
template <>
struct IsStruct<::llcpp::fidl::test::json::StructLargeArray>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::llcpp::fidl::test::json::StructLargeArray>);
static_assert(offsetof(::llcpp::fidl::test::json::StructLargeArray, a) == 0);
static_assert(sizeof(::llcpp::fidl::test::json::StructLargeArray) ==
              ::llcpp::fidl::test::json::StructLargeArray::PrimarySize);

}  // namespace fidl

namespace llcpp {

namespace fidl {
namespace test {
namespace json {}  // namespace json
}  // namespace test
}  // namespace fidl
}  // namespace llcpp

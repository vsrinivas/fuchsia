// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.fidl.json.llcpp.h>
#include <memory>

namespace llcpp {

namespace test {
namespace name {

::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::WithErrorSyntax_ResponseAsStruct_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::~WithErrorSyntax_ResponseAsStruct_Result() {
  Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~WithErrorSyntax_ResponseAsStruct_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::MoveImpl_(WithErrorSyntax_ResponseAsStruct_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result, response_) == 8);
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result, err_) == 8);
  static_assert(sizeof(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result) == ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::PrimarySize);
}


::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Response& ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

uint32_t& ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) uint32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::~WithErrorSyntax_ErrorAsPrimitive_Result() {
  Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~WithErrorSyntax_ErrorAsPrimitive_Response();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::MoveImpl_(WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result, response_) == 4);
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result, err_) == 4);
  static_assert(sizeof(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result) == ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::PrimarySize);
}


::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

uint32_t& ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) uint32_t;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 0x556693d200000000lu;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodA_GenOrdinal = 0x1b1e059b3f02bffclu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodAResponseTable;
extern "C" const fidl_type_t v1_test_name_ChannelProtocolMethodAResponseTable;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_EventA_Ordinal = 0x1c78c20200000000lu;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_EventA_GenOrdinal = 0x2558b206a254d8a0lu;
extern "C" const fidl_type_t test_name_ChannelProtocolEventARequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;
extern "C" const fidl_type_t v1_test_name_ChannelProtocolEventAEventTable;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 0xac6551b00000000lu;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodB_GenOrdinal = 0x5db17a61464744a3lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;
extern "C" const fidl_type_t v1_test_name_ChannelProtocolMethodBResponseTable;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 0x4b02e28600000000lu;
[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MutateSocket_GenOrdinal = 0x36caa6fff7569577lu;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;
extern "C" const fidl_type_t v1_test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace

ChannelProtocol::ResultOf::MethodA_Impl::MethodA_Impl(::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodARequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, MethodARequest::PrimarySize);
  auto& _request = *reinterpret_cast<MethodARequest*>(_write_bytes);
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      ChannelProtocol::InPlace::MethodA(std::move(_client_end), std::move(_decoded_request)));
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::SyncClient::MethodA(int64_t a, int64_t b) {
    return ResultOf::MethodA(::zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

ChannelProtocol::ResultOf::MethodA ChannelProtocol::Call::MethodA(::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodA(std::move(_client_end), std::move(a), std::move(b));
}


ChannelProtocol::UnownedResultOf::MethodA_Impl::MethodA_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  memset(_request_buffer.data(), 0, MethodARequest::PrimarySize);
  auto& _request = *reinterpret_cast<MethodARequest*>(_request_buffer.data());
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_buffer));
  Super::operator=(
      ChannelProtocol::InPlace::MethodA(std::move(_client_end), std::move(_decoded_request)));
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::SyncClient::MethodA(::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b));
}

ChannelProtocol::UnownedResultOf::MethodA ChannelProtocol::Call::MethodA(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return UnownedResultOf::MethodA(std::move(_client_end), std::move(_request_buffer), std::move(a), std::move(b));
}

::fidl::internal::StatusAndError ChannelProtocol::InPlace::MethodA(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodARequest> params) {
  ChannelProtocol::SetTransactionHeaderFor::MethodARequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
ChannelProtocol::ResultOf::MethodB_Impl<ChannelProtocol::MethodBResponse>::MethodB_Impl(::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, MethodBRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MethodBRequest*>(_write_bytes);
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      ChannelProtocol::InPlace::MethodB(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::SyncClient::MethodB(int64_t a, int64_t b) {
    return ResultOf::MethodB(::zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

ChannelProtocol::ResultOf::MethodB ChannelProtocol::Call::MethodB(::zx::unowned_channel _client_end, int64_t a, int64_t b) {
  return ResultOf::MethodB(std::move(_client_end), std::move(a), std::move(b));
}

template <>
ChannelProtocol::UnownedResultOf::MethodB_Impl<ChannelProtocol::MethodBResponse>::MethodB_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MethodBResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, MethodBRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MethodBRequest*>(_request_buffer.data());
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      ChannelProtocol::InPlace::MethodB(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::SyncClient::MethodB(::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer));
}

ChannelProtocol::UnownedResultOf::MethodB ChannelProtocol::Call::MethodB(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MethodB(std::move(_client_end), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse> ChannelProtocol::InPlace::MethodB(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  ChannelProtocol::SetTransactionHeaderFor::MethodBRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
ChannelProtocol::ResultOf::MutateSocket_Impl<ChannelProtocol::MutateSocketResponse>::MutateSocket_Impl(::zx::unowned_channel _client_end, ::zx::socket a) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, MutateSocketRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_write_bytes);
  _request.a = std::move(a);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      ChannelProtocol::InPlace::MutateSocket(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

ChannelProtocol::ResultOf::MutateSocket ChannelProtocol::SyncClient::MutateSocket(::zx::socket a) {
    return ResultOf::MutateSocket(::zx::unowned_channel(this->channel_), std::move(a));
}

ChannelProtocol::ResultOf::MutateSocket ChannelProtocol::Call::MutateSocket(::zx::unowned_channel _client_end, ::zx::socket a) {
  return ResultOf::MutateSocket(std::move(_client_end), std::move(a));
}

template <>
ChannelProtocol::UnownedResultOf::MutateSocket_Impl<ChannelProtocol::MutateSocketResponse>::MutateSocket_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<MutateSocketResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, MutateSocketRequest::PrimarySize);
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_request_buffer.data());
  _request.a = std::move(a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      ChannelProtocol::InPlace::MutateSocket(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

ChannelProtocol::UnownedResultOf::MutateSocket ChannelProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(_response_buffer));
}

ChannelProtocol::UnownedResultOf::MutateSocket ChannelProtocol::Call::MutateSocket(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::MutateSocket(std::move(_client_end), std::move(_request_buffer), std::move(a), std::move(_response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse> ChannelProtocol::InPlace::MutateSocket(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  ChannelProtocol::SetTransactionHeaderFor::MutateSocketRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t ChannelProtocol::SyncClient::HandleEvents(ChannelProtocol::EventHandlers handlers) {
  return ChannelProtocol::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t ChannelProtocol::Call::HandleEvents(::zx::unowned_channel client_end, ChannelProtocol::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<EventAResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<EventAResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal:
    case kChannelProtocol_EventA_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool ChannelProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kChannelProtocol_MethodA_Ordinal:
    case kChannelProtocol_MethodA_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
          Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MethodB_Ordinal:
    case kChannelProtocol_MethodB_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
          Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MutateSocket_Ordinal:
    case kChannelProtocol_MutateSocket_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
          Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool ChannelProtocol::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EventAResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EventAResponse*>(_write_bytes);
  ChannelProtocol::SetTransactionHeaderFor::EventAResponse(
      ::fidl::DecodedMessage<EventAResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EventAResponse::PrimarySize,
              EventAResponse::PrimarySize)));
  _response.a = std::move(a);
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EventAResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_response_bytes)));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<EventAResponse*>(_buffer.data());
  ChannelProtocol::SetTransactionHeaderFor::EventAResponse(
      ::fidl::DecodedMessage<EventAResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              EventAResponse::PrimarySize,
              EventAResponse::PrimarySize)));
  _response.a = std::move(a);
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventAResponse> params) {
  ChannelProtocol::SetTransactionHeaderFor::EventAResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}


void ChannelProtocol::Interface::MethodBCompleterBase::Reply(int64_t result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MethodBResponse*>(_write_bytes);
  ChannelProtocol::SetTransactionHeaderFor::MethodBResponse(
      ::fidl::DecodedMessage<MethodBResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MethodBResponse::PrimarySize,
              MethodBResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_response_bytes)));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MethodBResponse*>(_buffer.data());
  ChannelProtocol::SetTransactionHeaderFor::MethodBResponse(
      ::fidl::DecodedMessage<MethodBResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MethodBResponse::PrimarySize,
              MethodBResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(::fidl::DecodedMessage<MethodBResponse> params) {
  ChannelProtocol::SetTransactionHeaderFor::MethodBResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::zx::socket b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_write_bytes);
  ChannelProtocol::SetTransactionHeaderFor::MutateSocketResponse(
      ::fidl::DecodedMessage<MutateSocketResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MutateSocketResponse::PrimarySize,
              MutateSocketResponse::PrimarySize)));
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_response_bytes)));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_buffer.data());
  ChannelProtocol::SetTransactionHeaderFor::MutateSocketResponse(
      ::fidl::DecodedMessage<MutateSocketResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              MutateSocketResponse::PrimarySize,
              MutateSocketResponse::PrimarySize)));
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::DecodedMessage<MutateSocketResponse> params) {
  ChannelProtocol::SetTransactionHeaderFor::MutateSocketResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void ChannelProtocol::SetTransactionHeaderFor::MethodARequest(const ::fidl::DecodedMessage<ChannelProtocol::MethodARequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_MethodA_GenOrdinal);
}

void ChannelProtocol::SetTransactionHeaderFor::EventAResponse(const ::fidl::DecodedMessage<ChannelProtocol::EventAResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_EventA_GenOrdinal);
}

void ChannelProtocol::SetTransactionHeaderFor::MethodBRequest(const ::fidl::DecodedMessage<ChannelProtocol::MethodBRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_MethodB_GenOrdinal);
}
void ChannelProtocol::SetTransactionHeaderFor::MethodBResponse(const ::fidl::DecodedMessage<ChannelProtocol::MethodBResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_MethodB_GenOrdinal);
}

void ChannelProtocol::SetTransactionHeaderFor::MutateSocketRequest(const ::fidl::DecodedMessage<ChannelProtocol::MutateSocketRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_MutateSocket_GenOrdinal);
}
void ChannelProtocol::SetTransactionHeaderFor::MutateSocketResponse(const ::fidl::DecodedMessage<ChannelProtocol::MutateSocketResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kChannelProtocol_MutateSocket_GenOrdinal);
}

namespace {

[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal = 0x1e03f87500000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_GenOrdinal = 0x3931f96bc77fba8lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal = 0x4df6dbd500000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_GenOrdinal = 0x706ec7bd335005f9lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal = 0x668d7f800000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestWithResponse_GenOrdinal = 0x4625ad5934067a48lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal = 0x19c2137100000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestNoResponse_GenOrdinal = 0x46e5095902913025lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal = 0x76f2397300000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_GenOrdinal = 0x180c481d4a15967lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal = 0x1973292000000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestWithResponse_GenOrdinal = 0x553860267eceec0lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal = 0x697fd73200000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_GenOrdinal = 0x42e90e9a86944b3lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnEmptyResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal = 0x7a47120700000000lu;
[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_GenOrdinal = 0x2a9767b3ae6c2b09lu;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;
extern "C" const fidl_type_t v1_test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse_Impl::NoRequestNoResponse_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestNoResponseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NoRequestNoResponseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestNoResponseRequest));
  ::fidl::DecodedMessage<NoRequestNoResponseRequest> _decoded_request(std::move(_request_bytes));
  Super::operator=(
      WithAndWithoutRequestResponse::InPlace::NoRequestNoResponse(std::move(_client_end)));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse WithAndWithoutRequestResponse::SyncClient::NoRequestNoResponse() {
    return ResultOf::NoRequestNoResponse(::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestNoResponse WithAndWithoutRequestResponse::Call::NoRequestNoResponse(::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestNoResponse(std::move(_client_end));
}

::fidl::internal::StatusAndError WithAndWithoutRequestResponse::InPlace::NoRequestNoResponse(::zx::unowned_channel _client_end) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestNoResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NoRequestNoResponseRequest> params(std::move(_request_buffer));
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestNoResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse_Impl<WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>::NoRequestEmptyResponse_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestEmptyResponseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NoRequestEmptyResponseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestEmptyResponseRequest));
  ::fidl::DecodedMessage<NoRequestEmptyResponseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestEmptyResponse(std::move(_client_end), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse WithAndWithoutRequestResponse::SyncClient::NoRequestEmptyResponse() {
    return ResultOf::NoRequestEmptyResponse(::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestEmptyResponse WithAndWithoutRequestResponse::Call::NoRequestEmptyResponse(::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestEmptyResponse(std::move(_client_end));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse> WithAndWithoutRequestResponse::InPlace::NoRequestEmptyResponse(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestEmptyResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NoRequestEmptyResponseRequest> params(std::move(_request_buffer));
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestEmptyResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NoRequestEmptyResponseRequest, NoRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse_Impl<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::NoRequestWithResponse_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestWithResponseRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, NoRequestWithResponseRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestWithResponseRequest));
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(std::move(_client_end), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse() {
    return ResultOf::NoRequestWithResponse(::zx::unowned_channel(this->channel_));
}

WithAndWithoutRequestResponse::ResultOf::NoRequestWithResponse WithAndWithoutRequestResponse::Call::NoRequestWithResponse(::zx::unowned_channel _client_end) {
  return ResultOf::NoRequestWithResponse(std::move(_client_end));
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse_Impl<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::NoRequestWithResponse_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NoRequestWithResponseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, NoRequestWithResponseRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(NoRequestWithResponseRequest));
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(std::move(_client_end), std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::NoRequestWithResponse WithAndWithoutRequestResponse::Call::NoRequestWithResponse(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::NoRequestWithResponse(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse> WithAndWithoutRequestResponse::InPlace::NoRequestWithResponse(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestWithResponseRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> params(std::move(_request_buffer));
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<NoRequestWithResponseRequest, NoRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse_Impl::WithRequestNoResponse_Impl(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestNoResponseRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WithRequestNoResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestNoResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(std::move(_client_end), std::move(_decoded_request)));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(::fidl::StringView arg) {
    return ResultOf::WithRequestNoResponse(::zx::unowned_channel(this->channel_), std::move(arg));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestNoResponse WithAndWithoutRequestResponse::Call::WithRequestNoResponse(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestNoResponse(std::move(_client_end), std::move(arg));
}


WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse_Impl::WithRequestNoResponse_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  if (_request_buffer.capacity() < WithRequestNoResponseRequest::PrimarySize) {
    Super::status_ = ZX_ERR_BUFFER_TOO_SMALL;
    Super::error_ = ::fidl::internal::kErrorRequestBufferTooSmall;
    return;
  }
  WithRequestNoResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestNoResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::operator=(
      WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(std::move(_client_end), std::move(_decoded_request)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestNoResponse WithAndWithoutRequestResponse::Call::WithRequestNoResponse(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return UnownedResultOf::WithRequestNoResponse(std::move(_client_end), std::move(_request_buffer), std::move(arg));
}

::fidl::internal::StatusAndError WithAndWithoutRequestResponse::InPlace::WithRequestNoResponse(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestNoResponseRequest> params) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestNoResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::internal::StatusAndError::FromFailure(
        std::move(_encode_request_result));
  }
  zx_status_t _write_status =
      ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
  if (_write_status != ZX_OK) {
    return ::fidl::internal::StatusAndError(_write_status, ::fidl::internal::kErrorWriteFailed);
  } else {
    return ::fidl::internal::StatusAndError(ZX_OK, nullptr);
  }
}

template <>
WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse_Impl<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::WithRequestEmptyResponse_Impl(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WithRequestEmptyResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(::fidl::StringView arg) {
    return ResultOf::WithRequestEmptyResponse(::zx::unowned_channel(this->channel_), std::move(arg));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestEmptyResponse WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestEmptyResponse(std::move(_client_end), std::move(arg));
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse_Impl<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::WithRequestEmptyResponse_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WithRequestEmptyResponseRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WithRequestEmptyResponseResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WithRequestEmptyResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestEmptyResponse WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestEmptyResponse(std::move(_client_end), std::move(_request_buffer), std::move(arg), std::move(_response_buffer));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse> WithAndWithoutRequestResponse::InPlace::WithRequestEmptyResponse(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> params, ::fidl::BytePart response_buffer) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestEmptyResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WithRequestEmptyResponseRequest, WithRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse_Impl<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::WithRequestWithResponse_Impl(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestWithResponseRequest, ::fidl::MessageDirection::kSending>();
  std::unique_ptr _write_bytes_boxed = std::make_unique<::fidl::internal::AlignedBuffer<_kWriteAllocSize>>();
  auto& _write_bytes_array = *_write_bytes_boxed;
  WithRequestWithResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, _write_bytes_array.view());
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestWithResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(::fidl::StringView arg) {
    return ResultOf::WithRequestWithResponse(::zx::unowned_channel(this->channel_), std::move(arg));
}

WithAndWithoutRequestResponse::ResultOf::WithRequestWithResponse WithAndWithoutRequestResponse::Call::WithRequestWithResponse(::zx::unowned_channel _client_end, ::fidl::StringView arg) {
  return ResultOf::WithRequestWithResponse(std::move(_client_end), std::move(arg));
}

template <>
WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse_Impl<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::WithRequestWithResponse_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < WithRequestWithResponseRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<WithRequestWithResponseResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  WithRequestWithResponseRequest _request = {};
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    Super::SetFailure(std::move(_linearize_result));
    return;
  }
  ::fidl::DecodedMessage<WithRequestWithResponseRequest> _decoded_request = std::move(_linearize_result.message);
  Super::SetResult(
      WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(::zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg), std::move(_response_buffer));
}

WithAndWithoutRequestResponse::UnownedResultOf::WithRequestWithResponse WithAndWithoutRequestResponse::Call::WithRequestWithResponse(::zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::WithRequestWithResponse(std::move(_client_end), std::move(_request_buffer), std::move(arg), std::move(_response_buffer));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse> WithAndWithoutRequestResponse::InPlace::WithRequestWithResponse(::zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestWithResponseRequest> params, ::fidl::BytePart response_buffer) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<WithRequestWithResponseRequest, WithRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::HandleEvents(WithAndWithoutRequestResponse::EventHandlers handlers) {
  return WithAndWithoutRequestResponse::Call::HandleEvents(::zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t WithAndWithoutRequestResponse::Call::HandleEvents(::zx::unowned_channel client_end, WithAndWithoutRequestResponse::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            ::zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    if (::fidl::internal::ClampedMessageSize<OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnWithResponseResponse, ::fidl::MessageDirection::kReceiving>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnEmptyResponseResponse::MaxNumHandles >= x) {
      x = OnEmptyResponseResponse::MaxNumHandles;
    }
    if (OnWithResponseResponse::MaxNumHandles >= x) {
      x = OnWithResponseResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  ::fidl::internal::ByteStorage<kReadAllocSize> read_storage;
  uint8_t* read_bytes = read_storage.buffer().data();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
      .bytes = read_bytes,
      .handles = read_handles,
      .num_bytes = actual_bytes,
      .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    return status;
  }
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
    case kWithAndWithoutRequestResponse_OnEmptyResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnEmptyResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      return handlers.on_empty_response();
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
    case kWithAndWithoutRequestResponse_OnWithResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<OnWithResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_with_response(std::move(message->ret));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool WithAndWithoutRequestResponse::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal:
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NoRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestNoResponse(
          Interface::NoRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NoRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestEmptyResponse(
          Interface::NoRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<NoRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestWithResponse(
          Interface::NoRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal:
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WithRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestNoResponse(std::move(message->arg),
          Interface::WithRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WithRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestEmptyResponse(std::move(message->arg),
          Interface::WithRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<WithRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestWithResponse(std::move(message->arg),
          Interface::WithRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithAndWithoutRequestResponse::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void WithAndWithoutRequestResponse::Interface::NoRequestEmptyResponseCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestEmptyResponseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NoRequestEmptyResponseResponse*>(_write_bytes);
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestEmptyResponseResponse(
      ::fidl::DecodedMessage<NoRequestEmptyResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NoRequestEmptyResponseResponse::PrimarySize,
              NoRequestEmptyResponseResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestEmptyResponseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NoRequestEmptyResponseResponse>(std::move(_response_bytes)));
}


void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestWithResponseResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  NoRequestWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseResponse(
      ::fidl::DecodedMessage<NoRequestWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NoRequestWithResponseResponse::PrimarySize,
              NoRequestWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < NoRequestWithResponseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  NoRequestWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseResponse(
      ::fidl::DecodedMessage<NoRequestWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              NoRequestWithResponseResponse::PrimarySize,
              NoRequestWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::DecodedMessage<NoRequestWithResponseResponse> params) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void WithAndWithoutRequestResponse::Interface::WithRequestEmptyResponseCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WithRequestEmptyResponseResponse*>(_write_bytes);
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestEmptyResponseResponse(
      ::fidl::DecodedMessage<WithRequestEmptyResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WithRequestEmptyResponseResponse::PrimarySize,
              WithRequestEmptyResponseResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WithRequestEmptyResponseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WithRequestEmptyResponseResponse>(std::move(_response_bytes)));
}


void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestWithResponseResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WithRequestWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseResponse(
      ::fidl::DecodedMessage<WithRequestWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WithRequestWithResponseResponse::PrimarySize,
              WithRequestWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < WithRequestWithResponseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WithRequestWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseResponse(
      ::fidl::DecodedMessage<WithRequestWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              WithRequestWithResponseResponse::PrimarySize,
              WithRequestWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::DecodedMessage<WithRequestWithResponseResponse> params) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseResponse(params);
  CompleterBase::SendReply(std::move(params));
}


zx_status_t WithAndWithoutRequestResponse::SendOnEmptyResponseEvent(::zx::unowned_channel _chan) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OnEmptyResponseResponse*>(_write_bytes);
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnEmptyResponseResponse(
      ::fidl::DecodedMessage<OnEmptyResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnEmptyResponseResponse::PrimarySize,
              OnEmptyResponseResponse::PrimarySize)));
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnEmptyResponseResponse));
  return ::fidl::Write(::zx::unowned_channel(_chan), ::fidl::DecodedMessage<OnEmptyResponseResponse>(std::move(_response_bytes)));
}


zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnWithResponseResponse, ::fidl::MessageDirection::kSending>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnWithResponseResponse(
      ::fidl::DecodedMessage<OnWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnWithResponseResponse::PrimarySize,
              OnWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < OnWithResponseResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnWithResponseResponse _response = {};
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnWithResponseResponse(
      ::fidl::DecodedMessage<OnWithResponseResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              OnWithResponseResponse::PrimarySize,
              OnWithResponseResponse::PrimarySize)));
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnWithResponseResponse> params) {
  WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnWithResponseResponse(params);
  return ::fidl::Write(::zx::unowned_channel(_chan), std::move(params));
}



void WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestNoResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestNoResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_NoRequestNoResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestEmptyResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestEmptyResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_NoRequestEmptyResponse_GenOrdinal);
}
void WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestEmptyResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestEmptyResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_NoRequestEmptyResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestWithResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_NoRequestWithResponse_GenOrdinal);
}
void WithAndWithoutRequestResponse::SetTransactionHeaderFor::NoRequestWithResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_NoRequestWithResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestNoResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestNoResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_WithRequestNoResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestEmptyResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestEmptyResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_WithRequestEmptyResponse_GenOrdinal);
}
void WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestEmptyResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_WithRequestEmptyResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseRequest(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestWithResponseRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_WithRequestWithResponse_GenOrdinal);
}
void WithAndWithoutRequestResponse::SetTransactionHeaderFor::WithRequestWithResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_WithRequestWithResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnEmptyResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::OnEmptyResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_OnEmptyResponse_GenOrdinal);
}

void WithAndWithoutRequestResponse::SetTransactionHeaderFor::OnWithResponseResponse(const ::fidl::DecodedMessage<WithAndWithoutRequestResponse::OnWithResponseResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithAndWithoutRequestResponse_OnWithResponse_GenOrdinal);
}

::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() {
  ordinal_ = Ordinal::Invalid;
}

::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
  Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::Destroy() {
  switch (ordinal_) {
  case Ordinal::kResponse:
    response_.~WithErrorSyntax_ErrorAsEnum_Response();
    break;
  case Ordinal::kErr:
    err_.~ErrorEnun();
    break;
  default:
    break;
  }
  ordinal_ = Ordinal::Invalid;
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::MoveImpl_(WithErrorSyntax_ErrorAsEnum_Result&& other) {
  switch (other.ordinal_) {
  case Ordinal::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Ordinal::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result, response_) == 4);
  static_assert(offsetof(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result, err_) == 4);
  static_assert(sizeof(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result) == ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::PrimarySize);
}


::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Response& ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::mutable_response() {
  if (ordinal_ != Ordinal::kResponse) {
    Destroy();
    new (&response_) ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Response;
    ordinal_ = Ordinal::kResponse;
  }
  return response_;
}

::llcpp::test::name::ErrorEnun& ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result::mutable_err() {
  if (ordinal_ != Ordinal::kErr) {
    Destroy();
    new (&err_) ::llcpp::test::name::ErrorEnun;
    ordinal_ = Ordinal::kErr;
  }
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal = 0x4f3c32be00000000lu;
[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_GenOrdinal = 0x592157d505db2bcflu;
extern "C" const fidl_type_t test_name_WithErrorSyntaxResponseAsStructRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxResponseAsStructResponseTable;
extern "C" const fidl_type_t v1_test_name_WithErrorSyntaxResponseAsStructResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 0x7b58113900000000lu;
[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_GenOrdinal = 0x20cf80ad7d9b60belu;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
extern "C" const fidl_type_t v1_test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 0x4c95de1f00000000lu;
[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_GenOrdinal = 0x3fcd36560f812e7flu;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;
extern "C" const fidl_type_t v1_test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace
template <>
WithErrorSyntax::ResultOf::ResponseAsStruct_Impl<WithErrorSyntax::ResponseAsStructResponse>::ResponseAsStruct_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResponseAsStructRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ResponseAsStructRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ResponseAsStructRequest));
  ::fidl::DecodedMessage<ResponseAsStructRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      WithErrorSyntax::InPlace::ResponseAsStruct(std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ResponseAsStruct WithErrorSyntax::SyncClient::ResponseAsStruct() {
    return ResultOf::ResponseAsStruct(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ResponseAsStruct WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end) {
  return ResultOf::ResponseAsStruct(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::ResponseAsStruct_Impl<WithErrorSyntax::ResponseAsStructResponse>::ResponseAsStruct_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ResponseAsStructRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ResponseAsStructRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ResponseAsStructRequest));
  ::fidl::DecodedMessage<ResponseAsStructRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      WithErrorSyntax::InPlace::ResponseAsStruct(std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct WithErrorSyntax::SyncClient::ResponseAsStruct(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ResponseAsStruct WithErrorSyntax::Call::ResponseAsStruct(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ResponseAsStruct(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ResponseAsStructResponse> WithErrorSyntax::InPlace::ResponseAsStruct(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ResponseAsStructRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ResponseAsStructRequest> params(std::move(_request_buffer));
  WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ResponseAsStructResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ResponseAsStructRequest, ResponseAsStructResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ResponseAsStructResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithErrorSyntax::ResultOf::ErrorAsPrimitive_Impl<WithErrorSyntax::ErrorAsPrimitiveResponse>::ErrorAsPrimitive_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsPrimitiveRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ErrorAsPrimitiveRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      WithErrorSyntax::InPlace::ErrorAsPrimitive(std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive WithErrorSyntax::SyncClient::ErrorAsPrimitive() {
    return ResultOf::ErrorAsPrimitive(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ErrorAsPrimitive WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsPrimitive(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive_Impl<WithErrorSyntax::ErrorAsPrimitiveResponse>::ErrorAsPrimitive_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsPrimitiveRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ErrorAsPrimitiveRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      WithErrorSyntax::InPlace::ErrorAsPrimitive(std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive WithErrorSyntax::SyncClient::ErrorAsPrimitive(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ErrorAsPrimitive WithErrorSyntax::Call::ErrorAsPrimitive(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsPrimitive(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse> WithErrorSyntax::InPlace::ErrorAsPrimitive(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsPrimitiveRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> params(std::move(_request_buffer));
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ErrorAsPrimitiveRequest, ErrorAsPrimitiveResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
WithErrorSyntax::ResultOf::ErrorAsEnum_Impl<WithErrorSyntax::ErrorAsEnumResponse>::ErrorAsEnum_Impl(::zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsEnumRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, ErrorAsEnumRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      WithErrorSyntax::InPlace::ErrorAsEnum(std::move(_client_end), Super::response_buffer()));
}

WithErrorSyntax::ResultOf::ErrorAsEnum WithErrorSyntax::SyncClient::ErrorAsEnum() {
    return ResultOf::ErrorAsEnum(::zx::unowned_channel(this->channel_));
}

WithErrorSyntax::ResultOf::ErrorAsEnum WithErrorSyntax::Call::ErrorAsEnum(::zx::unowned_channel _client_end) {
  return ResultOf::ErrorAsEnum(std::move(_client_end));
}

template <>
WithErrorSyntax::UnownedResultOf::ErrorAsEnum_Impl<WithErrorSyntax::ErrorAsEnumResponse>::ErrorAsEnum_Impl(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsEnumRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, ErrorAsEnumRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      WithErrorSyntax::InPlace::ErrorAsEnum(std::move(_client_end), std::move(_response_buffer)));
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum WithErrorSyntax::SyncClient::ErrorAsEnum(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(::zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

WithErrorSyntax::UnownedResultOf::ErrorAsEnum WithErrorSyntax::Call::ErrorAsEnum(::zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::ErrorAsEnum(std::move(_client_end), std::move(_response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse> WithErrorSyntax::InPlace::ErrorAsEnum(::zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsEnumRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<ErrorAsEnumRequest> params(std::move(_request_buffer));
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumRequest(params);
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<ErrorAsEnumRequest, ErrorAsEnumResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool WithErrorSyntax::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  zx_status_t status = fidl_validate_txn_header(hdr);
  if (status != ZX_OK) {
    txn->Close(status);
    return true;
  }
  switch (hdr->ordinal) {
    case kWithErrorSyntax_ResponseAsStruct_Ordinal:
    case kWithErrorSyntax_ResponseAsStruct_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ResponseAsStructRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ResponseAsStruct(
          Interface::ResponseAsStructCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
    case kWithErrorSyntax_ErrorAsPrimitive_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ErrorAsPrimitiveRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ErrorAsPrimitive(
          Interface::ErrorAsPrimitiveCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal:
    case kWithErrorSyntax_ErrorAsEnum_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<ErrorAsEnumRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ErrorAsEnum(
          Interface::ErrorAsEnumCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithErrorSyntax::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ResponseAsStructResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ResponseAsStructResponse*>(_write_bytes);
  WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructResponse(
      ::fidl::DecodedMessage<ResponseAsStructResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResponseAsStructResponse::PrimarySize,
              ResponseAsStructResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ResponseAsStructResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ResponseAsStructResponse>(std::move(_response_bytes)));
}
void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(int64_t a, int64_t b, int64_t c) {
  WithErrorSyntax_ResponseAsStruct_Response response;
  response.a = std::move(a);
  response.b = std::move(b);
  response.c = std::move(c);

  Reply(WithErrorSyntax_ResponseAsStruct_Result::WithResponse(&response));
}
void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplyError(uint32_t error) {
  Reply(WithErrorSyntax_ResponseAsStruct_Result::WithErr(&error));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::test::name::WithErrorSyntax_ResponseAsStruct_Result result) {
  if (_buffer.capacity() < ResponseAsStructResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ResponseAsStructResponse*>(_buffer.data());
  WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructResponse(
      ::fidl::DecodedMessage<ResponseAsStructResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ResponseAsStructResponse::PrimarySize,
              ResponseAsStructResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ResponseAsStructResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ResponseAsStructResponse>(std::move(_buffer)));
}
void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::ReplySuccess(::fidl::BytePart _buffer, int64_t a, int64_t b, int64_t c) {
  WithErrorSyntax_ResponseAsStruct_Response response;
  response.a = std::move(a);
  response.b = std::move(b);
  response.c = std::move(c);

  Reply(std::move(_buffer), WithErrorSyntax_ResponseAsStruct_Result::WithResponse(&response));
}

void WithErrorSyntax::Interface::ResponseAsStructCompleterBase::Reply(::fidl::DecodedMessage<ResponseAsStructResponse> params) {
  WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsPrimitiveResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ErrorAsPrimitiveResponse*>(_write_bytes);
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveResponse(
      ::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ErrorAsPrimitiveResponse::PrimarySize,
              ErrorAsPrimitiveResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsPrimitiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(std::move(_response_bytes)));
}
void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess() {
  WithErrorSyntax_ErrorAsPrimitive_Response response;

  Reply(WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(&response));
}
void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplyError(uint32_t error) {
  Reply(WithErrorSyntax_ErrorAsPrimitive_Result::WithErr(&error));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::test::name::WithErrorSyntax_ErrorAsPrimitive_Result result) {
  if (_buffer.capacity() < ErrorAsPrimitiveResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ErrorAsPrimitiveResponse*>(_buffer.data());
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveResponse(
      ::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ErrorAsPrimitiveResponse::PrimarySize,
              ErrorAsPrimitiveResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ErrorAsPrimitiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(std::move(_buffer)));
}
void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  WithErrorSyntax_ErrorAsPrimitive_Response response;

  Reply(std::move(_buffer), WithErrorSyntax_ErrorAsPrimitive_Result::WithResponse(&response));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse> params) {
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveResponse(params);
  CompleterBase::SendReply(std::move(params));
}


void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsEnumResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ErrorAsEnumResponse*>(_write_bytes);
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumResponse(
      ::fidl::DecodedMessage<ErrorAsEnumResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ErrorAsEnumResponse::PrimarySize,
              ErrorAsEnumResponse::PrimarySize)));
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsEnumResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsEnumResponse>(std::move(_response_bytes)));
}
void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess() {
  WithErrorSyntax_ErrorAsEnum_Response response;

  Reply(WithErrorSyntax_ErrorAsEnum_Result::WithResponse(&response));
}
void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplyError(ErrorEnun error) {
  Reply(WithErrorSyntax_ErrorAsEnum_Result::WithErr(&error));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(::fidl::BytePart _buffer, ::llcpp::test::name::WithErrorSyntax_ErrorAsEnum_Result result) {
  if (_buffer.capacity() < ErrorAsEnumResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ErrorAsEnumResponse*>(_buffer.data());
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumResponse(
      ::fidl::DecodedMessage<ErrorAsEnumResponse>(
          ::fidl::BytePart(reinterpret_cast<uint8_t*>(&_response),
              ErrorAsEnumResponse::PrimarySize,
              ErrorAsEnumResponse::PrimarySize)));
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ErrorAsEnumResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsEnumResponse>(std::move(_buffer)));
}
void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::ReplySuccess(::fidl::BytePart _buffer) {
  WithErrorSyntax_ErrorAsEnum_Response response;

  Reply(std::move(_buffer), WithErrorSyntax_ErrorAsEnum_Result::WithResponse(&response));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(::fidl::DecodedMessage<ErrorAsEnumResponse> params) {
  WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumResponse(params);
  CompleterBase::SendReply(std::move(params));
}



void WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructRequest(const ::fidl::DecodedMessage<WithErrorSyntax::ResponseAsStructRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ResponseAsStruct_GenOrdinal);
}
void WithErrorSyntax::SetTransactionHeaderFor::ResponseAsStructResponse(const ::fidl::DecodedMessage<WithErrorSyntax::ResponseAsStructResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ResponseAsStruct_GenOrdinal);
}

void WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveRequest(const ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsPrimitiveRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ErrorAsPrimitive_GenOrdinal);
}
void WithErrorSyntax::SetTransactionHeaderFor::ErrorAsPrimitiveResponse(const ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsPrimitiveResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ErrorAsPrimitive_GenOrdinal);
}

void WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumRequest(const ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsEnumRequest>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ErrorAsEnum_GenOrdinal);
}
void WithErrorSyntax::SetTransactionHeaderFor::ErrorAsEnumResponse(const ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsEnumResponse>& _msg) {
  fidl_init_txn_header(&_msg.message()->_hdr, 0, kWithErrorSyntax_ErrorAsEnum_GenOrdinal);
}

}  // namespace name
}  // namespace test
}  // namespace llcpp

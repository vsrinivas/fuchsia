// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.fidl.json.llcpp.h>
#include <memory>

namespace test {
namespace name {

::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result() {
  tag_ = Tag::Invalid;
}

::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::~WithErrorSyntax_ErrorAsPrimitive_Result() {
  Destroy();
}

void ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~WithErrorSyntax_ErrorAsPrimitive_Response();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::MoveImpl_(WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::test::name::WithErrorSyntax_ErrorAsPrimitive_Result, response_) == 4);
  static_assert(offsetof(::test::name::WithErrorSyntax_ErrorAsPrimitive_Result, err_) == 4);
  static_assert(sizeof(::test::name::WithErrorSyntax_ErrorAsPrimitive_Result) == ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::PrimarySize);
}


WithErrorSyntax_ErrorAsPrimitive_Response& ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) WithErrorSyntax_ErrorAsPrimitive_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

uint32_t& ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) uint32_t;
  }
  tag_ = Tag::kErr;
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint32_t kKitchenSink_MethodA_Ordinal = 450577456u;
[[maybe_unused]]
constexpr uint32_t kKitchenSink_EventA_Ordinal = 1795426833u;
[[maybe_unused]]
constexpr uint32_t kKitchenSink_MethodB_Ordinal = 1999489700u;
[[maybe_unused]]
constexpr uint32_t kKitchenSink_MutateSocket_Ordinal = 115851270u;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketResponseTable;

}  // namespace

zx_status_t KitchenSink::SyncClient::MethodA(int64_t a, int64_t b) {
  return KitchenSink::Call::MethodA(zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

zx_status_t KitchenSink::Call::MethodA(zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodARequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodARequest*>(_write_bytes);
  _request._hdr.ordinal = kKitchenSink_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t KitchenSink::SyncClient::MethodA(::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return KitchenSink::Call::MethodA(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b));
}

zx_status_t KitchenSink::Call::MethodA(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<MethodARequest*>(_request_buffer.data());
  _request._hdr.ordinal = kKitchenSink_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t KitchenSink::SyncClient::MethodA(::fidl::DecodedMessage<MethodARequest> params) {
  return KitchenSink::Call::MethodA(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t KitchenSink::Call::MethodA(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodARequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_MethodA_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t KitchenSink::SyncClient::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  return KitchenSink::Call::MethodB(zx::unowned_channel(this->channel_), std::move(a), std::move(b), out_result);
}

zx_status_t KitchenSink::Call::MethodB(zx::unowned_channel _client_end, int64_t a, int64_t b, int64_t* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodBRequest*>(_write_bytes);
  _request._hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<KitchenSink::MethodBResponse> KitchenSink::SyncClient::MethodB(::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  return KitchenSink::Call::MethodB(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<KitchenSink::MethodBResponse> KitchenSink::Call::MethodB(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    return ::fidl::DecodeResult<MethodBResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MethodBRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<KitchenSink::MethodBResponse> KitchenSink::SyncClient::MethodB(::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  return KitchenSink::Call::MethodB(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<KitchenSink::MethodBResponse> KitchenSink::Call::MethodB(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<KitchenSink::MethodBResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<KitchenSink::MethodBResponse>());
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<KitchenSink::MethodBResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<KitchenSink::MethodBResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t KitchenSink::SyncClient::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  return KitchenSink::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(a), out_b);
}

zx_status_t KitchenSink::Call::MutateSocket(zx::unowned_channel _client_end, ::zx::socket a, ::zx::socket* out_b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_write_bytes);
  _request._hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  _request.a = std::move(a);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return ZX_OK;
}

::fidl::DecodeResult<KitchenSink::MutateSocketResponse> KitchenSink::SyncClient::MutateSocket(::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  return KitchenSink::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(_response_buffer), out_b);
}

::fidl::DecodeResult<KitchenSink::MutateSocketResponse> KitchenSink::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    return ::fidl::DecodeResult<MutateSocketResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  _request.a = std::move(a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return _decode_result;
}

::fidl::DecodeResult<KitchenSink::MutateSocketResponse> KitchenSink::SyncClient::MutateSocket(::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  return KitchenSink::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<KitchenSink::MutateSocketResponse> KitchenSink::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<KitchenSink::MutateSocketResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<KitchenSink::MutateSocketResponse>());
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<KitchenSink::MutateSocketResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<KitchenSink::MutateSocketResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t KitchenSink::SyncClient::HandleEvents(KitchenSink::EventHandlers handlers) {
  return KitchenSink::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t KitchenSink::Call::HandleEvents(zx::unowned_channel client_end,
                                            KitchenSink::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<EventAResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<EventAResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kKitchenSink_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool KitchenSink::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kKitchenSink_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
        Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kKitchenSink_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
        Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kKitchenSink_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
        Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool KitchenSink::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t KitchenSink::SendEventAEvent(::zx::unowned_channel _chan, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EventAResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EventAResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kKitchenSink_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_response_bytes)));
}

zx_status_t KitchenSink::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<EventAResponse*>(_buffer.data());
  _response._hdr = {};
  _response._hdr.ordinal = kKitchenSink_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t KitchenSink::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventAResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_EventA_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void KitchenSink::Interface::MethodBCompleterBase::Reply(int64_t result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MethodBResponse*>(_write_bytes);
  _response._hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_response_bytes)));
}

void KitchenSink::Interface::MethodBCompleterBase::Reply(::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MethodBResponse*>(_buffer.data());
  _response._hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void KitchenSink::Interface::MethodBCompleterBase::Reply(::fidl::DecodedMessage<MethodBResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_MethodB_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void KitchenSink::Interface::MutateSocketCompleterBase::Reply(::zx::socket b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_write_bytes);
  _response._hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_response_bytes)));
}

void KitchenSink::Interface::MutateSocketCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_buffer.data());
  _response._hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void KitchenSink::Interface::MutateSocketCompleterBase::Reply(::fidl::DecodedMessage<MutateSocketResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kKitchenSink_MutateSocket_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kChannelProtocol_MethodA_Ordinal = 1432785874u;
[[maybe_unused]]
constexpr uint32_t kChannelProtocol_EventA_Ordinal = 477676034u;
[[maybe_unused]]
constexpr uint32_t kChannelProtocol_MethodB_Ordinal = 180770075u;
[[maybe_unused]]
constexpr uint32_t kChannelProtocol_MutateSocket_Ordinal = 1258480262u;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace

zx_status_t ChannelProtocol::SyncClient::MethodA(int64_t a, int64_t b) {
  return ChannelProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

zx_status_t ChannelProtocol::Call::MethodA(zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodARequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodARequest*>(_write_bytes);
  _request._hdr.ordinal = kChannelProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t ChannelProtocol::SyncClient::MethodA(::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return ChannelProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b));
}

zx_status_t ChannelProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<MethodARequest*>(_request_buffer.data());
  _request._hdr.ordinal = kChannelProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t ChannelProtocol::SyncClient::MethodA(::fidl::DecodedMessage<MethodARequest> params) {
  return ChannelProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t ChannelProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodARequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_MethodA_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t ChannelProtocol::SyncClient::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  return ChannelProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(a), std::move(b), out_result);
}

zx_status_t ChannelProtocol::Call::MethodB(zx::unowned_channel _client_end, int64_t a, int64_t b, int64_t* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodBRequest*>(_write_bytes);
  _request._hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse> ChannelProtocol::SyncClient::MethodB(::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  return ChannelProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse> ChannelProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    return ::fidl::DecodeResult<MethodBResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MethodBRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse> ChannelProtocol::SyncClient::MethodB(::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  return ChannelProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MethodBResponse> ChannelProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<ChannelProtocol::MethodBResponse>());
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MethodBResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<ChannelProtocol::MethodBResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t ChannelProtocol::SyncClient::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  return ChannelProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(a), out_b);
}

zx_status_t ChannelProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::zx::socket a, ::zx::socket* out_b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_write_bytes);
  _request._hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return ZX_OK;
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse> ChannelProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  return ChannelProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(_response_buffer), out_b);
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse> ChannelProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    return ::fidl::DecodeResult<MutateSocketResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return _decode_result;
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse> ChannelProtocol::SyncClient::MutateSocket(::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  return ChannelProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse> ChannelProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<ChannelProtocol::MutateSocketResponse>());
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ChannelProtocol::MutateSocketResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<ChannelProtocol::MutateSocketResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t ChannelProtocol::SyncClient::HandleEvents(ChannelProtocol::EventHandlers handlers) {
  return ChannelProtocol::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t ChannelProtocol::Call::HandleEvents(zx::unowned_channel client_end,
                                            ChannelProtocol::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<EventAResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<EventAResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool ChannelProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kChannelProtocol_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
        Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
        Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kChannelProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
        Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool ChannelProtocol::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EventAResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EventAResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kChannelProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_response_bytes)));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<EventAResponse*>(_buffer.data());
  _response._hdr = {};
  _response._hdr.ordinal = kChannelProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t ChannelProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventAResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_EventA_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void ChannelProtocol::Interface::MethodBCompleterBase::Reply(int64_t result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MethodBResponse*>(_write_bytes);
  _response._hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_response_bytes)));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MethodBResponse*>(_buffer.data());
  _response._hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MethodBCompleterBase::Reply(::fidl::DecodedMessage<MethodBResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_MethodB_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::zx::socket b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_write_bytes);
  _response._hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_response_bytes)));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_buffer.data());
  _response._hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void ChannelProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::DecodedMessage<MutateSocketResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kChannelProtocol_MutateSocket_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kSocketControlProtocol_MethodA_Ordinal = 1007842318u;
[[maybe_unused]]
constexpr uint32_t kSocketControlProtocol_EventA_Ordinal = 955483393u;
[[maybe_unused]]
constexpr uint32_t kSocketControlProtocol_MethodB_Ordinal = 677342235u;
[[maybe_unused]]
constexpr uint32_t kSocketControlProtocol_MutateSocket_Ordinal = 255772213u;
extern "C" const fidl_type_t test_name_SocketControlProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_SocketControlProtocolMutateSocketResponseTable;

}  // namespace

zx_status_t SocketControlProtocol::SyncClient::MethodA(int64_t a, int64_t b) {
  return SocketControlProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

zx_status_t SocketControlProtocol::Call::MethodA(zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodARequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodARequest*>(_write_bytes);
  _request._hdr.ordinal = kSocketControlProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t SocketControlProtocol::SyncClient::MethodA(::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return SocketControlProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b));
}

zx_status_t SocketControlProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<MethodARequest*>(_request_buffer.data());
  _request._hdr.ordinal = kSocketControlProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t SocketControlProtocol::SyncClient::MethodA(::fidl::DecodedMessage<MethodARequest> params) {
  return SocketControlProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t SocketControlProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodARequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_MethodA_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t SocketControlProtocol::SyncClient::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  return SocketControlProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(a), std::move(b), out_result);
}

zx_status_t SocketControlProtocol::Call::MethodB(zx::unowned_channel _client_end, int64_t a, int64_t b, int64_t* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodBRequest*>(_write_bytes);
  _request._hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<SocketControlProtocol::MethodBResponse> SocketControlProtocol::SyncClient::MethodB(::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  return SocketControlProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<SocketControlProtocol::MethodBResponse> SocketControlProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    return ::fidl::DecodeResult<MethodBResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MethodBRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<SocketControlProtocol::MethodBResponse> SocketControlProtocol::SyncClient::MethodB(::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  return SocketControlProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<SocketControlProtocol::MethodBResponse> SocketControlProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SocketControlProtocol::MethodBResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<SocketControlProtocol::MethodBResponse>());
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SocketControlProtocol::MethodBResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<SocketControlProtocol::MethodBResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t SocketControlProtocol::SyncClient::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  return SocketControlProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(a), out_b);
}

zx_status_t SocketControlProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::zx::socket a, ::zx::socket* out_b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_write_bytes);
  _request._hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return ZX_OK;
}

::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse> SocketControlProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  return SocketControlProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(_response_buffer), out_b);
}

::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse> SocketControlProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    return ::fidl::DecodeResult<MutateSocketResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return _decode_result;
}

::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse> SocketControlProtocol::SyncClient::MutateSocket(::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  return SocketControlProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse> SocketControlProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<SocketControlProtocol::MutateSocketResponse>());
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SocketControlProtocol::MutateSocketResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<SocketControlProtocol::MutateSocketResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t SocketControlProtocol::SyncClient::HandleEvents(SocketControlProtocol::EventHandlers handlers) {
  return SocketControlProtocol::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t SocketControlProtocol::Call::HandleEvents(zx::unowned_channel client_end,
                                            SocketControlProtocol::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<EventAResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<EventAResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kSocketControlProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool SocketControlProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kSocketControlProtocol_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
        Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kSocketControlProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
        Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kSocketControlProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
        Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool SocketControlProtocol::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t SocketControlProtocol::SendEventAEvent(::zx::unowned_channel _chan, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EventAResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EventAResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kSocketControlProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_response_bytes)));
}

zx_status_t SocketControlProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<EventAResponse*>(_buffer.data());
  _response._hdr = {};
  _response._hdr.ordinal = kSocketControlProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t SocketControlProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventAResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_EventA_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void SocketControlProtocol::Interface::MethodBCompleterBase::Reply(int64_t result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MethodBResponse*>(_write_bytes);
  _response._hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_response_bytes)));
}

void SocketControlProtocol::Interface::MethodBCompleterBase::Reply(::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MethodBResponse*>(_buffer.data());
  _response._hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void SocketControlProtocol::Interface::MethodBCompleterBase::Reply(::fidl::DecodedMessage<MethodBResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_MethodB_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void SocketControlProtocol::Interface::MutateSocketCompleterBase::Reply(::zx::socket b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_write_bytes);
  _response._hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_response_bytes)));
}

void SocketControlProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_buffer.data());
  _response._hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void SocketControlProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::DecodedMessage<MutateSocketResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kSocketControlProtocol_MutateSocket_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kOvernetInternalProtocol_MethodA_Ordinal = 1993818253u;
[[maybe_unused]]
constexpr uint32_t kOvernetInternalProtocol_EventA_Ordinal = 1746007436u;
[[maybe_unused]]
constexpr uint32_t kOvernetInternalProtocol_MethodB_Ordinal = 952134976u;
[[maybe_unused]]
constexpr uint32_t kOvernetInternalProtocol_MutateSocket_Ordinal = 1691201382u;
extern "C" const fidl_type_t test_name_OvernetInternalProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_OvernetInternalProtocolMutateSocketResponseTable;

}  // namespace

zx_status_t OvernetInternalProtocol::SyncClient::MethodA(int64_t a, int64_t b) {
  return OvernetInternalProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(a), std::move(b));
}

zx_status_t OvernetInternalProtocol::Call::MethodA(zx::unowned_channel _client_end, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodARequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodARequest*>(_write_bytes);
  _request._hdr.ordinal = kOvernetInternalProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t OvernetInternalProtocol::SyncClient::MethodA(::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  return OvernetInternalProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b));
}

zx_status_t OvernetInternalProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b) {
  if (_request_buffer.capacity() < MethodARequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _request = *reinterpret_cast<MethodARequest*>(_request_buffer.data());
  _request._hdr.ordinal = kOvernetInternalProtocol_MethodA_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodARequest));
  ::fidl::DecodedMessage<MethodARequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t OvernetInternalProtocol::SyncClient::MethodA(::fidl::DecodedMessage<MethodARequest> params) {
  return OvernetInternalProtocol::Call::MethodA(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t OvernetInternalProtocol::Call::MethodA(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodARequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_MethodA_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t OvernetInternalProtocol::SyncClient::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  return OvernetInternalProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(a), std::move(b), out_result);
}

zx_status_t OvernetInternalProtocol::Call::MethodB(zx::unowned_channel _client_end, int64_t a, int64_t b, int64_t* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MethodBRequest*>(_write_bytes);
  _request._hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse> OvernetInternalProtocol::SyncClient::MethodB(::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  return OvernetInternalProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(b), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse> OvernetInternalProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t a, int64_t b, ::fidl::BytePart _response_buffer, int64_t* out_result) {
  if (_request_buffer.capacity() < MethodBRequest::PrimarySize) {
    return ::fidl::DecodeResult<MethodBResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MethodBRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  _request.a = std::move(a);
  _request.b = std::move(b);
  _request_buffer.set_actual(sizeof(MethodBRequest));
  ::fidl::DecodedMessage<MethodBRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MethodBResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse> OvernetInternalProtocol::SyncClient::MethodB(::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  return OvernetInternalProtocol::Call::MethodB(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse> OvernetInternalProtocol::Call::MethodB(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MethodBRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<OvernetInternalProtocol::MethodBResponse>());
  }
  auto _call_result = ::fidl::Call<MethodBRequest, MethodBResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OvernetInternalProtocol::MethodBResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<OvernetInternalProtocol::MethodBResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t OvernetInternalProtocol::SyncClient::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  return OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(a), out_b);
}

zx_status_t OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::zx::socket a, ::zx::socket* out_b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_write_bytes);
  _request._hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return ZX_OK;
}

::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse> OvernetInternalProtocol::SyncClient::MutateSocket(::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  return OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(a), std::move(_response_buffer), out_b);
}

::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse> OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::zx::socket a, ::fidl::BytePart _response_buffer, ::zx::socket* out_b) {
  if (_request_buffer.capacity() < MutateSocketRequest::PrimarySize) {
    return ::fidl::DecodeResult<MutateSocketResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<MutateSocketRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  _request.a = std::move(a);
  _request_buffer.set_actual(sizeof(MutateSocketRequest));
  ::fidl::DecodedMessage<MutateSocketRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<MutateSocketResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_b = std::move(_response.b);
  return _decode_result;
}

::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse> OvernetInternalProtocol::SyncClient::MutateSocket(::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  return OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse> OvernetInternalProtocol::Call::MutateSocket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MutateSocketRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<OvernetInternalProtocol::MutateSocketResponse>());
  }
  auto _call_result = ::fidl::Call<MutateSocketRequest, MutateSocketResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<OvernetInternalProtocol::MutateSocketResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<OvernetInternalProtocol::MutateSocketResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t OvernetInternalProtocol::SyncClient::HandleEvents(OvernetInternalProtocol::EventHandlers handlers) {
  return OvernetInternalProtocol::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t OvernetInternalProtocol::Call::HandleEvents(zx::unowned_channel client_end,
                                            OvernetInternalProtocol::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<EventAResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<EventAResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (EventAResponse::MaxNumHandles >= x) {
      x = EventAResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  FIDL_ALIGNDECL uint8_t read_bytes[kReadAllocSize];
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kOvernetInternalProtocol_EventA_Ordinal: {
      auto result = ::fidl::DecodeAs<EventAResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.event_a(std::move(message->a), std::move(message->b));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool OvernetInternalProtocol::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kOvernetInternalProtocol_MethodA_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodARequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodA(std::move(message->a), std::move(message->b),
        Interface::MethodACompleter::Sync(txn));
      return true;
    }
    case kOvernetInternalProtocol_MethodB_Ordinal: {
      auto result = ::fidl::DecodeAs<MethodBRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MethodB(std::move(message->a), std::move(message->b),
        Interface::MethodBCompleter::Sync(txn));
      return true;
    }
    case kOvernetInternalProtocol_MutateSocket_Ordinal: {
      auto result = ::fidl::DecodeAs<MutateSocketRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->MutateSocket(std::move(message->a),
        Interface::MutateSocketCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool OvernetInternalProtocol::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


zx_status_t OvernetInternalProtocol::SendEventAEvent(::zx::unowned_channel _chan, int64_t a, int64_t b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<EventAResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<EventAResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kOvernetInternalProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_response_bytes)));
}

zx_status_t OvernetInternalProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int64_t a, int64_t b) {
  if (_buffer.capacity() < EventAResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  auto& _response = *reinterpret_cast<EventAResponse*>(_buffer.data());
  _response._hdr = {};
  _response._hdr.ordinal = kOvernetInternalProtocol_EventA_Ordinal;
  _response.a = std::move(a);
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(EventAResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<EventAResponse>(std::move(_buffer)));
}

zx_status_t OvernetInternalProtocol::SendEventAEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<EventAResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_EventA_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


void OvernetInternalProtocol::Interface::MethodBCompleterBase::Reply(int64_t result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MethodBResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MethodBResponse*>(_write_bytes);
  _response._hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_response_bytes)));
}

void OvernetInternalProtocol::Interface::MethodBCompleterBase::Reply(::fidl::BytePart _buffer, int64_t result) {
  if (_buffer.capacity() < MethodBResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MethodBResponse*>(_buffer.data());
  _response._hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(MethodBResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MethodBResponse>(std::move(_buffer)));
}

void OvernetInternalProtocol::Interface::MethodBCompleterBase::Reply(::fidl::DecodedMessage<MethodBResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_MethodB_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void OvernetInternalProtocol::Interface::MutateSocketCompleterBase::Reply(::zx::socket b) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<MutateSocketResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_write_bytes);
  _response._hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_response_bytes)));
}

void OvernetInternalProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::BytePart _buffer, ::zx::socket b) {
  if (_buffer.capacity() < MutateSocketResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<MutateSocketResponse*>(_buffer.data());
  _response._hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  _response.b = std::move(b);
  _buffer.set_actual(sizeof(MutateSocketResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<MutateSocketResponse>(std::move(_buffer)));
}

void OvernetInternalProtocol::Interface::MutateSocketCompleterBase::Reply(::fidl::DecodedMessage<MutateSocketResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kOvernetInternalProtocol_MutateSocket_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


namespace {

[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal = 503576693u;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal = 1308023765u;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal = 107534328u;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal = 432149361u;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal = 1995585907u;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal = 426977568u;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal = 1769985842u;
[[maybe_unused]]
constexpr uint32_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal = 2051478023u;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace

zx_status_t WithAndWithoutRequestResponse::SyncClient::NoRequestNoResponse() {
  return WithAndWithoutRequestResponse::Call::NoRequestNoResponse(zx::unowned_channel(this->channel_));
}

zx_status_t WithAndWithoutRequestResponse::Call::NoRequestNoResponse(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestNoResponseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<NoRequestNoResponseRequest*>(_write_bytes);
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestNoResponseRequest));
  ::fidl::DecodedMessage<NoRequestNoResponseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t WithAndWithoutRequestResponse::SyncClient::NoRequestEmptyResponse() {
  return WithAndWithoutRequestResponse::Call::NoRequestEmptyResponse(zx::unowned_channel(this->channel_));
}

zx_status_t WithAndWithoutRequestResponse::Call::NoRequestEmptyResponse(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestEmptyResponseRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<NoRequestEmptyResponseRequest*>(_write_bytes);
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestEmptyResponseRequest));
  ::fidl::DecodedMessage<NoRequestEmptyResponseRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<NoRequestEmptyResponseRequest, NoRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  return ZX_OK;
}


::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse> WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse(::fidl::BytePart _response_buffer, ::fidl::StringView* out_ret) {
  return WithAndWithoutRequestResponse::Call::NoRequestWithResponse(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_ret);
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse> WithAndWithoutRequestResponse::Call::NoRequestWithResponse(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, ::fidl::StringView* out_ret) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NoRequestWithResponseRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<NoRequestWithResponseRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal;
  _request_buffer.set_actual(sizeof(NoRequestWithResponseRequest));
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<NoRequestWithResponseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<NoRequestWithResponseRequest, NoRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<NoRequestWithResponseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_ret = std::move(_response.ret);
  return _decode_result;
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse> WithAndWithoutRequestResponse::SyncClient::NoRequestWithResponse(::fidl::BytePart response_buffer) {
  return WithAndWithoutRequestResponse::Call::NoRequestWithResponse(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse> WithAndWithoutRequestResponse::Call::NoRequestWithResponse(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(NoRequestWithResponseRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(NoRequestWithResponseRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<NoRequestWithResponseRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>());
  }
  auto _call_result = ::fidl::Call<NoRequestWithResponseRequest, NoRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<WithAndWithoutRequestResponse::NoRequestWithResponseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(::fidl::StringView arg) {
  return WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel(this->channel_), std::move(arg));
}

zx_status_t WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel _client_end, ::fidl::StringView arg) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestNoResponseRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WithRequestNoResponseRequest _request = {};
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal;
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<WithRequestNoResponseRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg));
}

zx_status_t WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  if (_request_buffer.capacity() < WithRequestNoResponseRequest::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  WithRequestNoResponseRequest _request = {};
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal;
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<WithRequestNoResponseRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::WithRequestNoResponse(::fidl::DecodedMessage<WithRequestNoResponseRequest> params) {
  return WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t WithAndWithoutRequestResponse::Call::WithRequestNoResponse(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestNoResponseRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  return ::fidl::Write(std::move(_client_end), std::move(_encode_request_result.message));
}


zx_status_t WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(::fidl::StringView arg) {
  return WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel(this->channel_), std::move(arg));
}

zx_status_t WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel _client_end, ::fidl::StringView arg) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseRequest>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WithRequestEmptyResponseRequest _request = {};
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal;
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, ::fidl::BytePart(_write_bytes,
                                                                         _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<WithRequestEmptyResponseRequest, WithRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  return ZX_OK;
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse> WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  return WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestEmptyResponseResponse> WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg) {
  if (_request_buffer.capacity() < WithRequestEmptyResponseRequest::PrimarySize) {
    return ::fidl::DecodeResult<WithRequestEmptyResponseResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  WithRequestEmptyResponseRequest _request = {};
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal;
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestEmptyResponseResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestEmptyResponseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_buffer(_read_bytes, sizeof(_read_bytes));
  auto _call_result = ::fidl::Call<WithRequestEmptyResponseRequest, WithRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestEmptyResponseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  return _decode_result;
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::WithRequestEmptyResponse(::fidl::DecodedMessage<WithRequestEmptyResponseRequest> params) {
  return WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel(this->channel_), std::move(params));
}

zx_status_t WithAndWithoutRequestResponse::Call::WithRequestEmptyResponse(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestEmptyResponseRequest> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart response_buffer(_read_bytes, sizeof(_read_bytes));
  auto _call_result = ::fidl::Call<WithRequestEmptyResponseRequest, WithRequestEmptyResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  return _decode_result.status;
}


::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse> WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer, ::fidl::StringView* out_ret) {
  return WithAndWithoutRequestResponse::Call::WithRequestWithResponse(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(arg), std::move(_response_buffer), out_ret);
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse> WithAndWithoutRequestResponse::Call::WithRequestWithResponse(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView arg, ::fidl::BytePart _response_buffer, ::fidl::StringView* out_ret) {
  if (_request_buffer.capacity() < WithRequestWithResponseRequest::PrimarySize) {
    return ::fidl::DecodeResult<WithRequestWithResponseResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  WithRequestWithResponseRequest _request = {};
  _request._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal;
  _request.arg = std::move(arg);
  auto _linearize_result = ::fidl::Linearize(&_request, std::move(_request_buffer));
  if (_linearize_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestWithResponseResponse>(_linearize_result.status, _linearize_result.error);
  }
  ::fidl::DecodedMessage<WithRequestWithResponseRequest> _decoded_request = std::move(_linearize_result.message);
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestWithResponseResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<WithRequestWithResponseRequest, WithRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithRequestWithResponseResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_ret = std::move(_response.ret);
  return _decode_result;
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse> WithAndWithoutRequestResponse::SyncClient::WithRequestWithResponse(::fidl::DecodedMessage<WithRequestWithResponseRequest> params, ::fidl::BytePart response_buffer) {
  return WithAndWithoutRequestResponse::Call::WithRequestWithResponse(zx::unowned_channel(this->channel_), std::move(params), std::move(response_buffer));
}

::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse> WithAndWithoutRequestResponse::Call::WithRequestWithResponse(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WithRequestWithResponseRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>());
  }
  auto _call_result = ::fidl::Call<WithRequestWithResponseRequest, WithRequestWithResponseResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<WithAndWithoutRequestResponse::WithRequestWithResponseResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SyncClient::HandleEvents(WithAndWithoutRequestResponse::EventHandlers handlers) {
  return WithAndWithoutRequestResponse::Call::HandleEvents(zx::unowned_channel(channel_), std::move(handlers));
}

zx_status_t WithAndWithoutRequestResponse::Call::HandleEvents(zx::unowned_channel client_end,
                                            WithAndWithoutRequestResponse::EventHandlers handlers) {
  zx_status_t status = client_end->wait_one(ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED,
                                            zx::time::infinite(),
                                            nullptr);
  if (status != ZX_OK) {
    return status;
  }
  constexpr uint32_t kReadAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse>();
    }
    if (::fidl::internal::ClampedMessageSize<OnWithResponseResponse>() >= x) {
      x = ::fidl::internal::ClampedMessageSize<OnWithResponseResponse>();
    }
    return x;
  })();
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (OnEmptyResponseResponse::MaxNumHandles >= x) {
      x = OnEmptyResponseResponse::MaxNumHandles;
    }
    if (OnWithResponseResponse::MaxNumHandles >= x) {
      x = OnWithResponseResponse::MaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  std::unique_ptr<uint8_t[]> read_bytes_unique_ptr(new uint8_t[kReadAllocSize]);
  uint8_t* read_bytes = read_bytes_unique_ptr.get();
  zx_handle_t read_handles[kHandleAllocSize];
  uint32_t actual_bytes;
  uint32_t actual_handles;
  status = client_end->read(ZX_CHANNEL_READ_MAY_DISCARD,
                            read_bytes, read_handles,
                            kReadAllocSize, kHandleAllocSize,
                            &actual_bytes, &actual_handles);
  if (status == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new event,
    // whose size exceeds the maximum of known events in the current protocol.
    return handlers.unknown();
  }
  if (status != ZX_OK) {
    return status;
  }
  if (actual_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(read_handles, actual_handles);
    return ZX_ERR_INVALID_ARGS;
  }
  auto msg = fidl_msg_t {
    .bytes = read_bytes,
    .handles = read_handles,
    .num_bytes = actual_bytes,
    .num_handles = actual_handles
  };
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg.bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnEmptyResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      return handlers.on_empty_response();
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<OnWithResponseResponse>(&msg);
      if (result.status != ZX_OK) {
        return result.status;
      }
      auto message = result.message.message();
      return handlers.on_with_response(std::move(message->ret));
    }
    default:
      zx_handle_close_many(read_handles, actual_handles);
      return handlers.unknown();
  }
}

bool WithAndWithoutRequestResponse::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestNoResponse(
        Interface::NoRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestEmptyResponse(
        Interface::NoRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<NoRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->NoRequestWithResponse(
        Interface::NoRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestNoResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestNoResponse(std::move(message->arg),
        Interface::WithRequestNoResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestEmptyResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestEmptyResponse(std::move(message->arg),
        Interface::WithRequestEmptyResponseCompleter::Sync(txn));
      return true;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      auto result = ::fidl::DecodeAs<WithRequestWithResponseRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->WithRequestWithResponse(std::move(message->arg),
        Interface::WithRequestWithResponseCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithAndWithoutRequestResponse::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void WithAndWithoutRequestResponse::Interface::NoRequestEmptyResponseCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<NoRequestEmptyResponseResponse*>(_write_bytes);
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(NoRequestEmptyResponseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<NoRequestEmptyResponseResponse>(std::move(_response_bytes)));
}


void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<NoRequestWithResponseResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  NoRequestWithResponseResponse _response = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < NoRequestWithResponseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  NoRequestWithResponseResponse _response = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::NoRequestWithResponseCompleterBase::Reply(::fidl::DecodedMessage<NoRequestWithResponseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void WithAndWithoutRequestResponse::Interface::WithRequestEmptyResponseCompleterBase::Reply() {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<WithRequestEmptyResponseResponse*>(_write_bytes);
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(WithRequestEmptyResponseResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<WithRequestEmptyResponseResponse>(std::move(_response_bytes)));
}


void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<WithRequestWithResponseResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  WithRequestWithResponseResponse _response = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < WithRequestWithResponseResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  WithRequestWithResponseResponse _response = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void WithAndWithoutRequestResponse::Interface::WithRequestWithResponseCompleterBase::Reply(::fidl::DecodedMessage<WithRequestWithResponseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


zx_status_t WithAndWithoutRequestResponse::SendOnEmptyResponseEvent(::zx::unowned_channel _chan) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnEmptyResponseResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<OnEmptyResponseResponse*>(_write_bytes);
  _response._hdr = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal;
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(OnEmptyResponseResponse));
  return ::fidl::Write(zx::unowned_channel(_chan), ::fidl::DecodedMessage<OnEmptyResponseResponse>(std::move(_response_bytes)));
}


zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::StringView ret) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<OnWithResponseResponse>();
  std::unique_ptr<uint8_t[]> _write_bytes_unique_ptr(new uint8_t[_kWriteAllocSize]);
  uint8_t* _write_bytes = _write_bytes_unique_ptr.get();
  OnWithResponseResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_OnWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, ::fidl::StringView ret) {
  if (_buffer.capacity() < OnWithResponseResponse::PrimarySize) {
    return ZX_ERR_BUFFER_TOO_SMALL;
  }
  OnWithResponseResponse _response = {};
  _response._hdr = {};
  _response._hdr.ordinal = kWithAndWithoutRequestResponse_OnWithResponse_Ordinal;
  _response.ret = std::move(ret);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
	return _linearize_result.status;
  }
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(_linearize_result.message));
}

zx_status_t WithAndWithoutRequestResponse::SendOnWithResponseEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnWithResponseResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithAndWithoutRequestResponse_OnWithResponse_Ordinal;
  return ::fidl::Write(zx::unowned_channel(_chan), std::move(params));
}


::test::name::WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() {
  tag_ = Tag::Invalid;
}

::test::name::WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
  Destroy();
}

void ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Destroy() {
  switch (which()) {
  case Tag::kResponse:
    response_.~WithErrorSyntax_ErrorAsEnum_Response();
    break;
  case Tag::kErr:
    err_.~ErrorEnun();
    break;
  default:
    break;
  }
  tag_ = Tag::Invalid;
}

void ::test::name::WithErrorSyntax_ErrorAsEnum_Result::MoveImpl_(WithErrorSyntax_ErrorAsEnum_Result&& other) {
  switch (other.which()) {
  case Tag::kResponse:
    mutable_response() = std::move(other.mutable_response());
    break;
  case Tag::kErr:
    mutable_err() = std::move(other.mutable_err());
    break;
  default:
    break;
  }
  other.Destroy();
}

void ::test::name::WithErrorSyntax_ErrorAsEnum_Result::SizeAndOffsetAssertionHelper() {
  static_assert(offsetof(::test::name::WithErrorSyntax_ErrorAsEnum_Result, response_) == 4);
  static_assert(offsetof(::test::name::WithErrorSyntax_ErrorAsEnum_Result, err_) == 4);
  static_assert(sizeof(::test::name::WithErrorSyntax_ErrorAsEnum_Result) == ::test::name::WithErrorSyntax_ErrorAsEnum_Result::PrimarySize);
}


WithErrorSyntax_ErrorAsEnum_Response& ::test::name::WithErrorSyntax_ErrorAsEnum_Result::mutable_response() {
  if (which() != Tag::kResponse) {
    Destroy();
    new (&response_) WithErrorSyntax_ErrorAsEnum_Response;
  }
  tag_ = Tag::kResponse;
  return response_;
}

ErrorEnun& ::test::name::WithErrorSyntax_ErrorAsEnum_Result::mutable_err() {
  if (which() != Tag::kErr) {
    Destroy();
    new (&err_) ErrorEnun;
  }
  tag_ = Tag::kErr;
  return err_;
}


namespace {

[[maybe_unused]]
constexpr uint32_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 2069369145u;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
[[maybe_unused]]
constexpr uint32_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 1284890143u;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace

zx_status_t WithErrorSyntax::SyncClient::ErrorAsPrimitive(WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  return WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel(this->channel_), out_result);
}

zx_status_t WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel _client_end, WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsPrimitiveRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<ErrorAsPrimitiveRequest*>(_write_bytes);
  _request._hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsPrimitiveResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<ErrorAsPrimitiveRequest, ErrorAsPrimitiveResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse> WithErrorSyntax::SyncClient::ErrorAsPrimitive(::fidl::BytePart _response_buffer, WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  return WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse> WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsPrimitiveRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<ErrorAsPrimitiveRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  _request_buffer.set_actual(sizeof(ErrorAsPrimitiveRequest));
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ErrorAsPrimitiveResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ErrorAsPrimitiveRequest, ErrorAsPrimitiveResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ErrorAsPrimitiveResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse> WithErrorSyntax::SyncClient::ErrorAsPrimitive(::fidl::BytePart response_buffer) {
  return WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse> WithErrorSyntax::Call::ErrorAsPrimitive(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsPrimitiveRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsPrimitiveRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<ErrorAsPrimitiveRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsPrimitiveResponse>());
  }
  auto _call_result = ::fidl::Call<ErrorAsPrimitiveRequest, ErrorAsPrimitiveResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsPrimitiveResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsPrimitiveResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


zx_status_t WithErrorSyntax::SyncClient::ErrorAsEnum(WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  return WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel(this->channel_), out_result);
}

zx_status_t WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel _client_end, WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsEnumRequest>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<ErrorAsEnumRequest*>(_write_bytes);
  _request._hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsEnumResponse>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<ErrorAsEnumRequest, ErrorAsEnumResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return ZX_OK;
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse> WithErrorSyntax::SyncClient::ErrorAsEnum(::fidl::BytePart _response_buffer, WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  return WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_result);
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse> WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsEnumRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<ErrorAsEnumRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  _request_buffer.set_actual(sizeof(ErrorAsEnumRequest));
  ::fidl::DecodedMessage<ErrorAsEnumRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ErrorAsEnumResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<ErrorAsEnumRequest, ErrorAsEnumResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<ErrorAsEnumResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_result = std::move(_response.result);
  return _decode_result;
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse> WithErrorSyntax::SyncClient::ErrorAsEnum(::fidl::BytePart response_buffer) {
  return WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel(this->channel_), std::move(response_buffer));
}

::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse> WithErrorSyntax::Call::ErrorAsEnum(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(ErrorAsEnumRequest)] = {};
  constexpr uint32_t _write_num_bytes = sizeof(ErrorAsEnumRequest);
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes), _write_num_bytes);
  ::fidl::DecodedMessage<ErrorAsEnumRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>(
      _encode_request_result.status,
      _encode_request_result.error,
      ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsEnumResponse>());
  }
  auto _call_result = ::fidl::Call<ErrorAsEnumRequest, ErrorAsEnumResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<WithErrorSyntax::ErrorAsEnumResponse>(
      _call_result.status,
      _call_result.error,
      ::fidl::DecodedMessage<WithErrorSyntax::ErrorAsEnumResponse>());
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool WithErrorSyntax::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsPrimitiveRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ErrorAsPrimitive(
        Interface::ErrorAsPrimitiveCompleter::Sync(txn));
      return true;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      auto result = ::fidl::DecodeAs<ErrorAsEnumRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->ErrorAsEnum(
        Interface::ErrorAsEnumCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool WithErrorSyntax::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(WithErrorSyntax_ErrorAsPrimitive_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsPrimitiveResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ErrorAsPrimitiveResponse*>(_write_bytes);
  _response._hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsPrimitiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(std::move(_response_bytes)));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(::fidl::BytePart _buffer, WithErrorSyntax_ErrorAsPrimitive_Result result) {
  if (_buffer.capacity() < ErrorAsPrimitiveResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ErrorAsPrimitiveResponse*>(_buffer.data());
  _response._hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ErrorAsPrimitiveResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse>(std::move(_buffer)));
}

void WithErrorSyntax::Interface::ErrorAsPrimitiveCompleterBase::Reply(::fidl::DecodedMessage<ErrorAsPrimitiveResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithErrorSyntax_ErrorAsPrimitive_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(WithErrorSyntax_ErrorAsEnum_Result result) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<ErrorAsEnumResponse>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<ErrorAsEnumResponse*>(_write_bytes);
  _response._hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  _response.result = std::move(result);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(ErrorAsEnumResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsEnumResponse>(std::move(_response_bytes)));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(::fidl::BytePart _buffer, WithErrorSyntax_ErrorAsEnum_Result result) {
  if (_buffer.capacity() < ErrorAsEnumResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<ErrorAsEnumResponse*>(_buffer.data());
  _response._hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  _response.result = std::move(result);
  _buffer.set_actual(sizeof(ErrorAsEnumResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<ErrorAsEnumResponse>(std::move(_buffer)));
}

void WithErrorSyntax::Interface::ErrorAsEnumCompleterBase::Reply(::fidl::DecodedMessage<ErrorAsEnumResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kWithErrorSyntax_ErrorAsEnum_Ordinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace name
}  // namespace test

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/txn_header.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fit/function.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace test {
namespace name {

struct SimpleTable;
struct ReverseOrdinalTable;
struct OlderSimpleTable;
struct NewerSimpleTable;
struct EmptyTable;

extern "C" const fidl_type_t test_name_SimpleTableTable;
extern "C" const fidl_type_t v1_test_name_SimpleTableTable;

struct SimpleTable final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_x() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(5 - 1).data);
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(5 - 1).data);
  }
  bool has_y() const {
    return EnvelopesView::count() >= 5 && EnvelopesView::at(5 - 1).data != nullptr;
  }

  SimpleTable() = default;
  ~SimpleTable() = default;
  SimpleTable(SimpleTable&& other) noexcept = default;
  SimpleTable& operator=(SimpleTable&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &test_name_SimpleTableTable;
  static constexpr const fidl_type_t* AltType = &v1_test_name_SimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 48;

 private:
  SimpleTable(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class SimpleTable::Builder {
 public:
  SimpleTable view() { return SimpleTable(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder&& set_x(int64_t* elem);

  Builder&& set_y(int64_t* elem);

 private:
  Builder() = default;
  friend Builder SimpleTable::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 5> envelopes_ = {};
};

extern "C" const fidl_type_t test_name_ReverseOrdinalTableTable;
extern "C" const fidl_type_t v1_test_name_ReverseOrdinalTableTable;

struct ReverseOrdinalTable final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  const int64_t& z() const {
    ZX_ASSERT(has_z());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  int64_t& z() {
    ZX_ASSERT(has_z());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_z() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(2 - 1).data);
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(2 - 1).data);
  }
  bool has_y() const {
    return EnvelopesView::count() >= 2 && EnvelopesView::at(2 - 1).data != nullptr;
  }

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(3 - 1).data);
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(3 - 1).data);
  }
  bool has_x() const {
    return EnvelopesView::count() >= 3 && EnvelopesView::at(3 - 1).data != nullptr;
  }

  ReverseOrdinalTable() = default;
  ~ReverseOrdinalTable() = default;
  ReverseOrdinalTable(ReverseOrdinalTable&& other) noexcept = default;
  ReverseOrdinalTable& operator=(ReverseOrdinalTable&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &test_name_ReverseOrdinalTableTable;
  static constexpr const fidl_type_t* AltType = &v1_test_name_ReverseOrdinalTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 72;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 72;

 private:
  ReverseOrdinalTable(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class ReverseOrdinalTable::Builder {
 public:
  ReverseOrdinalTable view() { return ReverseOrdinalTable(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder&& set_z(int64_t* elem);

  Builder&& set_y(int64_t* elem);

  Builder&& set_x(int64_t* elem);

 private:
  Builder() = default;
  friend Builder ReverseOrdinalTable::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 3> envelopes_ = {};
};

extern "C" const fidl_type_t test_name_OlderSimpleTableTable;
extern "C" const fidl_type_t v1_test_name_OlderSimpleTableTable;

struct OlderSimpleTable final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_x() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  OlderSimpleTable() = default;
  ~OlderSimpleTable() = default;
  OlderSimpleTable(OlderSimpleTable&& other) noexcept = default;
  OlderSimpleTable& operator=(OlderSimpleTable&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &test_name_OlderSimpleTableTable;
  static constexpr const fidl_type_t* AltType = &v1_test_name_OlderSimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 24;

 private:
  OlderSimpleTable(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class OlderSimpleTable::Builder {
 public:
  OlderSimpleTable view() { return OlderSimpleTable(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder&& set_x(int64_t* elem);

 private:
  Builder() = default;
  friend Builder OlderSimpleTable::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 1> envelopes_ = {};
};

extern "C" const fidl_type_t test_name_NewerSimpleTableTable;
extern "C" const fidl_type_t v1_test_name_NewerSimpleTableTable;

struct NewerSimpleTable final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(1 - 1).data);
  }
  bool has_x() const {
    return EnvelopesView::count() >= 1 && EnvelopesView::at(1 - 1).data != nullptr;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(5 - 1).data);
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(5 - 1).data);
  }
  bool has_y() const {
    return EnvelopesView::count() >= 5 && EnvelopesView::at(5 - 1).data != nullptr;
  }

  const int64_t& z() const {
    ZX_ASSERT(has_z());
    return *reinterpret_cast<const int64_t*>(EnvelopesView::at(6 - 1).data);
  }
  int64_t& z() {
    ZX_ASSERT(has_z());
    return *reinterpret_cast<int64_t*>(EnvelopesView::at(6 - 1).data);
  }
  bool has_z() const {
    return EnvelopesView::count() >= 6 && EnvelopesView::at(6 - 1).data != nullptr;
  }

  NewerSimpleTable() = default;
  ~NewerSimpleTable() = default;
  NewerSimpleTable(NewerSimpleTable&& other) noexcept = default;
  NewerSimpleTable& operator=(NewerSimpleTable&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &test_name_NewerSimpleTableTable;
  static constexpr const fidl_type_t* AltType = &v1_test_name_NewerSimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 72;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 72;

 private:
  NewerSimpleTable(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class NewerSimpleTable::Builder {
 public:
  NewerSimpleTable view() { return NewerSimpleTable(max_ordinal_, envelopes_.data_); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

  Builder&& set_x(int64_t* elem);

  Builder&& set_y(int64_t* elem);

  Builder&& set_z(int64_t* elem);

 private:
  Builder() = default;
  friend Builder NewerSimpleTable::Build();

  uint64_t max_ordinal_ = 0;
  ::fidl::Array<fidl_envelope_t, 6> envelopes_ = {};
};

extern "C" const fidl_type_t test_name_EmptyTableTable;
extern "C" const fidl_type_t v1_test_name_EmptyTableTable;

struct EmptyTable final : private ::fidl::VectorView<fidl_envelope_t> {
  using EnvelopesView = ::fidl::VectorView<fidl_envelope_t>;
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return EnvelopesView::empty(); }

  EmptyTable() = default;
  ~EmptyTable() = default;
  EmptyTable(EmptyTable&& other) noexcept = default;
  EmptyTable& operator=(EmptyTable&& other) noexcept = default;

  class Builder;
  friend class Builder;
  static Builder Build();
  static constexpr const fidl_type_t* Type = &test_name_EmptyTableTable;
  static constexpr const fidl_type_t* AltType = &v1_test_name_EmptyTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t AltMaxOutOfLine = 0;

 private:
  EmptyTable(uint64_t max_ordinal, fidl_envelope_t* data) : EnvelopesView(data, max_ordinal) {}
};

class EmptyTable::Builder {
 public:
  EmptyTable view() { return EmptyTable(0, nullptr); }
  ~Builder() = default;
  Builder(Builder&& other) noexcept = default;
  Builder& operator=(Builder&& other) noexcept = default;

 private:
  Builder() = default;
  friend Builder EmptyTable::Build();
};

}  // namespace name
}  // namespace test
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::test::name::SimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::SimpleTable>);

template <>
struct IsFidlType<::llcpp::test::name::ReverseOrdinalTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::ReverseOrdinalTable>);

template <>
struct IsFidlType<::llcpp::test::name::OlderSimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::OlderSimpleTable>);

template <>
struct IsFidlType<::llcpp::test::name::NewerSimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::NewerSimpleTable>);

template <>
struct IsFidlType<::llcpp::test::name::EmptyTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::EmptyTable>);

}  // namespace fidl

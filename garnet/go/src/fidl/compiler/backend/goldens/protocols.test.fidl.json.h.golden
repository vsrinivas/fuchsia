// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"


namespace test {
namespace name {

class WithErrorSyntax_ErrorAsPrimitive_Response;
class WithErrorSyntax_ErrorAsPrimitive_Result;
class WithErrorSyntax_ErrorAsEnum_Response;
#ifdef __Fuchsia__
class KitchenSink;
using KitchenSinkPtr = ::fidl::InterfacePtr<KitchenSink>;
class KitchenSink_Proxy;
class KitchenSink_Stub;
class KitchenSink_EventSender;
class KitchenSink_Sync;
using KitchenSinkSyncPtr = ::fidl::SynchronousInterfacePtr<KitchenSink>;
class KitchenSink_SyncProxy;
#endif // __Fuchsia__
#ifdef __Fuchsia__
class KitchenSink;
using KitchenSinkPtr = ::fidl::InterfacePtr<KitchenSink>;
class KitchenSink_Proxy;
class KitchenSink_Stub;
class KitchenSink_EventSender;
class KitchenSink_Sync;
using KitchenSinkSyncPtr = ::fidl::SynchronousInterfacePtr<KitchenSink>;
class KitchenSink_SyncProxy;
#endif // __Fuchsia__
#ifdef __Fuchsia__
class ChannelProtocol;
using ChannelProtocolPtr = ::fidl::InterfacePtr<ChannelProtocol>;
class ChannelProtocol_Proxy;
class ChannelProtocol_Stub;
class ChannelProtocol_EventSender;
class ChannelProtocol_Sync;
using ChannelProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
class ChannelProtocol_SyncProxy;
#endif // __Fuchsia__
#ifdef __Fuchsia__
class SocketControlProtocol;
using SocketControlProtocolPtr = ::fidl::InterfacePtr<SocketControlProtocol>;
class SocketControlProtocol_Proxy;
class SocketControlProtocol_Stub;
class SocketControlProtocol_EventSender;
class SocketControlProtocol_Sync;
using SocketControlProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<SocketControlProtocol>;
class SocketControlProtocol_SyncProxy;
#endif // __Fuchsia__
#ifdef __Fuchsia__
class WithAndWithoutRequestResponse;
using WithAndWithoutRequestResponsePtr = ::fidl::InterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_Proxy;
class WithAndWithoutRequestResponse_Stub;
class WithAndWithoutRequestResponse_EventSender;
class WithAndWithoutRequestResponse_Sync;
using WithAndWithoutRequestResponseSyncPtr = ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_SyncProxy;
#endif // __Fuchsia__
enum class ErrorEnun : uint32_t {
  ERR_FOO = 1,
  ERR_BAR = 2,
};

inline zx_status_t Clone(::test::name::ErrorEnun value,
                         ::test::name::ErrorEnun* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_ErrorAsEnum_Result;
#ifdef __Fuchsia__
class WithErrorSyntax;
using WithErrorSyntaxPtr = ::fidl::InterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_Proxy;
class WithErrorSyntax_Stub;
class WithErrorSyntax_EventSender;
class WithErrorSyntax_Sync;
using WithErrorSyntaxSyncPtr = ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_SyncProxy;
#endif // __Fuchsia__

class WithErrorSyntax_ErrorAsPrimitive_Response  {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved = 0;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Response* value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Response* result) const;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Response& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Response& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& _value,
                         ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResponsePtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>;

class WithErrorSyntax_ErrorAsPrimitive_Result {
 public:
  WithErrorSyntax_ErrorAsPrimitive_Result();
  ~WithErrorSyntax_ErrorAsPrimitive_Result();

  WithErrorSyntax_ErrorAsPrimitive_Result(WithErrorSyntax_ErrorAsPrimitive_Result&&);
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(WithErrorSyntax_ErrorAsPrimitive_Result&&);

  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Result>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Result* _value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Result* result) const;

  bool has_invalid_tag() const { return Which() == Tag::Invalid; }

  bool is_response() const { return Which() == Tag(0); }
  
  WithErrorSyntax_ErrorAsPrimitive_Response& response() {
    if (!is_response()) {
      value_.emplace<0 + 1>();
    }
    return value_.template get<0 + 1>();
  }
  
  const WithErrorSyntax_ErrorAsPrimitive_Response& response() const { return value_.template get<0 + 1>(); }
  void set_response(WithErrorSyntax_ErrorAsPrimitive_Response value);

  bool is_err() const { return Which() == Tag(1); }
  
  uint32_t& err() {
    if (!is_err()) {
      value_.emplace<1 + 1>();
    }
    return value_.template get<1 + 1>();
  }
  
  const uint32_t& err() const { return value_.template get<1 + 1>(); }
  void set_err(uint32_t value);

  Tag Which() const {
    size_t index = value_.index();
    if (index == 0) {
      return Tag::Invalid;
    } else {
      return Tag(index - 1);
    }
  }

 private:
#ifdef FIDL_OPERATOR_EQUALS
  friend bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs);
#endif

  using Variant = fit::internal::variant<fit::internal::monostate, WithErrorSyntax_ErrorAsPrimitive_Response, uint32_t>;
  Variant value_;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result& value,
                         ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResultPtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>;

class WithErrorSyntax_ErrorAsEnum_Response  {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved = 0;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Response* result) const;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Response& _lhs, const WithErrorSyntax_ErrorAsEnum_Response& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsEnum_Response& _lhs, const WithErrorSyntax_ErrorAsEnum_Response& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsEnum_Response& _value,
                         ::test::name::WithErrorSyntax_ErrorAsEnum_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsEnum_ResponsePtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response>;
#ifdef __Fuchsia__

class KitchenSink {
 public:
  using Proxy_ = KitchenSink_Proxy;
  using Stub_ = KitchenSink_Stub;
  using EventSender_ = KitchenSink_EventSender;
  using Sync_ = KitchenSink_Sync;
  virtual ~KitchenSink();
      
  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback =
      fit::function<void(int64_t, int64_t)>;
  using MethodBCallback =
      fit::function<void(int64_t)>;
      
  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
};

class KitchenSink_EventSender {
 public:
  virtual ~KitchenSink_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class KitchenSink_Sync {
 public:
  using Proxy_ = KitchenSink_SyncProxy;
  virtual ~KitchenSink_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
};

class KitchenSink_Proxy : public ::fidl::internal::Proxy, public KitchenSink {
 public:
  explicit KitchenSink_Proxy(::fidl::internal::ProxyController* controller);
  ~KitchenSink_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;

 private:
  KitchenSink_Proxy(const KitchenSink_Proxy&) = delete;
  KitchenSink_Proxy& operator=(const KitchenSink_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class KitchenSink_Stub : public ::fidl::internal::Stub, public KitchenSink_EventSender {
 public:
  typedef class ::test::name::KitchenSink KitchenSink_clazz;
  explicit KitchenSink_Stub(KitchenSink_clazz* impl);
  ~KitchenSink_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  KitchenSink_clazz* impl_;
};

class KitchenSink_SyncProxy : public KitchenSink_Sync {
 public:
  explicit KitchenSink_SyncProxy(::zx::channel channel);
  ~KitchenSink_SyncProxy() override;
  zx_status_t MethodA(int64_t a, int64_t b) override;
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<KitchenSink>;
};
#endif // __Fuchsia__
#ifdef __Fuchsia__

class KitchenSink {
 public:
  using Proxy_ = KitchenSink_Proxy;
  using Stub_ = KitchenSink_Stub;
  using EventSender_ = KitchenSink_EventSender;
  using Sync_ = KitchenSink_Sync;
  virtual ~KitchenSink();
      
  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback =
      fit::function<void(int64_t, int64_t)>;
  using MethodBCallback =
      fit::function<void(int64_t)>;
      
  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
};

class KitchenSink_EventSender {
 public:
  virtual ~KitchenSink_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class KitchenSink_Sync {
 public:
  using Proxy_ = KitchenSink_SyncProxy;
  virtual ~KitchenSink_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
};

class KitchenSink_Proxy : public ::fidl::internal::Proxy, public KitchenSink {
 public:
  explicit KitchenSink_Proxy(::fidl::internal::ProxyController* controller);
  ~KitchenSink_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;

 private:
  KitchenSink_Proxy(const KitchenSink_Proxy&) = delete;
  KitchenSink_Proxy& operator=(const KitchenSink_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class KitchenSink_Stub : public ::fidl::internal::Stub, public KitchenSink_EventSender {
 public:
  typedef class ::test::name::KitchenSink KitchenSink_clazz;
  explicit KitchenSink_Stub(KitchenSink_clazz* impl);
  ~KitchenSink_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  KitchenSink_clazz* impl_;
};

class KitchenSink_SyncProxy : public KitchenSink_Sync {
 public:
  explicit KitchenSink_SyncProxy(::zx::channel channel);
  ~KitchenSink_SyncProxy() override;
  zx_status_t MethodA(int64_t a, int64_t b) override;
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<KitchenSink>;
};
#endif // __Fuchsia__
#ifdef __Fuchsia__

class ChannelProtocol {
 public:
  using Proxy_ = ChannelProtocol_Proxy;
  using Stub_ = ChannelProtocol_Stub;
  using EventSender_ = ChannelProtocol_EventSender;
  using Sync_ = ChannelProtocol_Sync;
  virtual ~ChannelProtocol();
      
  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback =
      fit::function<void(int64_t, int64_t)>;
  using MethodBCallback =
      fit::function<void(int64_t)>;
      
  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
};

class ChannelProtocol_EventSender {
 public:
  virtual ~ChannelProtocol_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class ChannelProtocol_Sync {
 public:
  using Proxy_ = ChannelProtocol_SyncProxy;
  virtual ~ChannelProtocol_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
};

class ChannelProtocol_Proxy : public ::fidl::internal::Proxy, public ChannelProtocol {
 public:
  explicit ChannelProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~ChannelProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;

 private:
  ChannelProtocol_Proxy(const ChannelProtocol_Proxy&) = delete;
  ChannelProtocol_Proxy& operator=(const ChannelProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class ChannelProtocol_Stub : public ::fidl::internal::Stub, public ChannelProtocol_EventSender {
 public:
  typedef class ::test::name::ChannelProtocol ChannelProtocol_clazz;
  explicit ChannelProtocol_Stub(ChannelProtocol_clazz* impl);
  ~ChannelProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  ChannelProtocol_clazz* impl_;
};

class ChannelProtocol_SyncProxy : public ChannelProtocol_Sync {
 public:
  explicit ChannelProtocol_SyncProxy(::zx::channel channel);
  ~ChannelProtocol_SyncProxy() override;
  zx_status_t MethodA(int64_t a, int64_t b) override;
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
};
#endif // __Fuchsia__
#ifdef __Fuchsia__

class SocketControlProtocol {
 public:
  using Proxy_ = SocketControlProtocol_Proxy;
  using Stub_ = SocketControlProtocol_Stub;
  using EventSender_ = SocketControlProtocol_EventSender;
  using Sync_ = SocketControlProtocol_Sync;
  virtual ~SocketControlProtocol();
      
  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback =
      fit::function<void(int64_t, int64_t)>;
  using MethodBCallback =
      fit::function<void(int64_t)>;
      
  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
};

class SocketControlProtocol_EventSender {
 public:
  virtual ~SocketControlProtocol_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class SocketControlProtocol_Sync {
 public:
  using Proxy_ = SocketControlProtocol_SyncProxy;
  virtual ~SocketControlProtocol_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
};

class SocketControlProtocol_Proxy : public ::fidl::internal::Proxy, public SocketControlProtocol {
 public:
  explicit SocketControlProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~SocketControlProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;

 private:
  SocketControlProtocol_Proxy(const SocketControlProtocol_Proxy&) = delete;
  SocketControlProtocol_Proxy& operator=(const SocketControlProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class SocketControlProtocol_Stub : public ::fidl::internal::Stub, public SocketControlProtocol_EventSender {
 public:
  typedef class ::test::name::SocketControlProtocol SocketControlProtocol_clazz;
  explicit SocketControlProtocol_Stub(SocketControlProtocol_clazz* impl);
  ~SocketControlProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  SocketControlProtocol_clazz* impl_;
};

class SocketControlProtocol_SyncProxy : public SocketControlProtocol_Sync {
 public:
  explicit SocketControlProtocol_SyncProxy(::zx::channel channel);
  ~SocketControlProtocol_SyncProxy() override;
  zx_status_t MethodA(int64_t a, int64_t b) override;
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<SocketControlProtocol>;
};
#endif // __Fuchsia__
#ifdef __Fuchsia__

class WithAndWithoutRequestResponse {
 public:
  using Proxy_ = WithAndWithoutRequestResponse_Proxy;
  using Stub_ = WithAndWithoutRequestResponse_Stub;
  using EventSender_ = WithAndWithoutRequestResponse_EventSender;
  using Sync_ = WithAndWithoutRequestResponse_Sync;
  virtual ~WithAndWithoutRequestResponse();
      
  virtual void NoRequestNoResponse() = 0;
  using NoRequestEmptyResponseCallback =
      fit::function<void()>;
      
  virtual void NoRequestEmptyResponse(NoRequestEmptyResponseCallback callback) = 0;
  using NoRequestWithResponseCallback =
      fit::function<void(::std::string)>;
      
  virtual void NoRequestWithResponse(NoRequestWithResponseCallback callback) = 0;
      
  virtual void WithRequestNoResponse(::std::string arg) = 0;
  using WithRequestEmptyResponseCallback =
      fit::function<void()>;
      
  virtual void WithRequestEmptyResponse(::std::string arg, WithRequestEmptyResponseCallback callback) = 0;
  using WithRequestWithResponseCallback =
      fit::function<void(::std::string)>;
      
  virtual void WithRequestWithResponse(::std::string arg, WithRequestWithResponseCallback callback) = 0;
  using OnEmptyResponseCallback =
      fit::function<void()>;
  using OnWithResponseCallback =
      fit::function<void(::std::string)>;
};

class WithAndWithoutRequestResponse_EventSender {
 public:
  virtual ~WithAndWithoutRequestResponse_EventSender();
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::std::string ret) = 0;
};

class WithAndWithoutRequestResponse_Sync {
 public:
  using Proxy_ = WithAndWithoutRequestResponse_SyncProxy;
  virtual ~WithAndWithoutRequestResponse_Sync();
  virtual zx_status_t NoRequestNoResponse() = 0;
  virtual zx_status_t NoRequestEmptyResponse() = 0;
  virtual zx_status_t NoRequestWithResponse(::std::string* out_ret) = 0;
  virtual zx_status_t WithRequestNoResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestEmptyResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestWithResponse(::std::string arg, ::std::string* out_ret) = 0;
};

class WithAndWithoutRequestResponse_Proxy : public ::fidl::internal::Proxy, public WithAndWithoutRequestResponse {
 public:
  explicit WithAndWithoutRequestResponse_Proxy(::fidl::internal::ProxyController* controller);
  ~WithAndWithoutRequestResponse_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void NoRequestNoResponse() override;
  void NoRequestEmptyResponse(NoRequestEmptyResponseCallback callback) override;
  void NoRequestWithResponse(NoRequestWithResponseCallback callback) override;
  void WithRequestNoResponse(::std::string arg) override;
  void WithRequestEmptyResponse(::std::string arg, WithRequestEmptyResponseCallback callback) override;
  void WithRequestWithResponse(::std::string arg, WithRequestWithResponseCallback callback) override;
  OnEmptyResponseCallback OnEmptyResponse;
  OnWithResponseCallback OnWithResponse;

 private:
  WithAndWithoutRequestResponse_Proxy(const WithAndWithoutRequestResponse_Proxy&) = delete;
  WithAndWithoutRequestResponse_Proxy& operator=(const WithAndWithoutRequestResponse_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithAndWithoutRequestResponse_Stub : public ::fidl::internal::Stub, public WithAndWithoutRequestResponse_EventSender {
 public:
  typedef class ::test::name::WithAndWithoutRequestResponse WithAndWithoutRequestResponse_clazz;
  explicit WithAndWithoutRequestResponse_Stub(WithAndWithoutRequestResponse_clazz* impl);
  ~WithAndWithoutRequestResponse_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;
  void OnEmptyResponse() override;
  void OnWithResponse(::std::string ret) override;

 private:
  WithAndWithoutRequestResponse_clazz* impl_;
};

class WithAndWithoutRequestResponse_SyncProxy : public WithAndWithoutRequestResponse_Sync {
 public:
  explicit WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel);
  ~WithAndWithoutRequestResponse_SyncProxy() override;
  zx_status_t NoRequestNoResponse() override;
  zx_status_t NoRequestEmptyResponse() override;
  zx_status_t NoRequestWithResponse(::std::string* out_ret) override;
  zx_status_t WithRequestNoResponse(::std::string arg) override;
  zx_status_t WithRequestEmptyResponse(::std::string arg) override;
  zx_status_t WithRequestWithResponse(::std::string arg, ::std::string* out_ret) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
};
#endif // __Fuchsia__

class WithErrorSyntax_ErrorAsEnum_Result {
 public:
  WithErrorSyntax_ErrorAsEnum_Result();
  ~WithErrorSyntax_ErrorAsEnum_Result();

  WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&&);
  WithErrorSyntax_ErrorAsEnum_Result& operator=(WithErrorSyntax_ErrorAsEnum_Result&&);

  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result> New() { return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Result>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Result* _value, size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Result* result) const;

  bool has_invalid_tag() const { return Which() == Tag::Invalid; }

  bool is_response() const { return Which() == Tag(0); }
  
  WithErrorSyntax_ErrorAsEnum_Response& response() {
    if (!is_response()) {
      value_.emplace<0 + 1>();
    }
    return value_.template get<0 + 1>();
  }
  
  const WithErrorSyntax_ErrorAsEnum_Response& response() const { return value_.template get<0 + 1>(); }
  void set_response(WithErrorSyntax_ErrorAsEnum_Response value);

  bool is_err() const { return Which() == Tag(1); }
  
  ErrorEnun& err() {
    if (!is_err()) {
      value_.emplace<1 + 1>();
    }
    return value_.template get<1 + 1>();
  }
  
  const ErrorEnun& err() const { return value_.template get<1 + 1>(); }
  void set_err(ErrorEnun value);

  Tag Which() const {
    size_t index = value_.index();
    if (index == 0) {
      return Tag::Invalid;
    } else {
      return Tag(index - 1);
    }
  }

 private:
#ifdef FIDL_OPERATOR_EQUALS
  friend bool operator==(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs);
#endif

  using Variant = fit::internal::variant<fit::internal::monostate, WithErrorSyntax_ErrorAsEnum_Response, ErrorEnun>;
  Variant value_;
};

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs);
inline bool operator!=(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs) {
  return !(_lhs == _rhs);
}
#endif

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsEnum_Result& value,
                         ::test::name::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsEnum_ResultPtr = ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result>;
#ifdef __Fuchsia__

class WithErrorSyntax {
 public:
  using Proxy_ = WithErrorSyntax_Proxy;
  using Stub_ = WithErrorSyntax_Stub;
  using EventSender_ = WithErrorSyntax_EventSender;
  using Sync_ = WithErrorSyntax_Sync;
  virtual ~WithErrorSyntax();
  using ErrorAsPrimitiveCallback =
      fit::function<void(WithErrorSyntax_ErrorAsPrimitive_Result)>;
      
  virtual void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) = 0;
  using ErrorAsEnumCallback =
      fit::function<void(WithErrorSyntax_ErrorAsEnum_Result)>;
      
  virtual void ErrorAsEnum(ErrorAsEnumCallback callback) = 0;
};

class WithErrorSyntax_EventSender {
 public:
  virtual ~WithErrorSyntax_EventSender();
};

class WithErrorSyntax_Sync {
 public:
  using Proxy_ = WithErrorSyntax_SyncProxy;
  virtual ~WithErrorSyntax_Sync();
  virtual zx_status_t ErrorAsPrimitive(WithErrorSyntax_ErrorAsPrimitive_Result* out_result) = 0;
  virtual zx_status_t ErrorAsEnum(WithErrorSyntax_ErrorAsEnum_Result* out_result) = 0;
};

class WithErrorSyntax_Proxy : public ::fidl::internal::Proxy, public WithErrorSyntax {
 public:
  explicit WithErrorSyntax_Proxy(::fidl::internal::ProxyController* controller);
  ~WithErrorSyntax_Proxy() override;

  zx_status_t Dispatch_(::fidl::Message message) override;
  void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) override;
  void ErrorAsEnum(ErrorAsEnumCallback callback) override;

 private:
  WithErrorSyntax_Proxy(const WithErrorSyntax_Proxy&) = delete;
  WithErrorSyntax_Proxy& operator=(const WithErrorSyntax_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithErrorSyntax_Stub : public ::fidl::internal::Stub, public WithErrorSyntax_EventSender {
 public:
  typedef class ::test::name::WithErrorSyntax WithErrorSyntax_clazz;
  explicit WithErrorSyntax_Stub(WithErrorSyntax_clazz* impl);
  ~WithErrorSyntax_Stub() override;

  zx_status_t Dispatch_(::fidl::Message message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  WithErrorSyntax_clazz* impl_;
};

class WithErrorSyntax_SyncProxy : public WithErrorSyntax_Sync {
 public:
  explicit WithErrorSyntax_SyncProxy(::zx::channel channel);
  ~WithErrorSyntax_SyncProxy() override;
  zx_status_t ErrorAsPrimitive(WithErrorSyntax_ErrorAsPrimitive_Result* out_result) override;
  zx_status_t ErrorAsEnum(WithErrorSyntax_ErrorAsEnum_Result* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
};
#endif // __Fuchsia__
}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public EncodableCodingTraits<::test::name::WithErrorSyntax_ErrorAsPrimitive_Response, 1> {};

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& value,
                         ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::WithErrorSyntax_ErrorAsPrimitive_Response> {
  static inline bool Equals(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Response& _rhs) {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::name::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public EncodableCodingTraits<::test::name::WithErrorSyntax_ErrorAsPrimitive_Result, 8> {};

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result& value,
                         ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::WithErrorSyntax_ErrorAsPrimitive_Result> {
  static inline bool Equals(const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result& _rhs) {
    if (_lhs.Which() != _rhs.Which()) {
      return false;
    }
    switch (_lhs.Which()) {
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kResponse:
	return ::fidl::Equals(_lhs.response(), _rhs.response());
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
	return ::fidl::Equals(_lhs.err(), _rhs.err());
      case ::test::name::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::Invalid:
	return true;
      default:
	return false;
    }
  }
};
template <>
struct CodingTraits<::test::name::WithErrorSyntax_ErrorAsEnum_Response>
    : public EncodableCodingTraits<::test::name::WithErrorSyntax_ErrorAsEnum_Response, 1> {};

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsEnum_Response& value,
                         ::test::name::WithErrorSyntax_ErrorAsEnum_Response* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::WithErrorSyntax_ErrorAsEnum_Response> {
  static inline bool Equals(const ::test::name::WithErrorSyntax_ErrorAsEnum_Response& _lhs, const ::test::name::WithErrorSyntax_ErrorAsEnum_Response& _rhs) {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::name::ErrorEnun> {
  static constexpr size_t encoded_size = sizeof(::test::name::ErrorEnun);
  static void Encode(Encoder* encoder, ::test::name::ErrorEnun* value, size_t offset) {
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::name::ErrorEnun* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::name::ErrorEnun>(underlying);
  }
};

inline zx_status_t Clone(::test::name::ErrorEnun value,
                         ::test::name::ErrorEnun* result) {
  return ::test::name::Clone(value, result);
}
template<>
struct Equality<::test::name::ErrorEnun> {
  static inline bool Equals(const ::test::name::ErrorEnun& _lhs, const ::test::name::ErrorEnun& _rhs) {
    return _lhs == _rhs;
  }
};


template <>
struct CodingTraits<::test::name::WithErrorSyntax_ErrorAsEnum_Result>
    : public EncodableCodingTraits<::test::name::WithErrorSyntax_ErrorAsEnum_Result, 8> {};

inline zx_status_t Clone(const ::test::name::WithErrorSyntax_ErrorAsEnum_Result& value,
                         ::test::name::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return ::test::name::Clone(value, result);
}

template<>
struct Equality<::test::name::WithErrorSyntax_ErrorAsEnum_Result> {
  static inline bool Equals(const ::test::name::WithErrorSyntax_ErrorAsEnum_Result& _lhs, const ::test::name::WithErrorSyntax_ErrorAsEnum_Result& _rhs) {
    if (_lhs.Which() != _rhs.Which()) {
      return false;
    }
    switch (_lhs.Which()) {
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
	return ::fidl::Equals(_lhs.response(), _rhs.response());
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
	return ::fidl::Equals(_lhs.err(), _rhs.err());
      case ::test::name::WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid:
	return true;
      default:
	return false;
    }
  }
};}  // namespace fidl

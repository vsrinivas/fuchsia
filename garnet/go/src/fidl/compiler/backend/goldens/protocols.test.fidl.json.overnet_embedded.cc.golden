// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.fidl.json.overnet_embedded.h>

#include "src/connectivity/overnet/lib/embedded/implementation.h"
namespace test {
namespace name {
namespace embedded {

extern "C" const fidl_type_t test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Response::FidlType = &test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

void WithErrorSyntax_ErrorAsPrimitive_Response::Encode(::overnet::internal::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &__reserved, _offset + 0);
}

void WithErrorSyntax_ErrorAsPrimitive_Response::Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Response* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->__reserved, _offset + 0);
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Response::Clone(WithErrorSyntax_ErrorAsPrimitive_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Response& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Response& _rhs) {
  if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
    return false;
  }
  return true;
}
#endif
WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result() : value_() {}

WithErrorSyntax_ErrorAsPrimitive_Result::~WithErrorSyntax_ErrorAsPrimitive_Result() {
}

WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result(WithErrorSyntax_ErrorAsPrimitive_Result&& other) : value_(std::move(other.value_)) {
}

WithErrorSyntax_ErrorAsPrimitive_Result& WithErrorSyntax_ErrorAsPrimitive_Result::operator=(WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Encode(::overnet::internal::Encoder* _encoder, size_t _offset) {
  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &response(), _offset + 4);
    break;
   case 1:
    ::fidl::Encode(_encoder, &err(), _offset + 4);
    break;
   default:
    break;
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Result* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      WithErrorSyntax_ErrorAsPrimitive_Response _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_response(std::move(_member));
      break;
    }
   case 1:
    {
      uint32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_err(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Result::Clone(WithErrorSyntax_ErrorAsPrimitive_Result* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kResponse:
      {
        WithErrorSyntax_ErrorAsPrimitive_Response _member{};
        _status = ::fidl::Clone(response(), &_member);
        if (_status == ZX_OK) {
          _result->set_response(std::move(_member));
        }
      }
      break;
    case Tag::kErr:
      {
        uint32_t _member{};
        _status = ::fidl::Clone(err(), &_member);
        if (_status == ZX_OK) {
          _result->set_err(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsPrimitive_Result& _lhs, const WithErrorSyntax_ErrorAsPrimitive_Result& _rhs) {
  if (_lhs.Which() != _rhs.Which()) {
    return false;
  }
  switch (_lhs.Which()) {
    case WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kResponse:
      return ::fidl::Equals(_lhs.response(), _rhs.response());
    case WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
      return ::fidl::Equals(_lhs.err(), _rhs.err());
    case WithErrorSyntax_ErrorAsPrimitive_Result::Tag::Invalid:
      return true;
    default:
      return false;
  }
}
#endif

void WithErrorSyntax_ErrorAsPrimitive_Result::set_response(WithErrorSyntax_ErrorAsPrimitive_Response value) {
  value_.emplace<static_cast<size_t>(Tag::kResponse) + 1>(std::move(value));
}

void WithErrorSyntax_ErrorAsPrimitive_Result::set_err(uint32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kErr) + 1>(std::move(value));
}
extern "C" const fidl_type_t test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Response::FidlType = &test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;

void WithErrorSyntax_ErrorAsEnum_Response::Encode(::overnet::internal::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &__reserved, _offset + 0);
}

void WithErrorSyntax_ErrorAsEnum_Response::Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->__reserved, _offset + 0);
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Response::Clone(WithErrorSyntax_ErrorAsEnum_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Response& _lhs, const WithErrorSyntax_ErrorAsEnum_Response& _rhs) {
  if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
    return false;
  }
  return true;
}
#endif
WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() : value_() {}

WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
}

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&& other) : value_(std::move(other.value_)) {
}

WithErrorSyntax_ErrorAsEnum_Result& WithErrorSyntax_ErrorAsEnum_Result::operator=(WithErrorSyntax_ErrorAsEnum_Result&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void WithErrorSyntax_ErrorAsEnum_Result::Encode(::overnet::internal::Encoder* _encoder, size_t _offset) {
  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &response(), _offset + 4);
    break;
   case 1:
    ::fidl::Encode(_encoder, &err(), _offset + 4);
    break;
   default:
    break;
  }
}

void WithErrorSyntax_ErrorAsEnum_Result::Decode(::overnet::internal::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Result* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      WithErrorSyntax_ErrorAsEnum_Response _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_response(std::move(_member));
      break;
    }
   case 1:
    {
      ErrorEnun _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_err(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Result::Clone(WithErrorSyntax_ErrorAsEnum_Result* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kResponse:
      {
        WithErrorSyntax_ErrorAsEnum_Response _member{};
        _status = ::fidl::Clone(response(), &_member);
        if (_status == ZX_OK) {
          _result->set_response(std::move(_member));
        }
      }
      break;
    case Tag::kErr:
      {
        ErrorEnun _member{};
        _status = ::fidl::Clone(err(), &_member);
        if (_status == ZX_OK) {
          _result->set_err(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

#ifdef FIDL_OPERATOR_EQUALS
bool operator==(const WithErrorSyntax_ErrorAsEnum_Result& _lhs, const WithErrorSyntax_ErrorAsEnum_Result& _rhs) {
  if (_lhs.Which() != _rhs.Which()) {
    return false;
  }
  switch (_lhs.Which()) {
    case WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
      return ::fidl::Equals(_lhs.response(), _rhs.response());
    case WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
      return ::fidl::Equals(_lhs.err(), _rhs.err());
    case WithErrorSyntax_ErrorAsEnum_Result::Tag::Invalid:
      return true;
    default:
      return false;
  }
}
#endif

void WithErrorSyntax_ErrorAsEnum_Result::set_response(WithErrorSyntax_ErrorAsEnum_Response value) {
  value_.emplace<static_cast<size_t>(Tag::kResponse) + 1>(std::move(value));
}

void WithErrorSyntax_ErrorAsEnum_Result::set_err(ErrorEnun value) {
  value_.emplace<static_cast<size_t>(Tag::kErr) + 1>(std::move(value));
}

}  // namespace embedded
}  // namespace name
}  // namespace test

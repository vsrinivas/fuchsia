// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

#[link(name = "crypto")]
extern "C" {}

/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const OPENSSL_VERSION_NUMBER: u32 = 269488255;
pub const SSLEAY_VERSION_NUMBER: u32 = 269488255;
pub const EVP_AEAD_MAX_KEY_LENGTH: u32 = 80;
pub const EVP_AEAD_MAX_NONCE_LENGTH: u32 = 24;
pub const EVP_AEAD_MAX_OVERHEAD: u32 = 64;
pub const EVP_AEAD_DEFAULT_TAG_LENGTH: u32 = 0;
pub const AES_ENCRYPT: u32 = 1;
pub const AES_DECRYPT: u32 = 0;
pub const AES_MAXNR: u32 = 14;
pub const AES_BLOCK_SIZE: u32 = 16;
pub const ERR_FLAG_STRING: u32 = 1;
pub const ERR_FLAG_MALLOCED: u32 = 2;
pub const ERR_R_FATAL: u32 = 64;
pub const ERR_R_MALLOC_FAILURE: u32 = 65;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED: u32 = 66;
pub const ERR_R_PASSED_NULL_PARAMETER: u32 = 67;
pub const ERR_R_INTERNAL_ERROR: u32 = 68;
pub const ERR_R_OVERFLOW: u32 = 69;
pub const ERR_ERROR_STRING_BUF_LEN: u32 = 120;
pub const ERR_TXT_STRING: u32 = 1;
pub const ERR_TXT_MALLOCED: u32 = 2;
pub const ERR_NUM_ERRORS: u32 = 16;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_PROXY_CLIENT: u32 = 526;
pub const BIO_TYPE_PROXY_SERVER: u32 = 527;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BER: u32 = 530;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_TYPE_START: u32 = 128;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_PROXY_PARAM: u32 = 103;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_GET_SSL: u32 = 110;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_GET_PROXY_PARAM: u32 = 121;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES: u32 = 125;
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES: u32 = 126;
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT: u32 = 127;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 100;
pub const BIO_R_BROKEN_PIPE: u32 = 101;
pub const BIO_R_CONNECT_ERROR: u32 = 102;
pub const BIO_R_ERROR_SETTING_NBIO: u32 = 103;
pub const BIO_R_INVALID_ARGUMENT: u32 = 104;
pub const BIO_R_IN_USE: u32 = 105;
pub const BIO_R_KEEPALIVE: u32 = 106;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 107;
pub const BIO_R_NO_HOSTNAME_SPECIFIED: u32 = 108;
pub const BIO_R_NO_PORT_SPECIFIED: u32 = 109;
pub const BIO_R_NO_SUCH_FILE: u32 = 110;
pub const BIO_R_NULL_PARAMETER: u32 = 111;
pub const BIO_R_SYS_LIB: u32 = 112;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 113;
pub const BIO_R_UNINITIALIZED: u32 = 114;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 115;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 116;
pub const BN_BITS2: u32 = 64;
pub const BN_DEC_FMT1: &[u8; 2usize] = b"%\0";
pub const BN_DEC_FMT2: &[u8; 5usize] = b"%019\0";
pub const BN_HEX_FMT1: &[u8; 2usize] = b"%\0";
pub const BN_HEX_FMT2: &[u8; 5usize] = b"%016\0";
pub const BN_RAND_TOP_ANY: i32 = -1;
pub const BN_RAND_TOP_ONE: u32 = 0;
pub const BN_RAND_TOP_TWO: u32 = 1;
pub const BN_RAND_BOTTOM_ANY: u32 = 0;
pub const BN_RAND_BOTTOM_ODD: u32 = 1;
pub const BN_GENCB_GENERATED: u32 = 0;
pub const BN_GENCB_PRIME_TEST: u32 = 1;
pub const BN_prime_checks_for_validation: u32 = 64;
pub const BN_prime_checks_for_generation: u32 = 0;
pub const BN_prime_checks: u32 = 64;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 102;
pub const BN_R_BITS_TOO_SMALL: u32 = 103;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 104;
pub const BN_R_DIV_BY_ZERO: u32 = 105;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 106;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 107;
pub const BN_R_INVALID_RANGE: u32 = 108;
pub const BN_R_NEGATIVE_NUMBER: u32 = 109;
pub const BN_R_NOT_A_SQUARE: u32 = 110;
pub const BN_R_NOT_INITIALIZED: u32 = 111;
pub const BN_R_NO_INVERSE: u32 = 112;
pub const BN_R_PRIVATE_KEY_TOO_LARGE: u32 = 113;
pub const BN_R_P_IS_NOT_PRIME: u32 = 114;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 115;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 116;
pub const BN_R_BAD_ENCODING: u32 = 117;
pub const BN_R_ENCODE_ERROR: u32 = 118;
pub const BN_R_INVALID_INPUT: u32 = 119;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_MAX_UNIVERSAL: u32 = 255;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const B_ASN1_TIME: u32 = 49152;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const ASN1_R_ASN1_LENGTH_MISMATCH: u32 = 100;
pub const ASN1_R_AUX_ERROR: u32 = 101;
pub const ASN1_R_BAD_GET_ASN1_OBJECT_CALL: u32 = 102;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 103;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 104;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 108;
pub const ASN1_R_DECODE_ERROR: u32 = 109;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 110;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 111;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 113;
pub const ASN1_R_EXPECTING_AN_ASN1_SEQUENCE: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPECTING_A_BOOLEAN: u32 = 117;
pub const ASN1_R_EXPECTING_A_TIME: u32 = 118;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 124;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 125;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 126;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 127;
pub const ASN1_R_ILLEGAL_HEX: u32 = 128;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 129;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 130;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 131;
pub const ASN1_R_ILLEGAL_NULL: u32 = 132;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 133;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 134;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 135;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 136;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 137;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 138;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 139;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 140;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 141;
pub const ASN1_R_INVALID_BMPSTRING: u32 = 142;
pub const ASN1_R_INVALID_DIGIT: u32 = 143;
pub const ASN1_R_INVALID_MODIFIER: u32 = 144;
pub const ASN1_R_INVALID_NUMBER: u32 = 145;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 146;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 147;
pub const ASN1_R_INVALID_TIME_FORMAT: u32 = 148;
pub const ASN1_R_INVALID_UNIVERSALSTRING: u32 = 149;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 150;
pub const ASN1_R_LIST_ERROR: u32 = 151;
pub const ASN1_R_MISSING_ASN1_EOS: u32 = 152;
pub const ASN1_R_MISSING_EOC: u32 = 153;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 154;
pub const ASN1_R_MISSING_VALUE: u32 = 155;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 156;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 157;
pub const ASN1_R_NESTED_ASN1_ERROR: u32 = 158;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 159;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 160;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 161;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 162;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 163;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 164;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 165;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 166;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 167;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 168;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 169;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 170;
pub const ASN1_R_SHORT_LINE: u32 = 171;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 172;
pub const ASN1_R_STRING_TOO_LONG: u32 = 173;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 174;
pub const ASN1_R_TAG_VALUE_TOO_HIGH: u32 = 175;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 176;
pub const ASN1_R_TOO_LONG: u32 = 177;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 178;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 179;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 180;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 181;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 182;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 183;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 184;
pub const ASN1_R_UNKNOWN_TAG: u32 = 185;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 186;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 187;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 188;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 189;
pub const ASN1_R_WRONG_TAG: u32 = 190;
pub const ASN1_R_WRONG_TYPE: u32 = 191;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 192;
pub const ASN1_R_BAD_TEMPLATE: u32 = 193;
pub const ASN1_R_INVALID_BIT_STRING_PADDING: u32 = 194;
pub const ASN1_TFLG_OPTIONAL: u32 = 1;
pub const ASN1_TFLG_SET_OF: u32 = 2;
pub const ASN1_TFLG_SEQUENCE_OF: u32 = 4;
pub const ASN1_TFLG_SK_MASK: u32 = 6;
pub const ASN1_TFLG_IMPTAG: u32 = 8;
pub const ASN1_TFLG_EXPTAG: u32 = 16;
pub const ASN1_TFLG_TAG_MASK: u32 = 24;
pub const ASN1_TFLG_UNIVERSAL: u32 = 0;
pub const ASN1_TFLG_APPLICATION: u32 = 64;
pub const ASN1_TFLG_CONTEXT: u32 = 128;
pub const ASN1_TFLG_PRIVATE: u32 = 192;
pub const ASN1_TFLG_TAG_CLASS: u32 = 192;
pub const ASN1_TFLG_ADB_MASK: u32 = 768;
pub const ASN1_TFLG_ADB_OID: u32 = 256;
pub const ASN1_TFLG_ADB_INT: u32 = 512;
pub const ASN1_TFLG_COMBINE: u32 = 1024;
pub const ASN1_ITYPE_PRIMITIVE: u32 = 0;
pub const ASN1_ITYPE_SEQUENCE: u32 = 1;
pub const ASN1_ITYPE_CHOICE: u32 = 2;
pub const ASN1_ITYPE_EXTERN: u32 = 4;
pub const ASN1_ITYPE_MSTRING: u32 = 5;
pub const ASN1_AFLG_REFCOUNT: u32 = 1;
pub const ASN1_AFLG_ENCODING: u32 = 2;
pub const ASN1_OP_NEW_PRE: u32 = 0;
pub const ASN1_OP_NEW_POST: u32 = 1;
pub const ASN1_OP_FREE_PRE: u32 = 2;
pub const ASN1_OP_FREE_POST: u32 = 3;
pub const ASN1_OP_D2I_PRE: u32 = 4;
pub const ASN1_OP_D2I_POST: u32 = 5;
pub const ASN1_OP_PRINT_PRE: u32 = 8;
pub const ASN1_OP_PRINT_POST: u32 = 9;
pub const ASN1_OP_STREAM_PRE: u32 = 10;
pub const ASN1_OP_STREAM_POST: u32 = 11;
pub const ASN1_OP_DETACHED_PRE: u32 = 12;
pub const ASN1_OP_DETACHED_POST: u32 = 13;
pub const CBS_ASN1_TAG_SHIFT: u32 = 24;
pub const CBS_ASN1_CONSTRUCTED: u32 = 536870912;
pub const CBS_ASN1_UNIVERSAL: u32 = 0;
pub const CBS_ASN1_APPLICATION: u32 = 1073741824;
pub const CBS_ASN1_CONTEXT_SPECIFIC: u32 = 2147483648;
pub const CBS_ASN1_PRIVATE: u32 = 3221225472;
pub const CBS_ASN1_CLASS_MASK: u32 = 3221225472;
pub const CBS_ASN1_TAG_NUMBER_MASK: u32 = 536870911;
pub const CBS_ASN1_BOOLEAN: u32 = 1;
pub const CBS_ASN1_INTEGER: u32 = 2;
pub const CBS_ASN1_BITSTRING: u32 = 3;
pub const CBS_ASN1_OCTETSTRING: u32 = 4;
pub const CBS_ASN1_NULL: u32 = 5;
pub const CBS_ASN1_OBJECT: u32 = 6;
pub const CBS_ASN1_ENUMERATED: u32 = 10;
pub const CBS_ASN1_UTF8STRING: u32 = 12;
pub const CBS_ASN1_SEQUENCE: u32 = 536870928;
pub const CBS_ASN1_SET: u32 = 536870929;
pub const CBS_ASN1_NUMERICSTRING: u32 = 18;
pub const CBS_ASN1_PRINTABLESTRING: u32 = 19;
pub const CBS_ASN1_T61STRING: u32 = 20;
pub const CBS_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const CBS_ASN1_IA5STRING: u32 = 22;
pub const CBS_ASN1_UTCTIME: u32 = 23;
pub const CBS_ASN1_GENERALIZEDTIME: u32 = 24;
pub const CBS_ASN1_GRAPHICSTRING: u32 = 25;
pub const CBS_ASN1_VISIBLESTRING: u32 = 26;
pub const CBS_ASN1_GENERALSTRING: u32 = 27;
pub const CBS_ASN1_UNIVERSALSTRING: u32 = 28;
pub const CBS_ASN1_BMPSTRING: u32 = 30;
pub const CAST_ENCRYPT: u32 = 1;
pub const CAST_DECRYPT: u32 = 0;
pub const CAST_BLOCK: u32 = 8;
pub const CAST_KEY_LENGTH: u32 = 16;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_XTS_MODE: u32 = 7;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 64;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 128;
pub const EVP_CIPH_CUSTOM_IV: u32 = 256;
pub const EVP_CIPH_CTRL_INIT: u32 = 512;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1024;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2048;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 4096;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const EVP_CIPH_CCM_MODE: i32 = -1;
pub const EVP_CIPH_OCB_MODE: i32 = -2;
pub const EVP_CIPH_WRAP_MODE: i32 = -3;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 0;
pub const EVP_CIPH_NO_PADDING: u32 = 2048;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_AEAD_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_AEAD_GET_TAG: u32 = 16;
pub const EVP_CTRL_AEAD_SET_TAG: u32 = 17;
pub const EVP_CTRL_AEAD_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const CIPHER_R_AES_KEY_SETUP_FAILED: u32 = 100;
pub const CIPHER_R_BAD_DECRYPT: u32 = 101;
pub const CIPHER_R_BAD_KEY_LENGTH: u32 = 102;
pub const CIPHER_R_BUFFER_TOO_SMALL: u32 = 103;
pub const CIPHER_R_CTRL_NOT_IMPLEMENTED: u32 = 104;
pub const CIPHER_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 105;
pub const CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 106;
pub const CIPHER_R_INITIALIZATION_ERROR: u32 = 107;
pub const CIPHER_R_INPUT_NOT_INITIALIZED: u32 = 108;
pub const CIPHER_R_INVALID_AD_SIZE: u32 = 109;
pub const CIPHER_R_INVALID_KEY_LENGTH: u32 = 110;
pub const CIPHER_R_INVALID_NONCE_SIZE: u32 = 111;
pub const CIPHER_R_INVALID_OPERATION: u32 = 112;
pub const CIPHER_R_IV_TOO_LARGE: u32 = 113;
pub const CIPHER_R_NO_CIPHER_SET: u32 = 114;
pub const CIPHER_R_OUTPUT_ALIASES_INPUT: u32 = 115;
pub const CIPHER_R_TAG_TOO_LARGE: u32 = 116;
pub const CIPHER_R_TOO_LARGE: u32 = 117;
pub const CIPHER_R_UNSUPPORTED_AD_SIZE: u32 = 118;
pub const CIPHER_R_UNSUPPORTED_INPUT_SIZE: u32 = 119;
pub const CIPHER_R_UNSUPPORTED_KEY_SIZE: u32 = 120;
pub const CIPHER_R_UNSUPPORTED_NONCE_SIZE: u32 = 121;
pub const CIPHER_R_UNSUPPORTED_TAG_SIZE: u32 = 122;
pub const CIPHER_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 123;
pub const CIPHER_R_NO_DIRECTION_SET: u32 = 124;
pub const CIPHER_R_INVALID_NONCE: u32 = 125;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA224_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_CBLOCK: u32 = 128;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_CBLOCK: u32 = 128;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_256_DIGEST_LENGTH: u32 = 32;
pub const RAND_MAX: u32 = 2147483647;
pub const OPENSSL_VERSION_TEXT: &[u8; 38usize] = b"OpenSSL 1.1.1 (compatible; BoringSSL)\0";
pub const OPENSSL_VERSION: u32 = 0;
pub const OPENSSL_CFLAGS: u32 = 1;
pub const OPENSSL_BUILT_ON: u32 = 2;
pub const OPENSSL_PLATFORM: u32 = 3;
pub const OPENSSL_DIR: u32 = 4;
pub const SSLEAY_VERSION: u32 = 0;
pub const SSLEAY_CFLAGS: u32 = 1;
pub const SSLEAY_BUILT_ON: u32 = 2;
pub const SSLEAY_PLATFORM: u32 = 3;
pub const SSLEAY_DIR: u32 = 4;
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS: u32 = 0;
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS: u32 = 0;
pub const OPENSSL_INIT_ADD_ALL_CIPHERS: u32 = 0;
pub const OPENSSL_INIT_ADD_ALL_DIGESTS: u32 = 0;
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS: u32 = 0;
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS: u32 = 0;
pub const OPENSSL_INIT_LOAD_CONFIG: u32 = 0;
pub const OPENSSL_INIT_NO_LOAD_CONFIG: u32 = 0;
pub const X25519_PRIVATE_KEY_LEN: u32 = 32;
pub const X25519_PUBLIC_VALUE_LEN: u32 = 32;
pub const X25519_SHARED_KEY_LEN: u32 = 32;
pub const ED25519_PRIVATE_KEY_LEN: u32 = 64;
pub const ED25519_PUBLIC_KEY_LEN: u32 = 32;
pub const ED25519_SIGNATURE_LEN: u32 = 64;
pub const DES_ENCRYPT: u32 = 1;
pub const DES_DECRYPT: u32 = 0;
pub const DES_CBC_MODE: u32 = 0;
pub const DES_PCBC_MODE: u32 = 1;
pub const DH_GENERATOR_2: u32 = 2;
pub const DH_GENERATOR_5: u32 = 5;
pub const DH_CHECK_P_NOT_PRIME: u32 = 1;
pub const DH_CHECK_P_NOT_SAFE_PRIME: u32 = 2;
pub const DH_CHECK_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_CHECK_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_CHECK_Q_NOT_PRIME: u32 = 16;
pub const DH_CHECK_INVALID_Q_VALUE: u32 = 32;
pub const DH_CHECK_INVALID_J_VALUE: u32 = 64;
pub const DH_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_CHECK_PUBKEY_TOO_SMALL: u32 = 1;
pub const DH_CHECK_PUBKEY_TOO_LARGE: u32 = 2;
pub const DH_CHECK_PUBKEY_INVALID: u32 = 4;
pub const DH_R_BAD_GENERATOR: u32 = 100;
pub const DH_R_INVALID_PUBKEY: u32 = 101;
pub const DH_R_MODULUS_TOO_LARGE: u32 = 102;
pub const DH_R_NO_PRIVATE_VALUE: u32 = 103;
pub const DH_R_DECODE_ERROR: u32 = 104;
pub const DH_R_ENCODE_ERROR: u32 = 105;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_MD_BLOCK_SIZE: u32 = 128;
pub const EVP_MD_FLAG_PKEY_DIGEST: u32 = 1;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 2;
pub const EVP_MD_FLAG_XOF: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const DIGEST_R_INPUT_NOT_INITIALIZED: u32 = 100;
pub const DIGEST_R_DECODE_ERROR: u32 = 101;
pub const DIGEST_R_UNKNOWN_HASH: u32 = 102;
pub const DSA_R_BAD_Q_VALUE: u32 = 100;
pub const DSA_R_MISSING_PARAMETERS: u32 = 101;
pub const DSA_R_MODULUS_TOO_LARGE: u32 = 102;
pub const DSA_R_NEED_NEW_SETUP_VALUES: u32 = 103;
pub const DSA_R_BAD_VERSION: u32 = 104;
pub const DSA_R_DECODE_ERROR: u32 = 105;
pub const DSA_R_ENCODE_ERROR: u32 = 106;
pub const DSA_R_INVALID_PARAMETERS: u32 = 107;
pub const OPENSSL_EC_EXPLICIT_CURVE: u32 = 0;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 101;
pub const EC_R_D2I_ECPKPARAMETERS_FAILURE: u32 = 102;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 103;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 104;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 105;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 106;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 107;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 108;
pub const EC_R_INVALID_ENCODING: u32 = 109;
pub const EC_R_INVALID_FIELD: u32 = 110;
pub const EC_R_INVALID_FORM: u32 = 111;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 112;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 113;
pub const EC_R_MISSING_PARAMETERS: u32 = 114;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 115;
pub const EC_R_NON_NAMED_CURVE: u32 = 116;
pub const EC_R_NOT_INITIALIZED: u32 = 117;
pub const EC_R_PKPARAMETERS2GROUP_FAILURE: u32 = 118;
pub const EC_R_POINT_AT_INFINITY: u32 = 119;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 120;
pub const EC_R_SLOT_FULL: u32 = 121;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 122;
pub const EC_R_UNKNOWN_GROUP: u32 = 123;
pub const EC_R_UNKNOWN_ORDER: u32 = 124;
pub const EC_R_WRONG_ORDER: u32 = 125;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 126;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 127;
pub const EC_R_DECODE_ERROR: u32 = 128;
pub const EC_R_ENCODE_ERROR: u32 = 129;
pub const EC_R_GROUP_MISMATCH: u32 = 130;
pub const EC_R_INVALID_COFACTOR: u32 = 131;
pub const EC_R_PUBLIC_KEY_VALIDATION_FAILED: u32 = 132;
pub const EC_R_INVALID_SCALAR: u32 = 133;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const ECDSA_FLAG_OPAQUE: u32 = 1;
pub const ECDH_R_KDF_FAILED: u32 = 100;
pub const ECDH_R_NO_PRIVATE_VALUE: u32 = 101;
pub const ECDH_R_POINT_ARITHMETIC_FAILURE: u32 = 102;
pub const ECDH_R_UNKNOWN_DIGEST_LENGTH: u32 = 103;
pub const ECDSA_R_BAD_SIGNATURE: u32 = 100;
pub const ECDSA_R_MISSING_PARAMETERS: u32 = 101;
pub const ECDSA_R_NEED_NEW_SETUP_VALUES: u32 = 102;
pub const ECDSA_R_NOT_IMPLEMENTED: u32 = 103;
pub const ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 104;
pub const ECDSA_R_ENCODE_ERROR: u32 = 105;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 101;
pub const EVP_R_DECODE_ERROR: u32 = 102;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 103;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 104;
pub const EVP_R_ENCODE_ERROR: u32 = 105;
pub const EVP_R_EXPECTING_AN_EC_KEY_KEY: u32 = 106;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 107;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 108;
pub const EVP_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE: u32 = 109;
pub const EVP_R_INVALID_DIGEST_LENGTH: u32 = 110;
pub const EVP_R_INVALID_DIGEST_TYPE: u32 = 111;
pub const EVP_R_INVALID_KEYBITS: u32 = 112;
pub const EVP_R_INVALID_MGF1_MD: u32 = 113;
pub const EVP_R_INVALID_OPERATION: u32 = 114;
pub const EVP_R_INVALID_PADDING_MODE: u32 = 115;
pub const EVP_R_INVALID_PSS_SALTLEN: u32 = 116;
pub const EVP_R_KEYS_NOT_SET: u32 = 117;
pub const EVP_R_MISSING_PARAMETERS: u32 = 118;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 119;
pub const EVP_R_NO_KEY_SET: u32 = 120;
pub const EVP_R_NO_MDC2_SUPPORT: u32 = 121;
pub const EVP_R_NO_NID_FOR_CURVE: u32 = 122;
pub const EVP_R_NO_OPERATION_SET: u32 = 123;
pub const EVP_R_NO_PARAMETERS_SET: u32 = 124;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 125;
pub const EVP_R_OPERATON_NOT_INITIALIZED: u32 = 126;
pub const EVP_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 127;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 128;
pub const EVP_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 129;
pub const EVP_R_NOT_A_PRIVATE_KEY: u32 = 130;
pub const EVP_R_INVALID_SIGNATURE: u32 = 131;
pub const EVP_R_MEMORY_LIMIT_EXCEEDED: u32 = 132;
pub const EVP_R_INVALID_PARAMETERS: u32 = 133;
pub const EVP_R_INVALID_PEER_KEY: u32 = 134;
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH: u32 = 135;
pub const EVP_R_EMPTY_PSK: u32 = 136;
pub const EVP_R_INVALID_BUFFER_SIZE: u32 = 137;
pub const NID_undef: u32 = 0;
pub const NID_rsadsi: u32 = 1;
pub const NID_pkcs: u32 = 2;
pub const NID_md2: u32 = 3;
pub const NID_md5: u32 = 4;
pub const NID_rc4: u32 = 5;
pub const NID_rsaEncryption: u32 = 6;
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const NID_X500: u32 = 11;
pub const NID_X509: u32 = 12;
pub const NID_commonName: u32 = 13;
pub const NID_countryName: u32 = 14;
pub const NID_localityName: u32 = 15;
pub const NID_stateOrProvinceName: u32 = 16;
pub const NID_organizationName: u32 = 17;
pub const NID_organizationalUnitName: u32 = 18;
pub const NID_rsa: u32 = 19;
pub const NID_pkcs7: u32 = 20;
pub const NID_pkcs7_data: u32 = 21;
pub const NID_pkcs7_signed: u32 = 22;
pub const NID_pkcs7_enveloped: u32 = 23;
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const NID_pkcs7_digest: u32 = 25;
pub const NID_pkcs7_encrypted: u32 = 26;
pub const NID_pkcs3: u32 = 27;
pub const NID_dhKeyAgreement: u32 = 28;
pub const NID_des_ecb: u32 = 29;
pub const NID_des_cfb64: u32 = 30;
pub const NID_des_cbc: u32 = 31;
pub const NID_des_ede_ecb: u32 = 32;
pub const NID_des_ede3_ecb: u32 = 33;
pub const NID_idea_cbc: u32 = 34;
pub const NID_idea_cfb64: u32 = 35;
pub const NID_idea_ecb: u32 = 36;
pub const NID_rc2_cbc: u32 = 37;
pub const NID_rc2_ecb: u32 = 38;
pub const NID_rc2_cfb64: u32 = 39;
pub const NID_rc2_ofb64: u32 = 40;
pub const NID_sha: u32 = 41;
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const NID_des_ede_cbc: u32 = 43;
pub const NID_des_ede3_cbc: u32 = 44;
pub const NID_des_ofb64: u32 = 45;
pub const NID_idea_ofb64: u32 = 46;
pub const NID_pkcs9: u32 = 47;
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const NID_pkcs9_contentType: u32 = 50;
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const NID_pkcs9_signingTime: u32 = 52;
pub const NID_pkcs9_countersignature: u32 = 53;
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const NID_netscape: u32 = 57;
pub const NID_netscape_cert_extension: u32 = 58;
pub const NID_netscape_data_type: u32 = 59;
pub const NID_des_ede_cfb64: u32 = 60;
pub const NID_des_ede3_cfb64: u32 = 61;
pub const NID_des_ede_ofb64: u32 = 62;
pub const NID_des_ede3_ofb64: u32 = 63;
pub const NID_sha1: u32 = 64;
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const NID_dsaWithSHA: u32 = 66;
pub const NID_dsa_2: u32 = 67;
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const NID_id_pbkdf2: u32 = 69;
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const NID_netscape_cert_type: u32 = 71;
pub const NID_netscape_base_url: u32 = 72;
pub const NID_netscape_revocation_url: u32 = 73;
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const NID_netscape_renewal_url: u32 = 75;
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const NID_netscape_comment: u32 = 78;
pub const NID_netscape_cert_sequence: u32 = 79;
pub const NID_desx_cbc: u32 = 80;
pub const NID_id_ce: u32 = 81;
pub const NID_subject_key_identifier: u32 = 82;
pub const NID_key_usage: u32 = 83;
pub const NID_private_key_usage_period: u32 = 84;
pub const NID_subject_alt_name: u32 = 85;
pub const NID_issuer_alt_name: u32 = 86;
pub const NID_basic_constraints: u32 = 87;
pub const NID_crl_number: u32 = 88;
pub const NID_certificate_policies: u32 = 89;
pub const NID_authority_key_identifier: u32 = 90;
pub const NID_bf_cbc: u32 = 91;
pub const NID_bf_ecb: u32 = 92;
pub const NID_bf_cfb64: u32 = 93;
pub const NID_bf_ofb64: u32 = 94;
pub const NID_mdc2: u32 = 95;
pub const NID_mdc2WithRSA: u32 = 96;
pub const NID_rc4_40: u32 = 97;
pub const NID_rc2_40_cbc: u32 = 98;
pub const NID_givenName: u32 = 99;
pub const NID_surname: u32 = 100;
pub const NID_initials: u32 = 101;
pub const NID_crl_distribution_points: u32 = 103;
pub const NID_md5WithRSA: u32 = 104;
pub const NID_serialNumber: u32 = 105;
pub const NID_title: u32 = 106;
pub const NID_description: u32 = 107;
pub const NID_cast5_cbc: u32 = 108;
pub const NID_cast5_ecb: u32 = 109;
pub const NID_cast5_cfb64: u32 = 110;
pub const NID_cast5_ofb64: u32 = 111;
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const NID_dsaWithSHA1: u32 = 113;
pub const NID_md5_sha1: u32 = 114;
pub const NID_sha1WithRSA: u32 = 115;
pub const NID_dsa: u32 = 116;
pub const NID_ripemd160: u32 = 117;
pub const NID_ripemd160WithRSA: u32 = 119;
pub const NID_rc5_cbc: u32 = 120;
pub const NID_rc5_ecb: u32 = 121;
pub const NID_rc5_cfb64: u32 = 122;
pub const NID_rc5_ofb64: u32 = 123;
pub const NID_zlib_compression: u32 = 125;
pub const NID_ext_key_usage: u32 = 126;
pub const NID_id_pkix: u32 = 127;
pub const NID_id_kp: u32 = 128;
pub const NID_server_auth: u32 = 129;
pub const NID_client_auth: u32 = 130;
pub const NID_code_sign: u32 = 131;
pub const NID_email_protect: u32 = 132;
pub const NID_time_stamp: u32 = 133;
pub const NID_ms_code_ind: u32 = 134;
pub const NID_ms_code_com: u32 = 135;
pub const NID_ms_ctl_sign: u32 = 136;
pub const NID_ms_sgc: u32 = 137;
pub const NID_ms_efs: u32 = 138;
pub const NID_ns_sgc: u32 = 139;
pub const NID_delta_crl: u32 = 140;
pub const NID_crl_reason: u32 = 141;
pub const NID_invalidity_date: u32 = 142;
pub const NID_sxnet: u32 = 143;
pub const SN_pbe_WithSHA1And128BitRC4: &[u8; 17usize] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &[u8; 24usize] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &[u8; 16usize] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &[u8; 23usize] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const NID_keyBag: u32 = 150;
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const NID_certBag: u32 = 152;
pub const NID_crlBag: u32 = 153;
pub const NID_secretBag: u32 = 154;
pub const NID_safeContentsBag: u32 = 155;
pub const NID_friendlyName: u32 = 156;
pub const NID_localKeyID: u32 = 157;
pub const NID_x509Certificate: u32 = 158;
pub const NID_sdsiCertificate: u32 = 159;
pub const NID_x509Crl: u32 = 160;
pub const NID_pbes2: u32 = 161;
pub const NID_pbmac1: u32 = 162;
pub const NID_hmacWithSHA1: u32 = 163;
pub const NID_id_qt_cps: u32 = 164;
pub const NID_id_qt_unotice: u32 = 165;
pub const NID_rc2_64_cbc: u32 = 166;
pub const NID_SMIMECapabilities: u32 = 167;
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const NID_ms_ext_req: u32 = 171;
pub const NID_ext_req: u32 = 172;
pub const NID_name: u32 = 173;
pub const NID_dnQualifier: u32 = 174;
pub const NID_id_pe: u32 = 175;
pub const NID_id_ad: u32 = 176;
pub const NID_info_access: u32 = 177;
pub const NID_ad_OCSP: u32 = 178;
pub const NID_ad_ca_issuers: u32 = 179;
pub const NID_OCSP_sign: u32 = 180;
pub const NID_iso: u32 = 181;
pub const NID_member_body: u32 = 182;
pub const NID_ISO_US: u32 = 183;
pub const NID_X9_57: u32 = 184;
pub const NID_X9cm: u32 = 185;
pub const NID_pkcs1: u32 = 186;
pub const NID_pkcs5: u32 = 187;
pub const NID_SMIME: u32 = 188;
pub const NID_id_smime_mod: u32 = 189;
pub const NID_id_smime_ct: u32 = 190;
pub const NID_id_smime_aa: u32 = 191;
pub const NID_id_smime_alg: u32 = 192;
pub const NID_id_smime_cd: u32 = 193;
pub const NID_id_smime_spq: u32 = 194;
pub const NID_id_smime_cti: u32 = 195;
pub const NID_id_smime_mod_cms: u32 = 196;
pub const NID_id_smime_mod_ess: u32 = 197;
pub const NID_id_smime_mod_oid: u32 = 198;
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const NID_id_smime_ct_authData: u32 = 205;
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const NID_md4: u32 = 257;
pub const NID_id_pkix_mod: u32 = 258;
pub const NID_id_qt: u32 = 259;
pub const NID_id_it: u32 = 260;
pub const NID_id_pkip: u32 = 261;
pub const NID_id_alg: u32 = 262;
pub const NID_id_cmc: u32 = 263;
pub const NID_id_on: u32 = 264;
pub const NID_id_pda: u32 = 265;
pub const NID_id_aca: u32 = 266;
pub const NID_id_qcs: u32 = 267;
pub const NID_id_cct: u32 = 268;
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const NID_id_mod_crmf: u32 = 273;
pub const NID_id_mod_cmc: u32 = 274;
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const NID_id_mod_cmp: u32 = 277;
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const NID_id_mod_ocsp: u32 = 282;
pub const NID_id_mod_dvcs: u32 = 283;
pub const NID_id_mod_cmp2000: u32 = 284;
pub const NID_biometricInfo: u32 = 285;
pub const NID_qcStatements: u32 = 286;
pub const NID_ac_auditEntity: u32 = 287;
pub const NID_ac_targeting: u32 = 288;
pub const NID_aaControls: u32 = 289;
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const NID_textNotice: u32 = 293;
pub const NID_ipsecEndSystem: u32 = 294;
pub const NID_ipsecTunnel: u32 = 295;
pub const NID_ipsecUser: u32 = 296;
pub const NID_dvcs: u32 = 297;
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const NID_id_it_currentCRL: u32 = 303;
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const NID_id_it_revPassphrase: u32 = 309;
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const NID_id_regCtrl: u32 = 313;
pub const NID_id_regInfo: u32 = 314;
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const NID_id_regInfo_certReq: u32 = 322;
pub const NID_id_alg_des40: u32 = 323;
pub const NID_id_alg_noSignature: u32 = 324;
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const NID_id_alg_dh_pop: u32 = 326;
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const NID_id_cmc_identification: u32 = 328;
pub const NID_id_cmc_identityProof: u32 = 329;
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const NID_id_cmc_transactionId: u32 = 331;
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const NID_id_cmc_getCert: u32 = 338;
pub const NID_id_cmc_getCRL: u32 = 339;
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const NID_id_cmc_regInfo: u32 = 341;
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const NID_id_cmc_queryPending: u32 = 343;
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const NID_id_on_personalData: u32 = 347;
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const NID_id_pda_gender: u32 = 351;
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const NID_id_aca_group: u32 = 357;
pub const NID_id_aca_role: u32 = 358;
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const NID_id_cct_crs: u32 = 360;
pub const NID_id_cct_PKIData: u32 = 361;
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const NID_ad_timeStamping: u32 = 363;
pub const NID_ad_dvcs: u32 = 364;
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const NID_algorithm: u32 = 376;
pub const NID_rsaSignature: u32 = 377;
pub const NID_X500algorithms: u32 = 378;
pub const NID_org: u32 = 379;
pub const NID_dod: u32 = 380;
pub const NID_iana: u32 = 381;
pub const NID_Directory: u32 = 382;
pub const NID_Management: u32 = 383;
pub const NID_Experimental: u32 = 384;
pub const NID_Private: u32 = 385;
pub const NID_Security: u32 = 386;
pub const NID_SNMPv2: u32 = 387;
pub const NID_Mail: u32 = 388;
pub const NID_Enterprises: u32 = 389;
pub const NID_dcObject: u32 = 390;
pub const NID_domainComponent: u32 = 391;
pub const NID_Domain: u32 = 392;
pub const NID_selected_attribute_types: u32 = 394;
pub const NID_clearance: u32 = 395;
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const NID_ac_proxying: u32 = 397;
pub const NID_sinfo_access: u32 = 398;
pub const NID_id_aca_encAttrs: u32 = 399;
pub const NID_role: u32 = 400;
pub const NID_policy_constraints: u32 = 401;
pub const NID_target_information: u32 = 402;
pub const NID_no_rev_avail: u32 = 403;
pub const NID_ansi_X9_62: u32 = 405;
pub const NID_X9_62_prime_field: u32 = 406;
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const NID_X9_62_prime192v1: u32 = 409;
pub const NID_X9_62_prime192v2: u32 = 410;
pub const NID_X9_62_prime192v3: u32 = 411;
pub const NID_X9_62_prime239v1: u32 = 412;
pub const NID_X9_62_prime239v2: u32 = 413;
pub const NID_X9_62_prime239v3: u32 = 414;
pub const NID_X9_62_prime256v1: u32 = 415;
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const NID_ms_csp_name: u32 = 417;
pub const NID_aes_128_ecb: u32 = 418;
pub const NID_aes_128_cbc: u32 = 419;
pub const NID_aes_128_ofb128: u32 = 420;
pub const NID_aes_128_cfb128: u32 = 421;
pub const NID_aes_192_ecb: u32 = 422;
pub const NID_aes_192_cbc: u32 = 423;
pub const NID_aes_192_ofb128: u32 = 424;
pub const NID_aes_192_cfb128: u32 = 425;
pub const NID_aes_256_ecb: u32 = 426;
pub const NID_aes_256_cbc: u32 = 427;
pub const NID_aes_256_ofb128: u32 = 428;
pub const NID_aes_256_cfb128: u32 = 429;
pub const NID_hold_instruction_code: u32 = 430;
pub const NID_hold_instruction_none: u32 = 431;
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const NID_hold_instruction_reject: u32 = 433;
pub const NID_data: u32 = 434;
pub const NID_pss: u32 = 435;
pub const NID_ucl: u32 = 436;
pub const NID_pilot: u32 = 437;
pub const NID_pilotAttributeType: u32 = 438;
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const NID_pilotObjectClass: u32 = 440;
pub const NID_pilotGroups: u32 = 441;
pub const NID_iA5StringSyntax: u32 = 442;
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const NID_pilotObject: u32 = 444;
pub const NID_pilotPerson: u32 = 445;
pub const NID_account: u32 = 446;
pub const NID_document: u32 = 447;
pub const NID_room: u32 = 448;
pub const NID_documentSeries: u32 = 449;
pub const NID_rFC822localPart: u32 = 450;
pub const NID_dNSDomain: u32 = 451;
pub const NID_domainRelatedObject: u32 = 452;
pub const NID_friendlyCountry: u32 = 453;
pub const NID_simpleSecurityObject: u32 = 454;
pub const NID_pilotOrganization: u32 = 455;
pub const NID_pilotDSA: u32 = 456;
pub const NID_qualityLabelledData: u32 = 457;
pub const NID_userId: u32 = 458;
pub const NID_textEncodedORAddress: u32 = 459;
pub const NID_rfc822Mailbox: u32 = 460;
pub const NID_info: u32 = 461;
pub const NID_favouriteDrink: u32 = 462;
pub const NID_roomNumber: u32 = 463;
pub const NID_photo: u32 = 464;
pub const NID_userClass: u32 = 465;
pub const NID_host: u32 = 466;
pub const NID_manager: u32 = 467;
pub const NID_documentIdentifier: u32 = 468;
pub const NID_documentTitle: u32 = 469;
pub const NID_documentVersion: u32 = 470;
pub const NID_documentAuthor: u32 = 471;
pub const NID_documentLocation: u32 = 472;
pub const NID_homeTelephoneNumber: u32 = 473;
pub const NID_secretary: u32 = 474;
pub const NID_otherMailbox: u32 = 475;
pub const NID_lastModifiedTime: u32 = 476;
pub const NID_lastModifiedBy: u32 = 477;
pub const NID_aRecord: u32 = 478;
pub const NID_pilotAttributeType27: u32 = 479;
pub const NID_mXRecord: u32 = 480;
pub const NID_nSRecord: u32 = 481;
pub const NID_sOARecord: u32 = 482;
pub const NID_cNAMERecord: u32 = 483;
pub const NID_associatedDomain: u32 = 484;
pub const NID_associatedName: u32 = 485;
pub const NID_homePostalAddress: u32 = 486;
pub const NID_personalTitle: u32 = 487;
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const NID_friendlyCountryName: u32 = 490;
pub const NID_organizationalStatus: u32 = 491;
pub const NID_janetMailbox: u32 = 492;
pub const NID_mailPreferenceOption: u32 = 493;
pub const NID_buildingName: u32 = 494;
pub const NID_dSAQuality: u32 = 495;
pub const NID_singleLevelQuality: u32 = 496;
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const NID_personalSignature: u32 = 499;
pub const NID_dITRedirect: u32 = 500;
pub const NID_audio: u32 = 501;
pub const NID_documentPublisher: u32 = 502;
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const NID_mime_mhs: u32 = 504;
pub const NID_mime_mhs_headings: u32 = 505;
pub const NID_mime_mhs_bodies: u32 = 506;
pub const NID_id_hex_partial_message: u32 = 507;
pub const NID_id_hex_multipart_message: u32 = 508;
pub const NID_generationQualifier: u32 = 509;
pub const NID_pseudonym: u32 = 510;
pub const NID_id_set: u32 = 512;
pub const NID_set_ctype: u32 = 513;
pub const NID_set_msgExt: u32 = 514;
pub const NID_set_attr: u32 = 515;
pub const NID_set_policy: u32 = 516;
pub const NID_set_certExt: u32 = 517;
pub const NID_set_brand: u32 = 518;
pub const NID_setct_PANData: u32 = 519;
pub const NID_setct_PANToken: u32 = 520;
pub const NID_setct_PANOnly: u32 = 521;
pub const NID_setct_OIData: u32 = 522;
pub const NID_setct_PI: u32 = 523;
pub const NID_setct_PIData: u32 = 524;
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const NID_setct_HODInput: u32 = 526;
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const NID_setct_PInitResData: u32 = 531;
pub const NID_setct_PI_TBS: u32 = 532;
pub const NID_setct_PResData: u32 = 533;
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const NID_setct_AuthResTBS: u32 = 535;
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const NID_setct_CapTokenData: u32 = 538;
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const NID_setct_AuthRevResData: u32 = 542;
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const NID_setct_CapReqTBS: u32 = 544;
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const NID_setct_CapResData: u32 = 546;
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const NID_setct_CapRevResData: u32 = 549;
pub const NID_setct_CredReqTBS: u32 = 550;
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const NID_setct_CredResData: u32 = 552;
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const NID_setct_CredRevResData: u32 = 555;
pub const NID_setct_PCertReqData: u32 = 556;
pub const NID_setct_PCertResTBS: u32 = 557;
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const NID_setct_CertReqData: u32 = 563;
pub const NID_setct_CertReqTBS: u32 = 564;
pub const NID_setct_CertResData: u32 = 565;
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const NID_setct_ErrorTBS: u32 = 567;
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const NID_setct_AuthResTBE: u32 = 571;
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const NID_setct_CapReqTBE: u32 = 580;
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const NID_setct_CapResTBE: u32 = 582;
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const NID_setct_CredReqTBE: u32 = 586;
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const NID_setct_CredResTBE: u32 = 588;
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const NID_setct_CertReqTBE: u32 = 595;
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const NID_setct_CertResTBE: u32 = 597;
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const NID_setext_genCrypt: u32 = 601;
pub const NID_setext_miAuth: u32 = 602;
pub const NID_setext_pinSecure: u32 = 603;
pub const NID_setext_pinAny: u32 = 604;
pub const NID_setext_track2: u32 = 605;
pub const NID_setext_cv: u32 = 606;
pub const NID_set_policy_root: u32 = 607;
pub const NID_setCext_hashedRoot: u32 = 608;
pub const NID_setCext_certType: u32 = 609;
pub const NID_setCext_merchData: u32 = 610;
pub const NID_setCext_cCertRequired: u32 = 611;
pub const NID_setCext_tunneling: u32 = 612;
pub const NID_setCext_setExt: u32 = 613;
pub const NID_setCext_setQualf: u32 = 614;
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const NID_setCext_Track2Data: u32 = 617;
pub const NID_setCext_TokenType: u32 = 618;
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const NID_setAttr_Cert: u32 = 620;
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const NID_setAttr_TokenType: u32 = 622;
pub const NID_setAttr_IssCap: u32 = 623;
pub const NID_set_rootKeyThumb: u32 = 624;
pub const NID_set_addPolicy: u32 = 625;
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const NID_setAttr_T2Enc: u32 = 632;
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const NID_set_brand_Diners: u32 = 637;
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const NID_set_brand_JCB: u32 = 639;
pub const NID_set_brand_Visa: u32 = 640;
pub const NID_set_brand_MasterCard: u32 = 641;
pub const NID_set_brand_Novus: u32 = 642;
pub const NID_des_cdmf: u32 = 643;
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const NID_itu_t: u32 = 645;
pub const NID_joint_iso_itu_t: u32 = 646;
pub const NID_international_organizations: u32 = 647;
pub const NID_ms_smartcard_login: u32 = 648;
pub const NID_ms_upn: u32 = 649;
pub const NID_aes_128_cfb1: u32 = 650;
pub const NID_aes_192_cfb1: u32 = 651;
pub const NID_aes_256_cfb1: u32 = 652;
pub const NID_aes_128_cfb8: u32 = 653;
pub const NID_aes_192_cfb8: u32 = 654;
pub const NID_aes_256_cfb8: u32 = 655;
pub const NID_des_cfb1: u32 = 656;
pub const NID_des_cfb8: u32 = 657;
pub const NID_des_ede3_cfb1: u32 = 658;
pub const NID_des_ede3_cfb8: u32 = 659;
pub const NID_streetAddress: u32 = 660;
pub const NID_postalCode: u32 = 661;
pub const NID_id_ppl: u32 = 662;
pub const NID_proxyCertInfo: u32 = 663;
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const NID_name_constraints: u32 = 666;
pub const NID_Independent: u32 = 667;
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const NID_sha256: u32 = 672;
pub const NID_sha384: u32 = 673;
pub const NID_sha512: u32 = 674;
pub const NID_sha224: u32 = 675;
pub const NID_identified_organization: u32 = 676;
pub const NID_certicom_arc: u32 = 677;
pub const NID_wap: u32 = 678;
pub const NID_wap_wsg: u32 = 679;
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const NID_X9_62_onBasis: u32 = 681;
pub const NID_X9_62_tpBasis: u32 = 682;
pub const NID_X9_62_ppBasis: u32 = 683;
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const NID_secp112r1: u32 = 704;
pub const NID_secp112r2: u32 = 705;
pub const NID_secp128r1: u32 = 706;
pub const NID_secp128r2: u32 = 707;
pub const NID_secp160k1: u32 = 708;
pub const NID_secp160r1: u32 = 709;
pub const NID_secp160r2: u32 = 710;
pub const NID_secp192k1: u32 = 711;
pub const NID_secp224k1: u32 = 712;
pub const NID_secp224r1: u32 = 713;
pub const NID_secp256k1: u32 = 714;
pub const NID_secp384r1: u32 = 715;
pub const NID_secp521r1: u32 = 716;
pub const NID_sect113r1: u32 = 717;
pub const NID_sect113r2: u32 = 718;
pub const NID_sect131r1: u32 = 719;
pub const NID_sect131r2: u32 = 720;
pub const NID_sect163k1: u32 = 721;
pub const NID_sect163r1: u32 = 722;
pub const NID_sect163r2: u32 = 723;
pub const NID_sect193r1: u32 = 724;
pub const NID_sect193r2: u32 = 725;
pub const NID_sect233k1: u32 = 726;
pub const NID_sect233r1: u32 = 727;
pub const NID_sect239k1: u32 = 728;
pub const NID_sect283k1: u32 = 729;
pub const NID_sect283r1: u32 = 730;
pub const NID_sect409k1: u32 = 731;
pub const NID_sect409r1: u32 = 732;
pub const NID_sect571k1: u32 = 733;
pub const NID_sect571r1: u32 = 734;
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const NID_any_policy: u32 = 746;
pub const NID_policy_mappings: u32 = 747;
pub const NID_inhibit_any_policy: u32 = 748;
pub const NID_ipsec3: u32 = 749;
pub const NID_ipsec4: u32 = 750;
pub const NID_camellia_128_cbc: u32 = 751;
pub const NID_camellia_192_cbc: u32 = 752;
pub const NID_camellia_256_cbc: u32 = 753;
pub const NID_camellia_128_ecb: u32 = 754;
pub const NID_camellia_192_ecb: u32 = 755;
pub const NID_camellia_256_ecb: u32 = 756;
pub const NID_camellia_128_cfb128: u32 = 757;
pub const NID_camellia_192_cfb128: u32 = 758;
pub const NID_camellia_256_cfb128: u32 = 759;
pub const NID_camellia_128_cfb1: u32 = 760;
pub const NID_camellia_192_cfb1: u32 = 761;
pub const NID_camellia_256_cfb1: u32 = 762;
pub const NID_camellia_128_cfb8: u32 = 763;
pub const NID_camellia_192_cfb8: u32 = 764;
pub const NID_camellia_256_cfb8: u32 = 765;
pub const NID_camellia_128_ofb128: u32 = 766;
pub const NID_camellia_192_ofb128: u32 = 767;
pub const NID_camellia_256_ofb128: u32 = 768;
pub const NID_subject_directory_attributes: u32 = 769;
pub const NID_issuing_distribution_point: u32 = 770;
pub const NID_certificate_issuer: u32 = 771;
pub const NID_kisa: u32 = 773;
pub const NID_seed_ecb: u32 = 776;
pub const NID_seed_cbc: u32 = 777;
pub const NID_seed_ofb128: u32 = 778;
pub const NID_seed_cfb128: u32 = 779;
pub const NID_hmac_md5: u32 = 780;
pub const NID_hmac_sha1: u32 = 781;
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const NID_id_DHBasedMac: u32 = 783;
pub const NID_id_it_suppLangTags: u32 = 784;
pub const NID_caRepository: u32 = 785;
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const NID_id_aes128_wrap: u32 = 788;
pub const NID_id_aes192_wrap: u32 = 789;
pub const NID_id_aes256_wrap: u32 = 790;
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const NID_hmacWithMD5: u32 = 797;
pub const NID_hmacWithSHA224: u32 = 798;
pub const NID_hmacWithSHA256: u32 = 799;
pub const NID_hmacWithSHA384: u32 = 800;
pub const NID_hmacWithSHA512: u32 = 801;
pub const NID_dsa_with_SHA224: u32 = 802;
pub const NID_dsa_with_SHA256: u32 = 803;
pub const NID_whirlpool: u32 = 804;
pub const NID_cryptopro: u32 = 805;
pub const NID_cryptocom: u32 = 806;
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const NID_id_GostR3411_94: u32 = 809;
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const NID_id_GostR3410_2001: u32 = 811;
pub const NID_id_GostR3410_94: u32 = 812;
pub const NID_id_Gost28147_89: u32 = 813;
pub const NID_gost89_cnt: u32 = 814;
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const NID_hmac: u32 = 855;
pub const NID_LocalKeySet: u32 = 856;
pub const NID_freshest_crl: u32 = 857;
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const NID_searchGuide: u32 = 859;
pub const NID_businessCategory: u32 = 860;
pub const NID_postalAddress: u32 = 861;
pub const NID_postOfficeBox: u32 = 862;
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const NID_telephoneNumber: u32 = 864;
pub const NID_telexNumber: u32 = 865;
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const NID_x121Address: u32 = 868;
pub const NID_internationaliSDNNumber: u32 = 869;
pub const NID_registeredAddress: u32 = 870;
pub const NID_destinationIndicator: u32 = 871;
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const NID_presentationAddress: u32 = 873;
pub const NID_supportedApplicationContext: u32 = 874;
pub const NID_member: u32 = 875;
pub const NID_owner: u32 = 876;
pub const NID_roleOccupant: u32 = 877;
pub const NID_seeAlso: u32 = 878;
pub const NID_userPassword: u32 = 879;
pub const NID_userCertificate: u32 = 880;
pub const NID_cACertificate: u32 = 881;
pub const NID_authorityRevocationList: u32 = 882;
pub const NID_certificateRevocationList: u32 = 883;
pub const NID_crossCertificatePair: u32 = 884;
pub const NID_enhancedSearchGuide: u32 = 885;
pub const NID_protocolInformation: u32 = 886;
pub const NID_distinguishedName: u32 = 887;
pub const NID_uniqueMember: u32 = 888;
pub const NID_houseIdentifier: u32 = 889;
pub const NID_supportedAlgorithms: u32 = 890;
pub const NID_deltaRevocationList: u32 = 891;
pub const NID_dmdName: u32 = 892;
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const NID_cmac: u32 = 894;
pub const NID_aes_128_gcm: u32 = 895;
pub const NID_aes_128_ccm: u32 = 896;
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const NID_aes_192_gcm: u32 = 898;
pub const NID_aes_192_ccm: u32 = 899;
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const NID_aes_256_gcm: u32 = 901;
pub const NID_aes_256_ccm: u32 = 902;
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const NID_aes_128_ctr: u32 = 904;
pub const NID_aes_192_ctr: u32 = 905;
pub const NID_aes_256_ctr: u32 = 906;
pub const NID_id_camellia128_wrap: u32 = 907;
pub const NID_id_camellia192_wrap: u32 = 908;
pub const NID_id_camellia256_wrap: u32 = 909;
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const NID_mgf1: u32 = 911;
pub const NID_rsassaPss: u32 = 912;
pub const NID_aes_128_xts: u32 = 913;
pub const NID_aes_256_xts: u32 = 914;
pub const NID_rc4_hmac_md5: u32 = 915;
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const NID_rsaesOaep: u32 = 919;
pub const NID_dhpublicnumber: u32 = 920;
pub const NID_brainpoolP160r1: u32 = 921;
pub const NID_brainpoolP160t1: u32 = 922;
pub const NID_brainpoolP192r1: u32 = 923;
pub const NID_brainpoolP192t1: u32 = 924;
pub const NID_brainpoolP224r1: u32 = 925;
pub const NID_brainpoolP224t1: u32 = 926;
pub const NID_brainpoolP256r1: u32 = 927;
pub const NID_brainpoolP256t1: u32 = 928;
pub const NID_brainpoolP320r1: u32 = 929;
pub const NID_brainpoolP320t1: u32 = 930;
pub const NID_brainpoolP384r1: u32 = 931;
pub const NID_brainpoolP384t1: u32 = 932;
pub const NID_brainpoolP512r1: u32 = 933;
pub const NID_brainpoolP512t1: u32 = 934;
pub const NID_pSpecified: u32 = 935;
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const NID_dh_std_kdf: u32 = 946;
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const NID_X25519: u32 = 948;
pub const NID_ED25519: u32 = 949;
pub const NID_chacha20_poly1305: u32 = 950;
pub const NID_kx_rsa: u32 = 951;
pub const NID_kx_ecdhe: u32 = 952;
pub const NID_kx_psk: u32 = 953;
pub const NID_auth_rsa: u32 = 954;
pub const NID_auth_ecdsa: u32 = 955;
pub const NID_auth_psk: u32 = 956;
pub const NID_kx_any: u32 = 957;
pub const NID_auth_any: u32 = 958;
pub const NID_CECPQ2: u32 = 959;
pub const NID_ED448: u32 = 960;
pub const NID_X448: u32 = 961;
pub const NID_sha512_256: u32 = 962;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA_PSS: u32 = 912;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_ED25519: u32 = 949;
pub const EVP_PKEY_X25519: u32 = 948;
pub const EVP_PKEY_DH: u32 = 28;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_X448: u32 = 961;
pub const EVP_PKEY_ED448: u32 = 960;
pub const EVP_HPKE_DHKEM_X25519_HKDF_SHA256: u32 = 32;
pub const EVP_HPKE_HKDF_SHA256: u32 = 1;
pub const EVP_HPKE_AES_128_GCM: u32 = 1;
pub const EVP_HPKE_AES_256_GCM: u32 = 2;
pub const EVP_HPKE_CHACHA20_POLY1305: u32 = 3;
pub const EVP_HPKE_MAX_PUBLIC_KEY_LENGTH: u32 = 32;
pub const EVP_HPKE_MAX_PRIVATE_KEY_LENGTH: u32 = 32;
pub const EVP_HPKE_MAX_ENC_LENGTH: u32 = 32;
pub const EVP_HPKE_MAX_OVERHEAD: u32 = 64;
pub const MD5_CBLOCK: u32 = 64;
pub const MD5_DIGEST_LENGTH: u32 = 16;
pub const RSA_PKCS1_PADDING: u32 = 1;
pub const RSA_NO_PADDING: u32 = 3;
pub const RSA_PKCS1_OAEP_PADDING: u32 = 4;
pub const RSA_PKCS1_PSS_PADDING: u32 = 6;
pub const RSA_FLAG_OPAQUE: u32 = 1;
pub const RSA_FLAG_NO_BLINDING: u32 = 8;
pub const RSA_FLAG_EXT_PKEY: u32 = 32;
pub const RSA_3: u32 = 3;
pub const RSA_F4: u32 = 65537;
pub const RSA_METHOD_FLAG_NO_CHECK: u32 = 1;
pub const RSA_R_BAD_ENCODING: u32 = 100;
pub const RSA_R_BAD_E_VALUE: u32 = 101;
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT: u32 = 102;
pub const RSA_R_BAD_PAD_BYTE_COUNT: u32 = 103;
pub const RSA_R_BAD_RSA_PARAMETERS: u32 = 104;
pub const RSA_R_BAD_SIGNATURE: u32 = 105;
pub const RSA_R_BAD_VERSION: u32 = 106;
pub const RSA_R_BLOCK_TYPE_IS_NOT_01: u32 = 107;
pub const RSA_R_BN_NOT_INITIALIZED: u32 = 108;
pub const RSA_R_CANNOT_RECOVER_MULTI_PRIME_KEY: u32 = 109;
pub const RSA_R_CRT_PARAMS_ALREADY_GIVEN: u32 = 110;
pub const RSA_R_CRT_VALUES_INCORRECT: u32 = 111;
pub const RSA_R_DATA_LEN_NOT_EQUAL_TO_MOD_LEN: u32 = 112;
pub const RSA_R_DATA_TOO_LARGE: u32 = 113;
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 114;
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS: u32 = 115;
pub const RSA_R_DATA_TOO_SMALL: u32 = 116;
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE: u32 = 117;
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY: u32 = 118;
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1: u32 = 119;
pub const RSA_R_EMPTY_PUBLIC_KEY: u32 = 120;
pub const RSA_R_ENCODE_ERROR: u32 = 121;
pub const RSA_R_FIRST_OCTET_INVALID: u32 = 122;
pub const RSA_R_INCONSISTENT_SET_OF_CRT_VALUES: u32 = 123;
pub const RSA_R_INTERNAL_ERROR: u32 = 124;
pub const RSA_R_INVALID_MESSAGE_LENGTH: u32 = 125;
pub const RSA_R_KEY_SIZE_TOO_SMALL: u32 = 126;
pub const RSA_R_LAST_OCTET_INVALID: u32 = 127;
pub const RSA_R_MODULUS_TOO_LARGE: u32 = 128;
pub const RSA_R_MUST_HAVE_AT_LEAST_TWO_PRIMES: u32 = 129;
pub const RSA_R_NO_PUBLIC_EXPONENT: u32 = 130;
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING: u32 = 131;
pub const RSA_R_N_NOT_EQUAL_P_Q: u32 = 132;
pub const RSA_R_OAEP_DECODING_ERROR: u32 = 133;
pub const RSA_R_ONLY_ONE_OF_P_Q_GIVEN: u32 = 134;
pub const RSA_R_OUTPUT_BUFFER_TOO_SMALL: u32 = 135;
pub const RSA_R_PADDING_CHECK_FAILED: u32 = 136;
pub const RSA_R_PKCS_DECODING_ERROR: u32 = 137;
pub const RSA_R_SLEN_CHECK_FAILED: u32 = 138;
pub const RSA_R_SLEN_RECOVERY_FAILED: u32 = 139;
pub const RSA_R_TOO_LONG: u32 = 140;
pub const RSA_R_TOO_MANY_ITERATIONS: u32 = 141;
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE: u32 = 142;
pub const RSA_R_UNKNOWN_PADDING_TYPE: u32 = 143;
pub const RSA_R_VALUE_MISSING: u32 = 144;
pub const RSA_R_WRONG_SIGNATURE_LENGTH: u32 = 145;
pub const RSA_R_PUBLIC_KEY_VALIDATION_FAILED: u32 = 146;
pub const RSA_R_D_OUT_OF_RANGE: u32 = 147;
pub const RSA_R_BLOCK_TYPE_IS_NOT_02: u32 = 148;
pub const OPENSSL_NPN_UNSUPPORTED: u32 = 0;
pub const OPENSSL_NPN_NEGOTIATED: u32 = 1;
pub const OPENSSL_NPN_NO_OVERLAP: u32 = 2;
pub const SSL_TXT_RC4: &[u8; 4usize] = b"RC4\0";
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS: u32 = 0;
pub const OPENSSL_INIT_LOAD_SSL_STRINGS: u32 = 0;
pub const OPENSSL_INIT_SSL_DEFAULT: u32 = 0;
pub type size_t = ::std::os::raw::c_ulong;
pub type time_t = ::std::os::raw::c_long;
pub type CRYPTO_THREADID = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_null_st {
    _unused: [u8; 0],
}
pub type ASN1_NULL = asn1_null_st;
pub type ASN1_BOOLEAN = ::std::os::raw::c_int;
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    _unused: [u8; 0],
}
pub type ASN1_OBJECT = asn1_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_TYPE = asn1_type_st;
pub type DSA_SIG = DSA_SIG_st;
pub type X509_ALGOR = X509_algor_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
pub type BIGNUM = bignum_st;
pub type BIO_METHOD = bio_method_st;
pub type BIO = bio_st;
pub type BN_GENCB = bn_gencb_st;
pub type BN_MONT_CTX = bn_mont_ctx_st;
pub type BUF_MEM = buf_mem_st;
pub type CBB = cbb_st;
pub type CBS = cbs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_buffer_pool_st {
    _unused: [u8; 0],
}
pub type CRYPTO_BUFFER_POOL = crypto_buffer_pool_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_buffer_st {
    _unused: [u8; 0],
}
pub type CRYPTO_BUFFER = crypto_buffer_st;
pub type DH = dh_st;
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
pub type ECDSA_METHOD = ecdsa_method_st;
pub type ECDSA_SIG = ecdsa_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
pub type EVP_MD_CTX = env_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = env_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_aead_st {
    _unused: [u8; 0],
}
pub type EVP_AEAD = evp_aead_st;
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
pub type EVP_CIPHER = evp_cipher_st;
pub type EVP_ENCODE_CTX = evp_encode_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_aead_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_AEAD = evp_hpke_aead_st;
pub type EVP_HPKE_CTX = evp_hpke_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_kdf_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_KDF = evp_hpke_kdf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_kem_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_KEM = evp_hpke_kem_st;
pub type EVP_HPKE_KEY = evp_hpke_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_METHOD = evp_pkey_method_st;
pub type EVP_PKEY = evp_pkey_st;
pub type HMAC_CTX = hmac_ctx_st;
pub type MD5_CTX = md5_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_init_settings_st {
    _unused: [u8; 0],
}
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    _unused: [u8; 0],
}
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
pub type RAND_METHOD = rand_meth_st;
pub type RC4_KEY = rc4_key_st;
pub type RSA_METHOD = rsa_meth_st;
pub type RSA_PSS_PARAMS = rsa_pss_params_st;
pub type RSA = rsa_st;
pub type SHA256_CTX = sha256_state_st;
pub type SHA512_CTX = sha512_state_st;
pub type SHA_CTX = sha_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_ERR_FNS {
    _unused: [u8; 0],
}
pub type ERR_FNS = st_ERR_FNS;
pub type OPENSSL_BLOCK = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn EVP_aead_aes_128_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_192_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_chacha20_poly1305() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_xchacha20_poly1305() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ctr_hmac_sha256() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_ctr_hmac_sha256() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_siv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_siv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_randnonce() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_randnonce() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ccm_bluetooth() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ccm_bluetooth_8() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_has_aes_hardware() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_key_length(aead: *const EVP_AEAD) -> size_t;
}
extern "C" {
    pub fn EVP_AEAD_nonce_length(aead: *const EVP_AEAD) -> size_t;
}
extern "C" {
    pub fn EVP_AEAD_max_overhead(aead: *const EVP_AEAD) -> size_t;
}
extern "C" {
    pub fn EVP_AEAD_max_tag_len(aead: *const EVP_AEAD) -> size_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evp_aead_ctx_st_state {
    pub opaque: [u8; 580usize],
    pub alignment: u64,
}
#[test]
fn bindgen_test_layout_evp_aead_ctx_st_state() {
    assert_eq!(
        ::std::mem::size_of::<evp_aead_ctx_st_state>(),
        584usize,
        concat!("Size of: ", stringify!(evp_aead_ctx_st_state))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_aead_ctx_st_state>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_aead_ctx_st_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_aead_ctx_st_state>())).opaque as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_aead_ctx_st_state), "::", stringify!(opaque))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_aead_ctx_st_state>())).alignment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st_state),
            "::",
            stringify!(alignment)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_aead_ctx_st {
    pub aead: *const EVP_AEAD,
    pub state: evp_aead_ctx_st_state,
    pub tag_len: u8,
}
#[test]
fn bindgen_test_layout_evp_aead_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_aead_ctx_st>(),
        600usize,
        concat!("Size of: ", stringify!(evp_aead_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_aead_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_aead_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_aead_ctx_st>())).aead as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_aead_ctx_st), "::", stringify!(aead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_aead_ctx_st>())).state as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_aead_ctx_st), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_aead_ctx_st>())).tag_len as *const _ as usize },
        592usize,
        concat!("Offset of field: ", stringify!(evp_aead_ctx_st), "::", stringify!(tag_len))
    );
}
pub type EVP_AEAD_CTX = evp_aead_ctx_st;
extern "C" {
    pub fn EVP_AEAD_CTX_zero(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_new(
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: size_t,
        tag_len: size_t,
    ) -> *mut EVP_AEAD_CTX;
}
extern "C" {
    pub fn EVP_AEAD_CTX_free(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_init(
        ctx: *mut EVP_AEAD_CTX,
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: size_t,
        tag_len: size_t,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_cleanup(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_seal(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        max_out_len: size_t,
        nonce: *const u8,
        nonce_len: size_t,
        in_: *const u8,
        in_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_open(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        max_out_len: size_t,
        nonce: *const u8,
        nonce_len: size_t,
        in_: *const u8,
        in_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_seal_scatter(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_tag: *mut u8,
        out_tag_len: *mut size_t,
        max_out_tag_len: size_t,
        nonce: *const u8,
        nonce_len: size_t,
        in_: *const u8,
        in_len: size_t,
        extra_in: *const u8,
        extra_in_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_open_gather(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        nonce: *const u8,
        nonce_len: size_t,
        in_: *const u8,
        in_len: size_t,
        in_tag: *const u8,
        in_tag_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_aead(ctx: *const EVP_AEAD_CTX) -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_des_ede3_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_null_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_tls12() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_tls12() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_tls13() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_tls13() -> *const EVP_AEAD;
}
pub const evp_aead_direction_t_evp_aead_open: evp_aead_direction_t = 0;
pub const evp_aead_direction_t_evp_aead_seal: evp_aead_direction_t = 1;
pub type evp_aead_direction_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn EVP_AEAD_CTX_init_with_direction(
        ctx: *mut EVP_AEAD_CTX,
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: size_t,
        tag_len: size_t,
        dir: evp_aead_direction_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_get_iv(
        ctx: *const EVP_AEAD_CTX,
        out_iv: *mut *const u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_tag_len(
        ctx: *const EVP_AEAD_CTX,
        out_tag_len: *mut size_t,
        in_len: size_t,
        extra_in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aes_key_st {
    pub rd_key: [u32; 60usize],
    pub rounds: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aes_key_st() {
    assert_eq!(
        ::std::mem::size_of::<aes_key_st>(),
        244usize,
        concat!("Size of: ", stringify!(aes_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<aes_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(aes_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aes_key_st>())).rd_key as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(aes_key_st), "::", stringify!(rd_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aes_key_st>())).rounds as *const _ as usize },
        240usize,
        concat!("Offset of field: ", stringify!(aes_key_st), "::", stringify!(rounds))
    );
}
pub type AES_KEY = aes_key_st;
extern "C" {
    pub fn AES_set_encrypt_key(
        key: *const u8,
        bits: ::std::os::raw::c_uint,
        aeskey: *mut AES_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_set_decrypt_key(
        key: *const u8,
        bits: ::std::os::raw::c_uint,
        aeskey: *mut AES_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_encrypt(in_: *const u8, out: *mut u8, key: *const AES_KEY);
}
extern "C" {
    pub fn AES_decrypt(in_: *const u8, out: *mut u8, key: *const AES_KEY);
}
extern "C" {
    pub fn AES_ctr128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        key: *const AES_KEY,
        ivec: *mut u8,
        ecount_buf: *mut u8,
        num: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn AES_ecb_encrypt(
        in_: *const u8,
        out: *mut u8,
        key: *const AES_KEY,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        key: *const AES_KEY,
        ivec: *mut u8,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_ofb128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        key: *const AES_KEY,
        ivec: *mut u8,
        num: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_cfb128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        key: *const AES_KEY,
        ivec: *mut u8,
        num: *mut ::std::os::raw::c_int,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_wrap_key(
        key: *const AES_KEY,
        iv: *const u8,
        out: *mut u8,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_unwrap_key(
        key: *const AES_KEY,
        iv: *const u8,
        out: *mut u8,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_wrap_key_padded(
        key: *const AES_KEY,
        out: *mut u8,
        out_len: *mut size_t,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_unwrap_key_padded(
        key: *const AES_KEY,
        out: *mut u8,
        out_len: *mut size_t,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    pub length: size_t,
    pub data: *mut ::std::os::raw::c_char,
    pub max: size_t,
}
#[test]
fn bindgen_test_layout_buf_mem_st() {
    assert_eq!(
        ::std::mem::size_of::<buf_mem_st>(),
        24usize,
        concat!("Size of: ", stringify!(buf_mem_st))
    );
    assert_eq!(
        ::std::mem::align_of::<buf_mem_st>(),
        8usize,
        concat!("Alignment of ", stringify!(buf_mem_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).length as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(buf_mem_st), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(buf_mem_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).max as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(buf_mem_st), "::", stringify!(max))
    );
}
extern "C" {
    pub fn ERR_load_BIO_strings();
}
extern "C" {
    pub fn ERR_load_ERR_strings();
}
extern "C" {
    pub fn ERR_load_crypto_strings();
}
extern "C" {
    pub fn ERR_load_RAND_strings();
}
extern "C" {
    pub fn ERR_free_strings();
}
extern "C" {
    pub fn ERR_get_error() -> u32;
}
extern "C" {
    pub fn ERR_get_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_get_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_error() -> u32;
}
extern "C" {
    pub fn ERR_peek_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error() -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_error_string_n(
        packed_error: u32,
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_lib_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_reason_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
pub type ERR_print_errors_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        len: size_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ERR_print_errors_cb(
        callback: ERR_print_errors_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ERR_print_errors_fp(file: *mut FILE);
}
extern "C" {
    pub fn ERR_clear_error();
}
extern "C" {
    pub fn ERR_set_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_pop_to_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_get_next_error_library() -> ::std::os::raw::c_int;
}
pub const ERR_LIB_NONE: ::std::os::raw::c_uint = 1;
pub const ERR_LIB_SYS: ::std::os::raw::c_uint = 2;
pub const ERR_LIB_BN: ::std::os::raw::c_uint = 3;
pub const ERR_LIB_RSA: ::std::os::raw::c_uint = 4;
pub const ERR_LIB_DH: ::std::os::raw::c_uint = 5;
pub const ERR_LIB_EVP: ::std::os::raw::c_uint = 6;
pub const ERR_LIB_BUF: ::std::os::raw::c_uint = 7;
pub const ERR_LIB_OBJ: ::std::os::raw::c_uint = 8;
pub const ERR_LIB_PEM: ::std::os::raw::c_uint = 9;
pub const ERR_LIB_DSA: ::std::os::raw::c_uint = 10;
pub const ERR_LIB_X509: ::std::os::raw::c_uint = 11;
pub const ERR_LIB_ASN1: ::std::os::raw::c_uint = 12;
pub const ERR_LIB_CONF: ::std::os::raw::c_uint = 13;
pub const ERR_LIB_CRYPTO: ::std::os::raw::c_uint = 14;
pub const ERR_LIB_EC: ::std::os::raw::c_uint = 15;
pub const ERR_LIB_SSL: ::std::os::raw::c_uint = 16;
pub const ERR_LIB_BIO: ::std::os::raw::c_uint = 17;
pub const ERR_LIB_PKCS7: ::std::os::raw::c_uint = 18;
pub const ERR_LIB_PKCS8: ::std::os::raw::c_uint = 19;
pub const ERR_LIB_X509V3: ::std::os::raw::c_uint = 20;
pub const ERR_LIB_RAND: ::std::os::raw::c_uint = 21;
pub const ERR_LIB_ENGINE: ::std::os::raw::c_uint = 22;
pub const ERR_LIB_OCSP: ::std::os::raw::c_uint = 23;
pub const ERR_LIB_UI: ::std::os::raw::c_uint = 24;
pub const ERR_LIB_COMP: ::std::os::raw::c_uint = 25;
pub const ERR_LIB_ECDSA: ::std::os::raw::c_uint = 26;
pub const ERR_LIB_ECDH: ::std::os::raw::c_uint = 27;
pub const ERR_LIB_HMAC: ::std::os::raw::c_uint = 28;
pub const ERR_LIB_DIGEST: ::std::os::raw::c_uint = 29;
pub const ERR_LIB_CIPHER: ::std::os::raw::c_uint = 30;
pub const ERR_LIB_HKDF: ::std::os::raw::c_uint = 31;
pub const ERR_LIB_TRUST_TOKEN: ::std::os::raw::c_uint = 32;
pub const ERR_LIB_USER: ::std::os::raw::c_uint = 33;
pub const ERR_NUM_LIBS: ::std::os::raw::c_uint = 34;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn ERR_remove_state(pid: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ERR_remove_thread_state(tid: *const CRYPTO_THREADID);
}
extern "C" {
    pub fn ERR_func_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_error_string(
        packed_error: u32,
        buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_clear_system_error();
}
extern "C" {
    pub fn ERR_put_error(
        library: ::std::os::raw::c_int,
        unused: ::std::os::raw::c_int,
        reason: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ERR_add_error_data(count: ::std::os::raw::c_uint, ...);
}
extern "C" {
    pub fn ERR_add_error_dataf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ERR_set_error_data(data: *mut ::std::os::raw::c_char, flags: ::std::os::raw::c_int);
}
pub type OPENSSL_STRING = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    _unused: [u8; 0],
}
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
pub type CRYPTO_EX_free = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CRYPTO_cleanup_all_ex_data();
}
pub type CRYPTO_EX_dup = ::std::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
        from_d: *mut *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type CRYPTO_EX_unused = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub sk: *mut stack_st_void,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Size of: ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_st>())).sk as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(crypto_ex_data_st), "::", stringify!(sk))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_mutex_st {
    pub alignment: f64,
    pub padding: [u8; 56usize],
}
#[test]
fn bindgen_test_layout_crypto_mutex_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_mutex_st>(),
        56usize,
        concat!("Size of: ", stringify!(crypto_mutex_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_mutex_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_mutex_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).alignment as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(alignment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_mutex_st>())).padding as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(crypto_mutex_st), "::", stringify!(padding))
    );
}
pub type CRYPTO_MUTEX = crypto_mutex_st;
pub type CRYPTO_refcount_t = u32;
extern "C" {
    pub fn CRYPTO_num_locks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_locking_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                lock_num: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_add_lock_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                num: *mut ::std::os::raw::c_int,
                amount: ::std::os::raw::c_int,
                lock_num: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_locking_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn CRYPTO_get_lock_name(lock_num: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_THREADID_set_callback(
        threadid_func: ::std::option::Option<unsafe extern "C" fn(threadid: *mut CRYPTO_THREADID)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREADID_set_numeric(id: *mut CRYPTO_THREADID, val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn CRYPTO_THREADID_set_pointer(id: *mut CRYPTO_THREADID, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CRYPTO_THREADID_current(id: *mut CRYPTO_THREADID);
}
extern "C" {
    pub fn CRYPTO_set_id_callback(
        func: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub references: ::std::os::raw::c_int,
    pub data: *mut CRYPTO_dynlock_value,
}
#[test]
fn bindgen_test_layout_CRYPTO_dynlock() {
    assert_eq!(
        ::std::mem::size_of::<CRYPTO_dynlock>(),
        16usize,
        concat!("Size of: ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CRYPTO_dynlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CRYPTO_dynlock>())).references as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CRYPTO_dynlock), "::", stringify!(references))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CRYPTO_dynlock>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CRYPTO_dynlock), "::", stringify!(data))
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_create_callback(
        dyn_create_function: ::std::option::Option<
            unsafe extern "C" fn(
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> *mut CRYPTO_dynlock_value,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_lock_callback(
        dyn_lock_function: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_destroy_callback(
        dyn_destroy_function: ::std::option::Option<
            unsafe extern "C" fn(
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_dynlock_create_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> *mut CRYPTO_dynlock_value,
    >;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_lock_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut CRYPTO_dynlock_value,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_destroy_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut CRYPTO_dynlock_value,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn BIO_new(method: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vfree(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_up_ref(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read(
        bio: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bio: *mut BIO,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write(
        bio: *mut BIO,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_all(
        bio: *mut BIO,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_puts(bio: *mut BIO, buf: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_flush(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        iarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_reset(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_eof(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_flags(bio: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_test_flags(bio: *const BIO, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_read(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_write(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_retry(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_io_special(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_retry_reason(bio: *mut BIO, reason: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_clear_flags(bio: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_set_retry_read(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_set_retry_write(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_get_retry_flags(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_clear_retry_flags(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_method_type(bio: *const BIO) -> ::std::os::raw::c_int;
}
pub type bio_info_cb = ::std::option::Option<
    unsafe extern "C" fn(
        bio: *mut BIO,
        event: ::std::os::raw::c_int,
        parg: *const ::std::os::raw::c_char,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        return_value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
extern "C" {
    pub fn BIO_callback_ctrl(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        fp: bio_info_cb,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_pending(bio: *const BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_pending(bio: *const BIO) -> size_t;
}
extern "C" {
    pub fn BIO_wpending(bio: *const BIO) -> size_t;
}
extern "C" {
    pub fn BIO_set_close(bio: *mut BIO, close_flag: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_number_read(bio: *const BIO) -> size_t;
}
extern "C" {
    pub fn BIO_number_written(bio: *const BIO) -> size_t;
}
extern "C" {
    pub fn BIO_push(bio: *mut BIO, appended_bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(bio: *mut BIO, type_: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_copy_next_retry(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_indent(
        bio: *mut BIO,
        indent: ::std::os::raw::c_uint,
        max_indent: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_hexdump(
        bio: *mut BIO,
        data: *const u8,
        len: size_t,
        indent: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_print_errors(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_read_asn1(
        bio: *mut BIO,
        out: *mut *mut u8,
        out_len: *mut size_t,
        max_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_mem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_mem_contents(
        bio: *const BIO,
        out_contents: *mut *const u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_mem_data(
        bio: *mut BIO,
        contents: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_get_mem_ptr(bio: *mut BIO, out: *mut *mut BUF_MEM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_mem_buf(
        bio: *mut BIO,
        b: *mut BUF_MEM,
        take_ownership: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_mem_eof_return(
        bio: *mut BIO,
        eof_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_fd() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_fd(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_fd(
        bio: *mut BIO,
        fd: ::std::os::raw::c_int,
        close_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_fd(bio: *mut BIO, out_fd: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_fp(bio: *mut BIO, out_file: *mut *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_fp(
        bio: *mut BIO,
        file: *mut FILE,
        close_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_append_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_rw_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_tell(bio: *mut BIO) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_seek(bio: *mut BIO, offset: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_s_socket() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_socket(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int)
        -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_connect() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_connect(host_and_optional_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_conn_hostname(
        bio: *mut BIO,
        host_and_optional_port: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_conn_port(
        bio: *mut BIO,
        port_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_conn_int_port(
        bio: *mut BIO,
        port: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_nbio(bio: *mut BIO, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_do_connect(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        out1: *mut *mut BIO,
        writebuf1: size_t,
        out2: *mut *mut BIO,
        writebuf2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(bio: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(bio: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_shutdown_wr(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_new_index() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_new(
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_meth_free(method: *mut BIO_METHOD);
}
extern "C" {
    pub fn BIO_meth_set_create(
        method: *mut BIO_METHOD,
        create: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_destroy(
        method: *mut BIO_METHOD,
        destroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_write(
        method: *mut BIO_METHOD,
        write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_read(
        method: *mut BIO_METHOD,
        read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_gets(
        method: *mut BIO_METHOD,
        gets: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_ctrl(
        method: *mut BIO_METHOD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_long,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_data(bio: *mut BIO, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn BIO_get_data(bio: *mut BIO) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_set_init(bio: *mut BIO, init: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_init(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_base64() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_retry_special(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_set_write_buffer_size(
        bio: *mut BIO,
        buffer_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_shutdown(bio: *mut BIO, shutdown: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_shutdown(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_puts(
        method: *mut BIO_METHOD,
        puts: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    pub type_: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub bwrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bread: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bputs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub bgets: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_long,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >,
    pub create:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub callback_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: bio_info_cb,
        ) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout_bio_method_st() {
    assert_eq!(
        ::std::mem::size_of::<bio_method_st>(),
        80usize,
        concat!("Size of: ", stringify!(bio_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bwrite as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(bwrite))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bread as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(bread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bputs as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(bputs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bgets as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(bgets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).ctrl as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(ctrl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).create as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(create))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).destroy as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(destroy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).callback_ctrl as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(bio_method_st), "::", stringify!(callback_ctrl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    pub method: *const BIO_METHOD,
    pub init: ::std::os::raw::c_int,
    pub shutdown: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub retry_reason: ::std::os::raw::c_int,
    pub num: ::std::os::raw::c_int,
    pub references: CRYPTO_refcount_t,
    pub ptr: *mut ::std::os::raw::c_void,
    pub next_bio: *mut BIO,
    pub num_read: size_t,
    pub num_write: size_t,
}
#[test]
fn bindgen_test_layout_bio_st() {
    assert_eq!(::std::mem::size_of::<bio_st>(), 64usize, concat!("Size of: ", stringify!(bio_st)));
    assert_eq!(
        ::std::mem::align_of::<bio_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).method as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(method))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).init as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).shutdown as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(shutdown))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).flags as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).retry_reason as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(retry_reason))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).references as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(references))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).ptr as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).next_bio as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(next_bio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num_read as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(num_read))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num_write as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(bio_st), "::", stringify!(num_write))
    );
}
pub type BN_ULONG = u64;
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_init(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_free(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_clear_free(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(src: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_copy(dest: *mut BIGNUM, src: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_clear(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_num_bits(bn: *const BIGNUM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn BN_num_bytes(bn: *const BIGNUM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn BN_zero(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_one(bn: *mut BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_word(bn: *mut BIGNUM, value: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_u64(bn: *mut BIGNUM, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_negative(bn: *mut BIGNUM, sign: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BN_is_negative(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bin2bn(in_: *const u8, len: size_t, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(in_: *const BIGNUM, out: *mut u8) -> size_t;
}
extern "C" {
    pub fn BN_le2bn(in_: *const u8, len: size_t, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2le_padded(out: *mut u8, len: size_t, in_: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2bin_padded(out: *mut u8, len: size_t, in_: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2cbb_padded(
        out: *mut CBB,
        len: size_t,
        in_: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2hex(bn: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_hex2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_dec2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_asc2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print(bio: *mut BIO, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_word(bn: *const BIGNUM) -> BN_ULONG;
}
extern "C" {
    pub fn BN_get_u64(bn: *const BIGNUM, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_parse_asn1_unsigned(cbs: *mut CBS, ret: *mut BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_marshal_asn1(cbb: *mut CBB, bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_free(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul_word(bn: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div(
        quotient: *mut BIGNUM,
        rem: *mut BIGNUM,
        numerator: *const BIGNUM,
        divisor: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div_word(numerator: *mut BIGNUM, divisor: BN_ULONG) -> BN_ULONG;
}
extern "C" {
    pub fn BN_sqrt(
        out_sqrt: *mut BIGNUM,
        in_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_cmp_word(a: *const BIGNUM, b: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_equal_consttime(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_abs_is_word(bn: *const BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_zero(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_one(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_word(bn: *const BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_odd(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_pow2(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_count_low_zero_bits(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: BN_ULONG) -> BN_ULONG;
}
extern "C" {
    pub fn BN_mod_pow2(r: *mut BIGNUM, a: *const BIGNUM, e: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod_pow2(r: *mut BIGNUM, a: *const BIGNUM, e: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod(
        rem: *mut BIGNUM,
        numerator: *const BIGNUM,
        divisor: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqrt(
        in_: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range_ex(
        r: *mut BIGNUM,
        min_inclusive: BN_ULONG,
        max_exclusive: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_gencb_st {
    pub arg: *mut ::std::os::raw::c_void,
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            event: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
            arg1: *mut bn_gencb_st,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_bn_gencb_st() {
    assert_eq!(
        ::std::mem::size_of::<bn_gencb_st>(),
        16usize,
        concat!("Size of: ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_gencb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).arg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bn_gencb_st), "::", stringify!(arg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).callback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(bn_gencb_st), "::", stringify!(callback))
    );
}
extern "C" {
    pub fn BN_GENCB_new() -> *mut BN_GENCB;
}
extern "C" {
    pub fn BN_GENCB_free(callback: *mut BN_GENCB);
}
extern "C" {
    pub fn BN_GENCB_set(
        callback: *mut BN_GENCB,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                event: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                arg1: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_call(
        callback: *mut BN_GENCB,
        event: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
pub const bn_primality_result_t_bn_probably_prime: bn_primality_result_t = 0;
pub const bn_primality_result_t_bn_composite: bn_primality_result_t = 1;
pub const bn_primality_result_t_bn_non_prime_power_composite: bn_primality_result_t = 2;
pub type bn_primality_result_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn BN_enhanced_miller_rabin_primality_test(
        out_result: *mut bn_primality_result_t,
        w: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_primality_test(
        is_probably_prime: *mut ::std::os::raw::c_int,
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_gcd(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(
        out: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_inverse_blinded(
        out: *mut BIGNUM,
        out_no_inverse: *mut ::std::os::raw::c_int,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse_odd(
        out: *mut BIGNUM,
        out_no_inverse: *mut ::std::os::raw::c_int,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new_for_modulus(mod_: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_new_consttime(mod_: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *const BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set_locked(
        pmont: *mut *mut BN_MONT_CTX,
        lock: *mut CRYPTO_MUTEX,
        mod_: *const BIGNUM,
        bn_ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_to_montgomery(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2mpi(in_: *const BIGNUM, out: *mut u8) -> size_t;
}
extern "C" {
    pub fn BN_mpi2bn(in_: *const u8, len: size_t, out: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: BN_ULONG,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set(
        mont: *mut BN_MONT_CTX,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2binpad(
        in_: *const BIGNUM,
        out: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    pub d: *mut BN_ULONG,
    pub width: ::std::os::raw::c_int,
    pub dmax: ::std::os::raw::c_int,
    pub neg: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bignum_st() {
    assert_eq!(
        ::std::mem::size_of::<bignum_st>(),
        24usize,
        concat!("Size of: ", stringify!(bignum_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bignum_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bignum_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).d as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).width as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).dmax as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(dmax))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).neg as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(neg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).flags as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(bignum_st), "::", stringify!(flags))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    pub RR: BIGNUM,
    pub N: BIGNUM,
    pub n0: [BN_ULONG; 2usize],
}
#[test]
fn bindgen_test_layout_bn_mont_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<bn_mont_ctx_st>(),
        64usize,
        concat!("Size of: ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_mont_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).RR as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(RR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).N as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(N))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).n0 as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(bn_mont_ctx_st), "::", stringify!(n0))
    );
}
extern "C" {
    pub fn BN_num_bits_word(l: BN_ULONG) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_tag2str(tag: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type i2d_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ITEM_EXP = ASN1_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i(
        out: *mut *mut ASN1_VALUE,
        inp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *mut ASN1_VALUE,
        outp: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_dup(
        it: *const ASN1_ITEM,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        out: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        out: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        in_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        in_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_unpack(
        oct: *const ASN1_STRING,
        it: *const ASN1_ITEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut ::std::os::raw::c_void,
        it: *const ASN1_ITEM,
        out: *mut *mut ASN1_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub static ASN1_BOOLEAN_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_TBOOLEAN_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_FBOOLEAN_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_asn1_string_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_string_st>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_string_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).length as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(asn1_string_st), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).type_ as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(asn1_string_st), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(asn1_string_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).flags as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(asn1_string_st), "::", stringify!(flags))
    );
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: ::std::os::raw::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(
        dst: *mut ASN1_STRING,
        str_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(str_: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type(str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get0_data(str_: *const ASN1_STRING) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_data(str_: *mut ASN1_STRING) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_length(str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str_: *mut ASN1_STRING,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(
        str_: *mut ASN1_STRING,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(str_: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(str_: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn ASN1_IA5STRING_free(str_: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(str_: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(str_: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn ASN1_T61STRING_free(str_: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(str_: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(str_: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(str_: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub static ASN1_BMPSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_GENERALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_IA5STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_OCTET_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_PRINTABLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_T61STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_UNIVERSALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_UTF8STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_VISIBLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(
        a: *const ASN1_OCTET_STRING,
        b: *const ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str_: *mut ASN1_OCTET_STRING,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut ::std::os::raw::c_uchar,
        in_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const u8,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const u8,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
        minsize: ::std::os::raw::c_long,
        maxsize: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        nid: ::std::os::raw::c_int,
        minsize: ::std::os::raw::c_long,
        maxsize: ::std::os::raw::c_long,
        mask: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(str_: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub static ASN1_BIT_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_bytes(
        str_: *const ASN1_BIT_STRING,
        out: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        str_: *mut ASN1_BIT_STRING,
        d: *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        str_: *mut ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(
        str_: *const ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        str_: *const ASN1_BIT_STRING,
        flags: *const ::std::os::raw::c_uchar,
        flags_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(str_: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn ASN1_INTEGER_dup(x: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub static ASN1_INTEGER_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_INTEGER_set(
        a: *mut ASN1_INTEGER,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_uint64(out: *mut ASN1_INTEGER, v: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(
        x: *const ASN1_INTEGER,
        y: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(str_: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub static ASN1_ENUMERATED_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(
        a: *mut ASN1_ENUMERATED,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *const ASN1_ENUMERATED) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(
        bn: *const BIGNUM,
        ai: *mut ASN1_ENUMERATED,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *const ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(str_: *mut ASN1_UTCTIME);
}
extern "C" {
    pub static ASN1_UTCTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, t: time_t) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(
        s: *mut ASN1_UTCTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(str_: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub static ASN1_GENERALIZEDTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(str_: *mut ASN1_TIME);
}
extern "C" {
    pub static ASN1_TIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        out_days: *mut ::std::os::raw::c_int,
        out_seconds: *mut ::std::os::raw::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, t: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *const ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(
        s: *mut ASN1_TIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(null: *mut ASN1_NULL);
}
extern "C" {
    pub static ASN1_NULL_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: ::std::os::raw::c_int,
        data: *const u8,
        len: ::std::os::raw::c_int,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub static ASN1_OBJECT_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: ::std::os::raw::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
}
#[test]
fn bindgen_test_layout_asn1_type_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(asn1_type_st__bindgen_ty_1), "::", stringify!(ptr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).enumerated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(enumerated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bit_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bit_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).octet_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(octet_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).printablestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(printablestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).t61string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(t61string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ia5string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ia5string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bmpstring as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bmpstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).universalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(universalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utctime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utctime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalizedtime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalizedtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).visiblestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(visiblestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utf8string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utf8string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).set as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(asn1_type_st__bindgen_ty_1), "::", stringify!(set))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_value)
        )
    );
}
#[test]
fn bindgen_test_layout_asn1_type_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_type_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(asn1_type_st), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).value as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(asn1_type_st), "::", stringify!(value))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub static ASN1_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn ASN1_UTCTIME_print(out: *mut BIO, a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(
        out: *mut BIO,
        a: *const ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(out: *mut BIO, a: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(out: *mut BIO, str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_get_object(
        inp: *mut *const ::std::os::raw::c_uchar,
        out_length: *mut ::std::os::raw::c_long,
        out_tag: *mut ::std::os::raw::c_int,
        out_class: *mut ::std::os::raw::c_int,
        max_len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        outp: *mut *mut ::std::os::raw::c_uchar,
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
        xclass: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(outp: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_type(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub static ASN1_PRINTABLE_it: ASN1_ITEM;
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    pub flags: ::std::os::raw::c_ulong,
    pub tag: ::std::os::raw::c_long,
    pub offset: ::std::os::raw::c_ulong,
    pub field_name: *const ::std::os::raw::c_char,
    pub item: *mut ASN1_ITEM_EXP,
}
#[test]
fn bindgen_test_layout_ASN1_TEMPLATE_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_TEMPLATE_st>(),
        40usize,
        concat!("Size of: ", stringify!(ASN1_TEMPLATE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_TEMPLATE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_TEMPLATE_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TEMPLATE_st>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_TEMPLATE_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TEMPLATE_st>())).tag as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_TEMPLATE_st), "::", stringify!(tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TEMPLATE_st>())).offset as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ASN1_TEMPLATE_st), "::", stringify!(offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TEMPLATE_st>())).field_name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ASN1_TEMPLATE_st), "::", stringify!(field_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TEMPLATE_st>())).item as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ASN1_TEMPLATE_st), "::", stringify!(item))
    );
}
pub type ASN1_ADB_TABLE = ASN1_ADB_TABLE_st;
pub type ASN1_ADB = ASN1_ADB_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_must_be_null_st {
    _unused: [u8; 0],
}
pub type ASN1_MUST_BE_NULL = asn1_must_be_null_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ADB_st {
    pub flags: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub unused: *mut ASN1_MUST_BE_NULL,
    pub tbl: *const ASN1_ADB_TABLE,
    pub tblcount: ::std::os::raw::c_long,
    pub default_tt: *const ASN1_TEMPLATE,
    pub null_tt: *const ASN1_TEMPLATE,
}
#[test]
fn bindgen_test_layout_ASN1_ADB_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_ADB_st>(),
        56usize,
        concat!("Size of: ", stringify!(ASN1_ADB_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ADB_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ADB_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).offset as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).unused as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(unused))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).tbl as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(tbl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).tblcount as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(tblcount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).default_tt as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(default_tt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_st>())).null_tt as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_st), "::", stringify!(null_tt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ADB_TABLE_st {
    pub value: ::std::os::raw::c_long,
    pub tt: ASN1_TEMPLATE,
}
#[test]
fn bindgen_test_layout_ASN1_ADB_TABLE_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_ADB_TABLE_st>(),
        48usize,
        concat!("Size of: ", stringify!(ASN1_ADB_TABLE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ADB_TABLE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ADB_TABLE_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_TABLE_st>())).value as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_TABLE_st), "::", stringify!(value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ADB_TABLE_st>())).tt as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_ADB_TABLE_st), "::", stringify!(tt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    pub itype: ::std::os::raw::c_char,
    pub utype: ::std::os::raw::c_long,
    pub templates: *const ASN1_TEMPLATE,
    pub tcount: ::std::os::raw::c_long,
    pub funcs: *const ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_long,
    pub sname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ASN1_ITEM_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_ITEM_st>(),
        56usize,
        concat!("Size of: ", stringify!(ASN1_ITEM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ITEM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ITEM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).itype as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(itype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).utype as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(utype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).templates as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(templates))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).tcount as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(tcount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).funcs as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(funcs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).size as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ITEM_st>())).sname as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(ASN1_ITEM_st), "::", stringify!(sname))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    pub valid: ::std::os::raw::c_char,
    pub ret: ::std::os::raw::c_int,
    pub plen: ::std::os::raw::c_long,
    pub ptag: ::std::os::raw::c_int,
    pub pclass: ::std::os::raw::c_int,
    pub hdrlen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_TLC_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_TLC_st>(),
        32usize,
        concat!("Size of: ", stringify!(ASN1_TLC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_TLC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_TLC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).valid as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(valid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).ret as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(ret))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).plen as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(plen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).ptag as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(ptag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).pclass as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(pclass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_TLC_st>())).hdrlen as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ASN1_TLC_st), "::", stringify!(hdrlen))
    );
}
pub type ASN1_new_func = ::std::option::Option<unsafe extern "C" fn() -> *mut ASN1_VALUE>;
pub type ASN1_free_func = ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_VALUE)>;
pub type ASN1_d2i_func = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_VALUE,
>;
pub type ASN1_i2d_func = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ASN1_VALUE,
        in_: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_d2i = ::std::option::Option<
    unsafe extern "C" fn(
        pval: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
        tag: ::std::os::raw::c_int,
        aclass: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_char,
        ctx: *mut ASN1_TLC,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_i2d = ::std::option::Option<
    unsafe extern "C" fn(
        pval: *mut *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
        tag: ::std::os::raw::c_int,
        aclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_new_func = ::std::option::Option<
    unsafe extern "C" fn(pval: *mut *mut ASN1_VALUE, it: *const ASN1_ITEM) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_free_func =
    ::std::option::Option<unsafe extern "C" fn(pval: *mut *mut ASN1_VALUE, it: *const ASN1_ITEM)>;
pub type ASN1_ex_print_func = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut BIO,
        pval: *mut *mut ASN1_VALUE,
        indent: ::std::os::raw::c_int,
        fname: *const ::std::os::raw::c_char,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_EXTERN_FUNCS_st {
    pub app_data: *mut ::std::os::raw::c_void,
    pub asn1_ex_new: ASN1_ex_new_func,
    pub asn1_ex_free: ASN1_ex_free_func,
    pub asn1_ex_clear: ASN1_ex_free_func,
    pub asn1_ex_d2i: ASN1_ex_d2i,
    pub asn1_ex_i2d: ASN1_ex_i2d,
    pub asn1_ex_print: ASN1_ex_print_func,
}
#[test]
fn bindgen_test_layout_ASN1_EXTERN_FUNCS_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_EXTERN_FUNCS_st>(),
        56usize,
        concat!("Size of: ", stringify!(ASN1_EXTERN_FUNCS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_EXTERN_FUNCS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_EXTERN_FUNCS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).app_data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_EXTERN_FUNCS_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_new as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_free as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_clear as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_clear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_d2i as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_d2i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_i2d as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_i2d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ASN1_EXTERN_FUNCS_st>())).asn1_ex_print as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_print)
        )
    );
}
pub type ASN1_EXTERN_FUNCS = ASN1_EXTERN_FUNCS_st;
pub type ASN1_aux_cb = ::std::option::Option<
    unsafe extern "C" fn(
        operation: ::std::os::raw::c_int,
        in_: *mut *mut ASN1_VALUE,
        it: *const ASN1_ITEM,
        exarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_AUX_st {
    pub app_data: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_int,
    pub ref_offset: ::std::os::raw::c_int,
    pub asn1_cb: ASN1_aux_cb,
    pub enc_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_AUX_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_AUX_st>(),
        32usize,
        concat!("Size of: ", stringify!(ASN1_AUX_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_AUX_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_AUX_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_AUX_st>())).app_data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ASN1_AUX_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_AUX_st>())).flags as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ASN1_AUX_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_AUX_st>())).ref_offset as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(ASN1_AUX_st), "::", stringify!(ref_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_AUX_st>())).asn1_cb as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ASN1_AUX_st), "::", stringify!(asn1_cb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_AUX_st>())).enc_offset as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ASN1_AUX_st), "::", stringify!(enc_offset))
    );
}
pub type ASN1_AUX = ASN1_AUX_st;
extern "C" {
    pub static ASN1_SEQUENCE_it: ASN1_ITEM;
}
extern "C" {
    pub fn EVP_EncodeBlock(dst: *mut u8, src: *const u8, src_len: size_t) -> size_t;
}
extern "C" {
    pub fn EVP_EncodedLength(out_len: *mut size_t, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodedLength(out_len: *mut size_t, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBase64(
        out: *mut u8,
        out_len: *mut size_t,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_new() -> *mut EVP_ENCODE_CTX;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_free(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: size_t,
    );
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(dst: *mut u8, src: *const u8, src_len: size_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_encode_ctx_st {
    pub data_used: ::std::os::raw::c_uint,
    pub data: [u8; 48usize],
    pub eof_seen: ::std::os::raw::c_char,
    pub error_encountered: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_evp_encode_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_encode_ctx_st>(),
        56usize,
        concat!("Size of: ", stringify!(evp_encode_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_encode_ctx_st>(),
        4usize,
        concat!("Alignment of ", stringify!(evp_encode_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_encode_ctx_st>())).data_used as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_encode_ctx_st), "::", stringify!(data_used))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_encode_ctx_st>())).data as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(evp_encode_ctx_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_encode_ctx_st>())).eof_seen as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(evp_encode_ctx_st), "::", stringify!(eof_seen))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evp_encode_ctx_st>())).error_encountered as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_encode_ctx_st),
            "::",
            stringify!(error_encountered)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbs_st {
    pub data: *const u8,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_cbs_st() {
    assert_eq!(::std::mem::size_of::<cbs_st>(), 16usize, concat!("Size of: ", stringify!(cbs_st)));
    assert_eq!(
        ::std::mem::align_of::<cbs_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbs_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbs_st>())).data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cbs_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbs_st>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cbs_st), "::", stringify!(len))
    );
}
extern "C" {
    pub fn CBS_init(cbs: *mut CBS, data: *const u8, len: size_t);
}
extern "C" {
    pub fn CBS_skip(cbs: *mut CBS, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_data(cbs: *const CBS) -> *const u8;
}
extern "C" {
    pub fn CBS_len(cbs: *const CBS) -> size_t;
}
extern "C" {
    pub fn CBS_stow(
        cbs: *const CBS,
        out_ptr: *mut *mut u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_strdup(
        cbs: *const CBS,
        out_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_contains_zero_byte(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_mem_equal(cbs: *const CBS, data: *const u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u8(cbs: *mut CBS, out: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16(cbs: *mut CBS, out: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16le(cbs: *mut CBS, out: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u24(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u32(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u32le(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u64(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u64le(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_last_u8(cbs: *mut CBS, out: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_bytes(cbs: *mut CBS, out: *mut CBS, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_copy_bytes(cbs: *mut CBS, out: *mut u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u8_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u24_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_until_first(cbs: *mut CBS, out: *mut CBS, c: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        tag_value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        tag_value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_peek_asn1_tag(
        cbs: *const CBS,
        tag_value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut ::std::os::raw::c_uint,
        out_header_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_ber_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut ::std::os::raw::c_uint,
        out_header_len: *mut size_t,
        out_ber_found: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_uint64(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_int64(cbs: *mut CBS, out: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_bool(
        cbs: *mut CBS,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        out_present: *mut ::std::os::raw::c_int,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_octet_string(
        cbs: *mut CBS,
        out: *mut CBS,
        out_present: *mut ::std::os::raw::c_int,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_uint64(
        cbs: *mut CBS,
        out: *mut u64,
        tag: ::std::os::raw::c_uint,
        default_value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_bool(
        cbs: *mut CBS,
        out: *mut ::std::os::raw::c_int,
        tag: ::std::os::raw::c_uint,
        default_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_valid_asn1_bitstring(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_asn1_bitstring_has_bit(
        cbs: *const CBS,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_valid_asn1_integer(
        cbs: *const CBS,
        out_is_negative: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_unsigned_asn1_integer(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_asn1_oid_to_text(cbs: *const CBS) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_buffer_st {
    pub buf: *mut u8,
    pub len: size_t,
    pub cap: size_t,
    pub can_resize: ::std::os::raw::c_char,
    pub error: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cbb_buffer_st() {
    assert_eq!(
        ::std::mem::size_of::<cbb_buffer_st>(),
        32usize,
        concat!("Size of: ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_buffer_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).buf as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).cap as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).can_resize as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(can_resize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).error as *const _ as usize },
        25usize,
        concat!("Offset of field: ", stringify!(cbb_buffer_st), "::", stringify!(error))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_st {
    pub base: *mut cbb_buffer_st,
    pub child: *mut CBB,
    pub offset: size_t,
    pub pending_len_len: u8,
    pub pending_is_asn1: ::std::os::raw::c_char,
    pub is_child: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cbb_st() {
    assert_eq!(::std::mem::size_of::<cbb_st>(), 32usize, concat!("Size of: ", stringify!(cbb_st)));
    assert_eq!(
        ::std::mem::align_of::<cbb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).base as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).child as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(child))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).offset as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_len_len as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(pending_len_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_is_asn1 as *const _ as usize },
        25usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(pending_is_asn1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).is_child as *const _ as usize },
        26usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(is_child))
    );
}
extern "C" {
    pub fn CBB_zero(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_init(cbb: *mut CBB, initial_capacity: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_init_fixed(cbb: *mut CBB, buf: *mut u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_cleanup(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_finish(
        cbb: *mut CBB,
        out_data: *mut *mut u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_flush(cbb: *mut CBB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_data(cbb: *const CBB) -> *const u8;
}
extern "C" {
    pub fn CBB_len(cbb: *const CBB) -> size_t;
}
extern "C" {
    pub fn CBB_add_u8_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u24_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1(
        cbb: *mut CBB,
        out_contents: *mut CBB,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_bytes(cbb: *mut CBB, data: *const u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_zeros(cbb: *mut CBB, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_space(
        cbb: *mut CBB,
        out_data: *mut *mut u8,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_reserve(cbb: *mut CBB, out_data: *mut *mut u8, len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_did_write(cbb: *mut CBB, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u8(cbb: *mut CBB, value: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16(cbb: *mut CBB, value: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16le(cbb: *mut CBB, value: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u24(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u32(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u32le(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u64(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u64le(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_discard_child(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_add_asn1_uint64(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_int64(cbb: *mut CBB, value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_octet_string(
        cbb: *mut CBB,
        data: *const u8,
        data_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_bool(cbb: *mut CBB, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_oid_from_text(
        cbb: *mut CBB,
        text: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_flush_asn1_set_of(cbb: *mut CBB) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cast_key_st {
    pub data: [u32; 32usize],
    pub short_key: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cast_key_st() {
    assert_eq!(
        ::std::mem::size_of::<cast_key_st>(),
        132usize,
        concat!("Size of: ", stringify!(cast_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cast_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(cast_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cast_key_st>())).data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cast_key_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cast_key_st>())).short_key as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(cast_key_st), "::", stringify!(short_key))
    );
}
pub type CAST_KEY = cast_key_st;
extern "C" {
    pub fn CAST_set_key(key: *mut CAST_KEY, len: size_t, data: *const u8);
}
extern "C" {
    pub fn CAST_ecb_encrypt(
        in_: *const u8,
        out: *mut u8,
        key: *const CAST_KEY,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CAST_encrypt(data: *mut u32, key: *const CAST_KEY);
}
extern "C" {
    pub fn CAST_decrypt(data: *mut u32, key: *const CAST_KEY);
}
extern "C" {
    pub fn CAST_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        length: size_t,
        ks: *const CAST_KEY,
        iv: *mut u8,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CAST_cfb64_encrypt(
        in_: *const u8,
        out: *mut u8,
        length: size_t,
        schedule: *const CAST_KEY,
        ivec: *mut u8,
        num: *mut ::std::os::raw::c_int,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_chacha_20(
        out: *mut u8,
        in_: *const u8,
        in_len: size_t,
        key: *const u8,
        nonce: *const u8,
        counter: u32,
    );
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_cipherbynid(nid: ::std::os::raw::c_int) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_init(ctx: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cleanup(ctx: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(ctx: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(
        out: *mut EVP_CIPHER_CTX,
        in_: *const EVP_CIPHER_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_reset(ctx: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        engine: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Cipher(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_nid(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_encrypting(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_flags(ctx: *const EVP_CIPHER_CTX) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_mode(ctx: *const EVP_CIPHER_CTX) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        command: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(
        ctx: *mut EVP_CIPHER_CTX,
        pad: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        ctx: *mut EVP_CIPHER_CTX,
        key_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_flags(cipher: *const EVP_CIPHER) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_mode(cipher: *const EVP_CIPHER) -> u32;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const u8,
        data: *const u8,
        data_len: size_t,
        count: ::std::os::raw::c_uint,
        key: *mut u8,
        iv: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_add_cipher_alias(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const ::std::os::raw::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *const EVP_CIPHER_CTX, flags: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    pub cipher: *const EVP_CIPHER,
    pub app_data: *mut ::std::os::raw::c_void,
    pub cipher_data: *mut ::std::os::raw::c_void,
    pub key_len: ::std::os::raw::c_uint,
    pub encrypt: ::std::os::raw::c_int,
    pub flags: u32,
    pub oiv: [u8; 16usize],
    pub iv: [u8; 16usize],
    pub buf: [u8; 32usize],
    pub buf_len: ::std::os::raw::c_int,
    pub num: ::std::os::raw::c_uint,
    pub final_used: ::std::os::raw::c_int,
    pub final_: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_ctx_st>(),
        144usize,
        concat!("Size of: ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).cipher as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(cipher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).app_data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).cipher_data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(cipher_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).key_len as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(key_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).encrypt as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(encrypt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).flags as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).oiv as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(oiv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).iv as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(iv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).buf as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).buf_len as *const _ as usize },
        100usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(buf_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).num as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).final_used as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(final_used))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).final_ as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(evp_cipher_ctx_st), "::", stringify!(final_))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_info_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_info_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).cipher as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_cipher_info_st), "::", stringify!(cipher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).iv as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_cipher_info_st), "::", stringify!(iv))
    );
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    pub nid: ::std::os::raw::c_int,
    pub block_size: ::std::os::raw::c_uint,
    pub key_len: ::std::os::raw::c_uint,
    pub iv_len: ::std::os::raw::c_uint,
    pub ctx_size: ::std::os::raw::c_uint,
    pub flags: u32,
    pub app_data: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_CIPHER_CTX,
            key: *const u8,
            iv: *const u8,
            enc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub cipher: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_CIPHER_CTX,
            out: *mut u8,
            in_: *const u8,
            inl: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX)>,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut EVP_CIPHER_CTX,
            type_: ::std::os::raw::c_int,
            arg: ::std::os::raw::c_int,
            ptr: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_evp_cipher_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_st>(),
        64usize,
        concat!("Size of: ", stringify!(evp_cipher_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).nid as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(nid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).block_size as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(block_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).key_len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(key_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).iv_len as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(iv_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).ctx_size as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(ctx_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).flags as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).app_data as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).init as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).cipher as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(cipher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).cleanup as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(cleanup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).ctrl as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(evp_cipher_st), "::", stringify!(ctrl))
    );
}
extern "C" {
    pub fn AES_CMAC(
        out: *mut u8,
        key: *const u8,
        key_len: size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_config(config_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn OPENSSL_no_config();
}
extern "C" {
    pub fn SHA1_Init(sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Update(
        sha: *mut SHA_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Final(out: *mut u8, sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Transform(sha: *mut SHA_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha_state_st {
    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1,
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sha_state_st__bindgen_ty_1 {
    pub h: [u32; 5usize],
    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha_state_st__bindgen_ty_1__bindgen_ty_1 {
    pub h0: u32,
    pub h1: u32,
    pub h2: u32,
    pub h3: u32,
    pub h4: u32,
}
#[test]
fn bindgen_test_layout_sha_state_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h3 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h4 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h4)
        )
    );
}
#[test]
fn bindgen_test_layout_sha_state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(sha_state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1>())).h as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sha_state_st__bindgen_ty_1), "::", stringify!(h))
    );
}
#[test]
fn bindgen_test_layout_sha_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st>(),
        96usize,
        concat!("Size of: ", stringify!(sha_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nl as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(Nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nh as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(Nh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).data as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).num as *const _ as usize },
        92usize,
        concat!("Offset of field: ", stringify!(sha_state_st), "::", stringify!(num))
    );
}
extern "C" {
    pub fn SHA224_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Update(
        sha: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Update(
        sha: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Transform(sha: *mut SHA256_CTX, block: *const u8);
}
extern "C" {
    pub fn SHA256_TransformBlocks(state: *mut u32, data: *const u8, num_blocks: size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_state_st {
    pub h: [u32; 8usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha256_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha256_state_st>(),
        112usize,
        concat!("Size of: ", stringify!(sha256_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha256_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).h as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nl as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(Nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nh as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(Nh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).data as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).num as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).md_len as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(sha256_state_st), "::", stringify!(md_len))
    );
}
extern "C" {
    pub fn SHA384_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Transform(sha: *mut SHA512_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha512_state_st {
    pub h: [u64; 8usize],
    pub Nl: u64,
    pub Nh: u64,
    pub p: [u8; 128usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha512_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha512_state_st>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha512_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).h as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nl as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(Nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nh as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(Nh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).p as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).num as *const _ as usize },
        208usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).md_len as *const _ as usize },
        212usize,
        concat!("Offset of field: ", stringify!(sha512_state_st), "::", stringify!(md_len))
    );
}
extern "C" {
    pub fn SHA512_256_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256(data: *const u8, len: size_t, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn OPENSSL_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn OPENSSL_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn CRYPTO_memcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_hash32(ptr: *const ::std::os::raw::c_void, len: size_t) -> u32;
}
extern "C" {
    pub fn OPENSSL_strhash(s: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn OPENSSL_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_strnlen(s: *const ::std::os::raw::c_char, len: size_t) -> size_t;
}
extern "C" {
    pub fn OPENSSL_tolower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strcasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strncasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        n: size_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strndup(
        str_: *const ::std::os::raw::c_char,
        size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_memdup(
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OPENSSL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn CRYPTO_malloc(
        size: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_free(
        ptr: *mut ::std::os::raw::c_void,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn OPENSSL_clear_free(ptr: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn CRYPTO_library_init();
}
extern "C" {
    pub fn CRYPTO_is_confidential_build() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_has_asm() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_pre_sandbox_init();
}
extern "C" {
    pub fn CRYPTO_malloc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_malloc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_load_builtin_modules();
}
extern "C" {
    pub fn OPENSSL_init_crypto(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_cleanup();
}
extern "C" {
    pub fn X25519_keypair(out_public_value: *mut u8, out_private_key: *mut u8);
}
extern "C" {
    pub fn X25519_public_from_private(out_public_value: *mut u8, private_key: *const u8);
}
extern "C" {
    pub fn ED25519_keypair(out_public_key: *mut u8, out_private_key: *mut u8);
}
extern "C" {
    pub fn ED25519_sign(
        out_sig: *mut u8,
        message: *const u8,
        message_len: size_t,
        private_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ED25519_verify(
        message: *const u8,
        message_len: size_t,
        signature: *const u8,
        public_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ED25519_keypair_from_seed(
        out_public_key: *mut u8,
        out_private_key: *mut u8,
        seed: *const u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DES_cblock_st {
    pub bytes: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_DES_cblock_st() {
    assert_eq!(
        ::std::mem::size_of::<DES_cblock_st>(),
        8usize,
        concat!("Size of: ", stringify!(DES_cblock_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DES_cblock_st>(),
        1usize,
        concat!("Alignment of ", stringify!(DES_cblock_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DES_cblock_st>())).bytes as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DES_cblock_st), "::", stringify!(bytes))
    );
}
pub type DES_cblock = DES_cblock_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DES_ks {
    pub subkeys: [[u32; 2usize]; 16usize],
}
#[test]
fn bindgen_test_layout_DES_ks() {
    assert_eq!(::std::mem::size_of::<DES_ks>(), 128usize, concat!("Size of: ", stringify!(DES_ks)));
    assert_eq!(
        ::std::mem::align_of::<DES_ks>(),
        4usize,
        concat!("Alignment of ", stringify!(DES_ks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DES_ks>())).subkeys as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DES_ks), "::", stringify!(subkeys))
    );
}
pub type DES_key_schedule = DES_ks;
extern "C" {
    pub fn DES_set_key(key: *const DES_cblock, schedule: *mut DES_key_schedule);
}
extern "C" {
    pub fn DES_set_odd_parity(key: *mut DES_cblock);
}
extern "C" {
    pub fn DES_ecb_encrypt(
        in_: *const DES_cblock,
        out: *mut DES_cblock,
        schedule: *const DES_key_schedule,
        is_encrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ncbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        schedule: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ecb3_encrypt(
        input: *const DES_cblock,
        output: *mut DES_cblock,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ede3_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ede2_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: size_t,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_set_key_unchecked(key: *const DES_cblock, schedule: *mut DES_key_schedule);
}
extern "C" {
    pub fn DES_ede3_cfb64_encrypt(
        in_: *const u8,
        out: *mut u8,
        length: ::std::os::raw::c_long,
        ks1: *mut DES_key_schedule,
        ks2: *mut DES_key_schedule,
        ks3: *mut DES_key_schedule,
        ivec: *mut DES_cblock,
        num: *mut ::std::os::raw::c_int,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ede3_cfb_encrypt(
        in_: *const u8,
        out: *mut u8,
        numbits: ::std::os::raw::c_int,
        length: ::std::os::raw::c_long,
        ks1: *mut DES_key_schedule,
        ks2: *mut DES_key_schedule,
        ks3: *mut DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_decrypt3(
        data: *mut u32,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
    );
}
extern "C" {
    pub fn DES_encrypt3(
        data: *mut u32,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
    );
}
extern "C" {
    pub fn DH_new() -> *mut DH;
}
extern "C" {
    pub fn DH_free(dh: *mut DH);
}
extern "C" {
    pub fn DH_up_ref(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_pub_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_priv_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_p(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_q(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_g(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_key(
        dh: *const DH,
        out_pub_key: *mut *const BIGNUM,
        out_priv_key: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DH_set0_key(
        dh: *mut DH,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_pqg(
        dh: *const DH,
        out_p: *mut *const BIGNUM,
        out_q: *mut *const BIGNUM,
        out_g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DH_set0_pqg(
        dh: *mut DH,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_set_length(dh: *mut DH, priv_length: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_1536(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn DH_get_rfc7919_2048() -> *mut DH;
}
extern "C" {
    pub fn DH_generate_parameters_ex(
        dh: *mut DH,
        prime_bits: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_key(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_padded(
        out: *mut u8,
        peers_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_hashed(
        dh: *mut DH,
        out: *mut u8,
        out_len: *mut size_t,
        max_out_len: size_t,
        peers_key: *const BIGNUM,
        digest: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_size(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_num_bits(dh: *const DH) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DH_check(dh: *const DH, out_flags: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_pub_key(
        dh: *const DH,
        pub_key: *const BIGNUM,
        out_flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_parse_parameters(cbs: *mut CBS) -> *mut DH;
}
extern "C" {
    pub fn DH_marshal_parameters(cbb: *mut CBB, dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_parameters(
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn DH_compute_key(
        out: *mut u8,
        peers_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dh_st {
    pub p: *mut BIGNUM,
    pub g: *mut BIGNUM,
    pub pub_key: *mut BIGNUM,
    pub priv_key: *mut BIGNUM,
    pub priv_length: ::std::os::raw::c_uint,
    pub method_mont_p_lock: CRYPTO_MUTEX,
    pub method_mont_p: *mut BN_MONT_CTX,
    pub q: *mut BIGNUM,
    pub j: *mut BIGNUM,
    pub seed: *mut ::std::os::raw::c_uchar,
    pub seedlen: ::std::os::raw::c_int,
    pub counter: *mut BIGNUM,
    pub flags: ::std::os::raw::c_int,
    pub references: CRYPTO_refcount_t,
}
#[test]
fn bindgen_test_layout_dh_st() {
    assert_eq!(::std::mem::size_of::<dh_st>(), 152usize, concat!("Size of: ", stringify!(dh_st)));
    assert_eq!(
        ::std::mem::align_of::<dh_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dh_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).g as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).pub_key as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(pub_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).priv_key as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(priv_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).priv_length as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(priv_length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).method_mont_p_lock as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(method_mont_p_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).method_mont_p as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(method_mont_p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).q as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).j as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(j))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).seed as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(seed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).seedlen as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(seedlen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).counter as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).flags as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).references as *const _ as usize },
        148usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(references))
    );
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2b256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_get_digestbynid(nid: ::std::os::raw::c_int) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_get_digestbyobj(obj: *const ASN1_OBJECT) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_init(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_new() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_cleanup(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_cleanse(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_free(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(
        out: *mut EVP_MD_CTX,
        in_: *const EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_move(out: *mut EVP_MD_CTX, in_: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_reset(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        engine: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md_out: *mut u8,
        out_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md_out: *mut u8,
        out_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const ::std::os::raw::c_void,
        len: size_t,
        md_out: *mut u8,
        md_out_size: *mut ::std::os::raw::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_flags(md: *const EVP_MD) -> u32;
}
extern "C" {
    pub fn EVP_MD_size(md: *const EVP_MD) -> size_t;
}
extern "C" {
    pub fn EVP_MD_block_size(md: *const EVP_MD) -> size_t;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_size(ctx: *const EVP_MD_CTX) -> size_t;
}
extern "C" {
    pub fn EVP_MD_CTX_block_size(ctx: *const EVP_MD_CTX) -> size_t;
}
extern "C" {
    pub fn EVP_MD_CTX_type(ctx: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_digest_algorithm(cbs: *mut CBS) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_marshal_digest_algorithm(cbb: *mut CBB, md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_digestbyname(arg1: *const ::std::os::raw::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_dss1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_create() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_destroy(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_DigestFinalXOF(
        ctx: *mut EVP_MD_CTX,
        out: *mut u8,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_flags(md: *const EVP_MD) -> u32;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_MD_nid(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_pctx_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_ctx_st {
    pub digest: *const EVP_MD,
    pub md_data: *mut ::std::os::raw::c_void,
    pub pctx: *mut EVP_PKEY_CTX,
    pub pctx_ops: *const evp_md_pctx_ops,
}
#[test]
fn bindgen_test_layout_env_md_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<env_md_ctx_st>(),
        32usize,
        concat!("Size of: ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<env_md_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).digest as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(digest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).md_data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(md_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(pctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx_ops as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(env_md_ctx_st), "::", stringify!(pctx_ops))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openssl_method_common_st {
    pub references: ::std::os::raw::c_int,
    pub is_static: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_openssl_method_common_st() {
    assert_eq!(
        ::std::mem::size_of::<openssl_method_common_st>(),
        8usize,
        concat!("Size of: ", stringify!(openssl_method_common_st))
    );
    assert_eq!(
        ::std::mem::align_of::<openssl_method_common_st>(),
        4usize,
        concat!("Alignment of ", stringify!(openssl_method_common_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<openssl_method_common_st>())).references as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_method_common_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<openssl_method_common_st>())).is_static as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_method_common_st),
            "::",
            stringify!(is_static)
        )
    );
}
extern "C" {
    pub fn DSA_new() -> *mut DSA;
}
extern "C" {
    pub fn DSA_free(dsa: *mut DSA);
}
extern "C" {
    pub fn DSA_up_ref(dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get0_pub_key(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_priv_key(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_p(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_q(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_g(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_key(
        dsa: *const DSA,
        out_pub_key: *mut *const BIGNUM,
        out_priv_key: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DSA_get0_pqg(
        dsa: *const DSA,
        out_p: *mut *const BIGNUM,
        out_q: *mut *const BIGNUM,
        out_g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DSA_set0_key(
        dsa: *mut DSA,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set0_pqg(
        dsa: *mut DSA,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_generate_parameters_ex(
        dsa: *mut DSA,
        bits: ::std::os::raw::c_uint,
        seed: *const u8,
        seed_len: size_t,
        out_counter: *mut ::std::os::raw::c_int,
        out_h: *mut ::std::os::raw::c_ulong,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_generate_key(dsa: *mut DSA) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DSA_SIG_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_DSA_SIG_st() {
    assert_eq!(
        ::std::mem::size_of::<DSA_SIG_st>(),
        16usize,
        concat!("Size of: ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DSA_SIG_st>(),
        8usize,
        concat!("Alignment of ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSA_SIG_st>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DSA_SIG_st), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSA_SIG_st>())).s as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DSA_SIG_st), "::", stringify!(s))
    );
}
extern "C" {
    pub fn DSA_SIG_new() -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_free(sig: *mut DSA_SIG);
}
extern "C" {
    pub fn DSA_SIG_get0(sig: *const DSA_SIG, out_r: *mut *const BIGNUM, out_s: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_SIG_set0(sig: *mut DSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_do_sign(digest: *const u8, digest_len: size_t, dsa: *const DSA) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_verify(
        digest: *const u8,
        digest_len: size_t,
        sig: *mut DSA_SIG,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_do_check_signature(
        out_valid: *mut ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *mut DSA_SIG,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        out_sig: *mut u8,
        out_siglen: *mut ::std::os::raw::c_uint,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_verify(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *const u8,
        sig_len: size_t,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_check_signature(
        out_valid: *mut ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *const u8,
        sig_len: size_t,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_size(dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_SIG_parse(cbs: *mut CBS) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_marshal(cbb: *mut CBB, sig: *const DSA_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_public_key(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_public_key(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_private_key(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_private_key(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_parameters(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_parameters(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_dup_DH(dsa: *const DSA) -> *mut DH;
}
extern "C" {
    pub fn DSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set_ex_data(
        dsa: *mut DSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_ex_data(
        dsa: *const DSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DSA_generate_parameters(
        bits: ::std::os::raw::c_int,
        seed: *mut ::std::os::raw::c_uchar,
        seed_len: ::std::os::raw::c_int,
        counter_ret: *mut ::std::os::raw::c_int,
        h_ret: *mut ::std::os::raw::c_ulong,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_st {
    pub version: ::std::os::raw::c_long,
    pub p: *mut BIGNUM,
    pub q: *mut BIGNUM,
    pub g: *mut BIGNUM,
    pub pub_key: *mut BIGNUM,
    pub priv_key: *mut BIGNUM,
    pub flags: ::std::os::raw::c_int,
    pub method_mont_lock: CRYPTO_MUTEX,
    pub method_mont_p: *mut BN_MONT_CTX,
    pub method_mont_q: *mut BN_MONT_CTX,
    pub references: CRYPTO_refcount_t,
    pub ex_data: CRYPTO_EX_DATA,
}
#[test]
fn bindgen_test_layout_dsa_st() {
    assert_eq!(::std::mem::size_of::<dsa_st>(), 144usize, concat!("Size of: ", stringify!(dsa_st)));
    assert_eq!(
        ::std::mem::align_of::<dsa_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dsa_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).version as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).p as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).q as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).g as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).pub_key as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(pub_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).priv_key as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(priv_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).flags as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).method_mont_lock as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(method_mont_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).method_mont_p as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(method_mont_p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).method_mont_q as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(method_mont_q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).references as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(references))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).ex_data as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(ex_data))
    );
}
pub const point_conversion_form_t_POINT_CONVERSION_COMPRESSED: point_conversion_form_t = 2;
pub const point_conversion_form_t_POINT_CONVERSION_UNCOMPRESSED: point_conversion_form_t = 4;
pub const point_conversion_form_t_POINT_CONVERSION_HYBRID: point_conversion_form_t = 6;
pub type point_conversion_form_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_dup(a: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_cmp(
        a: *const EC_GROUP,
        b: *const EC_GROUP,
        ignored: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_GROUP_get0_order(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_order_bits(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        out_p: *mut BIGNUM,
        out_a: *mut BIGNUM,
        out_b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_copy(dest: *mut EC_POINT, src: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_set_to_infinity(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_is_at_infinity(
        group: *const EC_GROUP,
        point: *const EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut u8,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_POINT_point2cbb(
        out: *mut CBB,
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        buf: *const u8,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_invert(
        group: *const EC_GROUP,
        a: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_order(
        group: *const EC_GROUP,
        order: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
extern "C" {
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: ::std::os::raw::c_int,
    pub comment: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EC_builtin_curve() {
    assert_eq!(
        ::std::mem::size_of::<EC_builtin_curve>(),
        16usize,
        concat!("Size of: ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        ::std::mem::align_of::<EC_builtin_curve>(),
        8usize,
        concat!("Alignment of ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).nid as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(EC_builtin_curve), "::", stringify!(nid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).comment as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(EC_builtin_curve), "::", stringify!(comment))
    );
}
extern "C" {
    pub fn EC_get_builtin_curves(
        out_curves: *mut EC_builtin_curve,
        max_num_curves: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new_method(engine: *const ENGINE) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_is_opaque(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, priv_: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(key: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_check_fips(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *const BIGNUM,
        y: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_key2buf(
        key: *const EC_KEY,
        form: point_conversion_form_t,
        out_buf: *mut *mut ::std::os::raw::c_uchar,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_generate_key_fips(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_derive_from_secret(
        group: *const EC_GROUP,
        secret: *const u8,
        secret_len: size_t,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_parse_private_key(cbs: *mut CBS, group: *const EC_GROUP) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_marshal_private_key(
        cbb: *mut CBB,
        key: *const EC_KEY,
        enc_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_parse_curve_name(cbs: *mut CBS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_marshal_curve_name(
        cbb: *mut CBB,
        group: *const EC_GROUP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_parse_parameters(cbs: *mut CBS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_ex_data(
        r: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_ex_data(
        r: *const EC_KEY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdsa_method_st {
    pub common: openssl_method_common_st,
    pub app_data: *mut ::std::os::raw::c_void,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int>,
    pub finish:
        ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int>,
    pub group_order_size: ::std::option::Option<unsafe extern "C" fn(key: *const EC_KEY) -> size_t>,
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            digest: *const u8,
            digest_len: size_t,
            sig: *mut u8,
            sig_len: *mut ::std::os::raw::c_uint,
            eckey: *mut EC_KEY,
        ) -> ::std::os::raw::c_int,
    >,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ecdsa_method_st() {
    assert_eq!(
        ::std::mem::size_of::<ecdsa_method_st>(),
        56usize,
        concat!("Size of: ", stringify!(ecdsa_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ecdsa_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdsa_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).common as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(common))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).app_data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).init as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).finish as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(finish))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ecdsa_method_st>())).group_order_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(group_order_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).sign as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(sign))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_method_st>())).flags as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(ecdsa_method_st), "::", stringify!(flags))
    );
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(key: *mut EC_KEY, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut ::std::os::raw::c_void,
        outlen: size_t,
        pub_key: *const EC_POINT,
        priv_key: *const EC_KEY,
        kdf: ::std::option::Option<
            unsafe extern "C" fn(
                in_: *const ::std::os::raw::c_void,
                inlen: size_t,
                out: *mut ::std::os::raw::c_void,
                outlen: *mut size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_compute_key_fips(
        out: *mut u8,
        out_len: size_t,
        pub_key: *const EC_POINT,
        priv_key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_sign(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *mut u8,
        sig_len: *mut ::std::os::raw::c_uint,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_verify(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *const u8,
        sig_len: size_t,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_size(key: *const EC_KEY) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdsa_sig_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_ecdsa_sig_st() {
    assert_eq!(
        ::std::mem::size_of::<ecdsa_sig_st>(),
        16usize,
        concat!("Size of: ", stringify!(ecdsa_sig_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ecdsa_sig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdsa_sig_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_sig_st>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ecdsa_sig_st), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ecdsa_sig_st>())).s as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ecdsa_sig_st), "::", stringify!(s))
    );
}
extern "C" {
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    pub fn ECDSA_SIG_get0_r(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0_s(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0(
        sig: *const ECDSA_SIG,
        out_r: *mut *const BIGNUM,
        out_s: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn ECDSA_SIG_set0(
        sig: *mut ECDSA_SIG,
        r: *mut BIGNUM,
        s: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_do_sign(
        digest: *const u8,
        digest_len: size_t,
        key: *const EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_verify(
        digest: *const u8,
        digest_len: size_t,
        sig: *const ECDSA_SIG,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_parse(cbs: *mut CBS) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_from_bytes(in_: *const u8, in_len: size_t) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_marshal(cbb: *mut CBB, sig: *const ECDSA_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut size_t,
        sig: *const ECDSA_SIG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_max_len(order_len: size_t) -> size_t;
}
extern "C" {
    pub fn ECDSA_sign_with_nonce_and_leak_private_key_for_testing(
        digest: *const u8,
        digest_len: size_t,
        eckey: *const EC_KEY,
        nonce: *const u8,
        nonce_len: size_t,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_is_opaque(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(
        to: *mut EVP_PKEY,
        from: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_size(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_bits(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_RSA(pkey: *const EVP_PKEY) -> *mut RSA;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *const EVP_PKEY) -> *mut RSA;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_DSA(pkey: *mut EVP_PKEY, key: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DSA(pkey: *const EVP_PKEY) -> *mut DSA;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *const EVP_PKEY) -> *mut DSA;
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_public_key(cbs: *mut CBS) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_marshal_public_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_private_key(cbs: *mut CBS) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_marshal_private_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key(
        type_: ::std::os::raw::c_int,
        unused: *mut ENGINE,
        in_: *const u8,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key(
        type_: ::std::os::raw::c_int,
        unused: *mut ENGINE,
        in_: *const u8,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_private_key(
        pkey: *const EVP_PKEY,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_public_key(
        pkey: *const EVP_PKEY,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        out_sig: *mut u8,
        out_sig_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSign(
        ctx: *mut EVP_MD_CTX,
        out_sig: *mut u8,
        out_sig_len: *mut size_t,
        data: *const u8,
        data_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerify(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: size_t,
        data: *const u8,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *const EVP_MD_CTX,
        sig: *mut u8,
        out_sig_len: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: size_t,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        password: *const ::std::os::raw::c_char,
        password_len: size_t,
        salt: *const u8,
        salt_len: size_t,
        iterations: ::std::os::raw::c_uint,
        digest: *const EVP_MD,
        key_len: size_t,
        out_key: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        password: *const ::std::os::raw::c_char,
        password_len: size_t,
        salt: *const u8,
        salt_len: size_t,
        iterations: ::std::os::raw::c_uint,
        key_len: size_t,
        out_key: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt(
        password: *const ::std::os::raw::c_char,
        password_len: size_t,
        salt: *const u8,
        salt_len: size_t,
        N: u64,
        r: u64,
        p: u64,
        max_mem: size_t,
        out_key: *mut u8,
        key_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: ::std::os::raw::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut u8,
        sig_len: *mut size_t,
        digest: *const u8,
        digest_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const u8,
        sig_len: size_t,
        digest: *const u8,
        digest_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        in_: *const u8,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        sig: *const u8,
        siglen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut u8,
        out_key_len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(
        ctx: *mut EVP_PKEY_CTX,
        out_pkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(
        ctx: *mut EVP_PKEY_CTX,
        out_pkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_signature_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_signature_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        out_padding: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        out_salt_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_bits(
        ctx: *mut EVP_PKEY_CTX,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_pubexp(
        ctx: *mut EVP_PKEY_CTX,
        e: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_oaep_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_oaep_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        label: *mut u8,
        label_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        out_label: *mut *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
        ctx: *mut EVP_PKEY_CTX,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *const EVP_PKEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_add_all_algorithms_conf();
}
extern "C" {
    pub fn EVP_cleanup();
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_CIPHER,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_MD,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_MD,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_PKEY_get0_DH(pkey: *const EVP_PKEY) -> *mut DH;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *const EVP_PKEY) -> *mut DH;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_param_enc(
        ctx: *mut EVP_PKEY_CTX,
        encoding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        in_: *const u8,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_tls_encodedpoint(pkey: *const EVP_PKEY, out_ptr: *mut *mut u8) -> size_t;
}
extern "C" {
    pub fn EVP_PKEY_base_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_pkey_st {
    pub references: CRYPTO_refcount_t,
    pub type_: ::std::os::raw::c_int,
    pub pkey: evp_pkey_st__bindgen_ty_1,
    pub ameth: *const EVP_PKEY_ASN1_METHOD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evp_pkey_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_void,
    pub rsa: *mut RSA,
    pub dsa: *mut DSA,
    pub dh: *mut DH,
    pub ec: *mut EC_KEY,
}
#[test]
fn bindgen_test_layout_evp_pkey_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).rsa as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(rsa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dsa as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(dsa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dh as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(dh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st__bindgen_ty_1), "::", stringify!(ec))
    );
}
#[test]
fn bindgen_test_layout_evp_pkey_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).references as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(references))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).type_ as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).pkey as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(pkey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).ameth as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(evp_pkey_st), "::", stringify!(ameth))
    );
}
extern "C" {
    pub fn HMAC_CTX_init(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_new() -> *mut HMAC_CTX;
}
extern "C" {
    pub fn HMAC_CTX_cleanup(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_cleanse(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_free(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        key_len: size_t,
        md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Update(
        ctx: *mut HMAC_CTX,
        data: *const u8,
        data_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_size(ctx: *const HMAC_CTX) -> size_t;
}
extern "C" {
    pub fn HMAC_CTX_copy_ex(dest: *mut HMAC_CTX, src: *const HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_reset(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        key_len: ::std::os::raw::c_int,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_copy(dest: *mut HMAC_CTX, src: *const HMAC_CTX) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_ctx_st {
    pub md: *const EVP_MD,
    pub md_ctx: EVP_MD_CTX,
    pub i_ctx: EVP_MD_CTX,
    pub o_ctx: EVP_MD_CTX,
}
#[test]
fn bindgen_test_layout_hmac_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<hmac_ctx_st>(),
        104usize,
        concat!("Size of: ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hmac_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(md))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md_ctx as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(md_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).i_ctx as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(i_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).o_ctx as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(hmac_ctx_st), "::", stringify!(o_ctx))
    );
}
extern "C" {
    pub fn EVP_hpke_x25519_hkdf_sha256() -> *const EVP_HPKE_KEM;
}
extern "C" {
    pub fn EVP_HPKE_KEM_id(kem: *const EVP_HPKE_KEM) -> u16;
}
extern "C" {
    pub fn EVP_hpke_hkdf_sha256() -> *const EVP_HPKE_KDF;
}
extern "C" {
    pub fn EVP_HPKE_KDF_id(kdf: *const EVP_HPKE_KDF) -> u16;
}
extern "C" {
    pub fn EVP_hpke_aes_128_gcm() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_hpke_aes_256_gcm() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_hpke_chacha20_poly1305() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_AEAD_id(aead: *const EVP_HPKE_AEAD) -> u16;
}
extern "C" {
    pub fn EVP_HPKE_AEAD_aead(aead: *const EVP_HPKE_AEAD) -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_KEY_zero(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_cleanup(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_new() -> *mut EVP_HPKE_KEY;
}
extern "C" {
    pub fn EVP_HPKE_KEY_free(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_copy(
        dst: *mut EVP_HPKE_KEY,
        src: *const EVP_HPKE_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_init(
        key: *mut EVP_HPKE_KEY,
        kem: *const EVP_HPKE_KEM,
        priv_key: *const u8,
        priv_key_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_generate(
        key: *mut EVP_HPKE_KEY,
        kem: *const EVP_HPKE_KEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_kem(key: *const EVP_HPKE_KEY) -> *const EVP_HPKE_KEM;
}
extern "C" {
    pub fn EVP_HPKE_KEY_public_key(
        key: *const EVP_HPKE_KEY,
        out: *mut u8,
        out_len: *mut size_t,
        max_out: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_private_key(
        key: *const EVP_HPKE_KEY,
        out: *mut u8,
        out_len: *mut size_t,
        max_out: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_zero(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_cleanup(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_new() -> *mut EVP_HPKE_CTX;
}
extern "C" {
    pub fn EVP_HPKE_CTX_free(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_sender(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut size_t,
        max_enc: size_t,
        kem: *const EVP_HPKE_KEM,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: size_t,
        info: *const u8,
        info_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_sender_with_seed_for_testing(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut size_t,
        max_enc: size_t,
        kem: *const EVP_HPKE_KEM,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: size_t,
        info: *const u8,
        info_len: size_t,
        seed: *const u8,
        seed_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_recipient(
        ctx: *mut EVP_HPKE_CTX,
        key: *const EVP_HPKE_KEY,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        enc: *const u8,
        enc_len: size_t,
        info: *const u8,
        info_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_open(
        ctx: *mut EVP_HPKE_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        max_out_len: size_t,
        in_: *const u8,
        in_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_seal(
        ctx: *mut EVP_HPKE_CTX,
        out: *mut u8,
        out_len: *mut size_t,
        max_out_len: size_t,
        in_: *const u8,
        in_len: size_t,
        ad: *const u8,
        ad_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_export(
        ctx: *const EVP_HPKE_CTX,
        out: *mut u8,
        secret_len: size_t,
        context: *const u8,
        context_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_max_overhead(ctx: *const EVP_HPKE_CTX) -> size_t;
}
extern "C" {
    pub fn EVP_HPKE_CTX_aead(ctx: *const EVP_HPKE_CTX) -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_CTX_kdf(ctx: *const EVP_HPKE_CTX) -> *const EVP_HPKE_KDF;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_hpke_ctx_st {
    pub aead: *const EVP_HPKE_AEAD,
    pub kdf: *const EVP_HPKE_KDF,
    pub aead_ctx: EVP_AEAD_CTX,
    pub base_nonce: [u8; 24usize],
    pub exporter_secret: [u8; 64usize],
    pub seq: u64,
    pub is_sender: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_evp_hpke_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_hpke_ctx_st>(),
        720usize,
        concat!("Size of: ", stringify!(evp_hpke_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_hpke_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_hpke_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).aead as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(aead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).kdf as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(kdf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).aead_ctx as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(aead_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).base_nonce as *const _ as usize },
        616usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(base_nonce))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).exporter_secret as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(exporter_secret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).seq as *const _ as usize },
        704usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(seq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_ctx_st>())).is_sender as *const _ as usize },
        712usize,
        concat!("Offset of field: ", stringify!(evp_hpke_ctx_st), "::", stringify!(is_sender))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_key_st {
    pub kem: *const EVP_HPKE_KEM,
    pub private_key: [u8; 32usize],
    pub public_key: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_evp_hpke_key_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_hpke_key_st>(),
        72usize,
        concat!("Size of: ", stringify!(evp_hpke_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_hpke_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_hpke_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_key_st>())).kem as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(evp_hpke_key_st), "::", stringify!(kem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_key_st>())).private_key as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(evp_hpke_key_st), "::", stringify!(private_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_hpke_key_st>())).public_key as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(evp_hpke_key_st), "::", stringify!(public_key))
    );
}
extern "C" {
    pub fn MD5_Init(md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Update(
        md5: *mut MD5_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Final(out: *mut u8, md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Transform(md5: *mut MD5_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_state_st {
    pub h: [u32; 4usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_md5_state_st() {
    assert_eq!(
        ::std::mem::size_of::<md5_state_st>(),
        92usize,
        concat!("Size of: ", stringify!(md5_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<md5_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<md5_state_st>())).h as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<md5_state_st>())).Nl as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(Nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<md5_state_st>())).Nh as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(Nh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<md5_state_st>())).data as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<md5_state_st>())).num as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(md5_state_st), "::", stringify!(num))
    );
}
extern "C" {
    pub fn CRYPTO_BUFFER_POOL_new() -> *mut CRYPTO_BUFFER_POOL;
}
extern "C" {
    pub fn CRYPTO_BUFFER_POOL_free(pool: *mut CRYPTO_BUFFER_POOL);
}
extern "C" {
    pub fn CRYPTO_BUFFER_new(
        data: *const u8,
        len: size_t,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_alloc(out_data: *mut *mut u8, len: size_t) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_new_from_CBS(
        cbs: *const CBS,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_new_from_static_data_unsafe(
        data: *const u8,
        len: size_t,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_free(buf: *mut CRYPTO_BUFFER);
}
extern "C" {
    pub fn CRYPTO_BUFFER_up_ref(buf: *mut CRYPTO_BUFFER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_BUFFER_data(buf: *const CRYPTO_BUFFER) -> *const u8;
}
extern "C" {
    pub fn CRYPTO_BUFFER_len(buf: *const CRYPTO_BUFFER) -> size_t;
}
extern "C" {
    pub fn CRYPTO_BUFFER_init_CBS(buf: *const CRYPTO_BUFFER, out: *mut CBS);
}
extern "C" {
    pub fn RSA_new() -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_method(engine: *const ENGINE) -> *mut RSA;
}
extern "C" {
    pub fn RSA_free(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_up_ref(rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_bits(rsa: *const RSA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RSA_get0_n(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_e(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_d(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_p(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_q(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmp1(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmq1(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_iqmp(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_key(
        rsa: *const RSA,
        out_n: *mut *const BIGNUM,
        out_e: *mut *const BIGNUM,
        out_d: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_get0_factors(rsa: *const RSA, out_p: *mut *const BIGNUM, out_q: *mut *const BIGNUM);
}
extern "C" {
    pub fn RSA_get0_crt_params(
        rsa: *const RSA,
        out_dmp1: *mut *const BIGNUM,
        out_dmq1: *mut *const BIGNUM,
        out_iqmp: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_set0_key(
        rsa: *mut RSA,
        n: *mut BIGNUM,
        e: *mut BIGNUM,
        d: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_factors(rsa: *mut RSA, p: *mut BIGNUM, q: *mut BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_crt_params(
        rsa: *mut RSA,
        dmp1: *mut BIGNUM,
        dmq1: *mut BIGNUM,
        iqmp: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key_ex(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key_fips(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_encrypt(
        rsa: *mut RSA,
        out_len: *mut size_t,
        out: *mut u8,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_decrypt(
        rsa: *mut RSA,
        out_len: *mut size_t,
        out: *mut u8,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_encrypt(
        flen: size_t,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_decrypt(
        flen: size_t,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign(
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: ::std::os::raw::c_uint,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_pss_mgf1(
        rsa: *mut RSA,
        out_len: *mut size_t,
        out: *mut u8,
        max_out: size_t,
        digest: *const u8,
        digest_len: size_t,
        md: *const EVP_MD,
        mgf1_md: *const EVP_MD,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_raw(
        rsa: *mut RSA,
        out_len: *mut size_t,
        out: *mut u8,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify(
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
        sig: *const u8,
        sig_len: size_t,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_pss_mgf1(
        rsa: *mut RSA,
        digest: *const u8,
        digest_len: size_t,
        md: *const EVP_MD,
        mgf1_md: *const EVP_MD,
        salt_len: ::std::os::raw::c_int,
        sig: *const u8,
        sig_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_raw(
        rsa: *mut RSA,
        out_len: *mut size_t,
        out: *mut u8,
        max_out: size_t,
        in_: *const u8,
        in_len: size_t,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_encrypt(
        flen: size_t,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_decrypt(
        flen: size_t,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_size(rsa: *const RSA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RSA_is_opaque(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_key(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_fips(key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS_mgf1(
        rsa: *const RSA,
        mHash: *const u8,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        EM: *const u8,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS_mgf1(
        rsa: *const RSA,
        EM: *mut u8,
        mHash: *const u8,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP_mgf1(
        to: *mut u8,
        to_len: size_t,
        from: *const u8,
        from_len: size_t,
        param: *const u8,
        param_len: size_t,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_add_pkcs1_prefix(
        out_msg: *mut *mut u8,
        out_msg_len: *mut size_t,
        is_alloced: *mut ::std::os::raw::c_int,
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_parse_public_key(cbs: *mut CBS) -> *mut RSA;
}
extern "C" {
    pub fn RSA_public_key_from_bytes(in_: *const u8, in_len: size_t) -> *mut RSA;
}
extern "C" {
    pub fn RSA_marshal_public_key(cbb: *mut CBB, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_key_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut size_t,
        rsa: *const RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_parse_private_key(cbs: *mut CBS) -> *mut RSA;
}
extern "C" {
    pub fn RSA_private_key_from_bytes(in_: *const u8, in_len: size_t) -> *mut RSA;
}
extern "C" {
    pub fn RSA_marshal_private_key(cbb: *mut CBB, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_key_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut size_t,
        rsa: *const RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_ex_data(
        rsa: *mut RSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_data(
        rsa: *const RSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RSA_flags(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_test_flags(rsa: *const RSA, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_on(rsa: *mut RSA, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key(
        bits: ::std::os::raw::c_int,
        e: ::std::os::raw::c_ulong,
        callback: *mut ::std::os::raw::c_void,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS(
        rsa: *const RSA,
        EM: *mut u8,
        mHash: *const u8,
        Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS(
        rsa: *const RSA,
        mHash: *const u8,
        Hash: *const EVP_MD,
        EM: *const u8,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP(
        to: *mut u8,
        to_len: size_t,
        from: *const u8,
        from_len: size_t,
        param: *const u8,
        param_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_print(
        bio: *mut BIO,
        rsa: *const RSA,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_pss_params(rsa: *const RSA) -> *const RSA_PSS_PARAMS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    pub common: openssl_method_common_st,
    pub app_data: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub size: ::std::option::Option<unsafe extern "C" fn(rsa: *const RSA) -> size_t>,
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            m: *const u8,
            m_length: ::std::os::raw::c_uint,
            sigret: *mut u8,
            siglen: *mut ::std::os::raw::c_uint,
            rsa: *const RSA,
        ) -> ::std::os::raw::c_int,
    >,
    pub sign_raw: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out_len: *mut size_t,
            out: *mut u8,
            max_out: size_t,
            in_: *const u8,
            in_len: size_t,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub decrypt: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out_len: *mut size_t,
            out: *mut u8,
            max_out: size_t,
            in_: *const u8,
            in_len: size_t,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub private_transform: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out: *mut u8,
            in_: *const u8,
            len: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rsa_meth_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_meth_st>(),
        80usize,
        concat!("Size of: ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_meth_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).common as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(common))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).app_data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(app_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).init as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).finish as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(finish))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).size as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).sign as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(sign))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).sign_raw as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(sign_raw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).decrypt as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(decrypt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).private_transform as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(private_transform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).flags as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rsa_meth_st), "::", stringify!(flags))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_blinding_st {
    _unused: [u8; 0],
}
pub type BN_BLINDING = bn_blinding_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsa_st {
    pub meth: *mut RSA_METHOD,
    pub n: *mut BIGNUM,
    pub e: *mut BIGNUM,
    pub d: *mut BIGNUM,
    pub p: *mut BIGNUM,
    pub q: *mut BIGNUM,
    pub dmp1: *mut BIGNUM,
    pub dmq1: *mut BIGNUM,
    pub iqmp: *mut BIGNUM,
    pub ex_data: CRYPTO_EX_DATA,
    pub references: CRYPTO_refcount_t,
    pub flags: ::std::os::raw::c_int,
    pub lock: CRYPTO_MUTEX,
    pub mont_n: *mut BN_MONT_CTX,
    pub mont_p: *mut BN_MONT_CTX,
    pub mont_q: *mut BN_MONT_CTX,
    pub d_fixed: *mut BIGNUM,
    pub dmp1_fixed: *mut BIGNUM,
    pub dmq1_fixed: *mut BIGNUM,
    pub inv_small_mod_large_mont: *mut BIGNUM,
    pub num_blindings: ::std::os::raw::c_uint,
    pub blindings: *mut *mut BN_BLINDING,
    pub blindings_inuse: *mut ::std::os::raw::c_uchar,
    pub blinding_fork_generation: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_rsa_st() {
    assert_eq!(::std::mem::size_of::<rsa_st>(), 240usize, concat!("Size of: ", stringify!(rsa_st)));
    assert_eq!(
        ::std::mem::align_of::<rsa_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).meth as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(meth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).n as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).e as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(e))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).d as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).p as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).q as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1 as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmp1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1 as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmq1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).iqmp as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(iqmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).ex_data as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(ex_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).references as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(references))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).flags as *const _ as usize },
        84usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).lock as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_n as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_p as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).mont_q as *const _ as usize },
        160usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(mont_q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).d_fixed as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d_fixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1_fixed as *const _ as usize },
        176usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmp1_fixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1_fixed as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(dmq1_fixed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).inv_small_mod_large_mont as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(inv_small_mod_large_mont)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).num_blindings as *const _ as usize },
        200usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(num_blindings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings as *const _ as usize },
        208usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).blindings_inuse as *const _ as usize },
        216usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(blindings_inuse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).blinding_fork_generation as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(blinding_fork_generation)
        )
    );
}
impl rsa_st {
    #[inline]
    pub fn private_key_frozen(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_key_frozen(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_key_frozen: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_key_frozen: u32 = unsafe { ::std::mem::transmute(private_key_frozen) };
            private_key_frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    pub algorithm: *mut ASN1_OBJECT,
    pub parameter: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_X509_algor_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_algor_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_algor_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_algor_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_algor_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).algorithm as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(X509_algor_st), "::", stringify!(algorithm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).parameter as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(X509_algor_st), "::", stringify!(parameter))
    );
}
extern "C" {
    pub fn ASN1_digest(
        i2d: i2d_of_void,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_char,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_digest(
        it: *const ASN1_ITEM,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_void,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_verify(
        it: *const ASN1_ITEM,
        algor1: *const X509_ALGOR,
        signature: *const ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign_ctx(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        asn: *mut ::std::os::raw::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKCS82PKEY(p8: *mut PKCS8_PRIV_KEY_INFO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8(pkey: *mut EVP_PKEY) -> *mut PKCS8_PRIV_KEY_INFO;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_pss_params_st {
    pub hashAlgorithm: *mut X509_ALGOR,
    pub maskGenAlgorithm: *mut X509_ALGOR,
    pub saltLength: *mut ASN1_INTEGER,
    pub trailerField: *mut ASN1_INTEGER,
    pub maskHash: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_rsa_pss_params_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_pss_params_st>(),
        40usize,
        concat!("Size of: ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_pss_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).hashAlgorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(hashAlgorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rsa_pss_params_st>())).maskGenAlgorithm as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskGenAlgorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).saltLength as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rsa_pss_params_st), "::", stringify!(saltLength))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).trailerField as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rsa_pss_params_st), "::", stringify!(trailerField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).maskHash as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rsa_pss_params_st), "::", stringify!(maskHash))
    );
}
extern "C" {
    pub fn RSA_PSS_PARAMS_new() -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_free(a: *mut RSA_PSS_PARAMS);
}
extern "C" {
    pub static RSA_PSS_PARAMS_it: ASN1_ITEM;
}
pub type poly1305_state = [u8; 512usize];
extern "C" {
    pub fn CRYPTO_poly1305_init(state: *mut poly1305_state, key: *const u8);
}
extern "C" {
    pub fn CRYPTO_poly1305_update(state: *mut poly1305_state, in_: *const u8, in_len: size_t);
}
extern "C" {
    pub fn CRYPTO_poly1305_finish(state: *mut poly1305_state, mac: *mut u8);
}
extern "C" {
    pub fn RAND_bytes(buf: *mut u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_cleanup();
}
extern "C" {
    pub fn RAND_enable_fork_unsafe_buffering(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RAND_pseudo_bytes(buf: *mut u8, len: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_seed(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RAND_load_file(
        path: *const ::std::os::raw::c_char,
        num: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_file_name(
        buf: *mut ::std::os::raw::c_char,
        num: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn RAND_add(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int, entropy: f64);
}
extern "C" {
    pub fn RAND_egd(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_poll() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_status() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    pub seed: ::std::option::Option<
        unsafe extern "C" fn(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int),
    >,
    pub bytes: ::std::option::Option<
        unsafe extern "C" fn(buf: *mut u8, num: size_t) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            buf: *const ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            entropy: f64,
        ),
    >,
    pub pseudorand: ::std::option::Option<
        unsafe extern "C" fn(buf: *mut u8, num: size_t) -> ::std::os::raw::c_int,
    >,
    pub status: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rand_meth_st() {
    assert_eq!(
        ::std::mem::size_of::<rand_meth_st>(),
        48usize,
        concat!("Size of: ", stringify!(rand_meth_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rand_meth_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rand_meth_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).seed as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(seed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).bytes as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).cleanup as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(cleanup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).add as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(add))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).pseudorand as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(pseudorand))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_meth_st>())).status as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rand_meth_st), "::", stringify!(status))
    );
}
extern "C" {
    pub fn RAND_SSLeay() -> *mut RAND_METHOD;
}
extern "C" {
    pub fn RAND_OpenSSL() -> *mut RAND_METHOD;
}
extern "C" {
    pub fn RAND_get_rand_method() -> *const RAND_METHOD;
}
extern "C" {
    pub fn RAND_set_rand_method(arg1: *const RAND_METHOD) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc4_key_st {
    pub x: u32,
    pub y: u32,
    pub data: [u32; 256usize],
}
#[test]
fn bindgen_test_layout_rc4_key_st() {
    assert_eq!(
        ::std::mem::size_of::<rc4_key_st>(),
        1032usize,
        concat!("Size of: ", stringify!(rc4_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rc4_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(rc4_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc4_key_st>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rc4_key_st), "::", stringify!(data))
    );
}
extern "C" {
    pub fn RC4_set_key(rc4key: *mut RC4_KEY, len: ::std::os::raw::c_uint, key: *const u8);
}
extern "C" {
    pub fn RC4(key: *mut RC4_KEY, len: size_t, in_: *const u8, out: *mut u8);
}
extern "C" {
    pub fn RC4_options() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_load_SSL_strings();
}
extern "C" {
    pub fn BIO_f_ssl() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_ssl(
        bio: *mut BIO,
        ssl: *mut SSL,
        take_owership: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn OPENSSL_init_ssl(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(gp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(fp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(reg_save_area))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock_value {
    pub _address: u8,
}

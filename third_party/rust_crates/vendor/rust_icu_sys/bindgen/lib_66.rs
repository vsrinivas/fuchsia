/* automatically generated by rust-bindgen 0.55.0 */

pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
extern "C" {
    pub fn u_versionFromString_66(
        versionArray: *mut u8,
        versionString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn u_versionFromUString_66(versionArray: *mut u8, versionString: *const UChar);
}
extern "C" {
    pub fn u_versionToString_66(versionArray: *mut u8, versionString: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getVersion_66(versionArray: *mut u8);
}
pub type UDate = f64;
impl UErrorCode {
    pub const U_ERROR_WARNING_START: UErrorCode = UErrorCode::U_USING_FALLBACK_WARNING;
}
impl UErrorCode {
    pub const U_PARSE_ERROR_START: UErrorCode = UErrorCode::U_BAD_VARIABLE_DEFINITION;
}
impl UErrorCode {
    pub const U_FMT_PARSE_ERROR_START: UErrorCode = UErrorCode::U_UNEXPECTED_TOKEN;
}
impl UErrorCode {
    pub const U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = UErrorCode::U_MULTIPLE_DECIMAL_SEPARATORS;
}
impl UErrorCode {
    pub const U_BRK_ERROR_START: UErrorCode = UErrorCode::U_BRK_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_REGEX_ERROR_START: UErrorCode = UErrorCode::U_REGEX_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_IDNA_ERROR_START: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = UErrorCode::U_IDNA_UNASSIGNED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = UErrorCode::U_IDNA_CHECK_BIDI_ERROR;
}
impl UErrorCode {
    pub const U_PLUGIN_TOO_HIGH: UErrorCode = UErrorCode::U_PLUGIN_ERROR_START;
}
impl UErrorCode {
    pub const U_ERROR_LIMIT: UErrorCode = UErrorCode::U_PLUGIN_ERROR_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UErrorCode {
    U_USING_FALLBACK_WARNING = -128,
    U_USING_DEFAULT_WARNING = -127,
    U_SAFECLONE_ALLOCATED_WARNING = -126,
    U_STATE_OLD_WARNING = -125,
    U_STRING_NOT_TERMINATED_WARNING = -124,
    U_SORT_KEY_TOO_SHORT_WARNING = -123,
    U_AMBIGUOUS_ALIAS_WARNING = -122,
    U_DIFFERENT_UCA_VERSION = -121,
    U_PLUGIN_CHANGED_LEVEL_WARNING = -120,
    U_ERROR_WARNING_LIMIT = -119,
    U_ZERO_ERROR = 0,
    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,
    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,
    U_NO_WRITE_PERMISSION = 30,
    U_STANDARD_ERROR_LIMIT = 31,
    U_BAD_VARIABLE_DEFINITION = 65536,
    U_MALFORMED_RULE = 65537,
    U_MALFORMED_SET = 65538,
    U_MALFORMED_SYMBOL_REFERENCE = 65539,
    U_MALFORMED_UNICODE_ESCAPE = 65540,
    U_MALFORMED_VARIABLE_DEFINITION = 65541,
    U_MALFORMED_VARIABLE_REFERENCE = 65542,
    U_MISMATCHED_SEGMENT_DELIMITERS = 65543,
    U_MISPLACED_ANCHOR_START = 65544,
    U_MISPLACED_CURSOR_OFFSET = 65545,
    U_MISPLACED_QUANTIFIER = 65546,
    U_MISSING_OPERATOR = 65547,
    U_MISSING_SEGMENT_CLOSE = 65548,
    U_MULTIPLE_ANTE_CONTEXTS = 65549,
    U_MULTIPLE_CURSORS = 65550,
    U_MULTIPLE_POST_CONTEXTS = 65551,
    U_TRAILING_BACKSLASH = 65552,
    U_UNDEFINED_SEGMENT_REFERENCE = 65553,
    U_UNDEFINED_VARIABLE = 65554,
    U_UNQUOTED_SPECIAL = 65555,
    U_UNTERMINATED_QUOTE = 65556,
    U_RULE_MASK_ERROR = 65557,
    U_MISPLACED_COMPOUND_FILTER = 65558,
    U_MULTIPLE_COMPOUND_FILTERS = 65559,
    U_INVALID_RBT_SYNTAX = 65560,
    U_INVALID_PROPERTY_PATTERN = 65561,
    U_MALFORMED_PRAGMA = 65562,
    U_UNCLOSED_SEGMENT = 65563,
    U_ILLEGAL_CHAR_IN_SEGMENT = 65564,
    U_VARIABLE_RANGE_EXHAUSTED = 65565,
    U_VARIABLE_RANGE_OVERLAP = 65566,
    U_ILLEGAL_CHARACTER = 65567,
    U_INTERNAL_TRANSLITERATOR_ERROR = 65568,
    U_INVALID_ID = 65569,
    U_INVALID_FUNCTION = 65570,
    U_PARSE_ERROR_LIMIT = 65571,
    U_UNEXPECTED_TOKEN = 65792,
    U_MULTIPLE_DECIMAL_SEPARATORS = 65793,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    U_MALFORMED_EXPONENTIAL_PATTERN = 65795,
    U_MULTIPLE_PERCENT_SYMBOLS = 65796,
    U_MULTIPLE_PERMILL_SYMBOLS = 65797,
    U_MULTIPLE_PAD_SPECIFIERS = 65798,
    U_PATTERN_SYNTAX_ERROR = 65799,
    U_ILLEGAL_PAD_POSITION = 65800,
    U_UNMATCHED_BRACES = 65801,
    U_UNSUPPORTED_PROPERTY = 65802,
    U_UNSUPPORTED_ATTRIBUTE = 65803,
    U_ARGUMENT_TYPE_MISMATCH = 65804,
    U_DUPLICATE_KEYWORD = 65805,
    U_UNDEFINED_KEYWORD = 65806,
    U_DEFAULT_KEYWORD_MISSING = 65807,
    U_DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    U_FORMAT_INEXACT_ERROR = 65809,
    U_NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    U_NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    U_FMT_PARSE_ERROR_LIMIT = 65812,
    U_BRK_INTERNAL_ERROR = 66048,
    U_BRK_HEX_DIGITS_EXPECTED = 66049,
    U_BRK_SEMICOLON_EXPECTED = 66050,
    U_BRK_RULE_SYNTAX = 66051,
    U_BRK_UNCLOSED_SET = 66052,
    U_BRK_ASSIGN_ERROR = 66053,
    U_BRK_VARIABLE_REDFINITION = 66054,
    U_BRK_MISMATCHED_PAREN = 66055,
    U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    U_BRK_UNDEFINED_VARIABLE = 66057,
    U_BRK_INIT_ERROR = 66058,
    U_BRK_RULE_EMPTY_SET = 66059,
    U_BRK_UNRECOGNIZED_OPTION = 66060,
    U_BRK_MALFORMED_RULE_TAG = 66061,
    U_BRK_ERROR_LIMIT = 66062,
    U_REGEX_INTERNAL_ERROR = 66304,
    U_REGEX_RULE_SYNTAX = 66305,
    U_REGEX_INVALID_STATE = 66306,
    U_REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    U_REGEX_PROPERTY_SYNTAX = 66308,
    U_REGEX_UNIMPLEMENTED = 66309,
    U_REGEX_MISMATCHED_PAREN = 66310,
    U_REGEX_NUMBER_TOO_BIG = 66311,
    U_REGEX_BAD_INTERVAL = 66312,
    U_REGEX_MAX_LT_MIN = 66313,
    U_REGEX_INVALID_BACK_REF = 66314,
    U_REGEX_INVALID_FLAG = 66315,
    U_REGEX_LOOK_BEHIND_LIMIT = 66316,
    U_REGEX_SET_CONTAINS_STRING = 66317,
    U_REGEX_OCTAL_TOO_BIG = 66318,
    U_REGEX_MISSING_CLOSE_BRACKET = 66319,
    U_REGEX_INVALID_RANGE = 66320,
    U_REGEX_STACK_OVERFLOW = 66321,
    U_REGEX_TIME_OUT = 66322,
    U_REGEX_STOPPED_BY_CALLER = 66323,
    U_REGEX_PATTERN_TOO_BIG = 66324,
    U_REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    U_REGEX_ERROR_LIMIT = 66326,
    U_IDNA_PROHIBITED_ERROR = 66560,
    U_IDNA_UNASSIGNED_ERROR = 66561,
    U_IDNA_CHECK_BIDI_ERROR = 66562,
    U_IDNA_STD3_ASCII_RULES_ERROR = 66563,
    U_IDNA_ACE_PREFIX_ERROR = 66564,
    U_IDNA_VERIFICATION_ERROR = 66565,
    U_IDNA_LABEL_TOO_LONG_ERROR = 66566,
    U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    U_IDNA_ERROR_LIMIT = 66569,
    U_PLUGIN_ERROR_START = 66816,
    U_PLUGIN_DIDNT_SET_LEVEL = 66817,
    U_PLUGIN_ERROR_LIMIT = 66818,
}
extern "C" {
    pub fn u_errorName_66(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uenum_close_66(en: *mut UEnumeration);
}
extern "C" {
    pub fn uenum_count_66(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn uenum_unext_66(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn uenum_next_66(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uenum_reset_66(en: *mut UEnumeration, status: *mut UErrorCode);
}
extern "C" {
    pub fn uenum_openUCharStringsEnumeration_66(
        strings: *const *const UChar,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uenum_openCharStringsEnumeration_66(
        strings: *const *const ::std::os::raw::c_char,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULocDataLocaleType {
    ULOC_ACTUAL_LOCALE = 0,
    ULOC_VALID_LOCALE = 1,
    ULOC_REQUESTED_LOCALE = 2,
    ULOC_DATA_LOCALE_TYPE_LIMIT = 3,
}
extern "C" {
    pub fn uloc_getDefault_66() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_setDefault_66(localeID: *const ::std::os::raw::c_char, status: *mut UErrorCode);
}
extern "C" {
    pub fn uloc_getLanguage_66(
        localeID: *const ::std::os::raw::c_char,
        language: *mut ::std::os::raw::c_char,
        languageCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getScript_66(
        localeID: *const ::std::os::raw::c_char,
        script: *mut ::std::os::raw::c_char,
        scriptCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getCountry_66(
        localeID: *const ::std::os::raw::c_char,
        country: *mut ::std::os::raw::c_char,
        countryCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getVariant_66(
        localeID: *const ::std::os::raw::c_char,
        variant: *mut ::std::os::raw::c_char,
        variantCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getName_66(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_canonicalize_66(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getISO3Language_66(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISO3Country_66(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getLCID_66(localeID: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn uloc_getDisplayLanguage_66(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        language: *mut UChar,
        languageCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayScript_66(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        script: *mut UChar,
        scriptCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayCountry_66(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        country: *mut UChar,
        countryCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayVariant_66(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        variant: *mut UChar,
        variantCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeyword_66(
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeywordValue_66(
        locale: *const ::std::os::raw::c_char,
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayName_66(
        localeID: *const ::std::os::raw::c_char,
        inLocaleID: *const ::std::os::raw::c_char,
        result: *mut UChar,
        maxResultSize: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getAvailable_66(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_countAvailable_66() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULocAvailableType {
    ULOC_AVAILABLE_DEFAULT = 0,
    ULOC_AVAILABLE_ONLY_LEGACY_ALIASES = 1,
    ULOC_AVAILABLE_WITH_LEGACY_ALIASES = 2,
    ULOC_AVAILABLE_COUNT = 3,
}
extern "C" {
    pub fn uloc_openAvailableByType_66(
        type_: ULocAvailableType,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getISOLanguages_66() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISOCountries_66() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getParent_66(
        localeID: *const ::std::os::raw::c_char,
        parent: *mut ::std::os::raw::c_char,
        parentCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getBaseName_66(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_openKeywords_66(
        localeID: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getKeywordValue_66(
        localeID: *const ::std::os::raw::c_char,
        keywordName: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_setKeywordValue_66(
        keywordName: *const ::std::os::raw::c_char,
        keywordValue: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_isRightToLeft_66(locale: *const ::std::os::raw::c_char) -> UBool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULayoutType {
    ULOC_LAYOUT_LTR = 0,
    ULOC_LAYOUT_RTL = 1,
    ULOC_LAYOUT_TTB = 2,
    ULOC_LAYOUT_BTT = 3,
    ULOC_LAYOUT_UNKNOWN = 4,
}
extern "C" {
    pub fn uloc_getCharacterOrientation_66(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
extern "C" {
    pub fn uloc_getLineOrientation_66(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UAcceptResult {
    ULOC_ACCEPT_FAILED = 0,
    ULOC_ACCEPT_VALID = 1,
    ULOC_ACCEPT_FALLBACK = 2,
}
extern "C" {
    pub fn uloc_acceptLanguageFromHTTP_66(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        httpAcceptLanguage: *const ::std::os::raw::c_char,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_acceptLanguage_66(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        acceptList: *mut *const ::std::os::raw::c_char,
        acceptListCount: i32,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getLocaleForLCID_66(
        hostID: u32,
        locale: *mut ::std::os::raw::c_char,
        localeCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_addLikelySubtags_66(
        localeID: *const ::std::os::raw::c_char,
        maximizedLocaleID: *mut ::std::os::raw::c_char,
        maximizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_minimizeSubtags_66(
        localeID: *const ::std::os::raw::c_char,
        minimizedLocaleID: *mut ::std::os::raw::c_char,
        minimizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_forLanguageTag_66(
        langtag: *const ::std::os::raw::c_char,
        localeID: *mut ::std::os::raw::c_char,
        localeIDCapacity: i32,
        parsedLength: *mut i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toLanguageTag_66(
        localeID: *const ::std::os::raw::c_char,
        langtag: *mut ::std::os::raw::c_char,
        langtagCapacity: i32,
        strict: UBool,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleKey_66(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleType_66(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyKey_66(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyType_66(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type UCalendar = *mut ::std::os::raw::c_void;
impl UCalendarType {
    pub const UCAL_DEFAULT: UCalendarType = UCalendarType::UCAL_TRADITIONAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarType {
    UCAL_TRADITIONAL = 0,
    UCAL_GREGORIAN = 1,
}
impl UCalendarDateFields {
    pub const UCAL_DAY_OF_MONTH: UCalendarDateFields = UCalendarDateFields::UCAL_DATE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDateFields {
    UCAL_ERA = 0,
    UCAL_YEAR = 1,
    UCAL_MONTH = 2,
    UCAL_WEEK_OF_YEAR = 3,
    UCAL_WEEK_OF_MONTH = 4,
    UCAL_DATE = 5,
    UCAL_DAY_OF_YEAR = 6,
    UCAL_DAY_OF_WEEK = 7,
    UCAL_DAY_OF_WEEK_IN_MONTH = 8,
    UCAL_AM_PM = 9,
    UCAL_HOUR = 10,
    UCAL_HOUR_OF_DAY = 11,
    UCAL_MINUTE = 12,
    UCAL_SECOND = 13,
    UCAL_MILLISECOND = 14,
    UCAL_ZONE_OFFSET = 15,
    UCAL_DST_OFFSET = 16,
    UCAL_YEAR_WOY = 17,
    UCAL_DOW_LOCAL = 18,
    UCAL_EXTENDED_YEAR = 19,
    UCAL_JULIAN_DAY = 20,
    UCAL_MILLISECONDS_IN_DAY = 21,
    UCAL_IS_LEAP_MONTH = 22,
    UCAL_FIELD_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDaysOfWeek {
    UCAL_SUNDAY = 1,
    UCAL_MONDAY = 2,
    UCAL_TUESDAY = 3,
    UCAL_WEDNESDAY = 4,
    UCAL_THURSDAY = 5,
    UCAL_FRIDAY = 6,
    UCAL_SATURDAY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarMonths {
    UCAL_JANUARY = 0,
    UCAL_FEBRUARY = 1,
    UCAL_MARCH = 2,
    UCAL_APRIL = 3,
    UCAL_MAY = 4,
    UCAL_JUNE = 5,
    UCAL_JULY = 6,
    UCAL_AUGUST = 7,
    UCAL_SEPTEMBER = 8,
    UCAL_OCTOBER = 9,
    UCAL_NOVEMBER = 10,
    UCAL_DECEMBER = 11,
    UCAL_UNDECIMBER = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAMPMs {
    UCAL_AM = 0,
    UCAL_PM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum USystemTimeZoneType {
    UCAL_ZONE_TYPE_ANY = 0,
    UCAL_ZONE_TYPE_CANONICAL = 1,
    UCAL_ZONE_TYPE_CANONICAL_LOCATION = 2,
}
extern "C" {
    pub fn ucal_openTimeZoneIDEnumeration_66(
        zoneType: USystemTimeZoneType,
        region: *const ::std::os::raw::c_char,
        rawOffset: *const i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openTimeZones_66(ec: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openCountryTimeZones_66(
        country: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_getDefaultTimeZone_66(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_setDefaultTimeZone_66(zoneID: *const UChar, ec: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_getHostTimeZone_66(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getDSTSavings_66(zoneID: *const UChar, ec: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucal_getNow_66() -> UDate;
}
extern "C" {
    pub fn ucal_open_66(
        zoneID: *const UChar,
        len: i32,
        locale: *const ::std::os::raw::c_char,
        type_: UCalendarType,
        status: *mut UErrorCode,
    ) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_close_66(cal: *mut UCalendar);
}
extern "C" {
    pub fn ucal_clone_66(cal: *const UCalendar, status: *mut UErrorCode) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_setTimeZone_66(
        cal: *mut UCalendar,
        zoneID: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getTimeZoneID_66(
        cal: *const UCalendar,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDisplayNameType {
    UCAL_STANDARD = 0,
    UCAL_SHORT_STANDARD = 1,
    UCAL_DST = 2,
    UCAL_SHORT_DST = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneDisplayName_66(
        cal: *const UCalendar,
        type_: UCalendarDisplayNameType,
        locale: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_inDaylightTime_66(cal: *const UCalendar, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_setGregorianChange_66(
        cal: *mut UCalendar,
        date: UDate,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getGregorianChange_66(cal: *const UCalendar, pErrorCode: *mut UErrorCode) -> UDate;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAttribute {
    UCAL_LENIENT = 0,
    UCAL_FIRST_DAY_OF_WEEK = 1,
    UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    UCAL_REPEATED_WALL_TIME = 3,
    UCAL_SKIPPED_WALL_TIME = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWallTimeOption {
    UCAL_WALLTIME_LAST = 0,
    UCAL_WALLTIME_FIRST = 1,
    UCAL_WALLTIME_NEXT_VALID = 2,
}
extern "C" {
    pub fn ucal_getAttribute_66(cal: *const UCalendar, attr: UCalendarAttribute) -> i32;
}
extern "C" {
    pub fn ucal_setAttribute_66(cal: *mut UCalendar, attr: UCalendarAttribute, newValue: i32);
}
extern "C" {
    pub fn ucal_getAvailable_66(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_countAvailable_66() -> i32;
}
extern "C" {
    pub fn ucal_getMillis_66(cal: *const UCalendar, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ucal_setMillis_66(cal: *mut UCalendar, dateTime: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_setDate_66(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_setDateTime_66(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        hour: i32,
        minute: i32,
        second: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_equivalentTo_66(cal1: *const UCalendar, cal2: *const UCalendar) -> UBool;
}
extern "C" {
    pub fn ucal_add_66(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_roll_66(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_get_66(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_set_66(cal: *mut UCalendar, field: UCalendarDateFields, value: i32);
}
extern "C" {
    pub fn ucal_isSet_66(cal: *const UCalendar, field: UCalendarDateFields) -> UBool;
}
extern "C" {
    pub fn ucal_clearField_66(cal: *mut UCalendar, field: UCalendarDateFields);
}
extern "C" {
    pub fn ucal_clear_66(calendar: *mut UCalendar);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarLimitType {
    UCAL_MINIMUM = 0,
    UCAL_MAXIMUM = 1,
    UCAL_GREATEST_MINIMUM = 2,
    UCAL_LEAST_MAXIMUM = 3,
    UCAL_ACTUAL_MINIMUM = 4,
    UCAL_ACTUAL_MAXIMUM = 5,
}
extern "C" {
    pub fn ucal_getLimit_66(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        type_: UCalendarLimitType,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getLocaleByType_66(
        cal: *const UCalendar,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getTZDataVersion_66(status: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getCanonicalTimeZoneID_66(
        id: *const UChar,
        len: i32,
        result: *mut UChar,
        resultCapacity: i32,
        isSystemID: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getType_66(
        cal: *const UCalendar,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getKeywordValuesForLocale_66(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWeekdayType {
    UCAL_WEEKDAY = 0,
    UCAL_WEEKEND = 1,
    UCAL_WEEKEND_ONSET = 2,
    UCAL_WEEKEND_CEASE = 3,
}
extern "C" {
    pub fn ucal_getDayOfWeekType_66(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> UCalendarWeekdayType;
}
extern "C" {
    pub fn ucal_getWeekendTransition_66(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_isWeekend_66(cal: *const UCalendar, date: UDate, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_getFieldDifference_66(
        cal: *mut UCalendar,
        target: UDate,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UTimeZoneTransitionType {
    UCAL_TZ_TRANSITION_NEXT = 0,
    UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = 1,
    UCAL_TZ_TRANSITION_PREVIOUS = 2,
    UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneTransitionDate_66(
        cal: *const UCalendar,
        type_: UTimeZoneTransitionType,
        transition: *mut UDate,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn ucal_getWindowsTimeZoneID_66(
        id: *const UChar,
        len: i32,
        winid: *mut UChar,
        winidCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getTimeZoneIDForWindowsID_66(
        winid: *const UChar,
        len: i32,
        region: *const ::std::os::raw::c_char,
        id: *mut UChar,
        idCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_init_66(status: *mut UErrorCode);
}
extern "C" {
    pub fn u_cleanup_66();
}
pub type UMemAllocFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type UMemReallocFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type UMemFreeFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, mem: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn u_setMemoryFunctions_66(
        context: *const ::std::os::raw::c_void,
        a: UMemAllocFn,
        r: UMemReallocFn,
        f: UMemFreeFn,
        status: *mut UErrorCode,
    );
}
pub type UMTX = *mut ::std::os::raw::c_void;
pub type UMtxInitFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        mutex: *mut UMTX,
        status: *mut UErrorCode,
    ),
>;
pub type UMtxFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, mutex: *mut UMTX),
>;
extern "C" {
    pub fn u_setMutexFunctions_66(
        context: *const ::std::os::raw::c_void,
        init: UMtxInitFn,
        destroy: UMtxFn,
        lock: UMtxFn,
        unlock: UMtxFn,
        status: *mut UErrorCode,
    );
}
pub type UMtxAtomicFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, p: *mut i32) -> i32,
>;
extern "C" {
    pub fn u_setAtomicIncDecFunctions_66(
        context: *const ::std::os::raw::c_void,
        inc: UMtxAtomicFn,
        dec: UMtxAtomicFn,
        status: *mut UErrorCode,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharIteratorOrigin {
    UITER_START = 0,
    UITER_CURRENT = 1,
    UITER_LIMIT = 2,
    UITER_ZERO = 3,
    UITER_LENGTH = 4,
}
pub type UCharIteratorGetIndex = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorMove = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, delta: i32, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorHasNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorHasPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorCurrent =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorReserved =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator, something: i32) -> i32>;
pub type UCharIteratorGetState =
    ::std::option::Option<unsafe extern "C" fn(iter: *const UCharIterator) -> u32>;
pub type UCharIteratorSetState = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, state: u32, pErrorCode: *mut UErrorCode),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UCharIterator {
    pub context: *const ::std::os::raw::c_void,
    pub length: i32,
    pub start: i32,
    pub index: i32,
    pub limit: i32,
    pub reservedField: i32,
    pub getIndex: UCharIteratorGetIndex,
    pub move_: UCharIteratorMove,
    pub hasNext: UCharIteratorHasNext,
    pub hasPrevious: UCharIteratorHasPrevious,
    pub current: UCharIteratorCurrent,
    pub next: UCharIteratorNext,
    pub previous: UCharIteratorPrevious,
    pub reservedFn: UCharIteratorReserved,
    pub getState: UCharIteratorGetState,
    pub setState: UCharIteratorSetState,
}
#[test]
fn bindgen_test_layout_UCharIterator() {
    assert_eq!(
        ::std::mem::size_of::<UCharIterator>(),
        112usize,
        concat!("Size of: ", stringify!(UCharIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<UCharIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(UCharIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).start as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).limit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedField as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).move_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasNext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasPrevious as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasPrevious)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).current as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).previous as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedFn as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getState as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).setState as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(setState)
        )
    );
}
impl Default for UCharIterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCPMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
    _unused: [u8; 0],
}
impl UProperty {
    pub const UCHAR_BINARY_START: UProperty = UProperty::UCHAR_ALPHABETIC;
}
impl UProperty {
    pub const UCHAR_INT_START: UProperty = UProperty::UCHAR_BIDI_CLASS;
}
impl UProperty {
    pub const UCHAR_MASK_START: UProperty = UProperty::UCHAR_GENERAL_CATEGORY_MASK;
}
impl UProperty {
    pub const UCHAR_DOUBLE_START: UProperty = UProperty::UCHAR_NUMERIC_VALUE;
}
impl UProperty {
    pub const UCHAR_STRING_START: UProperty = UProperty::UCHAR_AGE;
}
impl UProperty {
    pub const UCHAR_OTHER_PROPERTY_START: UProperty = UProperty::UCHAR_SCRIPT_EXTENSIONS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UProperty {
    UCHAR_ALPHABETIC = 0,
    UCHAR_ASCII_HEX_DIGIT = 1,
    UCHAR_BIDI_CONTROL = 2,
    UCHAR_BIDI_MIRRORED = 3,
    UCHAR_DASH = 4,
    UCHAR_DEFAULT_IGNORABLE_CODE_POINT = 5,
    UCHAR_DEPRECATED = 6,
    UCHAR_DIACRITIC = 7,
    UCHAR_EXTENDER = 8,
    UCHAR_FULL_COMPOSITION_EXCLUSION = 9,
    UCHAR_GRAPHEME_BASE = 10,
    UCHAR_GRAPHEME_EXTEND = 11,
    UCHAR_GRAPHEME_LINK = 12,
    UCHAR_HEX_DIGIT = 13,
    UCHAR_HYPHEN = 14,
    UCHAR_ID_CONTINUE = 15,
    UCHAR_ID_START = 16,
    UCHAR_IDEOGRAPHIC = 17,
    UCHAR_IDS_BINARY_OPERATOR = 18,
    UCHAR_IDS_TRINARY_OPERATOR = 19,
    UCHAR_JOIN_CONTROL = 20,
    UCHAR_LOGICAL_ORDER_EXCEPTION = 21,
    UCHAR_LOWERCASE = 22,
    UCHAR_MATH = 23,
    UCHAR_NONCHARACTER_CODE_POINT = 24,
    UCHAR_QUOTATION_MARK = 25,
    UCHAR_RADICAL = 26,
    UCHAR_SOFT_DOTTED = 27,
    UCHAR_TERMINAL_PUNCTUATION = 28,
    UCHAR_UNIFIED_IDEOGRAPH = 29,
    UCHAR_UPPERCASE = 30,
    UCHAR_WHITE_SPACE = 31,
    UCHAR_XID_CONTINUE = 32,
    UCHAR_XID_START = 33,
    UCHAR_CASE_SENSITIVE = 34,
    UCHAR_S_TERM = 35,
    UCHAR_VARIATION_SELECTOR = 36,
    UCHAR_NFD_INERT = 37,
    UCHAR_NFKD_INERT = 38,
    UCHAR_NFC_INERT = 39,
    UCHAR_NFKC_INERT = 40,
    UCHAR_SEGMENT_STARTER = 41,
    UCHAR_PATTERN_SYNTAX = 42,
    UCHAR_PATTERN_WHITE_SPACE = 43,
    UCHAR_POSIX_ALNUM = 44,
    UCHAR_POSIX_BLANK = 45,
    UCHAR_POSIX_GRAPH = 46,
    UCHAR_POSIX_PRINT = 47,
    UCHAR_POSIX_XDIGIT = 48,
    UCHAR_CASED = 49,
    UCHAR_CASE_IGNORABLE = 50,
    UCHAR_CHANGES_WHEN_LOWERCASED = 51,
    UCHAR_CHANGES_WHEN_UPPERCASED = 52,
    UCHAR_CHANGES_WHEN_TITLECASED = 53,
    UCHAR_CHANGES_WHEN_CASEFOLDED = 54,
    UCHAR_CHANGES_WHEN_CASEMAPPED = 55,
    UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    UCHAR_EMOJI = 57,
    UCHAR_EMOJI_PRESENTATION = 58,
    UCHAR_EMOJI_MODIFIER = 59,
    UCHAR_EMOJI_MODIFIER_BASE = 60,
    UCHAR_EMOJI_COMPONENT = 61,
    UCHAR_REGIONAL_INDICATOR = 62,
    UCHAR_PREPENDED_CONCATENATION_MARK = 63,
    UCHAR_EXTENDED_PICTOGRAPHIC = 64,
    UCHAR_BINARY_LIMIT = 65,
    UCHAR_BIDI_CLASS = 4096,
    UCHAR_BLOCK = 4097,
    UCHAR_CANONICAL_COMBINING_CLASS = 4098,
    UCHAR_DECOMPOSITION_TYPE = 4099,
    UCHAR_EAST_ASIAN_WIDTH = 4100,
    UCHAR_GENERAL_CATEGORY = 4101,
    UCHAR_JOINING_GROUP = 4102,
    UCHAR_JOINING_TYPE = 4103,
    UCHAR_LINE_BREAK = 4104,
    UCHAR_NUMERIC_TYPE = 4105,
    UCHAR_SCRIPT = 4106,
    UCHAR_HANGUL_SYLLABLE_TYPE = 4107,
    UCHAR_NFD_QUICK_CHECK = 4108,
    UCHAR_NFKD_QUICK_CHECK = 4109,
    UCHAR_NFC_QUICK_CHECK = 4110,
    UCHAR_NFKC_QUICK_CHECK = 4111,
    UCHAR_LEAD_CANONICAL_COMBINING_CLASS = 4112,
    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    UCHAR_GRAPHEME_CLUSTER_BREAK = 4114,
    UCHAR_SENTENCE_BREAK = 4115,
    UCHAR_WORD_BREAK = 4116,
    UCHAR_BIDI_PAIRED_BRACKET_TYPE = 4117,
    UCHAR_INDIC_POSITIONAL_CATEGORY = 4118,
    UCHAR_INDIC_SYLLABIC_CATEGORY = 4119,
    UCHAR_VERTICAL_ORIENTATION = 4120,
    UCHAR_INT_LIMIT = 4121,
    UCHAR_GENERAL_CATEGORY_MASK = 8192,
    UCHAR_MASK_LIMIT = 8193,
    UCHAR_NUMERIC_VALUE = 12288,
    UCHAR_DOUBLE_LIMIT = 12289,
    UCHAR_AGE = 16384,
    UCHAR_BIDI_MIRRORING_GLYPH = 16385,
    UCHAR_CASE_FOLDING = 16386,
    UCHAR_ISO_COMMENT = 16387,
    UCHAR_LOWERCASE_MAPPING = 16388,
    UCHAR_NAME = 16389,
    UCHAR_SIMPLE_CASE_FOLDING = 16390,
    UCHAR_SIMPLE_LOWERCASE_MAPPING = 16391,
    UCHAR_SIMPLE_TITLECASE_MAPPING = 16392,
    UCHAR_SIMPLE_UPPERCASE_MAPPING = 16393,
    UCHAR_TITLECASE_MAPPING = 16394,
    UCHAR_UNICODE_1_NAME = 16395,
    UCHAR_UPPERCASE_MAPPING = 16396,
    UCHAR_BIDI_PAIRED_BRACKET = 16397,
    UCHAR_STRING_LIMIT = 16398,
    UCHAR_SCRIPT_EXTENSIONS = 28672,
    UCHAR_OTHER_PROPERTY_LIMIT = 28673,
    UCHAR_INVALID_CODE = -1,
}
impl UCharCategory {
    pub const U_GENERAL_OTHER_TYPES: UCharCategory = UCharCategory::U_UNASSIGNED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharCategory {
    U_UNASSIGNED = 0,
    U_UPPERCASE_LETTER = 1,
    U_LOWERCASE_LETTER = 2,
    U_TITLECASE_LETTER = 3,
    U_MODIFIER_LETTER = 4,
    U_OTHER_LETTER = 5,
    U_NON_SPACING_MARK = 6,
    U_ENCLOSING_MARK = 7,
    U_COMBINING_SPACING_MARK = 8,
    U_DECIMAL_DIGIT_NUMBER = 9,
    U_LETTER_NUMBER = 10,
    U_OTHER_NUMBER = 11,
    U_SPACE_SEPARATOR = 12,
    U_LINE_SEPARATOR = 13,
    U_PARAGRAPH_SEPARATOR = 14,
    U_CONTROL_CHAR = 15,
    U_FORMAT_CHAR = 16,
    U_PRIVATE_USE_CHAR = 17,
    U_SURROGATE = 18,
    U_DASH_PUNCTUATION = 19,
    U_START_PUNCTUATION = 20,
    U_END_PUNCTUATION = 21,
    U_CONNECTOR_PUNCTUATION = 22,
    U_OTHER_PUNCTUATION = 23,
    U_MATH_SYMBOL = 24,
    U_CURRENCY_SYMBOL = 25,
    U_MODIFIER_SYMBOL = 26,
    U_OTHER_SYMBOL = 27,
    U_INITIAL_PUNCTUATION = 28,
    U_FINAL_PUNCTUATION = 29,
    U_CHAR_CATEGORY_COUNT = 30,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharDirection {
    U_LEFT_TO_RIGHT = 0,
    U_RIGHT_TO_LEFT = 1,
    U_EUROPEAN_NUMBER = 2,
    U_EUROPEAN_NUMBER_SEPARATOR = 3,
    U_EUROPEAN_NUMBER_TERMINATOR = 4,
    U_ARABIC_NUMBER = 5,
    U_COMMON_NUMBER_SEPARATOR = 6,
    U_BLOCK_SEPARATOR = 7,
    U_SEGMENT_SEPARATOR = 8,
    U_WHITE_SPACE_NEUTRAL = 9,
    U_OTHER_NEUTRAL = 10,
    U_LEFT_TO_RIGHT_EMBEDDING = 11,
    U_LEFT_TO_RIGHT_OVERRIDE = 12,
    U_RIGHT_TO_LEFT_ARABIC = 13,
    U_RIGHT_TO_LEFT_EMBEDDING = 14,
    U_RIGHT_TO_LEFT_OVERRIDE = 15,
    U_POP_DIRECTIONAL_FORMAT = 16,
    U_DIR_NON_SPACING_MARK = 17,
    U_BOUNDARY_NEUTRAL = 18,
    U_FIRST_STRONG_ISOLATE = 19,
    U_LEFT_TO_RIGHT_ISOLATE = 20,
    U_RIGHT_TO_LEFT_ISOLATE = 21,
    U_POP_DIRECTIONAL_ISOLATE = 22,
    U_CHAR_DIRECTION_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharNameChoice {
    U_UNICODE_CHAR_NAME = 0,
    U_UNICODE_10_CHAR_NAME = 1,
    U_EXTENDED_CHAR_NAME = 2,
    U_CHAR_NAME_ALIAS = 3,
    U_CHAR_NAME_CHOICE_COUNT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME = 0,
    U_LONG_PROPERTY_NAME = 1,
    U_PROPERTY_NAME_CHOICE_COUNT = 2,
}
extern "C" {
    pub fn u_hasBinaryProperty_66(c: UChar32, which: UProperty) -> UBool;
}
extern "C" {
    pub fn u_getBinaryPropertySet_66(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const USet;
}
extern "C" {
    pub fn u_isUAlphabetic_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isULowercase_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUUppercase_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUWhiteSpace_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_getIntPropertyValue_66(c: UChar32, which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMinValue_66(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMaxValue_66(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMap_66(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const UCPMap;
}
extern "C" {
    pub fn u_getNumericValue_66(c: UChar32) -> f64;
}
extern "C" {
    pub fn u_islower_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isupper_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_istitle_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdigit_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalpha_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalnum_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isxdigit_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_ispunct_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isgraph_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isblank_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdefined_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isspace_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaSpaceChar_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isWhitespace_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_iscntrl_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isISOControl_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isprint_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isbase_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charDirection_66(c: UChar32) -> UCharDirection;
}
extern "C" {
    pub fn u_isMirrored_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charMirror_66(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_getBidiPairedBracket_66(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_charType_66(c: UChar32) -> i8;
}
pub type UCharEnumTypeRange = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        start: UChar32,
        limit: UChar32,
        type_: UCharCategory,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharTypes_66(
        enumRange: UCharEnumTypeRange,
        context: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn u_getCombiningClass_66(c: UChar32) -> u8;
}
extern "C" {
    pub fn u_charDigitValue_66(c: UChar32) -> i32;
}
extern "C" {
    pub fn u_charName_66(
        code: UChar32,
        nameChoice: UCharNameChoice,
        buffer: *mut ::std::os::raw::c_char,
        bufferLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_getISOComment_66(
        c: UChar32,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_charFromName_66(
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> UChar32;
}
pub type UEnumCharNamesFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        code: UChar32,
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        length: i32,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharNames_66(
        start: UChar32,
        limit: UChar32,
        fn_: UEnumCharNamesFn,
        context: *mut ::std::os::raw::c_void,
        nameChoice: UCharNameChoice,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_getPropertyName_66(
        property: UProperty,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyEnum_66(alias: *const ::std::os::raw::c_char) -> UProperty;
}
extern "C" {
    pub fn u_getPropertyValueName_66(
        property: UProperty,
        value: i32,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyValueEnum_66(
        property: UProperty,
        alias: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn u_isIDStart_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDPart_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDIgnorable_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDStart_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDPart_66(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_tolower_66(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_toupper_66(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_totitle_66(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_foldCase_66(c: UChar32, options: u32) -> UChar32;
}
extern "C" {
    pub fn u_digit_66(ch: UChar32, radix: i8) -> i32;
}
extern "C" {
    pub fn u_forDigit_66(digit: i32, radix: i8) -> UChar32;
}
extern "C" {
    pub fn u_charAge_66(c: UChar32, versionArray: *mut u8);
}
extern "C" {
    pub fn u_getUnicodeVersion_66(versionArray: *mut u8);
}
extern "C" {
    pub fn u_getFC_NFKC_Closure_66(
        c: UChar32,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum USetSpanCondition {
    USET_SPAN_NOT_CONTAINED = 0,
    USET_SPAN_CONTAINED = 1,
    USET_SPAN_SIMPLE = 2,
    USET_SPAN_CONDITION_COUNT = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UParseError {
    pub line: i32,
    pub offset: i32,
    pub preContext: [UChar; 16usize],
    pub postContext: [UChar; 16usize],
}
#[test]
fn bindgen_test_layout_UParseError() {
    assert_eq!(
        ::std::mem::size_of::<UParseError>(),
        72usize,
        concat!("Size of: ", stringify!(UParseError))
    );
    assert_eq!(
        ::std::mem::align_of::<UParseError>(),
        4usize,
        concat!("Alignment of ", stringify!(UParseError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).preContext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(preContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).postContext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(postContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCollator {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCollationResult {
    UCOL_EQUAL = 0,
    UCOL_GREATER = 1,
    UCOL_LESS = -1,
}
impl UColAttributeValue {
    pub const UCOL_DEFAULT_STRENGTH: UColAttributeValue = UColAttributeValue::UCOL_TERTIARY;
}
impl UColAttributeValue {
    pub const UCOL_QUATERNARY: UColAttributeValue = UColAttributeValue::UCOL_CE_STRENGTH_LIMIT;
}
impl UColAttributeValue {
    pub const UCOL_OFF: UColAttributeValue = UColAttributeValue::UCOL_STRENGTH_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UColAttributeValue {
    UCOL_DEFAULT = -1,
    UCOL_PRIMARY = 0,
    UCOL_SECONDARY = 1,
    UCOL_TERTIARY = 2,
    UCOL_CE_STRENGTH_LIMIT = 3,
    UCOL_IDENTICAL = 15,
    UCOL_STRENGTH_LIMIT = 16,
    UCOL_ON = 17,
    UCOL_SHIFTED = 20,
    UCOL_NON_IGNORABLE = 21,
    UCOL_LOWER_FIRST = 24,
    UCOL_UPPER_FIRST = 25,
    UCOL_ATTRIBUTE_VALUE_COUNT = 26,
}
impl UColReorderCode {
    pub const UCOL_REORDER_CODE_OTHERS: UColReorderCode = UColReorderCode::UCOL_REORDER_CODE_NONE;
}
impl UColReorderCode {
    pub const UCOL_REORDER_CODE_FIRST: UColReorderCode = UColReorderCode::UCOL_REORDER_CODE_SPACE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UColReorderCode {
    UCOL_REORDER_CODE_DEFAULT = -1,
    UCOL_REORDER_CODE_NONE = 103,
    UCOL_REORDER_CODE_SPACE = 4096,
    UCOL_REORDER_CODE_PUNCTUATION = 4097,
    UCOL_REORDER_CODE_SYMBOL = 4098,
    UCOL_REORDER_CODE_CURRENCY = 4099,
    UCOL_REORDER_CODE_DIGIT = 4100,
    UCOL_REORDER_CODE_LIMIT = 4101,
}
pub use self::UColAttributeValue as UCollationStrength;
impl UColAttribute {
    pub const UCOL_DECOMPOSITION_MODE: UColAttribute = UColAttribute::UCOL_NORMALIZATION_MODE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UColAttribute {
    UCOL_FRENCH_COLLATION = 0,
    UCOL_ALTERNATE_HANDLING = 1,
    UCOL_CASE_FIRST = 2,
    UCOL_CASE_LEVEL = 3,
    UCOL_NORMALIZATION_MODE = 4,
    UCOL_STRENGTH = 5,
    UCOL_HIRAGANA_QUATERNARY_MODE = 6,
    UCOL_NUMERIC_COLLATION = 7,
    UCOL_ATTRIBUTE_COUNT = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UColRuleOption {
    UCOL_TAILORING_ONLY = 0,
    UCOL_FULL_RULES = 1,
}
extern "C" {
    pub fn ucol_open_66(
        loc: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_openRules_66(
        rules: *const UChar,
        rulesLength: i32,
        normalizationMode: UColAttributeValue,
        strength: UCollationStrength,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_openFromShortString_66(
        definition: *const ::std::os::raw::c_char,
        forceDefaults: UBool,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_getContractions_66(
        coll: *const UCollator,
        conts: *mut USet,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getContractionsAndExpansions_66(
        coll: *const UCollator,
        contractions: *mut USet,
        expansions: *mut USet,
        addPrefixes: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_close_66(coll: *mut UCollator);
}
extern "C" {
    pub fn ucol_strcoll_66(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_strcollUTF8_66(
        coll: *const UCollator,
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        target: *const ::std::os::raw::c_char,
        targetLength: i32,
        status: *mut UErrorCode,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_greater_66(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_greaterOrEqual_66(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_equal_66(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_strcollIter_66(
        coll: *const UCollator,
        sIter: *mut UCharIterator,
        tIter: *mut UCharIterator,
        status: *mut UErrorCode,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_getStrength_66(coll: *const UCollator) -> UCollationStrength;
}
extern "C" {
    pub fn ucol_setStrength_66(coll: *mut UCollator, strength: UCollationStrength);
}
extern "C" {
    pub fn ucol_getReorderCodes_66(
        coll: *const UCollator,
        dest: *mut i32,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_setReorderCodes_66(
        coll: *mut UCollator,
        reorderCodes: *const i32,
        reorderCodesLength: i32,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getEquivalentReorderCodes_66(
        reorderCode: i32,
        dest: *mut i32,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getDisplayName_66(
        objLoc: *const ::std::os::raw::c_char,
        dispLoc: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getAvailable_66(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_countAvailable_66() -> i32;
}
extern "C" {
    pub fn ucol_openAvailableLocales_66(status: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywords_66(status: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywordValues_66(
        keyword: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywordValuesForLocale_66(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getFunctionalEquivalent_66(
        result: *mut ::std::os::raw::c_char,
        resultCapacity: i32,
        keyword: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        isAvailable: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getRules_66(coll: *const UCollator, length: *mut i32) -> *const UChar;
}
extern "C" {
    pub fn ucol_getShortDefinitionString_66(
        coll: *const UCollator,
        locale: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_normalizeShortDefinitionString_66(
        source: *const ::std::os::raw::c_char,
        destination: *mut ::std::os::raw::c_char,
        capacity: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getSortKey_66(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        result: *mut u8,
        resultLength: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_nextSortKeyPart_66(
        coll: *const UCollator,
        iter: *mut UCharIterator,
        state: *mut u32,
        dest: *mut u8,
        count: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UColBoundMode {
    UCOL_BOUND_LOWER = 0,
    UCOL_BOUND_UPPER = 1,
    UCOL_BOUND_UPPER_LONG = 2,
    UCOL_BOUND_VALUE_COUNT = 3,
}
extern "C" {
    pub fn ucol_getBound_66(
        source: *const u8,
        sourceLength: i32,
        boundType: UColBoundMode,
        noOfLevels: u32,
        result: *mut u8,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getVersion_66(coll: *const UCollator, info: *mut u8);
}
extern "C" {
    pub fn ucol_getUCAVersion_66(coll: *const UCollator, info: *mut u8);
}
extern "C" {
    pub fn ucol_mergeSortkeys_66(
        src1: *const u8,
        src1Length: i32,
        src2: *const u8,
        src2Length: i32,
        dest: *mut u8,
        destCapacity: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_setAttribute_66(
        coll: *mut UCollator,
        attr: UColAttribute,
        value: UColAttributeValue,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getAttribute_66(
        coll: *const UCollator,
        attr: UColAttribute,
        status: *mut UErrorCode,
    ) -> UColAttributeValue;
}
extern "C" {
    pub fn ucol_setMaxVariable_66(
        coll: *mut UCollator,
        group: UColReorderCode,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getMaxVariable_66(coll: *const UCollator) -> UColReorderCode;
}
extern "C" {
    pub fn ucol_setVariableTop_66(
        coll: *mut UCollator,
        varTop: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    ) -> u32;
}
extern "C" {
    pub fn ucol_getVariableTop_66(coll: *const UCollator, status: *mut UErrorCode) -> u32;
}
extern "C" {
    pub fn ucol_restoreVariableTop_66(coll: *mut UCollator, varTop: u32, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucol_safeClone_66(
        coll: *const UCollator,
        stackBuffer: *mut ::std::os::raw::c_void,
        pBufferSize: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_getRulesEx_66(
        coll: *const UCollator,
        delta: UColRuleOption,
        buffer: *mut UChar,
        bufferLen: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getLocale_66(
        coll: *const UCollator,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_getLocaleByType_66(
        coll: *const UCollator,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_getTailoredSet_66(coll: *const UCollator, status: *mut UErrorCode) -> *mut USet;
}
extern "C" {
    pub fn ucol_getUnsafeSet_66(
        coll: *const UCollator,
        unsafe_: *mut USet,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_prepareShortStringOpen_66(
        definition: *const ::std::os::raw::c_char,
        forceDefaults: UBool,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_cloneBinary_66(
        coll: *const UCollator,
        buffer: *mut u8,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_openBinary_66(
        bin: *const u8,
        length: i32,
        base: *const UCollator,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UFieldPosition {
    pub field: i32,
    pub beginIndex: i32,
    pub endIndex: i32,
}
#[test]
fn bindgen_test_layout_UFieldPosition() {
    assert_eq!(
        ::std::mem::size_of::<UFieldPosition>(),
        12usize,
        concat!("Size of: ", stringify!(UFieldPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UFieldPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UFieldPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).field as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).beginIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(beginIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).endIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(endIndex)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UFormattableType {
    UFMT_DATE = 0,
    UFMT_DOUBLE = 1,
    UFMT_LONG = 2,
    UFMT_STRING = 3,
    UFMT_ARRAY = 4,
    UFMT_INT64 = 5,
    UFMT_OBJECT = 6,
    UFMT_COUNT = 7,
}
pub type UFormattable = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn ufmt_open_66(status: *mut UErrorCode) -> *mut UFormattable;
}
extern "C" {
    pub fn ufmt_close_66(fmt: *mut UFormattable);
}
extern "C" {
    pub fn ufmt_getType_66(fmt: *const UFormattable, status: *mut UErrorCode) -> UFormattableType;
}
extern "C" {
    pub fn ufmt_isNumeric_66(fmt: *const UFormattable) -> UBool;
}
extern "C" {
    pub fn ufmt_getDate_66(fmt: *const UFormattable, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ufmt_getDouble_66(fmt: *mut UFormattable, status: *mut UErrorCode) -> f64;
}
extern "C" {
    pub fn ufmt_getLong_66(fmt: *mut UFormattable, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ufmt_getInt64_66(fmt: *mut UFormattable, status: *mut UErrorCode) -> i64;
}
extern "C" {
    pub fn ufmt_getObject_66(
        fmt: *const UFormattable,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ufmt_getUChars_66(
        fmt: *mut UFormattable,
        len: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn ufmt_getArrayLength_66(fmt: *const UFormattable, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ufmt_getArrayItemByIndex_66(
        fmt: *mut UFormattable,
        n: i32,
        status: *mut UErrorCode,
    ) -> *mut UFormattable;
}
extern "C" {
    pub fn ufmt_getDecNumChars_66(
        fmt: *mut UFormattable,
        len: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContextType {
    UDISPCTX_TYPE_DIALECT_HANDLING = 0,
    UDISPCTX_TYPE_CAPITALIZATION = 1,
    UDISPCTX_TYPE_DISPLAY_LENGTH = 2,
    UDISPCTX_TYPE_SUBSTITUTE_HANDLING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContext {
    UDISPCTX_STANDARD_NAMES = 0,
    UDISPCTX_DIALECT_NAMES = 1,
    UDISPCTX_CAPITALIZATION_NONE = 256,
    UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    UDISPCTX_CAPITALIZATION_FOR_STANDALONE = 260,
    UDISPCTX_LENGTH_FULL = 512,
    UDISPCTX_LENGTH_SHORT = 513,
    UDISPCTX_SUBSTITUTE = 768,
    UDISPCTX_NO_SUBSTITUTE = 769,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFieldPositionIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ufieldpositer_open_66(status: *mut UErrorCode) -> *mut UFieldPositionIterator;
}
extern "C" {
    pub fn ufieldpositer_close_66(fpositer: *mut UFieldPositionIterator);
}
extern "C" {
    pub fn ufieldpositer_next_66(
        fpositer: *mut UFieldPositionIterator,
        beginIndex: *mut i32,
        endIndex: *mut i32,
    ) -> i32;
}
pub type UNumberFormat = *mut ::std::os::raw::c_void;
impl UNumberFormatStyle {
    pub const UNUM_DEFAULT: UNumberFormatStyle = UNumberFormatStyle::UNUM_DECIMAL;
}
impl UNumberFormatStyle {
    pub const UNUM_IGNORE: UNumberFormatStyle = UNumberFormatStyle::UNUM_PATTERN_DECIMAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UNumberFormatStyle {
    UNUM_PATTERN_DECIMAL = 0,
    UNUM_DECIMAL = 1,
    UNUM_CURRENCY = 2,
    UNUM_PERCENT = 3,
    UNUM_SCIENTIFIC = 4,
    UNUM_SPELLOUT = 5,
    UNUM_ORDINAL = 6,
    UNUM_DURATION = 7,
    UNUM_NUMBERING_SYSTEM = 8,
    UNUM_PATTERN_RULEBASED = 9,
    UNUM_CURRENCY_ISO = 10,
    UNUM_CURRENCY_PLURAL = 11,
    UNUM_CURRENCY_ACCOUNTING = 12,
    UNUM_CASH_CURRENCY = 13,
    UNUM_DECIMAL_COMPACT_SHORT = 14,
    UNUM_DECIMAL_COMPACT_LONG = 15,
    UNUM_CURRENCY_STANDARD = 16,
    UNUM_FORMAT_STYLE_COUNT = 17,
}
extern "C" {
    pub fn unum_open_66(
        style: UNumberFormatStyle,
        pattern: *const UChar,
        patternLength: i32,
        locale: *const ::std::os::raw::c_char,
        parseErr: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UNumberFormat;
}
extern "C" {
    pub fn unum_close_66(fmt: *mut UNumberFormat);
}
extern "C" {
    pub fn unum_clone_66(fmt: *const UNumberFormat, status: *mut UErrorCode) -> *mut UNumberFormat;
}
extern "C" {
    pub fn unum_format_66(
        fmt: *const UNumberFormat,
        number: i32,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatInt64_66(
        fmt: *const UNumberFormat,
        number: i64,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDouble_66(
        fmt: *const UNumberFormat,
        number: f64,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDoubleForFields_66(
        format: *const UNumberFormat,
        number: f64,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDecimal_66(
        fmt: *const UNumberFormat,
        number: *const ::std::os::raw::c_char,
        length: i32,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDoubleCurrency_66(
        fmt: *const UNumberFormat,
        number: f64,
        currency: *mut UChar,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatUFormattable_66(
        fmt: *const UNumberFormat,
        number: *const UFormattable,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parse_66(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parseInt64_66(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> i64;
}
extern "C" {
    pub fn unum_parseDouble_66(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> f64;
}
extern "C" {
    pub fn unum_parseDecimal_66(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        outBuf: *mut ::std::os::raw::c_char,
        outBufLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parseDoubleCurrency_66(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        currency: *mut UChar,
        status: *mut UErrorCode,
    ) -> f64;
}
extern "C" {
    pub fn unum_parseToUFormattable_66(
        fmt: *const UNumberFormat,
        result: *mut UFormattable,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UFormattable;
}
extern "C" {
    pub fn unum_applyPattern_66(
        format: *mut UNumberFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getAvailable_66(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unum_countAvailable_66() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UNumberFormatAttribute {
    UNUM_PARSE_INT_ONLY = 0,
    UNUM_GROUPING_USED = 1,
    UNUM_DECIMAL_ALWAYS_SHOWN = 2,
    UNUM_MAX_INTEGER_DIGITS = 3,
    UNUM_MIN_INTEGER_DIGITS = 4,
    UNUM_INTEGER_DIGITS = 5,
    UNUM_MAX_FRACTION_DIGITS = 6,
    UNUM_MIN_FRACTION_DIGITS = 7,
    UNUM_FRACTION_DIGITS = 8,
    UNUM_MULTIPLIER = 9,
    UNUM_GROUPING_SIZE = 10,
    UNUM_ROUNDING_MODE = 11,
    UNUM_ROUNDING_INCREMENT = 12,
    UNUM_FORMAT_WIDTH = 13,
    UNUM_PADDING_POSITION = 14,
    UNUM_SECONDARY_GROUPING_SIZE = 15,
    UNUM_SIGNIFICANT_DIGITS_USED = 16,
    UNUM_MIN_SIGNIFICANT_DIGITS = 17,
    UNUM_MAX_SIGNIFICANT_DIGITS = 18,
    UNUM_LENIENT_PARSE = 19,
    UNUM_PARSE_ALL_INPUT = 20,
    UNUM_SCALE = 21,
    UNUM_MINIMUM_GROUPING_DIGITS = 22,
    UNUM_CURRENCY_USAGE = 23,
    UNUM_MAX_NONBOOLEAN_ATTRIBUTE = 4095,
    UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = 4096,
    UNUM_PARSE_NO_EXPONENT = 4097,
    UNUM_PARSE_DECIMAL_MARK_REQUIRED = 4098,
    UNUM_PARSE_CASE_SENSITIVE = 4099,
    UNUM_SIGN_ALWAYS_SHOWN = 4100,
    UNUM_LIMIT_BOOLEAN_ATTRIBUTE = 4101,
}
extern "C" {
    pub fn unum_getAttribute_66(fmt: *const UNumberFormat, attr: UNumberFormatAttribute) -> i32;
}
extern "C" {
    pub fn unum_setAttribute_66(
        fmt: *mut UNumberFormat,
        attr: UNumberFormatAttribute,
        newValue: i32,
    );
}
extern "C" {
    pub fn unum_getDoubleAttribute_66(
        fmt: *const UNumberFormat,
        attr: UNumberFormatAttribute,
    ) -> f64;
}
extern "C" {
    pub fn unum_setDoubleAttribute_66(
        fmt: *mut UNumberFormat,
        attr: UNumberFormatAttribute,
        newValue: f64,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UNumberFormatTextAttribute {
    UNUM_POSITIVE_PREFIX = 0,
    UNUM_POSITIVE_SUFFIX = 1,
    UNUM_NEGATIVE_PREFIX = 2,
    UNUM_NEGATIVE_SUFFIX = 3,
    UNUM_PADDING_CHARACTER = 4,
    UNUM_CURRENCY_CODE = 5,
    UNUM_DEFAULT_RULESET = 6,
    UNUM_PUBLIC_RULESETS = 7,
}
extern "C" {
    pub fn unum_getTextAttribute_66(
        fmt: *const UNumberFormat,
        tag: UNumberFormatTextAttribute,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_setTextAttribute_66(
        fmt: *mut UNumberFormat,
        tag: UNumberFormatTextAttribute,
        newValue: *const UChar,
        newValueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_toPattern_66(
        fmt: *const UNumberFormat,
        isPatternLocalized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UNumberFormatSymbol {
    UNUM_DECIMAL_SEPARATOR_SYMBOL = 0,
    UNUM_GROUPING_SEPARATOR_SYMBOL = 1,
    UNUM_PATTERN_SEPARATOR_SYMBOL = 2,
    UNUM_PERCENT_SYMBOL = 3,
    UNUM_ZERO_DIGIT_SYMBOL = 4,
    UNUM_DIGIT_SYMBOL = 5,
    UNUM_MINUS_SIGN_SYMBOL = 6,
    UNUM_PLUS_SIGN_SYMBOL = 7,
    UNUM_CURRENCY_SYMBOL = 8,
    UNUM_INTL_CURRENCY_SYMBOL = 9,
    UNUM_MONETARY_SEPARATOR_SYMBOL = 10,
    UNUM_EXPONENTIAL_SYMBOL = 11,
    UNUM_PERMILL_SYMBOL = 12,
    UNUM_PAD_ESCAPE_SYMBOL = 13,
    UNUM_INFINITY_SYMBOL = 14,
    UNUM_NAN_SYMBOL = 15,
    UNUM_SIGNIFICANT_DIGIT_SYMBOL = 16,
    UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL = 17,
    UNUM_ONE_DIGIT_SYMBOL = 18,
    UNUM_TWO_DIGIT_SYMBOL = 19,
    UNUM_THREE_DIGIT_SYMBOL = 20,
    UNUM_FOUR_DIGIT_SYMBOL = 21,
    UNUM_FIVE_DIGIT_SYMBOL = 22,
    UNUM_SIX_DIGIT_SYMBOL = 23,
    UNUM_SEVEN_DIGIT_SYMBOL = 24,
    UNUM_EIGHT_DIGIT_SYMBOL = 25,
    UNUM_NINE_DIGIT_SYMBOL = 26,
    UNUM_EXPONENT_MULTIPLICATION_SYMBOL = 27,
    UNUM_FORMAT_SYMBOL_COUNT = 28,
}
extern "C" {
    pub fn unum_getSymbol_66(
        fmt: *const UNumberFormat,
        symbol: UNumberFormatSymbol,
        buffer: *mut UChar,
        size: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_setSymbol_66(
        fmt: *mut UNumberFormat,
        symbol: UNumberFormatSymbol,
        value: *const UChar,
        length: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getLocaleByType_66(
        fmt: *const UNumberFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unum_setContext_66(
        fmt: *mut UNumberFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getContext_66(
        fmt: *const UNumberFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
pub type UDateFormat = *mut ::std::os::raw::c_void;
impl UDateFormatStyle {
    pub const UDAT_DEFAULT: UDateFormatStyle = UDateFormatStyle::UDAT_MEDIUM;
}
impl UDateFormatStyle {
    pub const UDAT_FULL_RELATIVE: UDateFormatStyle = UDateFormatStyle::UDAT_RELATIVE;
}
impl UDateFormatStyle {
    pub const UDAT_IGNORE: UDateFormatStyle = UDateFormatStyle::UDAT_PATTERN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatStyle {
    UDAT_FULL = 0,
    UDAT_LONG = 1,
    UDAT_MEDIUM = 2,
    UDAT_SHORT = 3,
    UDAT_RELATIVE = 128,
    UDAT_LONG_RELATIVE = 129,
    UDAT_MEDIUM_RELATIVE = 130,
    UDAT_SHORT_RELATIVE = 131,
    UDAT_NONE = -1,
    UDAT_PATTERN = -2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatField {
    UDAT_ERA_FIELD = 0,
    UDAT_YEAR_FIELD = 1,
    UDAT_MONTH_FIELD = 2,
    UDAT_DATE_FIELD = 3,
    UDAT_HOUR_OF_DAY1_FIELD = 4,
    UDAT_HOUR_OF_DAY0_FIELD = 5,
    UDAT_MINUTE_FIELD = 6,
    UDAT_SECOND_FIELD = 7,
    UDAT_FRACTIONAL_SECOND_FIELD = 8,
    UDAT_DAY_OF_WEEK_FIELD = 9,
    UDAT_DAY_OF_YEAR_FIELD = 10,
    UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    UDAT_WEEK_OF_YEAR_FIELD = 12,
    UDAT_WEEK_OF_MONTH_FIELD = 13,
    UDAT_AM_PM_FIELD = 14,
    UDAT_HOUR1_FIELD = 15,
    UDAT_HOUR0_FIELD = 16,
    UDAT_TIMEZONE_FIELD = 17,
    UDAT_YEAR_WOY_FIELD = 18,
    UDAT_DOW_LOCAL_FIELD = 19,
    UDAT_EXTENDED_YEAR_FIELD = 20,
    UDAT_JULIAN_DAY_FIELD = 21,
    UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
    UDAT_TIMEZONE_RFC_FIELD = 23,
    UDAT_TIMEZONE_GENERIC_FIELD = 24,
    UDAT_STANDALONE_DAY_FIELD = 25,
    UDAT_STANDALONE_MONTH_FIELD = 26,
    UDAT_QUARTER_FIELD = 27,
    UDAT_STANDALONE_QUARTER_FIELD = 28,
    UDAT_TIMEZONE_SPECIAL_FIELD = 29,
    UDAT_YEAR_NAME_FIELD = 30,
    UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    UDAT_TIMEZONE_ISO_FIELD = 32,
    UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
    UDAT_RELATED_YEAR_FIELD = 34,
    UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
    UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
    UDAT_TIME_SEPARATOR_FIELD = 37,
    UDAT_FIELD_COUNT = 38,
}
extern "C" {
    pub fn udat_toCalendarDateField_66(field: UDateFormatField) -> UCalendarDateFields;
}
extern "C" {
    pub fn udat_open_66(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_close_66(format: *mut UDateFormat);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatBooleanAttribute {
    UDAT_PARSE_ALLOW_WHITESPACE = 0,
    UDAT_PARSE_ALLOW_NUMERIC = 1,
    UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
    UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4,
}
extern "C" {
    pub fn udat_getBooleanAttribute_66(
        fmt: *const UDateFormat,
        attr: UDateFormatBooleanAttribute,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn udat_setBooleanAttribute_66(
        fmt: *mut UDateFormat,
        attr: UDateFormatBooleanAttribute,
        newValue: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_clone_66(fmt: *const UDateFormat, status: *mut UErrorCode) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_format_66(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendar_66(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatForFields_66(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendarForFields_66(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_parse_66(
        format: *const UDateFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> UDate;
}
extern "C" {
    pub fn udat_parseCalendar_66(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_isLenient_66(fmt: *const UDateFormat) -> UBool;
}
extern "C" {
    pub fn udat_setLenient_66(fmt: *mut UDateFormat, isLenient: UBool);
}
extern "C" {
    pub fn udat_getCalendar_66(fmt: *const UDateFormat) -> *const UCalendar;
}
extern "C" {
    pub fn udat_setCalendar_66(fmt: *mut UDateFormat, calendarToSet: *const UCalendar);
}
extern "C" {
    pub fn udat_getNumberFormat_66(fmt: *const UDateFormat) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_getNumberFormatForField_66(
        fmt: *const UDateFormat,
        field: UChar,
    ) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_adoptNumberFormatForFields_66(
        fmt: *mut UDateFormat,
        fields: *const UChar,
        numberFormatToSet: *mut UNumberFormat,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_setNumberFormat_66(fmt: *mut UDateFormat, numberFormatToSet: *const UNumberFormat);
}
extern "C" {
    pub fn udat_adoptNumberFormat_66(
        fmt: *mut UDateFormat,
        numberFormatToAdopt: *mut UNumberFormat,
    );
}
extern "C" {
    pub fn udat_getAvailable_66(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_countAvailable_66() -> i32;
}
extern "C" {
    pub fn udat_get2DigitYearStart_66(fmt: *const UDateFormat, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn udat_set2DigitYearStart_66(fmt: *mut UDateFormat, d: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_toPattern_66(
        fmt: *const UDateFormat,
        localized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPattern_66(
        format: *mut UDateFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatSymbolType {
    UDAT_ERAS = 0,
    UDAT_MONTHS = 1,
    UDAT_SHORT_MONTHS = 2,
    UDAT_WEEKDAYS = 3,
    UDAT_SHORT_WEEKDAYS = 4,
    UDAT_AM_PMS = 5,
    UDAT_LOCALIZED_CHARS = 6,
    UDAT_ERA_NAMES = 7,
    UDAT_NARROW_MONTHS = 8,
    UDAT_NARROW_WEEKDAYS = 9,
    UDAT_STANDALONE_MONTHS = 10,
    UDAT_STANDALONE_SHORT_MONTHS = 11,
    UDAT_STANDALONE_NARROW_MONTHS = 12,
    UDAT_STANDALONE_WEEKDAYS = 13,
    UDAT_STANDALONE_SHORT_WEEKDAYS = 14,
    UDAT_STANDALONE_NARROW_WEEKDAYS = 15,
    UDAT_QUARTERS = 16,
    UDAT_SHORT_QUARTERS = 17,
    UDAT_STANDALONE_QUARTERS = 18,
    UDAT_STANDALONE_SHORT_QUARTERS = 19,
    UDAT_SHORTER_WEEKDAYS = 20,
    UDAT_STANDALONE_SHORTER_WEEKDAYS = 21,
    UDAT_CYCLIC_YEARS_WIDE = 22,
    UDAT_CYCLIC_YEARS_ABBREVIATED = 23,
    UDAT_CYCLIC_YEARS_NARROW = 24,
    UDAT_ZODIAC_NAMES_WIDE = 25,
    UDAT_ZODIAC_NAMES_ABBREVIATED = 26,
    UDAT_ZODIAC_NAMES_NARROW = 27,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDateFormatSymbols {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udat_getSymbols_66(
        fmt: *const UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_countSymbols_66(fmt: *const UDateFormat, type_: UDateFormatSymbolType) -> i32;
}
extern "C" {
    pub fn udat_setSymbols_66(
        format: *mut UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        value: *mut UChar,
        valueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getLocaleByType_66(
        fmt: *const UDateFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_setContext_66(
        fmt: *mut UDateFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getContext_66(
        fmt: *const UDateFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
extern "C" {
    pub fn udat_toPatternRelativeDate_66(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_toPatternRelativeTime_66(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPatternRelative_66(
        format: *mut UDateFormat,
        datePattern: *const UChar,
        datePatternLength: i32,
        timePattern: *const UChar,
        timePatternLength: i32,
        status: *mut UErrorCode,
    );
}
pub type UDateFormatOpener = ::std::option::Option<
    unsafe extern "C" fn(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat,
>;
extern "C" {
    pub fn udat_registerOpener_66(opener: UDateFormatOpener, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_unregisterOpener_66(
        opener: UDateFormatOpener,
        status: *mut UErrorCode,
    ) -> UDateFormatOpener;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UDataInfo {
    pub size: u16,
    pub reservedWord: u16,
    pub isBigEndian: u8,
    pub charsetFamily: u8,
    pub sizeofUChar: u8,
    pub reservedByte: u8,
    pub dataFormat: [u8; 4usize],
    pub formatVersion: [u8; 4usize],
    pub dataVersion: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_UDataInfo() {
    assert_eq!(
        ::std::mem::size_of::<UDataInfo>(),
        20usize,
        concat!("Size of: ", stringify!(UDataInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<UDataInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedWord as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).isBigEndian as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(isBigEndian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).charsetFamily as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(charsetFamily)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).sizeofUChar as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(sizeofUChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedByte as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedByte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataFormat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).formatVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(formatVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDataMemory {
    _unused: [u8; 0],
}
pub type UDataMemoryIsAcceptable = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pInfo: *const UDataInfo,
    ) -> UBool,
>;
extern "C" {
    pub fn udata_open_66(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_openChoice_66(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isAcceptable: UDataMemoryIsAcceptable,
        context: *mut ::std::os::raw::c_void,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_close_66(pData: *mut UDataMemory);
}
extern "C" {
    pub fn udata_getMemory_66(pData: *mut UDataMemory) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn udata_getInfo_66(pData: *mut UDataMemory, pInfo: *mut UDataInfo);
}
extern "C" {
    pub fn udata_setCommonData_66(data: *const ::std::os::raw::c_void, err: *mut UErrorCode);
}
extern "C" {
    pub fn udata_setAppData_66(
        packageName: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
impl UDataFileAccess {
    pub const UDATA_DEFAULT_ACCESS: UDataFileAccess = UDataFileAccess::UDATA_FILES_FIRST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDataFileAccess {
    UDATA_FILES_FIRST = 0,
    UDATA_ONLY_PACKAGES = 1,
    UDATA_PACKAGES_FIRST = 2,
    UDATA_NO_FILES = 3,
    UDATA_FILE_ACCESS_COUNT = 4,
}
extern "C" {
    pub fn udata_setFileAccess_66(access: UDataFileAccess, status: *mut UErrorCode);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UFieldCategory {
    UFIELD_CATEGORY_UNDEFINED = 0,
    UFIELD_CATEGORY_DATE = 1,
    UFIELD_CATEGORY_NUMBER = 2,
    UFIELD_CATEGORY_LIST = 3,
    UFIELD_CATEGORY_RELATIVE_DATETIME = 4,
    UFIELD_CATEGORY_DATE_INTERVAL = 5,
    UFIELD_CATEGORY_COUNT = 6,
    UFIELD_CATEGORY_LIST_SPAN = 4099,
    UFIELD_CATEGORY_DATE_INTERVAL_SPAN = 4101,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UListFormatter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedList {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UListFormatterField {
    ULISTFMT_LITERAL_FIELD = 0,
    ULISTFMT_ELEMENT_FIELD = 1,
}
extern "C" {
    pub fn ulistfmt_open_66(
        locale: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UListFormatter;
}
extern "C" {
    pub fn ulistfmt_close_66(listfmt: *mut UListFormatter);
}
extern "C" {
    pub fn ulistfmt_openResult_66(ec: *mut UErrorCode) -> *mut UFormattedList;
}
extern "C" {
    pub fn ulistfmt_resultAsValue_66(
        uresult: *const UFormattedList,
        ec: *mut UErrorCode,
    ) -> *const UFormattedValue;
}
extern "C" {
    pub fn ulistfmt_closeResult_66(uresult: *mut UFormattedList);
}
extern "C" {
    pub fn ulistfmt_format_66(
        listfmt: *const UListFormatter,
        strings: *const *const UChar,
        stringLengths: *const i32,
        stringCount: i32,
        result: *mut UChar,
        resultCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ulistfmt_formatStringsToResult_66(
        listfmt: *const UListFormatter,
        strings: *const *const UChar,
        stringLengths: *const i32,
        stringCount: i32,
        uresult: *mut UFormattedList,
        status: *mut UErrorCode,
    );
}
pub type va_list = __builtin_va_list;
extern "C" {
    pub fn u_formatMessage_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn u_vformatMessage_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_parseMessage_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn u_vparseMessage_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_formatMessageWithError_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn u_vformatMessageWithError_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        parseError: *mut UParseError,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_parseMessageWithError_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn u_vparseMessageWithError_66(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        ap: *mut __va_list_tag,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
pub type UMessageFormat = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn umsg_open_66(
        pattern: *const UChar,
        patternLength: i32,
        locale: *const ::std::os::raw::c_char,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UMessageFormat;
}
extern "C" {
    pub fn umsg_close_66(format: *mut UMessageFormat);
}
extern "C" {
    pub fn umsg_clone_66(fmt: *const UMessageFormat, status: *mut UErrorCode) -> UMessageFormat;
}
extern "C" {
    pub fn umsg_setLocale_66(fmt: *mut UMessageFormat, locale: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn umsg_getLocale_66(fmt: *const UMessageFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn umsg_applyPattern_66(
        fmt: *mut UMessageFormat,
        pattern: *const UChar,
        patternLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umsg_toPattern_66(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn umsg_format_66(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn umsg_vformat_66(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn umsg_parse_66(
        fmt: *const UMessageFormat,
        source: *const UChar,
        sourceLength: i32,
        count: *mut i32,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn umsg_vparse_66(
        fmt: *const UMessageFormat,
        source: *const UChar,
        sourceLength: i32,
        count: *mut i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umsg_autoQuoteApostrophe_66(
        pattern: *const UChar,
        patternLength: i32,
        dest: *mut UChar,
        destCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UNumberFormatter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedNumber {
    _unused: [u8; 0],
}
extern "C" {
    pub fn unumf_openForSkeletonAndLocale_66(
        skeleton: *const UChar,
        skeletonLen: i32,
        locale: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UNumberFormatter;
}
extern "C" {
    pub fn unumf_openForSkeletonAndLocaleWithError_66(
        skeleton: *const UChar,
        skeletonLen: i32,
        locale: *const ::std::os::raw::c_char,
        perror: *mut UParseError,
        ec: *mut UErrorCode,
    ) -> *mut UNumberFormatter;
}
extern "C" {
    pub fn unumf_openResult_66(ec: *mut UErrorCode) -> *mut UFormattedNumber;
}
extern "C" {
    pub fn unumf_formatInt_66(
        uformatter: *const UNumberFormatter,
        value: i64,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_formatDouble_66(
        uformatter: *const UNumberFormatter,
        value: f64,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_formatDecimal_66(
        uformatter: *const UNumberFormatter,
        value: *const ::std::os::raw::c_char,
        valueLen: i32,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_resultAsValue_66(
        uresult: *const UFormattedNumber,
        ec: *mut UErrorCode,
    ) -> *const UFormattedValue;
}
extern "C" {
    pub fn unumf_resultToString_66(
        uresult: *const UFormattedNumber,
        buffer: *mut UChar,
        bufferCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unumf_resultNextFieldPosition_66(
        uresult: *const UFormattedNumber,
        ufpos: *mut UFieldPosition,
        ec: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn unumf_resultGetAllFieldPositions_66(
        uresult: *const UFormattedNumber,
        ufpositer: *mut UFieldPositionIterator,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_close_66(uformatter: *mut UNumberFormatter);
}
extern "C" {
    pub fn unumf_closeResult_66(uresult: *mut UFormattedNumber);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UPluralType {
    UPLURAL_TYPE_CARDINAL = 0,
    UPLURAL_TYPE_ORDINAL = 1,
    UPLURAL_TYPE_COUNT = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UPluralRules {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uplrules_open_66(
        locale: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UPluralRules;
}
extern "C" {
    pub fn uplrules_openForType_66(
        locale: *const ::std::os::raw::c_char,
        type_: UPluralType,
        status: *mut UErrorCode,
    ) -> *mut UPluralRules;
}
extern "C" {
    pub fn uplrules_close_66(uplrules: *mut UPluralRules);
}
extern "C" {
    pub fn uplrules_select_66(
        uplrules: *const UPluralRules,
        number: f64,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_selectFormatted_66(
        uplrules: *const UPluralRules,
        number: *const UFormattedNumber,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_selectWithFormat_66(
        uplrules: *const UPluralRules,
        number: f64,
        fmt: *const UNumberFormat,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_getKeywords_66(
        uplrules: *const UPluralRules,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn u_getDataDirectory_66() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setDataDirectory_66(directory: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getTimeZoneFilesDirectory_66(status: *mut UErrorCode)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setTimeZoneFilesDirectory_66(
        path: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_charsToUChars_66(cs: *const ::std::os::raw::c_char, us: *mut UChar, length: i32);
}
extern "C" {
    pub fn u_UCharsToChars_66(us: *const UChar, cs: *mut ::std::os::raw::c_char, length: i32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UBreakIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn u_strlen_66(s: *const UChar) -> i32;
}
extern "C" {
    pub fn u_countChar32_66(s: *const UChar, length: i32) -> i32;
}
extern "C" {
    pub fn u_strHasMoreChar32Than_66(s: *const UChar, length: i32, number: i32) -> UBool;
}
extern "C" {
    pub fn u_strcat_66(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncat_66(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_strstr_66(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindFirst_66(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr_66(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr32_66(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strrstr_66(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindLast_66(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr_66(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr32_66(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strpbrk_66(string: *const UChar, matchSet: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strcspn_66(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strspn_66(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strtok_r_66(
        src: *mut UChar,
        delim: *const UChar,
        saveState: *mut *mut UChar,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strcmp_66(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strcmpCodePointOrder_66(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strCompare_66(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCompareIter_66(
        iter1: *mut UCharIterator,
        iter2: *mut UCharIterator,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCaseCompare_66(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strncmp_66(ucs1: *const UChar, ucs2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strncmpCodePointOrder_66(s1: *const UChar, s2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strcasecmp_66(s1: *const UChar, s2: *const UChar, options: u32) -> i32;
}
extern "C" {
    pub fn u_strncasecmp_66(s1: *const UChar, s2: *const UChar, n: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_memcasecmp_66(s1: *const UChar, s2: *const UChar, length: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_strcpy_66(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncpy_66(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrcpy_66(dst: *mut UChar, src: *const ::std::os::raw::c_char) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrncpy_66(
        dst: *mut UChar,
        src: *const ::std::os::raw::c_char,
        n: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_austrcpy_66(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_austrncpy_66(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
        n: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_memcpy_66(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memmove_66(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memset_66(dest: *mut UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memcmp_66(buf1: *const UChar, buf2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memcmpCodePointOrder_66(s1: *const UChar, s2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memchr_66(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memchr32_66(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr_66(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr32_66(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_unescape_66(
        src: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
    ) -> i32;
}
pub type UNESCAPE_CHAR_AT = ::std::option::Option<
    unsafe extern "C" fn(offset: i32, context: *mut ::std::os::raw::c_void) -> UChar,
>;
extern "C" {
    pub fn u_unescapeAt_66(
        charAt: UNESCAPE_CHAR_AT,
        offset: *mut i32,
        length: i32,
        context: *mut ::std::os::raw::c_void,
    ) -> UChar32;
}
extern "C" {
    pub fn u_strToUpper_66(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToLower_66(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToTitle_66(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        titleIter: *mut UBreakIterator,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strFoldCase_66(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToWCS_66(
        dest: *mut wchar_t,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn u_strFromWCS_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const wchar_t,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8_66(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8WithSub_66(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8WithSub_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strFromUTF8Lenient_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32_66(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32WithSub_66(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32WithSub_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToJavaModifiedUTF8_66(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromJavaModifiedUTF8WithSub_66(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn utext_close_66(ut: *mut UText) -> *mut UText;
}
extern "C" {
    pub fn utext_openUTF8_66(
        ut: *mut UText,
        s: *const ::std::os::raw::c_char,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_openUChars_66(
        ut: *mut UText,
        s: *const UChar,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_clone_66(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        readOnly: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_equals_66(a: *const UText, b: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_nativeLength_66(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_isLengthExpensive_66(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_char32At_66(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_current32_66(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32_66(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_previous32_66(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32From_66(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_previous32From_66(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_getNativeIndex_66(ut: *const UText) -> i64;
}
extern "C" {
    pub fn utext_setNativeIndex_66(ut: *mut UText, nativeIndex: i64);
}
extern "C" {
    pub fn utext_moveIndex32_66(ut: *mut UText, delta: i32) -> UBool;
}
extern "C" {
    pub fn utext_getPreviousNativeIndex_66(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_extract_66(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_isWritable_66(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_hasMetaData_66(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_replace_66(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacementLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_copy_66(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        destIndex: i64,
        move_: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utext_freeze_66(ut: *mut UText);
}
pub type UTextClone = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText,
>;
pub type UTextNativeLength = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText) -> i64>;
pub type UTextAccess = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText, nativeIndex: i64, forward: UBool) -> UBool,
>;
pub type UTextExtract = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextReplace = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacmentLength: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextCopy = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        nativeDest: i64,
        move_: UBool,
        status: *mut UErrorCode,
    ),
>;
pub type UTextMapOffsetToNative =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText) -> i64>;
pub type UTextMapNativeIndexToUTF16 =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText, nativeIndex: i64) -> i32>;
pub type UTextClose = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTextFuncs {
    pub tableSize: i32,
    pub reserved1: i32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub clone: UTextClone,
    pub nativeLength: UTextNativeLength,
    pub access: UTextAccess,
    pub extract: UTextExtract,
    pub replace: UTextReplace,
    pub copy: UTextCopy,
    pub mapOffsetToNative: UTextMapOffsetToNative,
    pub mapNativeIndexToUTF16: UTextMapNativeIndexToUTF16,
    pub close: UTextClose,
    pub spare1: UTextClose,
    pub spare2: UTextClose,
    pub spare3: UTextClose,
}
#[test]
fn bindgen_test_layout_UTextFuncs() {
    assert_eq!(
        ::std::mem::size_of::<UTextFuncs>(),
        112usize,
        concat!("Size of: ", stringify!(UTextFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<UTextFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(UTextFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).tableSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(tableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).clone as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).nativeLength as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(nativeLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).access as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).extract as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(extract)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).replace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).copy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).mapOffsetToNative as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapOffsetToNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UTextFuncs>())).mapNativeIndexToUTF16 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapNativeIndexToUTF16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare1 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare3 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UText {
    pub magic: u32,
    pub flags: i32,
    pub providerProperties: i32,
    pub sizeOfStruct: i32,
    pub chunkNativeLimit: i64,
    pub extraSize: i32,
    pub nativeIndexingLimit: i32,
    pub chunkNativeStart: i64,
    pub chunkOffset: i32,
    pub chunkLength: i32,
    pub chunkContents: *const UChar,
    pub pFuncs: *const UTextFuncs,
    pub pExtra: *mut ::std::os::raw::c_void,
    pub context: *const ::std::os::raw::c_void,
    pub p: *const ::std::os::raw::c_void,
    pub q: *const ::std::os::raw::c_void,
    pub r: *const ::std::os::raw::c_void,
    pub privP: *mut ::std::os::raw::c_void,
    pub a: i64,
    pub b: i32,
    pub c: i32,
    pub privA: i64,
    pub privB: i32,
    pub privC: i32,
}
#[test]
fn bindgen_test_layout_UText() {
    assert_eq!(
        ::std::mem::size_of::<UText>(),
        144usize,
        concat!("Size of: ", stringify!(UText))
    );
    assert_eq!(
        ::std::mem::align_of::<UText>(),
        8usize,
        concat!("Alignment of ", stringify!(UText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).providerProperties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(providerProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).sizeOfStruct as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(sizeOfStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeLimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).extraSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(extraSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).nativeIndexingLimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(nativeIndexingLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeStart as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkLength as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkContents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkContents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pFuncs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pFuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pExtra as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pExtra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).context as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).p as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).q as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).r as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privP as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).a as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).b as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).c as *const _ as usize },
        124usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privA as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privB as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privC as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privC)
        )
    );
}
impl Default for UText {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn utext_setup_66(ut: *mut UText, extraSpace: i32, status: *mut UErrorCode) -> *mut UText;
}
pub type UReplaceable = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UReplaceableCallbacks {
    pub length: ::std::option::Option<unsafe extern "C" fn(rep: *const UReplaceable) -> i32>,
    pub charAt:
        ::std::option::Option<unsafe extern "C" fn(rep: *const UReplaceable, offset: i32) -> UChar>,
    pub char32At: ::std::option::Option<
        unsafe extern "C" fn(rep: *const UReplaceable, offset: i32) -> UChar32,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(
            rep: *mut UReplaceable,
            start: i32,
            limit: i32,
            text: *const UChar,
            textLength: i32,
        ),
    >,
    pub extract: ::std::option::Option<
        unsafe extern "C" fn(rep: *mut UReplaceable, start: i32, limit: i32, dst: *mut UChar),
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(rep: *mut UReplaceable, start: i32, limit: i32, dest: i32),
    >,
}
#[test]
fn bindgen_test_layout_UReplaceableCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<UReplaceableCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(UReplaceableCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<UReplaceableCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(UReplaceableCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).charAt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(charAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).char32At as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(char32At)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).replace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).extract as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(extract)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).copy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(copy)
        )
    );
}
pub type UTransliterator = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UTransDirection {
    UTRANS_FORWARD = 0,
    UTRANS_REVERSE = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTransPosition {
    pub contextStart: i32,
    pub contextLimit: i32,
    pub start: i32,
    pub limit: i32,
}
#[test]
fn bindgen_test_layout_UTransPosition() {
    assert_eq!(
        ::std::mem::size_of::<UTransPosition>(),
        16usize,
        concat!("Size of: ", stringify!(UTransPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UTransPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UTransPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).contextStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(contextStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).contextLimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(contextLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).limit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(limit)
        )
    );
}
extern "C" {
    pub fn utrans_openU_66(
        id: *const UChar,
        idLength: i32,
        dir: UTransDirection,
        rules: *const UChar,
        rulesLength: i32,
        parseError: *mut UParseError,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_openInverse_66(
        trans: *const UTransliterator,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_clone_66(
        trans: *const UTransliterator,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_close_66(trans: *mut UTransliterator);
}
extern "C" {
    pub fn utrans_getUnicodeID_66(
        trans: *const UTransliterator,
        resultLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn utrans_register_66(adoptedTrans: *mut UTransliterator, status: *mut UErrorCode);
}
extern "C" {
    pub fn utrans_unregisterID_66(id: *const UChar, idLength: i32);
}
extern "C" {
    pub fn utrans_setFilter_66(
        trans: *mut UTransliterator,
        filterPattern: *const UChar,
        filterPatternLen: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_countAvailableIDs_66() -> i32;
}
extern "C" {
    pub fn utrans_openIDs_66(pErrorCode: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn utrans_trans_66(
        trans: *const UTransliterator,
        rep: *mut UReplaceable,
        repFunc: *const UReplaceableCallbacks,
        start: i32,
        limit: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transIncremental_66(
        trans: *const UTransliterator,
        rep: *mut UReplaceable,
        repFunc: *const UReplaceableCallbacks,
        pos: *mut UTransPosition,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transUChars_66(
        trans: *const UTransliterator,
        text: *mut UChar,
        textLength: *mut i32,
        textCapacity: i32,
        start: i32,
        limit: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transIncrementalUChars_66(
        trans: *const UTransliterator,
        text: *mut UChar,
        textLength: *mut i32,
        textCapacity: i32,
        pos: *mut UTransPosition,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_toRules_66(
        trans: *const UTransliterator,
        escapeUnprintable: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utrans_getSourceSet_66(
        trans: *const UTransliterator,
        ignoreFilter: UBool,
        fillIn: *mut USet,
        status: *mut UErrorCode,
    ) -> *mut USet;
}
extern "C" {
    pub fn utrans_open_66(
        id: *const ::std::os::raw::c_char,
        dir: UTransDirection,
        rules: *const UChar,
        rulesLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_getID_66(
        trans: *const UTransliterator,
        buf: *mut ::std::os::raw::c_char,
        bufCapacity: i32,
    ) -> i32;
}
extern "C" {
    pub fn utrans_unregister_66(id: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn utrans_getAvailableID_66(
        index: i32,
        buf: *mut ::std::os::raw::c_char,
        bufCapacity: i32,
    ) -> i32;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

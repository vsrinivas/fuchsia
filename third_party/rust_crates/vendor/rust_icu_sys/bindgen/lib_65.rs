/* automatically generated by rust-bindgen */

pub type wchar_t = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
extern "C" {
    pub fn u_versionFromString_65(
        versionArray: *mut u8,
        versionString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn u_versionFromUString_65(versionArray: *mut u8, versionString: *const UChar);
}
extern "C" {
    pub fn u_versionToString_65(versionArray: *mut u8, versionString: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getVersion_65(versionArray: *mut u8);
}
pub type UDate = f64;
impl UErrorCode {
    pub const U_ERROR_WARNING_START: UErrorCode = UErrorCode::U_USING_FALLBACK_WARNING;
}
impl UErrorCode {
    pub const U_PARSE_ERROR_START: UErrorCode = UErrorCode::U_BAD_VARIABLE_DEFINITION;
}
impl UErrorCode {
    pub const U_FMT_PARSE_ERROR_START: UErrorCode = UErrorCode::U_UNEXPECTED_TOKEN;
}
impl UErrorCode {
    pub const U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = UErrorCode::U_MULTIPLE_DECIMAL_SEPARATORS;
}
impl UErrorCode {
    pub const U_BRK_ERROR_START: UErrorCode = UErrorCode::U_BRK_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_REGEX_ERROR_START: UErrorCode = UErrorCode::U_REGEX_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_IDNA_ERROR_START: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = UErrorCode::U_IDNA_UNASSIGNED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = UErrorCode::U_IDNA_CHECK_BIDI_ERROR;
}
impl UErrorCode {
    pub const U_PLUGIN_TOO_HIGH: UErrorCode = UErrorCode::U_PLUGIN_ERROR_START;
}
impl UErrorCode {
    pub const U_ERROR_LIMIT: UErrorCode = UErrorCode::U_PLUGIN_ERROR_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UErrorCode {
    U_USING_FALLBACK_WARNING = -128,
    U_USING_DEFAULT_WARNING = -127,
    U_SAFECLONE_ALLOCATED_WARNING = -126,
    U_STATE_OLD_WARNING = -125,
    U_STRING_NOT_TERMINATED_WARNING = -124,
    U_SORT_KEY_TOO_SHORT_WARNING = -123,
    U_AMBIGUOUS_ALIAS_WARNING = -122,
    U_DIFFERENT_UCA_VERSION = -121,
    U_PLUGIN_CHANGED_LEVEL_WARNING = -120,
    U_ERROR_WARNING_LIMIT = -119,
    U_ZERO_ERROR = 0,
    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,
    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,
    U_NO_WRITE_PERMISSION = 30,
    U_STANDARD_ERROR_LIMIT = 31,
    U_BAD_VARIABLE_DEFINITION = 65536,
    U_MALFORMED_RULE = 65537,
    U_MALFORMED_SET = 65538,
    U_MALFORMED_SYMBOL_REFERENCE = 65539,
    U_MALFORMED_UNICODE_ESCAPE = 65540,
    U_MALFORMED_VARIABLE_DEFINITION = 65541,
    U_MALFORMED_VARIABLE_REFERENCE = 65542,
    U_MISMATCHED_SEGMENT_DELIMITERS = 65543,
    U_MISPLACED_ANCHOR_START = 65544,
    U_MISPLACED_CURSOR_OFFSET = 65545,
    U_MISPLACED_QUANTIFIER = 65546,
    U_MISSING_OPERATOR = 65547,
    U_MISSING_SEGMENT_CLOSE = 65548,
    U_MULTIPLE_ANTE_CONTEXTS = 65549,
    U_MULTIPLE_CURSORS = 65550,
    U_MULTIPLE_POST_CONTEXTS = 65551,
    U_TRAILING_BACKSLASH = 65552,
    U_UNDEFINED_SEGMENT_REFERENCE = 65553,
    U_UNDEFINED_VARIABLE = 65554,
    U_UNQUOTED_SPECIAL = 65555,
    U_UNTERMINATED_QUOTE = 65556,
    U_RULE_MASK_ERROR = 65557,
    U_MISPLACED_COMPOUND_FILTER = 65558,
    U_MULTIPLE_COMPOUND_FILTERS = 65559,
    U_INVALID_RBT_SYNTAX = 65560,
    U_INVALID_PROPERTY_PATTERN = 65561,
    U_MALFORMED_PRAGMA = 65562,
    U_UNCLOSED_SEGMENT = 65563,
    U_ILLEGAL_CHAR_IN_SEGMENT = 65564,
    U_VARIABLE_RANGE_EXHAUSTED = 65565,
    U_VARIABLE_RANGE_OVERLAP = 65566,
    U_ILLEGAL_CHARACTER = 65567,
    U_INTERNAL_TRANSLITERATOR_ERROR = 65568,
    U_INVALID_ID = 65569,
    U_INVALID_FUNCTION = 65570,
    U_PARSE_ERROR_LIMIT = 65571,
    U_UNEXPECTED_TOKEN = 65792,
    U_MULTIPLE_DECIMAL_SEPARATORS = 65793,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    U_MALFORMED_EXPONENTIAL_PATTERN = 65795,
    U_MULTIPLE_PERCENT_SYMBOLS = 65796,
    U_MULTIPLE_PERMILL_SYMBOLS = 65797,
    U_MULTIPLE_PAD_SPECIFIERS = 65798,
    U_PATTERN_SYNTAX_ERROR = 65799,
    U_ILLEGAL_PAD_POSITION = 65800,
    U_UNMATCHED_BRACES = 65801,
    U_UNSUPPORTED_PROPERTY = 65802,
    U_UNSUPPORTED_ATTRIBUTE = 65803,
    U_ARGUMENT_TYPE_MISMATCH = 65804,
    U_DUPLICATE_KEYWORD = 65805,
    U_UNDEFINED_KEYWORD = 65806,
    U_DEFAULT_KEYWORD_MISSING = 65807,
    U_DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    U_FORMAT_INEXACT_ERROR = 65809,
    U_NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    U_NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    U_FMT_PARSE_ERROR_LIMIT = 65812,
    U_BRK_INTERNAL_ERROR = 66048,
    U_BRK_HEX_DIGITS_EXPECTED = 66049,
    U_BRK_SEMICOLON_EXPECTED = 66050,
    U_BRK_RULE_SYNTAX = 66051,
    U_BRK_UNCLOSED_SET = 66052,
    U_BRK_ASSIGN_ERROR = 66053,
    U_BRK_VARIABLE_REDFINITION = 66054,
    U_BRK_MISMATCHED_PAREN = 66055,
    U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    U_BRK_UNDEFINED_VARIABLE = 66057,
    U_BRK_INIT_ERROR = 66058,
    U_BRK_RULE_EMPTY_SET = 66059,
    U_BRK_UNRECOGNIZED_OPTION = 66060,
    U_BRK_MALFORMED_RULE_TAG = 66061,
    U_BRK_ERROR_LIMIT = 66062,
    U_REGEX_INTERNAL_ERROR = 66304,
    U_REGEX_RULE_SYNTAX = 66305,
    U_REGEX_INVALID_STATE = 66306,
    U_REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    U_REGEX_PROPERTY_SYNTAX = 66308,
    U_REGEX_UNIMPLEMENTED = 66309,
    U_REGEX_MISMATCHED_PAREN = 66310,
    U_REGEX_NUMBER_TOO_BIG = 66311,
    U_REGEX_BAD_INTERVAL = 66312,
    U_REGEX_MAX_LT_MIN = 66313,
    U_REGEX_INVALID_BACK_REF = 66314,
    U_REGEX_INVALID_FLAG = 66315,
    U_REGEX_LOOK_BEHIND_LIMIT = 66316,
    U_REGEX_SET_CONTAINS_STRING = 66317,
    U_REGEX_OCTAL_TOO_BIG = 66318,
    U_REGEX_MISSING_CLOSE_BRACKET = 66319,
    U_REGEX_INVALID_RANGE = 66320,
    U_REGEX_STACK_OVERFLOW = 66321,
    U_REGEX_TIME_OUT = 66322,
    U_REGEX_STOPPED_BY_CALLER = 66323,
    U_REGEX_PATTERN_TOO_BIG = 66324,
    U_REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    U_REGEX_ERROR_LIMIT = 66326,
    U_IDNA_PROHIBITED_ERROR = 66560,
    U_IDNA_UNASSIGNED_ERROR = 66561,
    U_IDNA_CHECK_BIDI_ERROR = 66562,
    U_IDNA_STD3_ASCII_RULES_ERROR = 66563,
    U_IDNA_ACE_PREFIX_ERROR = 66564,
    U_IDNA_VERIFICATION_ERROR = 66565,
    U_IDNA_LABEL_TOO_LONG_ERROR = 66566,
    U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    U_IDNA_ERROR_LIMIT = 66569,
    U_PLUGIN_ERROR_START = 66816,
    U_PLUGIN_DIDNT_SET_LEVEL = 66817,
    U_PLUGIN_ERROR_LIMIT = 66818,
}
extern "C" {
    pub fn u_errorName_65(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uenum_close_65(en: *mut UEnumeration);
}
extern "C" {
    pub fn uenum_count_65(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn uenum_unext_65(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn uenum_next_65(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uenum_reset_65(en: *mut UEnumeration, status: *mut UErrorCode);
}
extern "C" {
    pub fn uenum_openUCharStringsEnumeration_65(
        strings: *const *const UChar,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uenum_openCharStringsEnumeration_65(
        strings: *const *const ::std::os::raw::c_char,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULocDataLocaleType {
    ULOC_ACTUAL_LOCALE = 0,
    ULOC_VALID_LOCALE = 1,
    ULOC_REQUESTED_LOCALE = 2,
    ULOC_DATA_LOCALE_TYPE_LIMIT = 3,
}
extern "C" {
    pub fn uloc_getDefault_65() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_setDefault_65(localeID: *const ::std::os::raw::c_char, status: *mut UErrorCode);
}
extern "C" {
    pub fn uloc_getLanguage_65(
        localeID: *const ::std::os::raw::c_char,
        language: *mut ::std::os::raw::c_char,
        languageCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getScript_65(
        localeID: *const ::std::os::raw::c_char,
        script: *mut ::std::os::raw::c_char,
        scriptCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getCountry_65(
        localeID: *const ::std::os::raw::c_char,
        country: *mut ::std::os::raw::c_char,
        countryCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getVariant_65(
        localeID: *const ::std::os::raw::c_char,
        variant: *mut ::std::os::raw::c_char,
        variantCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getName_65(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_canonicalize_65(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getISO3Language_65(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISO3Country_65(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getLCID_65(localeID: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn uloc_getDisplayLanguage_65(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        language: *mut UChar,
        languageCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayScript_65(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        script: *mut UChar,
        scriptCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayCountry_65(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        country: *mut UChar,
        countryCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayVariant_65(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        variant: *mut UChar,
        variantCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeyword_65(
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeywordValue_65(
        locale: *const ::std::os::raw::c_char,
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayName_65(
        localeID: *const ::std::os::raw::c_char,
        inLocaleID: *const ::std::os::raw::c_char,
        result: *mut UChar,
        maxResultSize: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getAvailable_65(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_countAvailable_65() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULocAvailableType {
    ULOC_AVAILABLE_DEFAULT = 0,
    ULOC_AVAILABLE_ONLY_LEGACY_ALIASES = 1,
    ULOC_AVAILABLE_WITH_LEGACY_ALIASES = 2,
    ULOC_AVAILABLE_COUNT = 3,
}
extern "C" {
    pub fn uloc_openAvailableByType_65(
        type_: ULocAvailableType,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getISOLanguages_65() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISOCountries_65() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getParent_65(
        localeID: *const ::std::os::raw::c_char,
        parent: *mut ::std::os::raw::c_char,
        parentCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getBaseName_65(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_openKeywords_65(
        localeID: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getKeywordValue_65(
        localeID: *const ::std::os::raw::c_char,
        keywordName: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_setKeywordValue_65(
        keywordName: *const ::std::os::raw::c_char,
        keywordValue: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_isRightToLeft_65(locale: *const ::std::os::raw::c_char) -> UBool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULayoutType {
    ULOC_LAYOUT_LTR = 0,
    ULOC_LAYOUT_RTL = 1,
    ULOC_LAYOUT_TTB = 2,
    ULOC_LAYOUT_BTT = 3,
    ULOC_LAYOUT_UNKNOWN = 4,
}
extern "C" {
    pub fn uloc_getCharacterOrientation_65(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
extern "C" {
    pub fn uloc_getLineOrientation_65(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UAcceptResult {
    ULOC_ACCEPT_FAILED = 0,
    ULOC_ACCEPT_VALID = 1,
    ULOC_ACCEPT_FALLBACK = 2,
}
extern "C" {
    pub fn uloc_acceptLanguageFromHTTP_65(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        httpAcceptLanguage: *const ::std::os::raw::c_char,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_acceptLanguage_65(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        acceptList: *mut *const ::std::os::raw::c_char,
        acceptListCount: i32,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getLocaleForLCID_65(
        hostID: u32,
        locale: *mut ::std::os::raw::c_char,
        localeCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_addLikelySubtags_65(
        localeID: *const ::std::os::raw::c_char,
        maximizedLocaleID: *mut ::std::os::raw::c_char,
        maximizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_minimizeSubtags_65(
        localeID: *const ::std::os::raw::c_char,
        minimizedLocaleID: *mut ::std::os::raw::c_char,
        minimizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_forLanguageTag_65(
        langtag: *const ::std::os::raw::c_char,
        localeID: *mut ::std::os::raw::c_char,
        localeIDCapacity: i32,
        parsedLength: *mut i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toLanguageTag_65(
        localeID: *const ::std::os::raw::c_char,
        langtag: *mut ::std::os::raw::c_char,
        langtagCapacity: i32,
        strict: UBool,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleKey_65(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleType_65(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyKey_65(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyType_65(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type UCalendar = *mut ::std::os::raw::c_void;
impl UCalendarType {
    pub const UCAL_DEFAULT: UCalendarType = UCalendarType::UCAL_TRADITIONAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarType {
    UCAL_TRADITIONAL = 0,
    UCAL_GREGORIAN = 1,
}
impl UCalendarDateFields {
    pub const UCAL_DAY_OF_MONTH: UCalendarDateFields = UCalendarDateFields::UCAL_DATE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDateFields {
    UCAL_ERA = 0,
    UCAL_YEAR = 1,
    UCAL_MONTH = 2,
    UCAL_WEEK_OF_YEAR = 3,
    UCAL_WEEK_OF_MONTH = 4,
    UCAL_DATE = 5,
    UCAL_DAY_OF_YEAR = 6,
    UCAL_DAY_OF_WEEK = 7,
    UCAL_DAY_OF_WEEK_IN_MONTH = 8,
    UCAL_AM_PM = 9,
    UCAL_HOUR = 10,
    UCAL_HOUR_OF_DAY = 11,
    UCAL_MINUTE = 12,
    UCAL_SECOND = 13,
    UCAL_MILLISECOND = 14,
    UCAL_ZONE_OFFSET = 15,
    UCAL_DST_OFFSET = 16,
    UCAL_YEAR_WOY = 17,
    UCAL_DOW_LOCAL = 18,
    UCAL_EXTENDED_YEAR = 19,
    UCAL_JULIAN_DAY = 20,
    UCAL_MILLISECONDS_IN_DAY = 21,
    UCAL_IS_LEAP_MONTH = 22,
    UCAL_FIELD_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDaysOfWeek {
    UCAL_SUNDAY = 1,
    UCAL_MONDAY = 2,
    UCAL_TUESDAY = 3,
    UCAL_WEDNESDAY = 4,
    UCAL_THURSDAY = 5,
    UCAL_FRIDAY = 6,
    UCAL_SATURDAY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarMonths {
    UCAL_JANUARY = 0,
    UCAL_FEBRUARY = 1,
    UCAL_MARCH = 2,
    UCAL_APRIL = 3,
    UCAL_MAY = 4,
    UCAL_JUNE = 5,
    UCAL_JULY = 6,
    UCAL_AUGUST = 7,
    UCAL_SEPTEMBER = 8,
    UCAL_OCTOBER = 9,
    UCAL_NOVEMBER = 10,
    UCAL_DECEMBER = 11,
    UCAL_UNDECIMBER = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAMPMs {
    UCAL_AM = 0,
    UCAL_PM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum USystemTimeZoneType {
    UCAL_ZONE_TYPE_ANY = 0,
    UCAL_ZONE_TYPE_CANONICAL = 1,
    UCAL_ZONE_TYPE_CANONICAL_LOCATION = 2,
}
extern "C" {
    pub fn ucal_openTimeZoneIDEnumeration_65(
        zoneType: USystemTimeZoneType,
        region: *const ::std::os::raw::c_char,
        rawOffset: *const i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openTimeZones_65(ec: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openCountryTimeZones_65(
        country: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_getDefaultTimeZone_65(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_setDefaultTimeZone_65(zoneID: *const UChar, ec: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_getHostTimeZone_65(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getDSTSavings_65(zoneID: *const UChar, ec: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucal_getNow_65() -> UDate;
}
extern "C" {
    pub fn ucal_open_65(
        zoneID: *const UChar,
        len: i32,
        locale: *const ::std::os::raw::c_char,
        type_: UCalendarType,
        status: *mut UErrorCode,
    ) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_close_65(cal: *mut UCalendar);
}
extern "C" {
    pub fn ucal_clone_65(cal: *const UCalendar, status: *mut UErrorCode) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_setTimeZone_65(
        cal: *mut UCalendar,
        zoneID: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getTimeZoneID_65(
        cal: *const UCalendar,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDisplayNameType {
    UCAL_STANDARD = 0,
    UCAL_SHORT_STANDARD = 1,
    UCAL_DST = 2,
    UCAL_SHORT_DST = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneDisplayName_65(
        cal: *const UCalendar,
        type_: UCalendarDisplayNameType,
        locale: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_inDaylightTime_65(cal: *const UCalendar, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_setGregorianChange_65(
        cal: *mut UCalendar,
        date: UDate,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getGregorianChange_65(cal: *const UCalendar, pErrorCode: *mut UErrorCode) -> UDate;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAttribute {
    UCAL_LENIENT = 0,
    UCAL_FIRST_DAY_OF_WEEK = 1,
    UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    UCAL_REPEATED_WALL_TIME = 3,
    UCAL_SKIPPED_WALL_TIME = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWallTimeOption {
    UCAL_WALLTIME_LAST = 0,
    UCAL_WALLTIME_FIRST = 1,
    UCAL_WALLTIME_NEXT_VALID = 2,
}
extern "C" {
    pub fn ucal_getAttribute_65(cal: *const UCalendar, attr: UCalendarAttribute) -> i32;
}
extern "C" {
    pub fn ucal_setAttribute_65(cal: *mut UCalendar, attr: UCalendarAttribute, newValue: i32);
}
extern "C" {
    pub fn ucal_getAvailable_65(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_countAvailable_65() -> i32;
}
extern "C" {
    pub fn ucal_getMillis_65(cal: *const UCalendar, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ucal_setMillis_65(cal: *mut UCalendar, dateTime: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_setDate_65(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_setDateTime_65(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        hour: i32,
        minute: i32,
        second: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_equivalentTo_65(cal1: *const UCalendar, cal2: *const UCalendar) -> UBool;
}
extern "C" {
    pub fn ucal_add_65(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_roll_65(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_get_65(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_set_65(cal: *mut UCalendar, field: UCalendarDateFields, value: i32);
}
extern "C" {
    pub fn ucal_isSet_65(cal: *const UCalendar, field: UCalendarDateFields) -> UBool;
}
extern "C" {
    pub fn ucal_clearField_65(cal: *mut UCalendar, field: UCalendarDateFields);
}
extern "C" {
    pub fn ucal_clear_65(calendar: *mut UCalendar);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarLimitType {
    UCAL_MINIMUM = 0,
    UCAL_MAXIMUM = 1,
    UCAL_GREATEST_MINIMUM = 2,
    UCAL_LEAST_MAXIMUM = 3,
    UCAL_ACTUAL_MINIMUM = 4,
    UCAL_ACTUAL_MAXIMUM = 5,
}
extern "C" {
    pub fn ucal_getLimit_65(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        type_: UCalendarLimitType,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getLocaleByType_65(
        cal: *const UCalendar,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getTZDataVersion_65(status: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getCanonicalTimeZoneID_65(
        id: *const UChar,
        len: i32,
        result: *mut UChar,
        resultCapacity: i32,
        isSystemID: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getType_65(
        cal: *const UCalendar,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getKeywordValuesForLocale_65(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWeekdayType {
    UCAL_WEEKDAY = 0,
    UCAL_WEEKEND = 1,
    UCAL_WEEKEND_ONSET = 2,
    UCAL_WEEKEND_CEASE = 3,
}
extern "C" {
    pub fn ucal_getDayOfWeekType_65(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> UCalendarWeekdayType;
}
extern "C" {
    pub fn ucal_getWeekendTransition_65(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_isWeekend_65(cal: *const UCalendar, date: UDate, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_getFieldDifference_65(
        cal: *mut UCalendar,
        target: UDate,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UTimeZoneTransitionType {
    UCAL_TZ_TRANSITION_NEXT = 0,
    UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = 1,
    UCAL_TZ_TRANSITION_PREVIOUS = 2,
    UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneTransitionDate_65(
        cal: *const UCalendar,
        type_: UTimeZoneTransitionType,
        transition: *mut UDate,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn ucal_getWindowsTimeZoneID_65(
        id: *const UChar,
        len: i32,
        winid: *mut UChar,
        winidCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getTimeZoneIDForWindowsID_65(
        winid: *const UChar,
        len: i32,
        region: *const ::std::os::raw::c_char,
        id: *mut UChar,
        idCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UFieldPosition {
    pub field: i32,
    pub beginIndex: i32,
    pub endIndex: i32,
}
#[test]
fn bindgen_test_layout_UFieldPosition() {
    assert_eq!(
        ::std::mem::size_of::<UFieldPosition>(),
        12usize,
        concat!("Size of: ", stringify!(UFieldPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UFieldPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UFieldPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).field as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).beginIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(beginIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).endIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(endIndex)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContextType {
    UDISPCTX_TYPE_DIALECT_HANDLING = 0,
    UDISPCTX_TYPE_CAPITALIZATION = 1,
    UDISPCTX_TYPE_DISPLAY_LENGTH = 2,
    UDISPCTX_TYPE_SUBSTITUTE_HANDLING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContext {
    UDISPCTX_STANDARD_NAMES = 0,
    UDISPCTX_DIALECT_NAMES = 1,
    UDISPCTX_CAPITALIZATION_NONE = 256,
    UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    UDISPCTX_CAPITALIZATION_FOR_STANDALONE = 260,
    UDISPCTX_LENGTH_FULL = 512,
    UDISPCTX_LENGTH_SHORT = 513,
    UDISPCTX_SUBSTITUTE = 768,
    UDISPCTX_NO_SUBSTITUTE = 769,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFieldPositionIterator {
    _unused: [u8; 0],
}
pub type UNumberFormat = *mut ::std::os::raw::c_void;
pub type UDateFormat = *mut ::std::os::raw::c_void;
impl UDateFormatStyle {
    pub const UDAT_DEFAULT: UDateFormatStyle = UDateFormatStyle::UDAT_MEDIUM;
}
impl UDateFormatStyle {
    pub const UDAT_FULL_RELATIVE: UDateFormatStyle = UDateFormatStyle::UDAT_RELATIVE;
}
impl UDateFormatStyle {
    pub const UDAT_IGNORE: UDateFormatStyle = UDateFormatStyle::UDAT_PATTERN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatStyle {
    UDAT_FULL = 0,
    UDAT_LONG = 1,
    UDAT_MEDIUM = 2,
    UDAT_SHORT = 3,
    UDAT_RELATIVE = 128,
    UDAT_LONG_RELATIVE = 129,
    UDAT_MEDIUM_RELATIVE = 130,
    UDAT_SHORT_RELATIVE = 131,
    UDAT_NONE = -1,
    UDAT_PATTERN = -2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatField {
    UDAT_ERA_FIELD = 0,
    UDAT_YEAR_FIELD = 1,
    UDAT_MONTH_FIELD = 2,
    UDAT_DATE_FIELD = 3,
    UDAT_HOUR_OF_DAY1_FIELD = 4,
    UDAT_HOUR_OF_DAY0_FIELD = 5,
    UDAT_MINUTE_FIELD = 6,
    UDAT_SECOND_FIELD = 7,
    UDAT_FRACTIONAL_SECOND_FIELD = 8,
    UDAT_DAY_OF_WEEK_FIELD = 9,
    UDAT_DAY_OF_YEAR_FIELD = 10,
    UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    UDAT_WEEK_OF_YEAR_FIELD = 12,
    UDAT_WEEK_OF_MONTH_FIELD = 13,
    UDAT_AM_PM_FIELD = 14,
    UDAT_HOUR1_FIELD = 15,
    UDAT_HOUR0_FIELD = 16,
    UDAT_TIMEZONE_FIELD = 17,
    UDAT_YEAR_WOY_FIELD = 18,
    UDAT_DOW_LOCAL_FIELD = 19,
    UDAT_EXTENDED_YEAR_FIELD = 20,
    UDAT_JULIAN_DAY_FIELD = 21,
    UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
    UDAT_TIMEZONE_RFC_FIELD = 23,
    UDAT_TIMEZONE_GENERIC_FIELD = 24,
    UDAT_STANDALONE_DAY_FIELD = 25,
    UDAT_STANDALONE_MONTH_FIELD = 26,
    UDAT_QUARTER_FIELD = 27,
    UDAT_STANDALONE_QUARTER_FIELD = 28,
    UDAT_TIMEZONE_SPECIAL_FIELD = 29,
    UDAT_YEAR_NAME_FIELD = 30,
    UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    UDAT_TIMEZONE_ISO_FIELD = 32,
    UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
    UDAT_RELATED_YEAR_FIELD = 34,
    UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
    UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
    UDAT_TIME_SEPARATOR_FIELD = 37,
    UDAT_FIELD_COUNT = 38,
}
extern "C" {
    pub fn udat_toCalendarDateField_65(field: UDateFormatField) -> UCalendarDateFields;
}
extern "C" {
    pub fn udat_open_65(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_close_65(format: *mut UDateFormat);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatBooleanAttribute {
    UDAT_PARSE_ALLOW_WHITESPACE = 0,
    UDAT_PARSE_ALLOW_NUMERIC = 1,
    UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
    UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4,
}
extern "C" {
    pub fn udat_getBooleanAttribute_65(
        fmt: *const UDateFormat,
        attr: UDateFormatBooleanAttribute,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn udat_setBooleanAttribute_65(
        fmt: *mut UDateFormat,
        attr: UDateFormatBooleanAttribute,
        newValue: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_clone_65(fmt: *const UDateFormat, status: *mut UErrorCode) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_format_65(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendar_65(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatForFields_65(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendarForFields_65(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_parse_65(
        format: *const UDateFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> UDate;
}
extern "C" {
    pub fn udat_parseCalendar_65(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_isLenient_65(fmt: *const UDateFormat) -> UBool;
}
extern "C" {
    pub fn udat_setLenient_65(fmt: *mut UDateFormat, isLenient: UBool);
}
extern "C" {
    pub fn udat_getCalendar_65(fmt: *const UDateFormat) -> *const UCalendar;
}
extern "C" {
    pub fn udat_setCalendar_65(fmt: *mut UDateFormat, calendarToSet: *const UCalendar);
}
extern "C" {
    pub fn udat_getNumberFormat_65(fmt: *const UDateFormat) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_getNumberFormatForField_65(
        fmt: *const UDateFormat,
        field: UChar,
    ) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_adoptNumberFormatForFields_65(
        fmt: *mut UDateFormat,
        fields: *const UChar,
        numberFormatToSet: *mut UNumberFormat,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_setNumberFormat_65(fmt: *mut UDateFormat, numberFormatToSet: *const UNumberFormat);
}
extern "C" {
    pub fn udat_adoptNumberFormat_65(
        fmt: *mut UDateFormat,
        numberFormatToAdopt: *mut UNumberFormat,
    );
}
extern "C" {
    pub fn udat_getAvailable_65(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_countAvailable_65() -> i32;
}
extern "C" {
    pub fn udat_get2DigitYearStart_65(fmt: *const UDateFormat, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn udat_set2DigitYearStart_65(fmt: *mut UDateFormat, d: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_toPattern_65(
        fmt: *const UDateFormat,
        localized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPattern_65(
        format: *mut UDateFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatSymbolType {
    UDAT_ERAS = 0,
    UDAT_MONTHS = 1,
    UDAT_SHORT_MONTHS = 2,
    UDAT_WEEKDAYS = 3,
    UDAT_SHORT_WEEKDAYS = 4,
    UDAT_AM_PMS = 5,
    UDAT_LOCALIZED_CHARS = 6,
    UDAT_ERA_NAMES = 7,
    UDAT_NARROW_MONTHS = 8,
    UDAT_NARROW_WEEKDAYS = 9,
    UDAT_STANDALONE_MONTHS = 10,
    UDAT_STANDALONE_SHORT_MONTHS = 11,
    UDAT_STANDALONE_NARROW_MONTHS = 12,
    UDAT_STANDALONE_WEEKDAYS = 13,
    UDAT_STANDALONE_SHORT_WEEKDAYS = 14,
    UDAT_STANDALONE_NARROW_WEEKDAYS = 15,
    UDAT_QUARTERS = 16,
    UDAT_SHORT_QUARTERS = 17,
    UDAT_STANDALONE_QUARTERS = 18,
    UDAT_STANDALONE_SHORT_QUARTERS = 19,
    UDAT_SHORTER_WEEKDAYS = 20,
    UDAT_STANDALONE_SHORTER_WEEKDAYS = 21,
    UDAT_CYCLIC_YEARS_WIDE = 22,
    UDAT_CYCLIC_YEARS_ABBREVIATED = 23,
    UDAT_CYCLIC_YEARS_NARROW = 24,
    UDAT_ZODIAC_NAMES_WIDE = 25,
    UDAT_ZODIAC_NAMES_ABBREVIATED = 26,
    UDAT_ZODIAC_NAMES_NARROW = 27,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDateFormatSymbols {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udat_getSymbols_65(
        fmt: *const UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_countSymbols_65(fmt: *const UDateFormat, type_: UDateFormatSymbolType) -> i32;
}
extern "C" {
    pub fn udat_setSymbols_65(
        format: *mut UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        value: *mut UChar,
        valueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getLocaleByType_65(
        fmt: *const UDateFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_setContext_65(
        fmt: *mut UDateFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getContext_65(
        fmt: *const UDateFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
extern "C" {
    pub fn udat_toPatternRelativeDate_65(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_toPatternRelativeTime_65(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPatternRelative_65(
        format: *mut UDateFormat,
        datePattern: *const UChar,
        datePatternLength: i32,
        timePattern: *const UChar,
        timePatternLength: i32,
        status: *mut UErrorCode,
    );
}
pub type UDateFormatOpener = ::std::option::Option<
    unsafe extern "C" fn(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat,
>;
extern "C" {
    pub fn udat_registerOpener_65(opener: UDateFormatOpener, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_unregisterOpener_65(
        opener: UDateFormatOpener,
        status: *mut UErrorCode,
    ) -> UDateFormatOpener;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UDataInfo {
    pub size: u16,
    pub reservedWord: u16,
    pub isBigEndian: u8,
    pub charsetFamily: u8,
    pub sizeofUChar: u8,
    pub reservedByte: u8,
    pub dataFormat: [u8; 4usize],
    pub formatVersion: [u8; 4usize],
    pub dataVersion: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_UDataInfo() {
    assert_eq!(
        ::std::mem::size_of::<UDataInfo>(),
        20usize,
        concat!("Size of: ", stringify!(UDataInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<UDataInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedWord as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).isBigEndian as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(isBigEndian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).charsetFamily as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(charsetFamily)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).sizeofUChar as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(sizeofUChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedByte as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedByte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataFormat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).formatVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(formatVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDataMemory {
    _unused: [u8; 0],
}
pub type UDataMemoryIsAcceptable = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pInfo: *const UDataInfo,
    ) -> UBool,
>;
extern "C" {
    pub fn udata_open_65(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_openChoice_65(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isAcceptable: UDataMemoryIsAcceptable,
        context: *mut ::std::os::raw::c_void,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_close_65(pData: *mut UDataMemory);
}
extern "C" {
    pub fn udata_getMemory_65(pData: *mut UDataMemory) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn udata_getInfo_65(pData: *mut UDataMemory, pInfo: *mut UDataInfo);
}
extern "C" {
    pub fn udata_setCommonData_65(data: *const ::std::os::raw::c_void, err: *mut UErrorCode);
}
extern "C" {
    pub fn udata_setAppData_65(
        packageName: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
impl UDataFileAccess {
    pub const UDATA_DEFAULT_ACCESS: UDataFileAccess = UDataFileAccess::UDATA_FILES_FIRST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDataFileAccess {
    UDATA_FILES_FIRST = 0,
    UDATA_ONLY_PACKAGES = 1,
    UDATA_PACKAGES_FIRST = 2,
    UDATA_NO_FILES = 3,
    UDATA_FILE_ACCESS_COUNT = 4,
}
extern "C" {
    pub fn udata_setFileAccess_65(access: UDataFileAccess, status: *mut UErrorCode);
}
extern "C" {
    pub fn u_getDataDirectory_65() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setDataDirectory_65(directory: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getTimeZoneFilesDirectory_65(status: *mut UErrorCode)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setTimeZoneFilesDirectory_65(
        path: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_charsToUChars_65(cs: *const ::std::os::raw::c_char, us: *mut UChar, length: i32);
}
extern "C" {
    pub fn u_UCharsToChars_65(us: *const UChar, cs: *mut ::std::os::raw::c_char, length: i32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharIteratorOrigin {
    UITER_START = 0,
    UITER_CURRENT = 1,
    UITER_LIMIT = 2,
    UITER_ZERO = 3,
    UITER_LENGTH = 4,
}
pub type UCharIteratorGetIndex = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorMove = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, delta: i32, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorHasNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorHasPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorCurrent =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorReserved =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator, something: i32) -> i32>;
pub type UCharIteratorGetState =
    ::std::option::Option<unsafe extern "C" fn(iter: *const UCharIterator) -> u32>;
pub type UCharIteratorSetState = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, state: u32, pErrorCode: *mut UErrorCode),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UCharIterator {
    pub context: *const ::std::os::raw::c_void,
    pub length: i32,
    pub start: i32,
    pub index: i32,
    pub limit: i32,
    pub reservedField: i32,
    pub getIndex: UCharIteratorGetIndex,
    pub move_: UCharIteratorMove,
    pub hasNext: UCharIteratorHasNext,
    pub hasPrevious: UCharIteratorHasPrevious,
    pub current: UCharIteratorCurrent,
    pub next: UCharIteratorNext,
    pub previous: UCharIteratorPrevious,
    pub reservedFn: UCharIteratorReserved,
    pub getState: UCharIteratorGetState,
    pub setState: UCharIteratorSetState,
}
#[test]
fn bindgen_test_layout_UCharIterator() {
    assert_eq!(
        ::std::mem::size_of::<UCharIterator>(),
        112usize,
        concat!("Size of: ", stringify!(UCharIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<UCharIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(UCharIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).start as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).limit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedField as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).move_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasNext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasPrevious as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasPrevious)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).current as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).previous as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedFn as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getState as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).setState as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(setState)
        )
    );
}
impl Default for UCharIterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UBreakIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn u_strlen_65(s: *const UChar) -> i32;
}
extern "C" {
    pub fn u_countChar32_65(s: *const UChar, length: i32) -> i32;
}
extern "C" {
    pub fn u_strHasMoreChar32Than_65(s: *const UChar, length: i32, number: i32) -> UBool;
}
extern "C" {
    pub fn u_strcat_65(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncat_65(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_strstr_65(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindFirst_65(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr_65(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr32_65(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strrstr_65(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindLast_65(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr_65(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr32_65(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strpbrk_65(string: *const UChar, matchSet: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strcspn_65(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strspn_65(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strtok_r_65(
        src: *mut UChar,
        delim: *const UChar,
        saveState: *mut *mut UChar,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strcmp_65(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strcmpCodePointOrder_65(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strCompare_65(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCompareIter_65(
        iter1: *mut UCharIterator,
        iter2: *mut UCharIterator,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCaseCompare_65(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strncmp_65(ucs1: *const UChar, ucs2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strncmpCodePointOrder_65(s1: *const UChar, s2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strcasecmp_65(s1: *const UChar, s2: *const UChar, options: u32) -> i32;
}
extern "C" {
    pub fn u_strncasecmp_65(s1: *const UChar, s2: *const UChar, n: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_memcasecmp_65(s1: *const UChar, s2: *const UChar, length: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_strcpy_65(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncpy_65(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrcpy_65(dst: *mut UChar, src: *const ::std::os::raw::c_char) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrncpy_65(
        dst: *mut UChar,
        src: *const ::std::os::raw::c_char,
        n: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_austrcpy_65(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_austrncpy_65(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
        n: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_memcpy_65(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memmove_65(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memset_65(dest: *mut UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memcmp_65(buf1: *const UChar, buf2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memcmpCodePointOrder_65(s1: *const UChar, s2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memchr_65(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memchr32_65(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr_65(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr32_65(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_unescape_65(
        src: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
    ) -> i32;
}
pub type UNESCAPE_CHAR_AT = ::std::option::Option<
    unsafe extern "C" fn(offset: i32, context: *mut ::std::os::raw::c_void) -> UChar,
>;
extern "C" {
    pub fn u_unescapeAt_65(
        charAt: UNESCAPE_CHAR_AT,
        offset: *mut i32,
        length: i32,
        context: *mut ::std::os::raw::c_void,
    ) -> UChar32;
}
extern "C" {
    pub fn u_strToUpper_65(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToLower_65(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToTitle_65(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        titleIter: *mut UBreakIterator,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strFoldCase_65(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToWCS_65(
        dest: *mut wchar_t,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn u_strFromWCS_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const wchar_t,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8_65(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8WithSub_65(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8WithSub_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strFromUTF8Lenient_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32_65(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32WithSub_65(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32WithSub_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToJavaModifiedUTF8_65(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromJavaModifiedUTF8WithSub_65(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCPMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
    _unused: [u8; 0],
}
impl UProperty {
    pub const UCHAR_BINARY_START: UProperty = UProperty::UCHAR_ALPHABETIC;
}
impl UProperty {
    pub const UCHAR_INT_START: UProperty = UProperty::UCHAR_BIDI_CLASS;
}
impl UProperty {
    pub const UCHAR_MASK_START: UProperty = UProperty::UCHAR_GENERAL_CATEGORY_MASK;
}
impl UProperty {
    pub const UCHAR_DOUBLE_START: UProperty = UProperty::UCHAR_NUMERIC_VALUE;
}
impl UProperty {
    pub const UCHAR_STRING_START: UProperty = UProperty::UCHAR_AGE;
}
impl UProperty {
    pub const UCHAR_OTHER_PROPERTY_START: UProperty = UProperty::UCHAR_SCRIPT_EXTENSIONS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UProperty {
    UCHAR_ALPHABETIC = 0,
    UCHAR_ASCII_HEX_DIGIT = 1,
    UCHAR_BIDI_CONTROL = 2,
    UCHAR_BIDI_MIRRORED = 3,
    UCHAR_DASH = 4,
    UCHAR_DEFAULT_IGNORABLE_CODE_POINT = 5,
    UCHAR_DEPRECATED = 6,
    UCHAR_DIACRITIC = 7,
    UCHAR_EXTENDER = 8,
    UCHAR_FULL_COMPOSITION_EXCLUSION = 9,
    UCHAR_GRAPHEME_BASE = 10,
    UCHAR_GRAPHEME_EXTEND = 11,
    UCHAR_GRAPHEME_LINK = 12,
    UCHAR_HEX_DIGIT = 13,
    UCHAR_HYPHEN = 14,
    UCHAR_ID_CONTINUE = 15,
    UCHAR_ID_START = 16,
    UCHAR_IDEOGRAPHIC = 17,
    UCHAR_IDS_BINARY_OPERATOR = 18,
    UCHAR_IDS_TRINARY_OPERATOR = 19,
    UCHAR_JOIN_CONTROL = 20,
    UCHAR_LOGICAL_ORDER_EXCEPTION = 21,
    UCHAR_LOWERCASE = 22,
    UCHAR_MATH = 23,
    UCHAR_NONCHARACTER_CODE_POINT = 24,
    UCHAR_QUOTATION_MARK = 25,
    UCHAR_RADICAL = 26,
    UCHAR_SOFT_DOTTED = 27,
    UCHAR_TERMINAL_PUNCTUATION = 28,
    UCHAR_UNIFIED_IDEOGRAPH = 29,
    UCHAR_UPPERCASE = 30,
    UCHAR_WHITE_SPACE = 31,
    UCHAR_XID_CONTINUE = 32,
    UCHAR_XID_START = 33,
    UCHAR_CASE_SENSITIVE = 34,
    UCHAR_S_TERM = 35,
    UCHAR_VARIATION_SELECTOR = 36,
    UCHAR_NFD_INERT = 37,
    UCHAR_NFKD_INERT = 38,
    UCHAR_NFC_INERT = 39,
    UCHAR_NFKC_INERT = 40,
    UCHAR_SEGMENT_STARTER = 41,
    UCHAR_PATTERN_SYNTAX = 42,
    UCHAR_PATTERN_WHITE_SPACE = 43,
    UCHAR_POSIX_ALNUM = 44,
    UCHAR_POSIX_BLANK = 45,
    UCHAR_POSIX_GRAPH = 46,
    UCHAR_POSIX_PRINT = 47,
    UCHAR_POSIX_XDIGIT = 48,
    UCHAR_CASED = 49,
    UCHAR_CASE_IGNORABLE = 50,
    UCHAR_CHANGES_WHEN_LOWERCASED = 51,
    UCHAR_CHANGES_WHEN_UPPERCASED = 52,
    UCHAR_CHANGES_WHEN_TITLECASED = 53,
    UCHAR_CHANGES_WHEN_CASEFOLDED = 54,
    UCHAR_CHANGES_WHEN_CASEMAPPED = 55,
    UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    UCHAR_EMOJI = 57,
    UCHAR_EMOJI_PRESENTATION = 58,
    UCHAR_EMOJI_MODIFIER = 59,
    UCHAR_EMOJI_MODIFIER_BASE = 60,
    UCHAR_EMOJI_COMPONENT = 61,
    UCHAR_REGIONAL_INDICATOR = 62,
    UCHAR_PREPENDED_CONCATENATION_MARK = 63,
    UCHAR_EXTENDED_PICTOGRAPHIC = 64,
    UCHAR_BINARY_LIMIT = 65,
    UCHAR_BIDI_CLASS = 4096,
    UCHAR_BLOCK = 4097,
    UCHAR_CANONICAL_COMBINING_CLASS = 4098,
    UCHAR_DECOMPOSITION_TYPE = 4099,
    UCHAR_EAST_ASIAN_WIDTH = 4100,
    UCHAR_GENERAL_CATEGORY = 4101,
    UCHAR_JOINING_GROUP = 4102,
    UCHAR_JOINING_TYPE = 4103,
    UCHAR_LINE_BREAK = 4104,
    UCHAR_NUMERIC_TYPE = 4105,
    UCHAR_SCRIPT = 4106,
    UCHAR_HANGUL_SYLLABLE_TYPE = 4107,
    UCHAR_NFD_QUICK_CHECK = 4108,
    UCHAR_NFKD_QUICK_CHECK = 4109,
    UCHAR_NFC_QUICK_CHECK = 4110,
    UCHAR_NFKC_QUICK_CHECK = 4111,
    UCHAR_LEAD_CANONICAL_COMBINING_CLASS = 4112,
    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    UCHAR_GRAPHEME_CLUSTER_BREAK = 4114,
    UCHAR_SENTENCE_BREAK = 4115,
    UCHAR_WORD_BREAK = 4116,
    UCHAR_BIDI_PAIRED_BRACKET_TYPE = 4117,
    UCHAR_INDIC_POSITIONAL_CATEGORY = 4118,
    UCHAR_INDIC_SYLLABIC_CATEGORY = 4119,
    UCHAR_VERTICAL_ORIENTATION = 4120,
    UCHAR_INT_LIMIT = 4121,
    UCHAR_GENERAL_CATEGORY_MASK = 8192,
    UCHAR_MASK_LIMIT = 8193,
    UCHAR_NUMERIC_VALUE = 12288,
    UCHAR_DOUBLE_LIMIT = 12289,
    UCHAR_AGE = 16384,
    UCHAR_BIDI_MIRRORING_GLYPH = 16385,
    UCHAR_CASE_FOLDING = 16386,
    UCHAR_ISO_COMMENT = 16387,
    UCHAR_LOWERCASE_MAPPING = 16388,
    UCHAR_NAME = 16389,
    UCHAR_SIMPLE_CASE_FOLDING = 16390,
    UCHAR_SIMPLE_LOWERCASE_MAPPING = 16391,
    UCHAR_SIMPLE_TITLECASE_MAPPING = 16392,
    UCHAR_SIMPLE_UPPERCASE_MAPPING = 16393,
    UCHAR_TITLECASE_MAPPING = 16394,
    UCHAR_UNICODE_1_NAME = 16395,
    UCHAR_UPPERCASE_MAPPING = 16396,
    UCHAR_BIDI_PAIRED_BRACKET = 16397,
    UCHAR_STRING_LIMIT = 16398,
    UCHAR_SCRIPT_EXTENSIONS = 28672,
    UCHAR_OTHER_PROPERTY_LIMIT = 28673,
    UCHAR_INVALID_CODE = -1,
}
impl UCharCategory {
    pub const U_GENERAL_OTHER_TYPES: UCharCategory = UCharCategory::U_UNASSIGNED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharCategory {
    U_UNASSIGNED = 0,
    U_UPPERCASE_LETTER = 1,
    U_LOWERCASE_LETTER = 2,
    U_TITLECASE_LETTER = 3,
    U_MODIFIER_LETTER = 4,
    U_OTHER_LETTER = 5,
    U_NON_SPACING_MARK = 6,
    U_ENCLOSING_MARK = 7,
    U_COMBINING_SPACING_MARK = 8,
    U_DECIMAL_DIGIT_NUMBER = 9,
    U_LETTER_NUMBER = 10,
    U_OTHER_NUMBER = 11,
    U_SPACE_SEPARATOR = 12,
    U_LINE_SEPARATOR = 13,
    U_PARAGRAPH_SEPARATOR = 14,
    U_CONTROL_CHAR = 15,
    U_FORMAT_CHAR = 16,
    U_PRIVATE_USE_CHAR = 17,
    U_SURROGATE = 18,
    U_DASH_PUNCTUATION = 19,
    U_START_PUNCTUATION = 20,
    U_END_PUNCTUATION = 21,
    U_CONNECTOR_PUNCTUATION = 22,
    U_OTHER_PUNCTUATION = 23,
    U_MATH_SYMBOL = 24,
    U_CURRENCY_SYMBOL = 25,
    U_MODIFIER_SYMBOL = 26,
    U_OTHER_SYMBOL = 27,
    U_INITIAL_PUNCTUATION = 28,
    U_FINAL_PUNCTUATION = 29,
    U_CHAR_CATEGORY_COUNT = 30,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharDirection {
    U_LEFT_TO_RIGHT = 0,
    U_RIGHT_TO_LEFT = 1,
    U_EUROPEAN_NUMBER = 2,
    U_EUROPEAN_NUMBER_SEPARATOR = 3,
    U_EUROPEAN_NUMBER_TERMINATOR = 4,
    U_ARABIC_NUMBER = 5,
    U_COMMON_NUMBER_SEPARATOR = 6,
    U_BLOCK_SEPARATOR = 7,
    U_SEGMENT_SEPARATOR = 8,
    U_WHITE_SPACE_NEUTRAL = 9,
    U_OTHER_NEUTRAL = 10,
    U_LEFT_TO_RIGHT_EMBEDDING = 11,
    U_LEFT_TO_RIGHT_OVERRIDE = 12,
    U_RIGHT_TO_LEFT_ARABIC = 13,
    U_RIGHT_TO_LEFT_EMBEDDING = 14,
    U_RIGHT_TO_LEFT_OVERRIDE = 15,
    U_POP_DIRECTIONAL_FORMAT = 16,
    U_DIR_NON_SPACING_MARK = 17,
    U_BOUNDARY_NEUTRAL = 18,
    U_FIRST_STRONG_ISOLATE = 19,
    U_LEFT_TO_RIGHT_ISOLATE = 20,
    U_RIGHT_TO_LEFT_ISOLATE = 21,
    U_POP_DIRECTIONAL_ISOLATE = 22,
    U_CHAR_DIRECTION_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharNameChoice {
    U_UNICODE_CHAR_NAME = 0,
    U_UNICODE_10_CHAR_NAME = 1,
    U_EXTENDED_CHAR_NAME = 2,
    U_CHAR_NAME_ALIAS = 3,
    U_CHAR_NAME_CHOICE_COUNT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME = 0,
    U_LONG_PROPERTY_NAME = 1,
    U_PROPERTY_NAME_CHOICE_COUNT = 2,
}
extern "C" {
    pub fn u_hasBinaryProperty_65(c: UChar32, which: UProperty) -> UBool;
}
extern "C" {
    pub fn u_getBinaryPropertySet_65(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const USet;
}
extern "C" {
    pub fn u_isUAlphabetic_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isULowercase_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUUppercase_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUWhiteSpace_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_getIntPropertyValue_65(c: UChar32, which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMinValue_65(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMaxValue_65(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMap_65(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const UCPMap;
}
extern "C" {
    pub fn u_getNumericValue_65(c: UChar32) -> f64;
}
extern "C" {
    pub fn u_islower_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isupper_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_istitle_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdigit_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalpha_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalnum_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isxdigit_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_ispunct_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isgraph_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isblank_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdefined_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isspace_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaSpaceChar_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isWhitespace_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_iscntrl_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isISOControl_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isprint_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isbase_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charDirection_65(c: UChar32) -> UCharDirection;
}
extern "C" {
    pub fn u_isMirrored_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charMirror_65(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_getBidiPairedBracket_65(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_charType_65(c: UChar32) -> i8;
}
pub type UCharEnumTypeRange = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        start: UChar32,
        limit: UChar32,
        type_: UCharCategory,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharTypes_65(
        enumRange: UCharEnumTypeRange,
        context: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn u_getCombiningClass_65(c: UChar32) -> u8;
}
extern "C" {
    pub fn u_charDigitValue_65(c: UChar32) -> i32;
}
extern "C" {
    pub fn u_charName_65(
        code: UChar32,
        nameChoice: UCharNameChoice,
        buffer: *mut ::std::os::raw::c_char,
        bufferLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_getISOComment_65(
        c: UChar32,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_charFromName_65(
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> UChar32;
}
pub type UEnumCharNamesFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        code: UChar32,
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        length: i32,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharNames_65(
        start: UChar32,
        limit: UChar32,
        fn_: UEnumCharNamesFn,
        context: *mut ::std::os::raw::c_void,
        nameChoice: UCharNameChoice,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_getPropertyName_65(
        property: UProperty,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyEnum_65(alias: *const ::std::os::raw::c_char) -> UProperty;
}
extern "C" {
    pub fn u_getPropertyValueName_65(
        property: UProperty,
        value: i32,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyValueEnum_65(
        property: UProperty,
        alias: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn u_isIDStart_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDPart_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDIgnorable_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDStart_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDPart_65(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_tolower_65(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_toupper_65(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_totitle_65(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_foldCase_65(c: UChar32, options: u32) -> UChar32;
}
extern "C" {
    pub fn u_digit_65(ch: UChar32, radix: i8) -> i32;
}
extern "C" {
    pub fn u_forDigit_65(digit: i32, radix: i8) -> UChar32;
}
extern "C" {
    pub fn u_charAge_65(c: UChar32, versionArray: *mut u8);
}
extern "C" {
    pub fn u_getUnicodeVersion_65(versionArray: *mut u8);
}
extern "C" {
    pub fn u_getFC_NFKC_Closure_65(
        c: UChar32,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_close_65(ut: *mut UText) -> *mut UText;
}
extern "C" {
    pub fn utext_openUTF8_65(
        ut: *mut UText,
        s: *const ::std::os::raw::c_char,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_openUChars_65(
        ut: *mut UText,
        s: *const UChar,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_clone_65(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        readOnly: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_equals_65(a: *const UText, b: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_nativeLength_65(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_isLengthExpensive_65(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_char32At_65(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_current32_65(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32_65(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_previous32_65(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32From_65(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_previous32From_65(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_getNativeIndex_65(ut: *const UText) -> i64;
}
extern "C" {
    pub fn utext_setNativeIndex_65(ut: *mut UText, nativeIndex: i64);
}
extern "C" {
    pub fn utext_moveIndex32_65(ut: *mut UText, delta: i32) -> UBool;
}
extern "C" {
    pub fn utext_getPreviousNativeIndex_65(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_extract_65(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_isWritable_65(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_hasMetaData_65(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_replace_65(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacementLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_copy_65(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        destIndex: i64,
        move_: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utext_freeze_65(ut: *mut UText);
}
pub type UTextClone = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText,
>;
pub type UTextNativeLength = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText) -> i64>;
pub type UTextAccess = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText, nativeIndex: i64, forward: UBool) -> UBool,
>;
pub type UTextExtract = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextReplace = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacmentLength: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextCopy = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        nativeDest: i64,
        move_: UBool,
        status: *mut UErrorCode,
    ),
>;
pub type UTextMapOffsetToNative =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText) -> i64>;
pub type UTextMapNativeIndexToUTF16 =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText, nativeIndex: i64) -> i32>;
pub type UTextClose = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTextFuncs {
    pub tableSize: i32,
    pub reserved1: i32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub clone: UTextClone,
    pub nativeLength: UTextNativeLength,
    pub access: UTextAccess,
    pub extract: UTextExtract,
    pub replace: UTextReplace,
    pub copy: UTextCopy,
    pub mapOffsetToNative: UTextMapOffsetToNative,
    pub mapNativeIndexToUTF16: UTextMapNativeIndexToUTF16,
    pub close: UTextClose,
    pub spare1: UTextClose,
    pub spare2: UTextClose,
    pub spare3: UTextClose,
}
#[test]
fn bindgen_test_layout_UTextFuncs() {
    assert_eq!(
        ::std::mem::size_of::<UTextFuncs>(),
        112usize,
        concat!("Size of: ", stringify!(UTextFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<UTextFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(UTextFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).tableSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(tableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).clone as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).nativeLength as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(nativeLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).access as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).extract as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(extract)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).replace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).copy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).mapOffsetToNative as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapOffsetToNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UTextFuncs>())).mapNativeIndexToUTF16 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapNativeIndexToUTF16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare1 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare3 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UText {
    pub magic: u32,
    pub flags: i32,
    pub providerProperties: i32,
    pub sizeOfStruct: i32,
    pub chunkNativeLimit: i64,
    pub extraSize: i32,
    pub nativeIndexingLimit: i32,
    pub chunkNativeStart: i64,
    pub chunkOffset: i32,
    pub chunkLength: i32,
    pub chunkContents: *const UChar,
    pub pFuncs: *const UTextFuncs,
    pub pExtra: *mut ::std::os::raw::c_void,
    pub context: *const ::std::os::raw::c_void,
    pub p: *const ::std::os::raw::c_void,
    pub q: *const ::std::os::raw::c_void,
    pub r: *const ::std::os::raw::c_void,
    pub privP: *mut ::std::os::raw::c_void,
    pub a: i64,
    pub b: i32,
    pub c: i32,
    pub privA: i64,
    pub privB: i32,
    pub privC: i32,
}
#[test]
fn bindgen_test_layout_UText() {
    assert_eq!(
        ::std::mem::size_of::<UText>(),
        144usize,
        concat!("Size of: ", stringify!(UText))
    );
    assert_eq!(
        ::std::mem::align_of::<UText>(),
        8usize,
        concat!("Alignment of ", stringify!(UText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).providerProperties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(providerProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).sizeOfStruct as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(sizeOfStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeLimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).extraSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(extraSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).nativeIndexingLimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(nativeIndexingLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeStart as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkLength as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkContents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkContents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pFuncs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pFuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pExtra as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pExtra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).context as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).p as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).q as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).r as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privP as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).a as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).b as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).c as *const _ as usize },
        124usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privA as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privB as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privC as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privC)
        )
    );
}
impl Default for UText {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn utext_setup_65(ut: *mut UText, extraSpace: i32, status: *mut UErrorCode) -> *mut UText;
}
extern "C" {
    pub fn u_init_65(status: *mut UErrorCode);
}
extern "C" {
    pub fn u_cleanup_65();
}
pub type UMemAllocFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type UMemReallocFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        mem: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type UMemFreeFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, mem: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn u_setMemoryFunctions_65(
        context: *const ::std::os::raw::c_void,
        a: UMemAllocFn,
        r: UMemReallocFn,
        f: UMemFreeFn,
        status: *mut UErrorCode,
    );
}
pub type UMTX = *mut ::std::os::raw::c_void;
pub type UMtxInitFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        mutex: *mut UMTX,
        status: *mut UErrorCode,
    ),
>;
pub type UMtxFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, mutex: *mut UMTX),
>;
extern "C" {
    pub fn u_setMutexFunctions_65(
        context: *const ::std::os::raw::c_void,
        init: UMtxInitFn,
        destroy: UMtxFn,
        lock: UMtxFn,
        unlock: UMtxFn,
        status: *mut UErrorCode,
    );
}
pub type UMtxAtomicFn = ::std::option::Option<
    unsafe extern "C" fn(context: *const ::std::os::raw::c_void, p: *mut i32) -> i32,
>;
extern "C" {
    pub fn u_setAtomicIncDecFunctions_65(
        context: *const ::std::os::raw::c_void,
        inc: UMtxAtomicFn,
        dec: UMtxAtomicFn,
        status: *mut UErrorCode,
    );
}

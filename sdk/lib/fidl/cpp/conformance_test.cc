// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Code generated by tools/fidl/gidl-conformance-suite/regen.sh; DO NOT EDIT.

// +build fuchsia

//

#include <conformance/cpp/fidl.h>
#include <gtest/gtest.h>
#include <lib/fidl/cpp/test/test_util.h>

TEST(Conformance, EmptyStruct_Encoding) {
  conformance::EmptyStruct v1;

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, EmptyStruct_Decoding) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::EmptyStruct v1;

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, EmptyStructSandwich_Encoding) {
  conformance::EmptyStructSandwich v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  conformance::EmptyStruct v3;
  v1.es = std::move(v3);

  std::string v4 = "after";
  v1.after = std::move(v4);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65,
      0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, EmptyStructSandwich_Decoding) {
  auto input = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65,
      0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::EmptyStructSandwich v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  conformance::EmptyStruct v3;
  v1.es = std::move(v3);

  std::string v4 = "after";
  v1.after = std::move(v4);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint8Uint16Uint32Uint64_Encoding) {
  conformance::Uint8Uint16Uint32Uint64 v1;

  uint64_t v2 = 515ull;
  v1.f2 = std::move(v2);

  uint64_t v3 = 67438087ull;
  v1.f3 = std::move(v3);

  uint64_t v4 = 579005069656919567ull;
  v1.f4 = std::move(v4);

  uint64_t v5 = 1ull;
  v1.f1 = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04,
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint8Uint16Uint32Uint64_Decoding) {
  auto input = std::vector<uint8_t>{
      0x01, 0x00, 0x03, 0x02, 0x07, 0x06, 0x05, 0x04,
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,

  };

  conformance::Uint8Uint16Uint32Uint64 v1;

  uint64_t v2 = 515ull;
  v1.f2 = std::move(v2);

  uint64_t v3 = 67438087ull;
  v1.f3 = std::move(v3);

  uint64_t v4 = 579005069656919567ull;
  v1.f4 = std::move(v4);

  uint64_t v5 = 1ull;
  v1.f1 = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Uint64Uint32Uint16Uint8_Encoding) {
  conformance::Uint64Uint32Uint16Uint8 v1;

  uint64_t v2 = 579005069656919567ull;
  v1.f1 = std::move(v2);

  uint64_t v3 = 67438087ull;
  v1.f2 = std::move(v3);

  uint64_t v4 = 515ull;
  v1.f3 = std::move(v4);

  uint64_t v5 = 1ull;
  v1.f4 = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
      0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Uint64Uint32Uint16Uint8_Decoding) {
  auto input = std::vector<uint8_t>{
      0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
      0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,

  };

  conformance::Uint64Uint32Uint16Uint8 v1;

  uint64_t v2 = 579005069656919567ull;
  v1.f1 = std::move(v2);

  uint64_t v3 = 67438087ull;
  v1.f2 = std::move(v3);

  uint64_t v4 = 515ull;
  v1.f3 = std::move(v4);

  uint64_t v5 = 1ull;
  v1.f4 = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableEmpty_Encoding) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableEmpty_Decoding) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableXAndY_Encoding) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  uint64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableXAndY_Decoding) {
  auto input = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  uint64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableJustY_Encoding) {
  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 67ull;
  v2.set_y(std::move(v3));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableJustY_Decoding) {
  auto input = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfSimpleTable v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 67ull;
  v2.set_y(std::move(v3));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, TableWithStringAndVectorNoVectorContent_Encoding) {
  conformance::StructOfTableWithStringAndVector v1;

  conformance::TableWithStringAndVector v2;

  std::string v3 = "hello";
  v2.set_foo(std::move(v3));

  uint64_t v4 = 27ull;
  v2.set_bar(std::move(v4));
  v1.table = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
      0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, TableWithStringAndVectorNoVectorContent_Decoding) {
  auto input = std::vector<uint8_t>{
      0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00,
      0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructOfTableWithStringAndVector v1;

  conformance::TableWithStringAndVector v2;

  std::string v3 = "hello";
  v2.set_foo(std::move(v3));

  uint64_t v4 = 27ull;
  v2.set_bar(std::move(v4));
  v1.table = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, SimpleTableThenUint64_Encoding) {
  conformance::SimpleTableThenUint64 v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  uint64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  uint64_t v5 = 16045690984833335023ull;
  v1.number = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, SimpleTableThenUint64_Decoding) {
  auto input = std::vector<uint8_t>{
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2a,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::SimpleTableThenUint64 v1;

  conformance::SimpleTable v2;

  uint64_t v3 = 42ull;
  v2.set_x(std::move(v3));

  uint64_t v4 = 67ull;
  v2.set_y(std::move(v4));
  v1.table = std::move(v2);

  uint64_t v5 = 16045690984833335023ull;
  v1.number = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, InlineXUnionInStruct_Encoding) {
  conformance::TestInlineXUnionInStruct v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  conformance::SampleXUnion v3;

  uint64_t v4 = 3735928559ull;
  v3.set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5 = "after";
  v1.after = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, InlineXUnionInStruct_Decoding) {
  auto input = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestInlineXUnionInStruct v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  conformance::SampleXUnion v3;

  uint64_t v4 = 3735928559ull;
  v3.set_u(std::move(v4));
  v1.xu = std::move(v3);

  std::string v5 = "after";
  v1.after = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructAbsent_Encoding) {
  conformance::TestOptionalXUnionInStruct v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  std::string v3 = "after";
  v1.after = std::move(v3);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructAbsent_Decoding) {
  auto input = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestOptionalXUnionInStruct v1;

  std::string v2 = "before";
  v1.before = std::move(v2);

  std::string v3 = "after";
  v1.after = std::move(v3);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructPresent_Encoding) {
  conformance::TestOptionalXUnionInStruct v1;

  auto v2 = std::make_unique<conformance::SampleXUnion>();

  uint64_t v3 = 3735928559ull;
  v2->set_u(std::move(v3));
  v1.xu = std::move(v2);

  std::string v4 = "after";
  v1.after = std::move(v4);

  std::string v5 = "before";
  v1.before = std::move(v5);

  auto expected = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, OptionalXUnionInStructPresent_Decoding) {
  auto input = std::vector<uint8_t>{
      0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xb2, 0x56, 0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00,
      0x00, 0x00, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestOptionalXUnionInStruct v1;

  auto v2 = std::make_unique<conformance::SampleXUnion>();

  uint64_t v3 = 3735928559ull;
  v2->set_u(std::move(v3));
  v1.xu = std::move(v2);

  std::string v4 = "after";
  v1.after = std::move(v4);

  std::string v5 = "before";
  v1.before = std::move(v5);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionAbsent_Encoding) {
  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3 = "before";
  v2.set_before(std::move(v3));

  std::string v4 = "after";
  v2.set_after(std::move(v4));
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionAbsent_Decoding) {
  auto input = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f,
      0x72, 0x65, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3 = "before";
  v2.set_before(std::move(v3));

  std::string v4 = "after";
  v2.set_after(std::move(v4));
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionPresent_Encoding) {
  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3 = "before";
  v2.set_before(std::move(v3));

  conformance::SampleXUnion v4;

  uint64_t v5 = 3735928559ull;
  v4.set_u(std::move(v5));
  v2.set_xu(std::move(v4));

  std::string v6 = "after";
  v2.set_after(std::move(v6));
  v1.value = std::move(v2);

  auto expected = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2, 0x56,
      0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, XUnionInTableXUnionPresent_Decoding) {
  auto input = std::vector<uint8_t>{
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x00, 0x00, 0xb2, 0x56,
      0x9c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,

  };

  conformance::TestXUnionInTable v1;

  conformance::XUnionInTable v2;

  std::string v3 = "before";
  v2.set_before(std::move(v3));

  conformance::SampleXUnion v4;

  uint64_t v5 = 3735928559ull;
  v4.set_u(std::move(v5));
  v2.set_xu(std::move(v4));

  std::string v6 = "after";
  v2.set_after(std::move(v6));
  v1.value = std::move(v2);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, AddEthernetDeviceRequest_Encoding) {
  conformance::TestAddEthernetDeviceRequest v1;

  std::string v2 = "@/dev/sys/pci/00:03.0/e1000/ethernet";
  v1.topological_path = std::move(v2);

  conformance::InterfaceConfig v3;

  std::string v4 = "ethp0003";
  v3.name = std::move(v4);

  conformance::IpAddressConfig v5;

  bool v6 = true;
  v5.set_dhcp(std::move(v6));
  v3.ip_address_config = std::move(v5);
  v1.config = std::move(v3);

  uint64_t v7 = 4294967295ull;
  v1.this_should_be_a_handle = std::move(v7);

  auto expected = std::vector<uint8_t>{
      0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64,
      0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30,
      0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72,
      0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, AddEthernetDeviceRequest_Decoding) {
  auto input = std::vector<uint8_t>{
      0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2f, 0x64,
      0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, 0x30,
      0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, 0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72,
      0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33,

  };

  conformance::TestAddEthernetDeviceRequest v1;

  std::string v2 = "@/dev/sys/pci/00:03.0/e1000/ethernet";
  v1.topological_path = std::move(v2);

  conformance::InterfaceConfig v3;

  std::string v4 = "ethp0003";
  v3.name = std::move(v4);

  conformance::IpAddressConfig v5;

  bool v6 = true;
  v5.set_dhcp(std::move(v6));
  v3.ip_address_config = std::move(v5);
  v1.config = std::move(v3);

  uint64_t v7 = 4294967295ull;
  v1.this_should_be_a_handle = std::move(v7);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, FileGetAttrResponse_Encoding) {
  conformance::FileGetAttrResponse v1;

  uint64_t v2 = 2125315759ull;
  v1.s = std::move(v2);

  conformance::NodeAttributes v3;

  uint64_t v4 = 1ull;
  v3.link_count = std::move(v4);

  uint64_t v5 = 9833440827789222417ull;
  v3.creation_time = std::move(v5);

  uint64_t v6 = 72038755451251353ull;
  v3.modification_time = std::move(v6);

  uint64_t v7 = 2518909348ull;
  v3.mode = std::move(v7);

  uint64_t v8 = 1ull;
  v3.id = std::move(v8);

  uint64_t v9 = 231ull;
  v3.content_size = std::move(v9);

  uint64_t v10 = 231ull;
  v3.storage_size = std::move(v10);
  v1.attributes = std::move(v3);

  auto expected = std::vector<uint8_t>{
      0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44,
      0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, FileGetAttrResponse_Decoding) {
  auto input = std::vector<uint8_t>{
      0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x23, 0x96, 0x00,
      0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44,
      0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,

  };

  conformance::FileGetAttrResponse v1;

  uint64_t v2 = 2125315759ull;
  v1.s = std::move(v2);

  conformance::NodeAttributes v3;

  uint64_t v4 = 1ull;
  v3.link_count = std::move(v4);

  uint64_t v5 = 9833440827789222417ull;
  v3.creation_time = std::move(v5);

  uint64_t v6 = 72038755451251353ull;
  v3.modification_time = std::move(v6);

  uint64_t v7 = 2518909348ull;
  v3.mode = std::move(v7);

  uint64_t v8 = 1ull;
  v3.id = std::move(v8);

  uint64_t v9 = 231ull;
  v3.content_size = std::move(v9);

  uint64_t v10 = 231ull;
  v3.storage_size = std::move(v10);
  v1.attributes = std::move(v3);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

TEST(Conformance, Optionals_Encoding) {
  conformance::StructWithOptionals v1;

  auto v2 = std::make_unique<conformance::UnionWithEmptyStruct>();

  conformance::EmptyStruct v3;
  v2->set_s(std::move(v3));
  v1.u2 = std::move(v2);

  conformance::EmptyStruct v4;
  v1.s = std::move(v4);

  auto v5 = std::make_unique<conformance::EmptyStruct>();
  v1.s2 = std::move(v5);

  conformance::TableWithEmptyStruct v6;

  conformance::EmptyStruct v7;
  v6.set_s(std::move(v7));
  v1.t = std::move(v6);

  conformance::XUnionWithEmptyStruct v8;

  conformance::EmptyStruct v9;
  v8.set_s(std::move(v9));
  v1.xu = std::move(v8);

  auto v10 = std::make_unique<conformance::XUnionWithEmptyStruct>();

  conformance::EmptyStruct v11;
  v10->set_s(std::move(v11));
  v1.xu2 = std::move(v10);

  conformance::UnionWithEmptyStruct v12;

  conformance::EmptyStruct v13;
  v12.set_s(std::move(v13));
  v1.u = std::move(v12);

  auto expected = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  EXPECT_TRUE(::fidl::test::util::ValueToBytes(v1, expected));
}

TEST(Conformance, Optionals_Decoding) {
  auto input = std::vector<uint8_t>{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xfe, 0xe0, 0x99, 0x74, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  };

  conformance::StructWithOptionals v1;

  auto v2 = std::make_unique<conformance::UnionWithEmptyStruct>();

  conformance::EmptyStruct v3;
  v2->set_s(std::move(v3));
  v1.u2 = std::move(v2);

  conformance::EmptyStruct v4;
  v1.s = std::move(v4);

  auto v5 = std::make_unique<conformance::EmptyStruct>();
  v1.s2 = std::move(v5);

  conformance::TableWithEmptyStruct v6;

  conformance::EmptyStruct v7;
  v6.set_s(std::move(v7));
  v1.t = std::move(v6);

  conformance::XUnionWithEmptyStruct v8;

  conformance::EmptyStruct v9;
  v8.set_s(std::move(v9));
  v1.xu = std::move(v8);

  auto v10 = std::make_unique<conformance::XUnionWithEmptyStruct>();

  conformance::EmptyStruct v11;
  v10->set_s(std::move(v11));
  v1.xu2 = std::move(v10);

  conformance::UnionWithEmptyStruct v12;

  conformance::EmptyStruct v13;
  v12.set_s(std::move(v13));
  v1.u = std::move(v12);

  auto expected = ::fidl::test::util::DecodedBytes<decltype(v1)>(input);
  EXPECT_TRUE(::fidl::Equals(v1, expected));
}

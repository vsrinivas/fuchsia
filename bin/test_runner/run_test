#!/usr/bin/python

# Copyright 2017 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import argparse
import hashlib
import json
import os
import os.path
import random
import re
import socket
import subprocess
import sys
from subprocess import call
from urlparse import urlparse


class color:
  PURPLE = "\033[95m"
  CYAN = "\033[96m"
  DARKCYAN = "\033[36m"
  BLUE = "\033[94m"
  GREEN = "\033[92m"
  YELLOW = "\033[93m"
  RED = "\033[91m"
  BOLD = "\033[1m"
  UNDERLINE = "\033[4m"
  END = "\033[0m"



def read_log_listener(listener_process, test_id):
  """ Returns the output of loglistener up until it sees the |test_id|."""
  termination_substring = "test_runner: teardown %s" % test_id
  lines = []
  while True:
    line = listener_process.stdout.readline()
    if line == "" or line.find(termination_substring) != -1:
      return "".join(lines) + line
    lines.append(line)

  return "".join(lines)


def copy_files(copy):
  """ copy is a map of destination directories on the device to source
    files in $FUCHSIA_BUILD_DIR """
  if copy is None:
    return True

  netcp = os.path.join(os.environ["FUCHSIA_DIR"],
                       "out/build-magenta/tools/netcp")
  for dirname, files in copy.iteritems():
    for filename in files:
      filepath = os.path.join(os.environ["FUCHSIA_BUILD_DIR"], filename)
      command_line = [netcp, filepath, ":" + os.path.join(dirname, filename)]
      print "Copying %s" % filename
      # netcp returns the error value from magenta
      if call(command_line) != 0:
        print "Error: netcp failed to copy %s" % filename
        return False
  return True


def run_test(sock, listener_process, command_str):
  """ Runs |command_str| on the remote test runner server, waits for the
    result, and prints the relevant device log snippet in the event of a
    failure. """
  test_id = hashlib.sha1(command_str + str(random.random())).hexdigest()

  sock.send("run %s %s\n" % (test_id, command_str))
  read_sock_file = sock.makefile()
  for line in read_sock_file:
    ret_test_id, op, msg = line.split(" ", 2)
    msg = msg.strip()
    assert ret_test_id == test_id, "Uhoh, wrong test result returned."

    if op == "teardown":
      result = msg
      print ".. %s" % result
      # Consume the log output even, regardless of if we print it.
      log_output = read_log_listener(listener_process, test_id)
      if result == "fail":
        print "%s%s%s" % (colors.RED, log_output, colors.END)
      return
    elif op == "log":
      print msg
    else:
      print "UNRECOGNIZED STRING:", line.strip()


def main(argv):
  if not "FUCHSIA_DIR" in os.environ:
    print "Error: could not find env variable $FUCHSIA_DIR"
    return 1
  if not "FUCHSIA_BUILD_DIR" in os.environ:
    print "Error: could not find env variable $FUCHSIA_BUILD_DIR"
    return 1

  parser = argparse.ArgumentParser()
  default_port = 8342
  # An ipv6 address must be in square brackets
  default_server = "192.168.3.53:" + str(default_port)
  parser.add_argument(
      "--server",
      help="Address ('server:port') of where the test_runner daemon is running. Default: "
      + default_server,
      type=str,
      default=default_server)
  parser.add_argument(
      "--loglistener_path",
      help="Path to the loglistener binary",
      type=str,
      default=os.path.join(os.environ["FUCHSIA_DIR"],
                           "out/build-magenta/tools/loglistener"))
  parser.add_argument(
      "--test_file",
      help="Path to a json file containing a series of tests to run.",
      type=str,
      default="")
  parser.add_argument("command", nargs="*")
  args = parser.parse_args()

  host = urlparse("http://" + args.server)
  port = host.port
  if port is None:
    port = default_port

  if args.test_file == "" and len(args.command) == 0:
    print("Error: either a single test command, or --test_file must be "
          "specified.")
    return 1

  # 1. Start listening to the device log.
  listener_process = subprocess.Popen(
      [args.loglistener_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  # 2. Open up a connection to the on-device test runner server.
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  try:
    sock.connect((host.hostname, port))
  except socket.error, exc:
    print "Error: Can't connect socket %s for %s port %d" % (exc, host.hostname,
                                                            port)
    return 1

  # 3. Read commands and send them to the test runner server.
  if args.test_file is None and len(args.command) == 0:
    print "Error: either a single test command, or --test_file must be specified."
    return 1

  if len(args.command) > 0:
    command_str = " ".join(args.command)
    # Run a single command
    print "%sRunning %s ..%s" % (color.BOLD, command_str, color.END)
    sys.stdout.flush()
    run_test(sock, listener_process, command_str)
  else:
    # Run series of commands from test file
    with open(args.test_file) as f:
      tests = json.load(f)
      for test in tests["tests"]:
        print "%sRunning %s ..%s" % (color.BOLD, test["name"], color.END)
        sys.stdout.flush()
        if "copy" in test:
          if not copy_files(test["copy"]):
            return 1
        run_test(sock, listener_process, test["exec"])

  # 4. Cleanup
  listener_process.terminate()
  sock.close()


if __name__ == "__main__":
  main(sys.argv)

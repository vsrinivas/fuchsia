// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: This file is machine generated by fidlc.

#pragma once

#include <ddk/protocol/usb-dci.h>
#include <fbl/macros.h>

namespace ddk {
namespace internal {

DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_interface_control, UsbDciInterfaceControl,
                                     zx_status_t (C::*)(const usb_setup_t* setup,
                                                        const void* write_buffer, size_t write_size,
                                                        void* out_read_buffer, size_t read_size,
                                                        size_t* out_read_actual));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_interface_set_connected,
                                     UsbDciInterfaceSetConnected, void (C::*)(bool connected));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_interface_set_speed, UsbDciInterfaceSetSpeed,
                                     void (C::*)(usb_speed_t speed));

template <typename D>
constexpr void CheckUsbDciInterfaceSubclass() {
    static_assert(
        internal::has_usb_dci_interface_control<D>::value,
        "UsbDciInterface subclasses must implement "
        "zx_status_t UsbDciInterfaceControl(const usb_setup_t* setup, const void* write_buffer, "
        "size_t write_size, void* out_read_buffer, size_t read_size, size_t* out_read_actual");
    static_assert(internal::has_usb_dci_interface_set_connected<D>::value,
                  "UsbDciInterface subclasses must implement "
                  "void UsbDciInterfaceSetConnected(bool connected");
    static_assert(internal::has_usb_dci_interface_set_speed<D>::value,
                  "UsbDciInterface subclasses must implement "
                  "void UsbDciInterfaceSetSpeed(usb_speed_t speed");
}

DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_request_queue, UsbDciRequestQueue,
                                     void (C::*)(usb_request_t* req));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_set_interface, UsbDciSetInterface,
                                     zx_status_t (C::*)(const usb_dci_interface_t* interface));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(
    has_usb_dci_protocol_config_ep, UsbDciConfigEp,
    zx_status_t (C::*)(const usb_endpoint_descriptor_t* ep_desc,
                       const usb_ss_ep_comp_descriptor_t* ss_comp_desc));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_disable_ep, UsbDciDisableEp,
                                     zx_status_t (C::*)(uint8_t ep_address));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_ep_set_stall, UsbDciEpSetStall,
                                     zx_status_t (C::*)(uint8_t ep_address));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_ep_clear_stall, UsbDciEpClearStall,
                                     zx_status_t (C::*)(uint8_t ep_address));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_get_bti, UsbDciGetBti,
                                     zx_status_t (C::*)(zx_handle_t* out_bti));
DECLARE_HAS_MEMBER_FN_WITH_SIGNATURE(has_usb_dci_protocol_get_request_size, UsbDciGetRequestSize,
                                     size_t (C::*)());

template <typename D>
constexpr void CheckUsbDciProtocolSubclass() {
    static_assert(internal::has_usb_dci_protocol_request_queue<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "void UsbDciRequestQueue(usb_request_t* req");
    static_assert(internal::has_usb_dci_protocol_set_interface<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciSetInterface(const usb_dci_interface_t* interface");
    static_assert(internal::has_usb_dci_protocol_config_ep<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciConfigEp(const usb_endpoint_descriptor_t* ep_desc, const "
                  "usb_ss_ep_comp_descriptor_t* ss_comp_desc");
    static_assert(internal::has_usb_dci_protocol_disable_ep<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciDisableEp(uint8_t ep_address");
    static_assert(internal::has_usb_dci_protocol_ep_set_stall<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciEpSetStall(uint8_t ep_address");
    static_assert(internal::has_usb_dci_protocol_ep_clear_stall<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciEpClearStall(uint8_t ep_address");
    static_assert(internal::has_usb_dci_protocol_get_bti<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "zx_status_t UsbDciGetBti(zx_handle_t* out_bti");
    static_assert(internal::has_usb_dci_protocol_get_request_size<D>::value,
                  "UsbDciProtocol subclasses must implement "
                  "size_t UsbDciGetRequestSize()");
}

} // namespace internal
} // namespace ddk

# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/config/clang/clang.gni")
import("//build/config/fuchsia/zircon.gni")

images_dir = "$root_out_dir/images"

# Build a "kernel partition" target for ChromeOS targets.
#
# Parameters
#
#   deps (required)
#     [list of labels] Must be bootdata labels defined earlier in the file.
#
template("vboot") {
  output_name = "${target_name}.vboot"
  compiled_action(output_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    tool = "//garnet/tools/vboot_reference:futility"
    vboot_dir = "//third_party/vboot_reference"
    kernel_keyblock = "$vboot_dir/tests/devkeys/kernel.keyblock"
    private_keyblock = "$vboot_dir/tests/devkeys/kernel_data_key.vbprivk"
    inputs = [
      kernel_keyblock,
      private_keyblock,
    ]

    deps = invoker.deps

    bootdata_bins = []
    foreach(bootdata_label, deps) {
      bootdata_bins += get_target_outputs(bootdata_label)
    }
    inputs += bootdata_bins

    bootdata_bin = bootdata_bins[0]
    assert([ bootdata_bin ] == bootdata_bins)

    zircon_bin = "${zircon_build_dir}/zircon.bin"
    inputs += [ zircon_bin ]

    output = "$images_dir/$output_name"
    outputs = [
      output,
    ]

    args = [
      "vbutil_kernel",
      "--pack",
      rebase_path(output),
      "--keyblock",
      rebase_path(kernel_keyblock),
      "--signprivate",
      rebase_path(private_keyblock),
      "--bootloader",
      rebase_path(bootdata_bin),
      "--vmlinuz",
      rebase_path(zircon_bin),
      "--version",
      "1",
      "--flags",
      "0x2",
    ]
  }
}

# Build an "EFI System Partition" target for EFI targets.
#
# Parameters
#
#   bootdata_bin (optional)
#     [path] Must be a ramdisk that compliments zircon_bin.
#
#   zircon_bin (optional)
#     [path] A zircon kernel.
#
#   zedboot_bin (optional)
#     [label] A Zedboot zbi bin.
#
#   cmdline (optional)
#     [path] A bootloader (Gigaboot) cmdline file to include in the EFI root.
#
template("esp") {
  output_name = "${target_name}.esp.blk"
  compiled_action(output_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                             "visibility",
                           ])

    tool = "//garnet/go/src/make-efi"
    tool_output_name = "make-efi"

    efi_image_path = "$images_dir/$output_name"
    mkfs_msdosfs_bin = "$zircon_tools_dir/mkfs-msdosfs"

    outputs = [
      efi_image_path,
    ]
    inputs = [
      mkfs_msdosfs_bin,
    ]
    args = [
      "--output",
      rebase_path(efi_image_path),
      "--mkfs",
      rebase_path(mkfs_msdosfs_bin),
    ]

    if (defined(invoker.zircon_bin)) {
      args += [
        "--zircon",
        rebase_path(invoker.zircon_bin),
      ]
      inputs += [ invoker.zircon_bin ]
    }

    if (defined(invoker.bootdata_bin)) {
      args += [
        "--bootdata",
        rebase_path(invoker.bootdata_bin),
      ]
      inputs += [ invoker.bootdata_bin ]
    }

    if (defined(invoker.zedboot_bin)) {
      args += [
        "--zedboot",
        rebase_path(invoker.zedboot_bin),
      ]
      inputs += [ invoker.zedboot_bin ]
    }

    if (defined(invoker.cmdline)) {
      args += [
        "--cmdline",
        rebase_path(invoker.cmdline),
      ]
    }

    if (target_cpu == "x64") {
      gigaboot_bin = "${zircon_build_dir}/bootloader/bootx64.efi"
      args += [
        "--efi-bootloader",
        rebase_path(gigaboot_bin),
      ]
      inputs += [ gigaboot_bin ]
    }
  }
}

# Build a Zircon Boot Image (ZBI) that is a bootable "kernel partition".
#
# Parameters
#
#   deps (optional)
#     [list of labels] Build targets that are necessary to produce any of the other arguments.
#
#   zircon_bin (optional)
#     [path] A zircon kernel.
#
#   manifest (optional)
#     [path] A bootfs manifest file.

#   bootdata (optional)
#     [path] A bootdata path defined earlier in the file.
#
#   cmdline (optional):
#     [list of paths] Text files containing cmdline arguments.
#
template("zbi") {
  output_name = "${target_name}.zbi"

  zircon_tool_action(output_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "sources",
                             "visibility",
                             "testonly",
                           ])
    tool = "zbi"

    zbi_image_path = "$images_dir/$output_name"
    outputs = [
      zbi_image_path,
    ]

    inputs = []

    args = [
      "-o",
      rebase_path(zbi_image_path),
    ]

    if (defined(invoker.zircon_bin)) {
      assert(!defined(invoker.manifest))
      inputs += [ invoker.zircon_bin ]
      args += [
        rebase_path(invoker.zircon_bin),
      ]
    }

    if (defined(invoker.manifest)) {
      assert(!defined(invoker.zircon_bin))
      inputs += [ invoker.manifest ]
      args += [
        "-c",
        rebase_path(invoker.manifest),
      ]
    }

    if (defined(invoker.bootdata)) {
      inputs += [ invoker.bootdata ]
      args += [
        rebase_path(invoker.bootdata),
      ]
    }

    if (defined(invoker.cmdline)) {
      inputs += invoker.cmdline
      args += [
        "-T",
        "cmdline",
      ]
      foreach(cmdline, invoker.cmdline) {
        args += [ rebase_path(cmdline) ]
      }
    }
  }
}

# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/fuchsia/bootdata.gni")
import("//build/images/boot.gni")
import("//build/images/manifest.gni")

declare_args() {
  # File containing kernel command line arguments to roll into the
  # bootdata image used for zedboot.
  zedboot_cmdline_file = ""
}

# zedboot_image_paths aggregates a list of environment variable style strings of the form:
# IMAGE_{NAME}_{TYPE}=path
# path is relative to $root_build_dir
# This will be written out at generation time and is later consumed by
# //scripts and various tools to find the relevant images.
zedboot_image_paths = []

bootdata_cmdline("zedboot_cmdline") {
  visibility = [ ":*" ]
  inputs = [
    "cmdline.txt",
  ]
}

# Let the build configuration choose some extra fixed command-line arguments
# for zedboot.
if (zedboot_cmdline_file != "") {
  bootdata_cmdline("extra_zedboot_cmdline") {
    visibility = [ ":*" ]
    inputs = [
      zedboot_cmdline_file,
    ]
  }
}

# Construct a minimal manifest containing only the few user binaries
# that constitute zedboot, and the libraries they depend on.
# TODO(mcgrathr): This could be made smaller by constraining the drivers
# included, but we don't currently have a good way to determine the
# subset that is useful to Zedboot.
zedboot_binary_patterns = [
  # These are the core things needed for booting (local and netboot).
  "bin/crashlogger",
  "bin/devmgr",
  "bin/dlog",
  "bin/fshost",
  "bin/netsvc",
  "bin/svchost",
  "bin/virtual-console",
  "driver/*",  # Drivers automagically cause devhost to be brought in.

  # These are needed for installer runs.
  "bin/blobfs",
  "bin/install-disk-image",
  "bin/minfs",
  "bin/mount",

  # These are useful for debugging.
  "bin/dd",
  "bin/driverctl",
  "bin/fixfs",
  "bin/fsck*",
  "bin/gpt",
  "bin/killall",
  "bin/lsblk",
  "bin/lsdev",
  "bin/lsusb",
  "bin/mkfs*",
  "bin/netdump",
  "bin/ping",
  "bin/ps",
  "bin/sh",
  "bin/umount",
]

generate_manifest("zedboot.manifest") {
  visibility = [ ":*" ]
  args = []
  foreach(pattern, zedboot_binary_patterns) {
    args += [ "--binary=" + pattern ]
  }
}

# zedboot-data.bin is a Zircon BOOTDATA file containing the
# command line and BOOTFS pieces necessary to make Zircon be Zedboot.
bootdata("zedboot-data") {
  boot = true
  deps = [
    ":zedboot.manifest",
  ]
  manifest_outputs = get_target_outputs(":zedboot.manifest")
  inputs = [
    manifest_outputs[0],
  ]
  bootdata_deps = [ ":zedboot_cmdline" ]
  if (zedboot_cmdline_file != "") {
    bootdata_deps += [ ":extra_zedboot_cmdline" ]
  }
  deps += bootdata_deps
  foreach(label, bootdata_deps) {
    inputs += get_target_outputs(label)
  }
}

# images/zedboot.bin combines the kernel image itself with
# the BOOTDATA bits.  This single file can be booted by Gigaboot.
bootdata("zedboot.bin") {
  # XXX(raggi): this path is shared with //build/images/BUILD.gn.
  output_name = "zedboot"
  deps = [
    ":zedboot-data",
  ]
  inputs = [
    "$zircon_build_dir/zircon.bin",
  ]
  foreach(label, deps) {
    inputs += get_target_outputs(label)
  }
}
zedboot_zbi_image_path = get_target_outputs(":zedboot.bin")
zedboot_image_paths += [ "IMAGE_ZEDBOOT_ZBI=" + rebase_path(zedboot_zbi_image_path[0], root_build_dir) ]

vboot("zedboot") {
  deps = [
    ":zedboot.bin",
  ]
}
zedboot_vboot_image_path = get_target_outputs(":zedboot.vboot")
zedboot_image_paths += [ "IMAGE_ZEDBOOT_VBOOT=" + rebase_path(zedboot_vboot_image_path[0], root_build_dir) ]

if (target_cpu != "arm64") {
  esp("zedboot") {
    cmdline = "efi_cmdline.txt"

    zedboot_outputs = get_target_outputs(":zedboot.bin")
    zedboot_bin = zedboot_outputs[0]
    deps = [ ":zedboot.bin" ]
  }
  zedboot_esp_image_path = get_target_outputs(":zedboot.esp.blk")
  zedboot_image_paths += [ "IMAGE_ZEDBOOT_ESP=" + rebase_path(zedboot_esp_image_path[0], root_build_dir) ]
}

zbi("zedboot-bootfs") {
  manifest_outputs = get_target_outputs(":zedboot.manifest")
  manifest = manifest_outputs[0]
  deps = [
    ":zedboot.manifest",
  ]
}
zedboot_bootfs_label = ":zedboot-bootfs.zbi"

zbi("zedboot") {
  zircon_bin = "${zircon_build_dir}/zircon.bin"
  cmdline = [
    "cmdline.txt",
  ]
  if (zedboot_cmdline_file != "") {
    cmdline += [ zedboot_cmdline_file ]
  }

  boot_output = get_target_outputs(zedboot_bootfs_label)
  bootdata = boot_output[0]
  deps = [
    zedboot_bootfs_label
  ]
}
zedboot_image_path = get_target_outputs(":zedboot.zbi")
zedboot_image_paths += [ "IMAGE_ZIRCONR_ZBI=" + rebase_path(zedboot_image_path[0], root_build_dir) ]

group("zedboot") {
  deps = [
    ":zedboot.bin",
    ":zedboot.vboot",
    ":zedboot.zbi",
  ]
  if (target_cpu != "arm64") {
    deps += [ ":zedboot.esp.blk" ]
  }
}

# See definition of zedboot_image_paths for purpose.
write_file("$root_build_dir/zedboot_image_paths.sh", zedboot_image_paths)

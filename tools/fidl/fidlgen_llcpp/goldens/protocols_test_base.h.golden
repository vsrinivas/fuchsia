// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test/protocols/llcpp/fidl.h>
namespace fidl_test_protocols {
namespace testing {

class Transitional_TestBase
    : public ::fidl_test_protocols::Transitional::Interface {
 public:
  virtual ~Transitional_TestBase() {}
  virtual void NotImplemented_(const std::string& name,
                               ::fidl::CompleterBase& completer) = 0;

  using Interface = ::fidl_test_protocols::Transitional::Interface;
  virtual void Request(int64_t x,
                       Interface::RequestCompleter::Sync& completer) override {
    NotImplemented_("Request", completer);
  }
  virtual void OneWay(int64_t x,
                      Interface::OneWayCompleter::Sync& completer) override {
    NotImplemented_("OneWay", completer);
  }
};

class ChannelProtocol_TestBase
    : public ::fidl_test_protocols::ChannelProtocol::Interface {
 public:
  virtual ~ChannelProtocol_TestBase() {}
  virtual void NotImplemented_(const std::string& name,
                               ::fidl::CompleterBase& completer) = 0;

  using Interface = ::fidl_test_protocols::ChannelProtocol::Interface;
  virtual void MethodA(int64_t a, int64_t b,
                       Interface::MethodACompleter::Sync& completer) override {
    NotImplemented_("MethodA", completer);
  }
  virtual void MethodB(int64_t a, int64_t b,
                       Interface::MethodBCompleter::Sync& completer) override {
    NotImplemented_("MethodB", completer);
  }
  virtual void TakeHandle(
      ::zx::handle h,
      Interface::TakeHandleCompleter::Sync& completer) override {
    NotImplemented_("TakeHandle", completer);
  }
  virtual void MutateSocket(
      ::zx::socket a,
      Interface::MutateSocketCompleter::Sync& completer) override {
    NotImplemented_("MutateSocket", completer);
  }
};

class WithAndWithoutRequestResponse_TestBase
    : public ::fidl_test_protocols::WithAndWithoutRequestResponse::Interface {
 public:
  virtual ~WithAndWithoutRequestResponse_TestBase() {}
  virtual void NotImplemented_(const std::string& name,
                               ::fidl::CompleterBase& completer) = 0;

  using Interface =
      ::fidl_test_protocols::WithAndWithoutRequestResponse::Interface;
  virtual void NoRequestNoResponse(
      Interface::NoRequestNoResponseCompleter::Sync& completer) override {
    NotImplemented_("NoRequestNoResponse", completer);
  }
  virtual void NoRequestEmptyResponse(
      Interface::NoRequestEmptyResponseCompleter::Sync& completer) override {
    NotImplemented_("NoRequestEmptyResponse", completer);
  }
  virtual void NoRequestWithResponse(
      Interface::NoRequestWithResponseCompleter::Sync& completer) override {
    NotImplemented_("NoRequestWithResponse", completer);
  }
  virtual void WithRequestNoResponse(
      ::fidl::StringView arg,
      Interface::WithRequestNoResponseCompleter::Sync& completer) override {
    NotImplemented_("WithRequestNoResponse", completer);
  }
  virtual void WithRequestEmptyResponse(
      ::fidl::StringView arg,
      Interface::WithRequestEmptyResponseCompleter::Sync& completer) override {
    NotImplemented_("WithRequestEmptyResponse", completer);
  }
  virtual void WithRequestWithResponse(
      ::fidl::StringView arg,
      Interface::WithRequestWithResponseCompleter::Sync& completer) override {
    NotImplemented_("WithRequestWithResponse", completer);
  }
};

class WithErrorSyntax_TestBase
    : public ::fidl_test_protocols::WithErrorSyntax::Interface {
 public:
  virtual ~WithErrorSyntax_TestBase() {}
  virtual void NotImplemented_(const std::string& name,
                               ::fidl::CompleterBase& completer) = 0;

  using Interface = ::fidl_test_protocols::WithErrorSyntax::Interface;
  virtual void ResponseAsStruct(
      Interface::ResponseAsStructCompleter::Sync& completer) override {
    NotImplemented_("ResponseAsStruct", completer);
  }
  virtual void ErrorAsPrimitive(
      Interface::ErrorAsPrimitiveCompleter::Sync& completer) override {
    NotImplemented_("ErrorAsPrimitive", completer);
  }
  virtual void ErrorAsEnum(
      Interface::ErrorAsEnumCompleter::Sync& completer) override {
    NotImplemented_("ErrorAsEnum", completer);
  }
};
}  // namespace testing
}  // namespace fidl_test_protocols

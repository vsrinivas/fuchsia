// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>

#endif  // __Fuchsia__

#include <fidl/test.protocols/cpp/common_types.h>
#include <fidl/test.protocols/cpp/markers.h>

namespace test_protocols {
namespace wire {
using Rights = ::test_protocols::rights;

using ObjType = ::test_protocols::obj_type;
using ErrorEnum = ::test_protocols::ErrorEnum;

struct WithErrorSyntaxHandleInResultResponse;

struct WithErrorSyntaxHandleInResultTopResponse;

struct HandleRightsProtocolResponseMethodTopResponse;

struct HandleRightsProtocolResponseMethodRequest;

struct HandleRightsProtocolNoResponseMethodRequest;

struct HandleRightsProtocolAnEventRequest;

struct ChannelProtocolTakeHandleRequest;

struct ChannelProtocolMutateSocketTopResponse;

struct ChannelProtocolMutateSocketRequest;

struct WithProtocolEndsServerEndsTopResponse;

struct WithProtocolEndsServerEndsRequest;

struct WithProtocolEndsClientEndsTopResponse;

struct WithProtocolEndsClientEndsRequest;

struct WithErrorSyntaxResponseAsStructResponse;

struct WithErrorSyntaxResponseAsStructTopResponse;

struct WithErrorSyntaxErrorAsPrimitiveResponse;

struct WithErrorSyntaxErrorAsPrimitiveTopResponse;

struct WithErrorSyntaxErrorAsEnumResponse;

struct WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;

struct WithAndWithoutRequestResponseWithRequestWithResponseRequest;

struct WithAndWithoutRequestResponseWithRequestNoResponseRequest;

struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

struct WithAndWithoutRequestResponseOnWithResponseRequest;

struct WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;

struct TransitionalRequestTopResponse;

struct TransitionalRequestRequest;

struct TransitionalOneWayRequest;

struct TransitionalEventRequest;

struct MethodWithUnionUnionMethodRequest;

struct SyscallProtocolMethodCRequest;

struct ProtocolEnds;

struct WithProtocolEndsStructContainingEndsTopResponse;

struct WithProtocolEndsStructContainingEndsRequest;

struct ManyParametersFifteenRequest;

struct WithErrorSyntaxErrorAsEnumTopResponse;

struct ChannelProtocolMethodBTopResponse;

struct ChannelProtocolMethodBRequest;

struct ChannelProtocolMethodARequest;

struct ChannelProtocolEventARequest;

class WithErrorSyntaxHandleInResultResult;

class WithErrorSyntaxResponseAsStructResult;

class WithErrorSyntaxErrorAsPrimitiveResult;

class TheUnion;

class WithErrorSyntaxErrorAsEnumResult;

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

struct WithErrorSyntaxHandleInResultResponse {
  ::zx::handle h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

struct HandleRightsProtocolResponseMethodTopResponse {
  ::zx::socket h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

struct HandleRightsProtocolResponseMethodRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

struct HandleRightsProtocolNoResponseMethodRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

struct HandleRightsProtocolAnEventRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

struct ChannelProtocolTakeHandleRequest {
  ::zx::handle h = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

struct ChannelProtocolMutateSocketTopResponse {
  ::zx::socket b = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

struct ChannelProtocolMutateSocketRequest {
  ::zx::socket a = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

struct WithProtocolEndsServerEndsTopResponse {
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

struct WithProtocolEndsServerEndsRequest {
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

struct WithProtocolEndsClientEndsTopResponse {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

struct WithProtocolEndsClientEndsRequest {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

struct WithErrorSyntaxErrorAsPrimitiveResponse {
  uint8_t __reserved = {};
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

struct WithErrorSyntaxErrorAsEnumResponse {
  uint8_t __reserved = {};
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

class WithErrorSyntaxHandleInResultResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxHandleInResultResponse;

  WithErrorSyntaxHandleInResultResult()
      : ordinal_(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  ~WithErrorSyntaxHandleInResultResult();
  WithErrorSyntaxHandleInResultResult(
      WithErrorSyntaxHandleInResultResult&& other) {
    _Move(std::move(other));
  }
  WithErrorSyntaxHandleInResultResult& operator=(
      WithErrorSyntaxHandleInResultResult&& other) {
    if (this != &other) {
      _Move(std::move(other));
    }
    return *this;
  }

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
               Ordinal::kResponse;
  }
  static WithErrorSyntaxHandleInResultResult WithResponse(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse val) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>()
        .set_data(std::move(elem));
  }

  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>()
        .get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxHandleInResultResult::Ordinal::kErr;
  }
  static WithErrorSyntaxHandleInResultResult WithErr(uint32_t val) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag>(
        ordinal_);
  }
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };
  void _Move(WithErrorSyntaxHandleInResultResult&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

class WithErrorSyntaxResponseAsStructResult {
 public:
  using Response =
      test_protocols::wire::WithErrorSyntaxResponseAsStructResponse;

  WithErrorSyntaxResponseAsStructResult()
      : ordinal_(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  WithErrorSyntaxResponseAsStructResult(
      const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(
      const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult(
      WithErrorSyntaxResponseAsStructResult&&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(
      WithErrorSyntaxResponseAsStructResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
               Ordinal::kResponse;
  }
  static WithErrorSyntaxResponseAsStructResult WithResponse(
      ::fidl::ObjectView<
          ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
          val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxResponseAsStructResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_response(
        ::fidl::ObjectView<
            ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
          elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>()
        .set_data(std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
        Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<
            ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>()
        .get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxResponseAsStructResult::Ordinal::kErr;
  }
  static WithErrorSyntaxResponseAsStructResult WithErr(uint32_t val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

class WithErrorSyntaxErrorAsPrimitiveResult {
 public:
  using Response =
      test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse;

  WithErrorSyntaxErrorAsPrimitiveResult()
      : ordinal_(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  WithErrorSyntaxErrorAsPrimitiveResult(
      const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(
      const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult(
      WithErrorSyntaxErrorAsPrimitiveResult&&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(
      WithErrorSyntaxErrorAsPrimitiveResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
               Ordinal::kResponse;
  }
  static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>()
        .set_data(std::move(elem));
  }

  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>()
        .get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr;
  }
  static WithErrorSyntaxErrorAsPrimitiveResult WithErr(uint32_t val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                  Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_protocols_TheUnionTable;

class TheUnion {
 public:
  TheUnion()
      : ordinal_(::test_protocols::wire::TheUnion::Ordinal::Invalid),
        envelope_ {}
  {}

  TheUnion(const TheUnion&) = default;
  TheUnion& operator=(const TheUnion&) = default;
  TheUnion(TheUnion&&) = default;
  TheUnion& operator=(TheUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::Invalid;
  }

  bool is_v() const {
    return ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV;
  }
  static TheUnion WithV(uint32_t val) {
    TheUnion result;
    result.set_v(std::move(val));
    return result;
  }

  void set_v(uint32_t elem) {
    ordinal_ = ::test_protocols::wire::TheUnion::Ordinal::kV;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& v() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& v() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::TheUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::TheUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

class WithErrorSyntaxErrorAsEnumResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse;

  WithErrorSyntaxErrorAsEnumResult()
      : ordinal_(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  WithErrorSyntaxErrorAsEnumResult(const WithErrorSyntaxErrorAsEnumResult&) =
      default;
  WithErrorSyntaxErrorAsEnumResult& operator=(
      const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult&&) =
      default;
  WithErrorSyntaxErrorAsEnumResult& operator=(
      WithErrorSyntaxErrorAsEnumResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse;
  }
  static WithErrorSyntaxErrorAsEnumResult WithResponse(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse elem) {
    ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
        Ordinal::kResponse;
    envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>()
        .set_data(std::move(elem));
  }

  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>()
        .get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response()
      const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr;
  }
  static WithErrorSyntaxErrorAsEnumResult WithErr(
      ::test_protocols::wire::ErrorEnum val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(::test_protocols::wire::ErrorEnum elem) {
    ordinal_ =
        ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr;
    envelope_.As<::test_protocols::wire::ErrorEnum>().set_data(std::move(elem));
  }

  ::test_protocols::wire::ErrorEnum& err() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::
                              WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return envelope_.As<::test_protocols::wire::ErrorEnum>().get_data();
  }
  const ::test_protocols::wire::ErrorEnum& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::
                              WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return envelope_.As<::test_protocols::wire::ErrorEnum>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

struct WithErrorSyntaxHandleInResultTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

struct WithErrorSyntaxResponseAsStructResponse {
  int64_t a = {};

  int64_t b = {};

  int64_t c = {};
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

struct WithErrorSyntaxResponseAsStructTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result = {};
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

struct WithErrorSyntaxErrorAsPrimitiveTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

struct WithAndWithoutRequestResponseWithRequestWithResponseTopResponse {
  ::fidl::StringView ret = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
  ::fidl::StringView arg = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
  ::fidl::StringView arg = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
  ::fidl::StringView arg = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

struct WithAndWithoutRequestResponseOnWithResponseRequest {
  ::fidl::StringView ret = {};
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

struct WithAndWithoutRequestResponseNoRequestWithResponseTopResponse {
  ::fidl::StringView ret = {};
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

struct TransitionalRequestTopResponse {
  int64_t y = {};
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

struct TransitionalRequestRequest {
  int64_t x = {};
};

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

struct TransitionalOneWayRequest {
  int64_t x = {};
};

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

struct TransitionalEventRequest {
  int64_t x = {};
};

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

struct MethodWithUnionUnionMethodRequest {
  ::test_protocols::wire::TheUnion u = {};
};

extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

struct SyscallProtocolMethodCRequest {
  int64_t a = {};

  int64_t b = {};
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

struct ProtocolEnds {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client = {};

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server = {};

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt = {};

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

struct WithProtocolEndsStructContainingEndsTopResponse {
  ::test_protocols::wire::ProtocolEnds out = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

struct WithProtocolEndsStructContainingEndsRequest {
  ::test_protocols::wire::ProtocolEnds in = {};

  void _CloseHandles();
};
#endif  // __Fuchsia__

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

struct ManyParametersFifteenRequest {
  bool p1 = {};

  bool p2 = {};

  bool p3 = {};

  bool p4 = {};

  bool p5 = {};

  bool p6 = {};

  bool p7 = {};

  bool p8 = {};

  bool p9 = {};

  bool p10 = {};

  bool p11 = {};

  bool p12 = {};

  bool p13 = {};

  bool p14 = {};

  bool p15 = {};
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

struct WithErrorSyntaxErrorAsEnumTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result = {};
};

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

struct ChannelProtocolMethodBTopResponse {
  int64_t result = {};
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

struct ChannelProtocolMethodBRequest {
  int64_t a = {};

  int64_t b = {};
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

struct ChannelProtocolMethodARequest {
  int64_t a = {};

  int64_t b = {};
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

struct ChannelProtocolEventARequest {
  int64_t a = {};

  int64_t b = {};
};

}  // namespace wire
}  // namespace test_protocols
namespace fidl {

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse,
             h) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse) ==
    TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse,
             result) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse) ==
    TypeTraits<::test_protocols::wire::
                   WithErrorSyntaxHandleInResultTopResponse>::kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse>);
static_assert(
    offsetof(
        ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse,
        h) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               HandleRightsProtocolResponseMethodTopResponse) ==
    TypeTraits<
        ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>);
static_assert(
    offsetof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest,
             h) == 0);
static_assert(
    sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest) ==
    TypeTraits<::test_protocols::wire::
                   HandleRightsProtocolResponseMethodRequest>::kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>);
static_assert(
    offsetof(
        ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest,
        h) == 0);
static_assert(
    sizeof(
        ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest) ==
    TypeTraits<::test_protocols::wire::
                   HandleRightsProtocolNoResponseMethodRequest>::kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::HandleRightsProtocolAnEventRequest>);
static_assert(
    offsetof(::test_protocols::wire::HandleRightsProtocolAnEventRequest, h) ==
    0);
static_assert(
    sizeof(::test_protocols::wire::HandleRightsProtocolAnEventRequest) ==
    TypeTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolTakeHandleRequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolTakeHandleRequest,
                       h) == 0);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolTakeHandleRequest) ==
    TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::ChannelProtocolMutateSocketTopResponse,
             b) == 0);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolMutateSocketTopResponse) ==
    TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketTopResponse>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolMutateSocketRequest>);
static_assert(
    offsetof(::test_protocols::wire::ChannelProtocolMutateSocketRequest, a) ==
    0);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolMutateSocketRequest) ==
    TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithProtocolEndsServerEndsTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithProtocolEndsServerEndsTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithProtocolEndsServerEndsTopResponse,
             out) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithProtocolEndsServerEndsTopResponse) ==
    TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithProtocolEndsServerEndsRequest>);
static_assert(
    offsetof(::test_protocols::wire::WithProtocolEndsServerEndsRequest, in) ==
    0);
static_assert(
    sizeof(::test_protocols::wire::WithProtocolEndsServerEndsRequest) ==
    TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithProtocolEndsClientEndsTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithProtocolEndsClientEndsTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithProtocolEndsClientEndsTopResponse,
             out) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithProtocolEndsClientEndsTopResponse) ==
    TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse>::
        kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithProtocolEndsClientEndsRequest>);
static_assert(
    offsetof(::test_protocols::wire::WithProtocolEndsClientEndsRequest, in) ==
    0);
static_assert(
    sizeof(::test_protocols::wire::WithProtocolEndsClientEndsRequest) ==
    TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest>::
        kPrimarySize);
#endif  // __Fuchsia__

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 24;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
             a) == 0);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
             b) == 8);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
             c) == 16);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse) ==
    TypeTraits<::test_protocols::wire::
                   WithErrorSyntaxResponseAsStructResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse,
             result) == 0);
static_assert(
    sizeof(
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse) ==
    TypeTraits<::test_protocols::wire::
                   WithErrorSyntaxResponseAsStructTopResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse,
             __reserved) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse) ==
    TypeTraits<::test_protocols::wire::
                   WithErrorSyntaxErrorAsPrimitiveResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse,
             result) == 0);
static_assert(
    sizeof(
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse) ==
    TypeTraits<::test_protocols::wire::
                   WithErrorSyntaxErrorAsPrimitiveTopResponse>::kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse,
             __reserved) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse) ==
    TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>);
static_assert(
    offsetof(
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
        ret) == 0);
static_assert(
    sizeof(
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse) ==
    TypeTraits<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::
                    WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::
                  WithAndWithoutRequestResponseWithRequestWithResponseRequest>);
static_assert(
    offsetof(::test_protocols::wire::
                 WithAndWithoutRequestResponseWithRequestWithResponseRequest,
             arg) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithAndWithoutRequestResponseWithRequestWithResponseRequest) ==
    TypeTraits<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::
                      WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::
                    WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::
                  WithAndWithoutRequestResponseWithRequestNoResponseRequest>);
static_assert(
    offsetof(::test_protocols::wire::
                 WithAndWithoutRequestResponseWithRequestNoResponseRequest,
             arg) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithAndWithoutRequestResponseWithRequestNoResponseRequest) ==
    TypeTraits<::test_protocols::wire::
                   WithAndWithoutRequestResponseWithRequestNoResponseRequest>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>);
static_assert(
    offsetof(::test_protocols::wire::
                 WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
             arg) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithAndWithoutRequestResponseWithRequestEmptyResponseRequest) ==
    TypeTraits<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::
                      WithAndWithoutRequestResponseOnWithResponseRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::
                  WithAndWithoutRequestResponseOnWithResponseRequest>);
static_assert(offsetof(::test_protocols::wire::
                           WithAndWithoutRequestResponseOnWithResponseRequest,
                       ret) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithAndWithoutRequestResponseOnWithResponseRequest) ==
    TypeTraits<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseOnWithResponseRequest>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::
                 WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
             ret) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithAndWithoutRequestResponseNoRequestWithResponseTopResponse) ==
    TypeTraits<
        ::test_protocols::wire::
            WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::TransitionalRequestTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_TransitionalRequestTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalRequestTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalRequestTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::TransitionalRequestTopResponse>);
static_assert(offsetof(::test_protocols::wire::TransitionalRequestTopResponse,
                       y) == 0);
static_assert(
    sizeof(::test_protocols::wire::TransitionalRequestTopResponse) ==
    TypeTraits<
        ::test_protocols::wire::TransitionalRequestTopResponse>::kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::TransitionalRequestRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalRequestRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalRequestRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::TransitionalRequestRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalRequestRequest, x) ==
              0);
static_assert(sizeof(::test_protocols::wire::TransitionalRequestRequest) ==
              TypeTraits<::test_protocols::wire::TransitionalRequestRequest>::
                  kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::TransitionalOneWayRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalOneWayRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalOneWayRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::TransitionalOneWayRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalOneWayRequest, x) ==
              0);
static_assert(sizeof(::test_protocols::wire::TransitionalOneWayRequest) ==
              TypeTraits<::test_protocols::wire::TransitionalOneWayRequest>::
                  kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::TransitionalEventRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalEventRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalEventRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::TransitionalEventRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalEventRequest, x) ==
              0);
static_assert(
    sizeof(::test_protocols::wire::TransitionalEventRequest) ==
    TypeTraits<::test_protocols::wire::TransitionalEventRequest>::kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::MethodWithUnionUnionMethodRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::MethodWithUnionUnionMethodRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::MethodWithUnionUnionMethodRequest>);
static_assert(
    offsetof(::test_protocols::wire::MethodWithUnionUnionMethodRequest, u) ==
    0);
static_assert(
    sizeof(::test_protocols::wire::MethodWithUnionUnionMethodRequest) ==
    TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::SyscallProtocolMethodCRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_SyscallProtocolMethodCRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::SyscallProtocolMethodCRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::SyscallProtocolMethodCRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::SyscallProtocolMethodCRequest>);
static_assert(offsetof(::test_protocols::wire::SyscallProtocolMethodCRequest,
                       a) == 0);
static_assert(offsetof(::test_protocols::wire::SyscallProtocolMethodCRequest,
                       b) == 8);
static_assert(
    sizeof(::test_protocols::wire::SyscallProtocolMethodCRequest) ==
    TypeTraits<
        ::test_protocols::wire::SyscallProtocolMethodCRequest>::kPrimarySize);

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ProtocolEnds>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ProtocolEnds> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_ProtocolEndsTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ProtocolEnds>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ProtocolEnds> : public std::true_type {
};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ProtocolEnds>);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, client) == 0);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, server) == 4);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, client_opt) == 8);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, server_opt) == 12);
static_assert(sizeof(::test_protocols::wire::ProtocolEnds) ==
              TypeTraits<::test_protocols::wire::ProtocolEnds>::kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::
                  WithProtocolEndsStructContainingEndsTopResponse>);
static_assert(
    offsetof(
        ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse,
        out) == 0);
static_assert(
    sizeof(::test_protocols::wire::
               WithProtocolEndsStructContainingEndsTopResponse) ==
    TypeTraits<
        ::test_protocols::wire::
            WithProtocolEndsStructContainingEndsTopResponse>::kPrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsResource<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};

template <>
struct TypeTraits<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>);
static_assert(
    offsetof(
        ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest,
        in) == 0);
static_assert(
    sizeof(
        ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest) ==
    TypeTraits<::test_protocols::wire::
                   WithProtocolEndsStructContainingEndsRequest>::kPrimarySize);
#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 15;
  static constexpr uint32_t kPrimarySizeV1 = 15;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ManyParametersFifteenRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ManyParametersFifteenRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ManyParametersFifteenRequest>);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p1) == 0);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p2) == 1);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p3) == 2);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p4) == 3);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p5) == 4);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p6) == 5);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p7) == 6);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p8) == 7);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p9) == 8);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p10) == 9);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p11) == 10);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p12) == 11);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p13) == 12);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p14) == 13);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest,
                       p15) == 14);
static_assert(sizeof(::test_protocols::wire::ManyParametersFifteenRequest) ==
              TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest>::
                  kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse,
             result) == 0);
static_assert(
    sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse) ==
    TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolMethodBTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolMethodBTopResponse>);
static_assert(
    offsetof(::test_protocols::wire::ChannelProtocolMethodBTopResponse,
             result) == 0);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolMethodBTopResponse) ==
    TypeTraits<::test_protocols::wire::ChannelProtocolMethodBTopResponse>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolMethodBRequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest,
                       a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest,
                       b) == 8);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolMethodBRequest) ==
    TypeTraits<
        ::test_protocols::wire::ChannelProtocolMethodBRequest>::kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodARequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodARequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolMethodARequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest,
                       a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest,
                       b) == 8);
static_assert(
    sizeof(::test_protocols::wire::ChannelProtocolMethodARequest) ==
    TypeTraits<
        ::test_protocols::wire::ChannelProtocolMethodARequest>::kPrimarySize);

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolEventARequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolEventARequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolEventARequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::ChannelProtocolEventARequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolEventARequest,
                       a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolEventARequest,
                       b) == 8);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolEventARequest) ==
              TypeTraits<::test_protocols::wire::ChannelProtocolEventARequest>::
                  kPrimarySize);

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResult>
    : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_HandleInResult_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxHandleInResultResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxHandleInResultResult>);
#endif  // __Fuchsia__

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult>);

template <>
struct TypeTraits<
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>);

template <>
struct TypeTraits<::test_protocols::wire::TheUnion> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::test_protocols_TheUnionTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::TheUnion> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::TheUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TheUnion>);

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocols::wire::
          test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>);

}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/result.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fidl/llcpp/wire_messaging.h>
#include <lib/fit/function.h>
#include <lib/stdcompat/optional.h>

#include <algorithm>
#include <cstddef>
#include <variant>
#ifdef __Fuchsia__
#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/client_end.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/server_end.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/txn_header.h>

#endif  // __Fuchsia__
#include <zircon/fidl.h>

namespace fidl_test_table {
namespace wire {
class TableWithAttributes;

class SimpleTable;

class ReverseOrdinalTable;

class OlderSimpleTable;

class NewerSimpleTable;

class GreaterThan64OrdinalTable;

class EmptyTable;

extern "C" const fidl_type_t fidl_test_table_TableWithAttributesTable;

class TableWithAttributes final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  bool has_x() const { return max_ordinal_ >= 1 && frame_ptr_->x_.has_data(); }
  TableWithAttributes& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  TableWithAttributes& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }

  TableWithAttributes& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    return *this;
  }

  template <typename... Args>
  TableWithAttributes& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  TableWithAttributes() = default;
  explicit TableWithAttributes(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit TableWithAttributes(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~TableWithAttributes() = default;
  TableWithAttributes(const TableWithAttributes& other) noexcept = default;
  TableWithAttributes& operator=(const TableWithAttributes& other) noexcept =
      default;
  TableWithAttributes(TableWithAttributes&& other) noexcept = default;
  TableWithAttributes& operator=(TableWithAttributes&& other) noexcept =
      default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_table_TableWithAttributesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> x_;

    friend class TableWithAttributes;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class TableWithAttributes::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        TableWithAttributes* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        TableWithAttributes* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<TableWithAttributes>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class TableWithAttributes::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(TableWithAttributes* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      TableWithAttributes* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<40> backing_buffer_;
  UnownedEncodedMessage message_;
};

class TableWithAttributes::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<TableWithAttributes> {
 public:
  using DecodedMessageBase<TableWithAttributes>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  TableWithAttributes* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<TableWithAttributes*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_SimpleTableTable;

class SimpleTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  bool has_x() const { return max_ordinal_ >= 1 && frame_ptr_->x_.has_data(); }
  SimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  SimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }

  SimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    return *this;
  }

  template <typename... Args>
  SimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  bool has_y() const { return max_ordinal_ >= 5 && frame_ptr_->y_.has_data(); }
  SimpleTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  SimpleTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }

  SimpleTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    return *this;
  }

  template <typename... Args>
  SimpleTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  SimpleTable() = default;
  explicit SimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit SimpleTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~SimpleTable() = default;
  SimpleTable(const SimpleTable& other) noexcept = default;
  SimpleTable& operator=(const SimpleTable& other) noexcept = default;
  SimpleTable(SimpleTable&& other) noexcept = default;
  SimpleTable& operator=(SimpleTable&& other) noexcept = default;

  static constexpr const fidl_type_t* Type = &fidl_test_table_SimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 56;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> x_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_1_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_2_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_3_;
    ::fidl::Envelope<int64_t> y_;

    friend class SimpleTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class SimpleTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        SimpleTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, SimpleTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<SimpleTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class SimpleTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(SimpleTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, SimpleTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<112> backing_buffer_;
  UnownedEncodedMessage message_;
};

class SimpleTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<SimpleTable> {
 public:
  using DecodedMessageBase<SimpleTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  SimpleTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<SimpleTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_ReverseOrdinalTableTable;

class ReverseOrdinalTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& z() const {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  int64_t& z() {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  bool has_z() const { return max_ordinal_ >= 1 && frame_ptr_->z_.has_data(); }
  ReverseOrdinalTable& set_z(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  ReverseOrdinalTable& set_z(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(nullptr);
    return *this;
  }

  ReverseOrdinalTable& clear_z() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.clear_data();
    return *this;
  }

  template <typename... Args>
  ReverseOrdinalTable& set_z(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  bool has_y() const { return max_ordinal_ >= 2 && frame_ptr_->y_.has_data(); }
  ReverseOrdinalTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }
  ReverseOrdinalTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }

  ReverseOrdinalTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    return *this;
  }

  template <typename... Args>
  ReverseOrdinalTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  bool has_x() const { return max_ordinal_ >= 3 && frame_ptr_->x_.has_data(); }
  ReverseOrdinalTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }
  ReverseOrdinalTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }

  ReverseOrdinalTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    return *this;
  }

  template <typename... Args>
  ReverseOrdinalTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }

  ReverseOrdinalTable() = default;
  explicit ReverseOrdinalTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit ReverseOrdinalTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~ReverseOrdinalTable() = default;
  ReverseOrdinalTable(const ReverseOrdinalTable& other) noexcept = default;
  ReverseOrdinalTable& operator=(const ReverseOrdinalTable& other) noexcept =
      default;
  ReverseOrdinalTable(ReverseOrdinalTable&& other) noexcept = default;
  ReverseOrdinalTable& operator=(ReverseOrdinalTable&& other) noexcept =
      default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_table_ReverseOrdinalTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> z_;
    ::fidl::Envelope<int64_t> y_;
    ::fidl::Envelope<int64_t> x_;

    friend class ReverseOrdinalTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class ReverseOrdinalTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ReverseOrdinalTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        ReverseOrdinalTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ReverseOrdinalTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ReverseOrdinalTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ReverseOrdinalTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ReverseOrdinalTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<88> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ReverseOrdinalTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ReverseOrdinalTable> {
 public:
  using DecodedMessageBase<ReverseOrdinalTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  ReverseOrdinalTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ReverseOrdinalTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_OlderSimpleTableTable;

class OlderSimpleTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  bool has_x() const { return max_ordinal_ >= 1 && frame_ptr_->x_.has_data(); }
  OlderSimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  OlderSimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }

  OlderSimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    return *this;
  }

  template <typename... Args>
  OlderSimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  OlderSimpleTable() = default;
  explicit OlderSimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit OlderSimpleTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~OlderSimpleTable() = default;
  OlderSimpleTable(const OlderSimpleTable& other) noexcept = default;
  OlderSimpleTable& operator=(const OlderSimpleTable& other) noexcept = default;
  OlderSimpleTable(OlderSimpleTable&& other) noexcept = default;
  OlderSimpleTable& operator=(OlderSimpleTable&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_table_OlderSimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> x_;

    friend class OlderSimpleTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class OlderSimpleTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        OlderSimpleTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, OlderSimpleTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<OlderSimpleTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class OlderSimpleTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(OlderSimpleTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      OlderSimpleTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<40> backing_buffer_;
  UnownedEncodedMessage message_;
};

class OlderSimpleTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<OlderSimpleTable> {
 public:
  using DecodedMessageBase<OlderSimpleTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  OlderSimpleTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<OlderSimpleTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_NewerSimpleTableTable;

class NewerSimpleTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  int64_t& x() {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  bool has_x() const { return max_ordinal_ >= 1 && frame_ptr_->x_.has_data(); }
  NewerSimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  NewerSimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }

  NewerSimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    return *this;
  }

  template <typename... Args>
  NewerSimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  const int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  int64_t& y() {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  bool has_y() const { return max_ordinal_ >= 5 && frame_ptr_->y_.has_data(); }
  NewerSimpleTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  NewerSimpleTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }

  NewerSimpleTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    return *this;
  }

  template <typename... Args>
  NewerSimpleTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  const int64_t& z() const {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  int64_t& z() {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  bool has_z() const { return max_ordinal_ >= 6 && frame_ptr_->z_.has_data(); }
  NewerSimpleTable& set_z(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }
  NewerSimpleTable& set_z(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(nullptr);
    return *this;
  }

  NewerSimpleTable& clear_z() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.clear_data();
    return *this;
  }

  template <typename... Args>
  NewerSimpleTable& set_z(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }

  NewerSimpleTable() = default;
  explicit NewerSimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit NewerSimpleTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~NewerSimpleTable() = default;
  NewerSimpleTable(const NewerSimpleTable& other) noexcept = default;
  NewerSimpleTable& operator=(const NewerSimpleTable& other) noexcept = default;
  NewerSimpleTable(NewerSimpleTable&& other) noexcept = default;
  NewerSimpleTable& operator=(NewerSimpleTable&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_table_NewerSimpleTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 72;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> x_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_1_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_2_;
    [[maybe_unused]] ::fidl::UntypedEnvelope reserved_3_;
    ::fidl::Envelope<int64_t> y_;
    ::fidl::Envelope<int64_t> z_;

    friend class NewerSimpleTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class NewerSimpleTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        NewerSimpleTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, NewerSimpleTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<NewerSimpleTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class NewerSimpleTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(NewerSimpleTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      NewerSimpleTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<136> backing_buffer_;
  UnownedEncodedMessage message_;
};

class NewerSimpleTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<NewerSimpleTable> {
 public:
  using DecodedMessageBase<NewerSimpleTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  NewerSimpleTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<NewerSimpleTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_GreaterThan64OrdinalTableTable;

class GreaterThan64OrdinalTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  const int64_t& v1() const {
    ZX_ASSERT(has_v1());
    return frame_ptr_->v1_.get_data();
  }
  int64_t& v1() {
    ZX_ASSERT(has_v1());
    return frame_ptr_->v1_.get_data();
  }
  bool has_v1() const {
    return max_ordinal_ >= 1 && frame_ptr_->v1_.has_data();
  }
  GreaterThan64OrdinalTable& set_v1(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v1(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v1() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v1(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  const int64_t& v2() const {
    ZX_ASSERT(has_v2());
    return frame_ptr_->v2_.get_data();
  }
  int64_t& v2() {
    ZX_ASSERT(has_v2());
    return frame_ptr_->v2_.get_data();
  }
  bool has_v2() const {
    return max_ordinal_ >= 2 && frame_ptr_->v2_.has_data();
  }
  GreaterThan64OrdinalTable& set_v2(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v2(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v2() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v2(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }

  const int64_t& v3() const {
    ZX_ASSERT(has_v3());
    return frame_ptr_->v3_.get_data();
  }
  int64_t& v3() {
    ZX_ASSERT(has_v3());
    return frame_ptr_->v3_.get_data();
  }
  bool has_v3() const {
    return max_ordinal_ >= 3 && frame_ptr_->v3_.has_data();
  }
  GreaterThan64OrdinalTable& set_v3(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v3(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v3() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v3(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }

  const int64_t& v4() const {
    ZX_ASSERT(has_v4());
    return frame_ptr_->v4_.get_data();
  }
  int64_t& v4() {
    ZX_ASSERT(has_v4());
    return frame_ptr_->v4_.get_data();
  }
  bool has_v4() const {
    return max_ordinal_ >= 4 && frame_ptr_->v4_.has_data();
  }
  GreaterThan64OrdinalTable& set_v4(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v4(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v4() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v4(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
    return *this;
  }

  const int64_t& v5() const {
    ZX_ASSERT(has_v5());
    return frame_ptr_->v5_.get_data();
  }
  int64_t& v5() {
    ZX_ASSERT(has_v5());
    return frame_ptr_->v5_.get_data();
  }
  bool has_v5() const {
    return max_ordinal_ >= 5 && frame_ptr_->v5_.has_data();
  }
  GreaterThan64OrdinalTable& set_v5(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v5(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v5() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v5(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  const int64_t& v6() const {
    ZX_ASSERT(has_v6());
    return frame_ptr_->v6_.get_data();
  }
  int64_t& v6() {
    ZX_ASSERT(has_v6());
    return frame_ptr_->v6_.get_data();
  }
  bool has_v6() const {
    return max_ordinal_ >= 6 && frame_ptr_->v6_.has_data();
  }
  GreaterThan64OrdinalTable& set_v6(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v6(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v6() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v6(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }

  const int64_t& v7() const {
    ZX_ASSERT(has_v7());
    return frame_ptr_->v7_.get_data();
  }
  int64_t& v7() {
    ZX_ASSERT(has_v7());
    return frame_ptr_->v7_.get_data();
  }
  bool has_v7() const {
    return max_ordinal_ >= 7 && frame_ptr_->v7_.has_data();
  }
  GreaterThan64OrdinalTable& set_v7(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(7));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v7(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v7() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v7(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(7));
    return *this;
  }

  const int64_t& v8() const {
    ZX_ASSERT(has_v8());
    return frame_ptr_->v8_.get_data();
  }
  int64_t& v8() {
    ZX_ASSERT(has_v8());
    return frame_ptr_->v8_.get_data();
  }
  bool has_v8() const {
    return max_ordinal_ >= 8 && frame_ptr_->v8_.has_data();
  }
  GreaterThan64OrdinalTable& set_v8(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(8));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v8(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v8() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v8(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(8));
    return *this;
  }

  const int64_t& v9() const {
    ZX_ASSERT(has_v9());
    return frame_ptr_->v9_.get_data();
  }
  int64_t& v9() {
    ZX_ASSERT(has_v9());
    return frame_ptr_->v9_.get_data();
  }
  bool has_v9() const {
    return max_ordinal_ >= 9 && frame_ptr_->v9_.has_data();
  }
  GreaterThan64OrdinalTable& set_v9(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(9));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v9(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v9() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v9(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(9));
    return *this;
  }

  const int64_t& v10() const {
    ZX_ASSERT(has_v10());
    return frame_ptr_->v10_.get_data();
  }
  int64_t& v10() {
    ZX_ASSERT(has_v10());
    return frame_ptr_->v10_.get_data();
  }
  bool has_v10() const {
    return max_ordinal_ >= 10 && frame_ptr_->v10_.has_data();
  }
  GreaterThan64OrdinalTable& set_v10(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(10));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v10(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v10() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v10(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(10));
    return *this;
  }

  const int64_t& v11() const {
    ZX_ASSERT(has_v11());
    return frame_ptr_->v11_.get_data();
  }
  int64_t& v11() {
    ZX_ASSERT(has_v11());
    return frame_ptr_->v11_.get_data();
  }
  bool has_v11() const {
    return max_ordinal_ >= 11 && frame_ptr_->v11_.has_data();
  }
  GreaterThan64OrdinalTable& set_v11(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(11));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v11(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v11() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v11(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(11));
    return *this;
  }

  const int64_t& v12() const {
    ZX_ASSERT(has_v12());
    return frame_ptr_->v12_.get_data();
  }
  int64_t& v12() {
    ZX_ASSERT(has_v12());
    return frame_ptr_->v12_.get_data();
  }
  bool has_v12() const {
    return max_ordinal_ >= 12 && frame_ptr_->v12_.has_data();
  }
  GreaterThan64OrdinalTable& set_v12(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(12));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v12(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v12() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v12(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(12));
    return *this;
  }

  const int64_t& v13() const {
    ZX_ASSERT(has_v13());
    return frame_ptr_->v13_.get_data();
  }
  int64_t& v13() {
    ZX_ASSERT(has_v13());
    return frame_ptr_->v13_.get_data();
  }
  bool has_v13() const {
    return max_ordinal_ >= 13 && frame_ptr_->v13_.has_data();
  }
  GreaterThan64OrdinalTable& set_v13(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(13));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v13(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v13() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v13(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(13));
    return *this;
  }

  const int64_t& v14() const {
    ZX_ASSERT(has_v14());
    return frame_ptr_->v14_.get_data();
  }
  int64_t& v14() {
    ZX_ASSERT(has_v14());
    return frame_ptr_->v14_.get_data();
  }
  bool has_v14() const {
    return max_ordinal_ >= 14 && frame_ptr_->v14_.has_data();
  }
  GreaterThan64OrdinalTable& set_v14(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(14));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v14(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v14() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v14(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(14));
    return *this;
  }

  const int64_t& v15() const {
    ZX_ASSERT(has_v15());
    return frame_ptr_->v15_.get_data();
  }
  int64_t& v15() {
    ZX_ASSERT(has_v15());
    return frame_ptr_->v15_.get_data();
  }
  bool has_v15() const {
    return max_ordinal_ >= 15 && frame_ptr_->v15_.has_data();
  }
  GreaterThan64OrdinalTable& set_v15(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(15));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v15(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v15() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v15(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(15));
    return *this;
  }

  const int64_t& v16() const {
    ZX_ASSERT(has_v16());
    return frame_ptr_->v16_.get_data();
  }
  int64_t& v16() {
    ZX_ASSERT(has_v16());
    return frame_ptr_->v16_.get_data();
  }
  bool has_v16() const {
    return max_ordinal_ >= 16 && frame_ptr_->v16_.has_data();
  }
  GreaterThan64OrdinalTable& set_v16(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(16));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v16(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v16() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v16(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(16));
    return *this;
  }

  const int64_t& v17() const {
    ZX_ASSERT(has_v17());
    return frame_ptr_->v17_.get_data();
  }
  int64_t& v17() {
    ZX_ASSERT(has_v17());
    return frame_ptr_->v17_.get_data();
  }
  bool has_v17() const {
    return max_ordinal_ >= 17 && frame_ptr_->v17_.has_data();
  }
  GreaterThan64OrdinalTable& set_v17(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(17));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v17(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v17() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v17(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(17));
    return *this;
  }

  const int64_t& v18() const {
    ZX_ASSERT(has_v18());
    return frame_ptr_->v18_.get_data();
  }
  int64_t& v18() {
    ZX_ASSERT(has_v18());
    return frame_ptr_->v18_.get_data();
  }
  bool has_v18() const {
    return max_ordinal_ >= 18 && frame_ptr_->v18_.has_data();
  }
  GreaterThan64OrdinalTable& set_v18(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(18));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v18(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v18() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v18(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(18));
    return *this;
  }

  const int64_t& v19() const {
    ZX_ASSERT(has_v19());
    return frame_ptr_->v19_.get_data();
  }
  int64_t& v19() {
    ZX_ASSERT(has_v19());
    return frame_ptr_->v19_.get_data();
  }
  bool has_v19() const {
    return max_ordinal_ >= 19 && frame_ptr_->v19_.has_data();
  }
  GreaterThan64OrdinalTable& set_v19(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(19));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v19(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v19() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v19(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(19));
    return *this;
  }

  const int64_t& v20() const {
    ZX_ASSERT(has_v20());
    return frame_ptr_->v20_.get_data();
  }
  int64_t& v20() {
    ZX_ASSERT(has_v20());
    return frame_ptr_->v20_.get_data();
  }
  bool has_v20() const {
    return max_ordinal_ >= 20 && frame_ptr_->v20_.has_data();
  }
  GreaterThan64OrdinalTable& set_v20(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(20));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v20(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v20() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v20(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(20));
    return *this;
  }

  const int64_t& v21() const {
    ZX_ASSERT(has_v21());
    return frame_ptr_->v21_.get_data();
  }
  int64_t& v21() {
    ZX_ASSERT(has_v21());
    return frame_ptr_->v21_.get_data();
  }
  bool has_v21() const {
    return max_ordinal_ >= 21 && frame_ptr_->v21_.has_data();
  }
  GreaterThan64OrdinalTable& set_v21(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(21));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v21(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v21() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v21(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(21));
    return *this;
  }

  const int64_t& v22() const {
    ZX_ASSERT(has_v22());
    return frame_ptr_->v22_.get_data();
  }
  int64_t& v22() {
    ZX_ASSERT(has_v22());
    return frame_ptr_->v22_.get_data();
  }
  bool has_v22() const {
    return max_ordinal_ >= 22 && frame_ptr_->v22_.has_data();
  }
  GreaterThan64OrdinalTable& set_v22(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(22));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v22(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v22() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v22(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(22));
    return *this;
  }

  const int64_t& v23() const {
    ZX_ASSERT(has_v23());
    return frame_ptr_->v23_.get_data();
  }
  int64_t& v23() {
    ZX_ASSERT(has_v23());
    return frame_ptr_->v23_.get_data();
  }
  bool has_v23() const {
    return max_ordinal_ >= 23 && frame_ptr_->v23_.has_data();
  }
  GreaterThan64OrdinalTable& set_v23(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(23));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v23(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v23() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v23(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(23));
    return *this;
  }

  const int64_t& v24() const {
    ZX_ASSERT(has_v24());
    return frame_ptr_->v24_.get_data();
  }
  int64_t& v24() {
    ZX_ASSERT(has_v24());
    return frame_ptr_->v24_.get_data();
  }
  bool has_v24() const {
    return max_ordinal_ >= 24 && frame_ptr_->v24_.has_data();
  }
  GreaterThan64OrdinalTable& set_v24(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(24));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v24(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v24() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v24(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(24));
    return *this;
  }

  const int64_t& v25() const {
    ZX_ASSERT(has_v25());
    return frame_ptr_->v25_.get_data();
  }
  int64_t& v25() {
    ZX_ASSERT(has_v25());
    return frame_ptr_->v25_.get_data();
  }
  bool has_v25() const {
    return max_ordinal_ >= 25 && frame_ptr_->v25_.has_data();
  }
  GreaterThan64OrdinalTable& set_v25(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(25));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v25(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v25() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v25(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(25));
    return *this;
  }

  const int64_t& v26() const {
    ZX_ASSERT(has_v26());
    return frame_ptr_->v26_.get_data();
  }
  int64_t& v26() {
    ZX_ASSERT(has_v26());
    return frame_ptr_->v26_.get_data();
  }
  bool has_v26() const {
    return max_ordinal_ >= 26 && frame_ptr_->v26_.has_data();
  }
  GreaterThan64OrdinalTable& set_v26(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(26));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v26(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v26() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v26(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(26));
    return *this;
  }

  const int64_t& v27() const {
    ZX_ASSERT(has_v27());
    return frame_ptr_->v27_.get_data();
  }
  int64_t& v27() {
    ZX_ASSERT(has_v27());
    return frame_ptr_->v27_.get_data();
  }
  bool has_v27() const {
    return max_ordinal_ >= 27 && frame_ptr_->v27_.has_data();
  }
  GreaterThan64OrdinalTable& set_v27(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(27));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v27(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v27() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v27(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(27));
    return *this;
  }

  const int64_t& v28() const {
    ZX_ASSERT(has_v28());
    return frame_ptr_->v28_.get_data();
  }
  int64_t& v28() {
    ZX_ASSERT(has_v28());
    return frame_ptr_->v28_.get_data();
  }
  bool has_v28() const {
    return max_ordinal_ >= 28 && frame_ptr_->v28_.has_data();
  }
  GreaterThan64OrdinalTable& set_v28(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(28));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v28(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v28() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v28(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(28));
    return *this;
  }

  const int64_t& v29() const {
    ZX_ASSERT(has_v29());
    return frame_ptr_->v29_.get_data();
  }
  int64_t& v29() {
    ZX_ASSERT(has_v29());
    return frame_ptr_->v29_.get_data();
  }
  bool has_v29() const {
    return max_ordinal_ >= 29 && frame_ptr_->v29_.has_data();
  }
  GreaterThan64OrdinalTable& set_v29(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(29));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v29(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v29() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v29(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(29));
    return *this;
  }

  const int64_t& v30() const {
    ZX_ASSERT(has_v30());
    return frame_ptr_->v30_.get_data();
  }
  int64_t& v30() {
    ZX_ASSERT(has_v30());
    return frame_ptr_->v30_.get_data();
  }
  bool has_v30() const {
    return max_ordinal_ >= 30 && frame_ptr_->v30_.has_data();
  }
  GreaterThan64OrdinalTable& set_v30(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(30));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v30(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v30() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v30(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(30));
    return *this;
  }

  const int64_t& v31() const {
    ZX_ASSERT(has_v31());
    return frame_ptr_->v31_.get_data();
  }
  int64_t& v31() {
    ZX_ASSERT(has_v31());
    return frame_ptr_->v31_.get_data();
  }
  bool has_v31() const {
    return max_ordinal_ >= 31 && frame_ptr_->v31_.has_data();
  }
  GreaterThan64OrdinalTable& set_v31(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(31));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v31(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v31() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v31(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(31));
    return *this;
  }

  const int64_t& v32() const {
    ZX_ASSERT(has_v32());
    return frame_ptr_->v32_.get_data();
  }
  int64_t& v32() {
    ZX_ASSERT(has_v32());
    return frame_ptr_->v32_.get_data();
  }
  bool has_v32() const {
    return max_ordinal_ >= 32 && frame_ptr_->v32_.has_data();
  }
  GreaterThan64OrdinalTable& set_v32(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(32));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v32(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v32() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v32(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(32));
    return *this;
  }

  const int64_t& v33() const {
    ZX_ASSERT(has_v33());
    return frame_ptr_->v33_.get_data();
  }
  int64_t& v33() {
    ZX_ASSERT(has_v33());
    return frame_ptr_->v33_.get_data();
  }
  bool has_v33() const {
    return max_ordinal_ >= 33 && frame_ptr_->v33_.has_data();
  }
  GreaterThan64OrdinalTable& set_v33(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(33));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v33(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v33() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v33(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(33));
    return *this;
  }

  const int64_t& v34() const {
    ZX_ASSERT(has_v34());
    return frame_ptr_->v34_.get_data();
  }
  int64_t& v34() {
    ZX_ASSERT(has_v34());
    return frame_ptr_->v34_.get_data();
  }
  bool has_v34() const {
    return max_ordinal_ >= 34 && frame_ptr_->v34_.has_data();
  }
  GreaterThan64OrdinalTable& set_v34(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(34));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v34(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v34() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v34(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(34));
    return *this;
  }

  const int64_t& v35() const {
    ZX_ASSERT(has_v35());
    return frame_ptr_->v35_.get_data();
  }
  int64_t& v35() {
    ZX_ASSERT(has_v35());
    return frame_ptr_->v35_.get_data();
  }
  bool has_v35() const {
    return max_ordinal_ >= 35 && frame_ptr_->v35_.has_data();
  }
  GreaterThan64OrdinalTable& set_v35(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(35));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v35(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v35() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v35(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(35));
    return *this;
  }

  const int64_t& v36() const {
    ZX_ASSERT(has_v36());
    return frame_ptr_->v36_.get_data();
  }
  int64_t& v36() {
    ZX_ASSERT(has_v36());
    return frame_ptr_->v36_.get_data();
  }
  bool has_v36() const {
    return max_ordinal_ >= 36 && frame_ptr_->v36_.has_data();
  }
  GreaterThan64OrdinalTable& set_v36(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(36));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v36(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v36() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v36(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(36));
    return *this;
  }

  const int64_t& v37() const {
    ZX_ASSERT(has_v37());
    return frame_ptr_->v37_.get_data();
  }
  int64_t& v37() {
    ZX_ASSERT(has_v37());
    return frame_ptr_->v37_.get_data();
  }
  bool has_v37() const {
    return max_ordinal_ >= 37 && frame_ptr_->v37_.has_data();
  }
  GreaterThan64OrdinalTable& set_v37(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(37));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v37(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v37() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v37(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(37));
    return *this;
  }

  const int64_t& v38() const {
    ZX_ASSERT(has_v38());
    return frame_ptr_->v38_.get_data();
  }
  int64_t& v38() {
    ZX_ASSERT(has_v38());
    return frame_ptr_->v38_.get_data();
  }
  bool has_v38() const {
    return max_ordinal_ >= 38 && frame_ptr_->v38_.has_data();
  }
  GreaterThan64OrdinalTable& set_v38(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(38));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v38(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v38() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v38(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(38));
    return *this;
  }

  const int64_t& v39() const {
    ZX_ASSERT(has_v39());
    return frame_ptr_->v39_.get_data();
  }
  int64_t& v39() {
    ZX_ASSERT(has_v39());
    return frame_ptr_->v39_.get_data();
  }
  bool has_v39() const {
    return max_ordinal_ >= 39 && frame_ptr_->v39_.has_data();
  }
  GreaterThan64OrdinalTable& set_v39(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(39));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v39(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v39() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v39(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(39));
    return *this;
  }

  const int64_t& v40() const {
    ZX_ASSERT(has_v40());
    return frame_ptr_->v40_.get_data();
  }
  int64_t& v40() {
    ZX_ASSERT(has_v40());
    return frame_ptr_->v40_.get_data();
  }
  bool has_v40() const {
    return max_ordinal_ >= 40 && frame_ptr_->v40_.has_data();
  }
  GreaterThan64OrdinalTable& set_v40(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(40));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v40(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v40() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v40(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(40));
    return *this;
  }

  const int64_t& v41() const {
    ZX_ASSERT(has_v41());
    return frame_ptr_->v41_.get_data();
  }
  int64_t& v41() {
    ZX_ASSERT(has_v41());
    return frame_ptr_->v41_.get_data();
  }
  bool has_v41() const {
    return max_ordinal_ >= 41 && frame_ptr_->v41_.has_data();
  }
  GreaterThan64OrdinalTable& set_v41(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(41));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v41(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v41() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v41(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(41));
    return *this;
  }

  const int64_t& v42() const {
    ZX_ASSERT(has_v42());
    return frame_ptr_->v42_.get_data();
  }
  int64_t& v42() {
    ZX_ASSERT(has_v42());
    return frame_ptr_->v42_.get_data();
  }
  bool has_v42() const {
    return max_ordinal_ >= 42 && frame_ptr_->v42_.has_data();
  }
  GreaterThan64OrdinalTable& set_v42(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(42));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v42(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v42() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v42(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(42));
    return *this;
  }

  const int64_t& v43() const {
    ZX_ASSERT(has_v43());
    return frame_ptr_->v43_.get_data();
  }
  int64_t& v43() {
    ZX_ASSERT(has_v43());
    return frame_ptr_->v43_.get_data();
  }
  bool has_v43() const {
    return max_ordinal_ >= 43 && frame_ptr_->v43_.has_data();
  }
  GreaterThan64OrdinalTable& set_v43(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(43));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v43(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v43() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v43(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(43));
    return *this;
  }

  const int64_t& v44() const {
    ZX_ASSERT(has_v44());
    return frame_ptr_->v44_.get_data();
  }
  int64_t& v44() {
    ZX_ASSERT(has_v44());
    return frame_ptr_->v44_.get_data();
  }
  bool has_v44() const {
    return max_ordinal_ >= 44 && frame_ptr_->v44_.has_data();
  }
  GreaterThan64OrdinalTable& set_v44(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(44));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v44(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v44() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v44(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(44));
    return *this;
  }

  const int64_t& v45() const {
    ZX_ASSERT(has_v45());
    return frame_ptr_->v45_.get_data();
  }
  int64_t& v45() {
    ZX_ASSERT(has_v45());
    return frame_ptr_->v45_.get_data();
  }
  bool has_v45() const {
    return max_ordinal_ >= 45 && frame_ptr_->v45_.has_data();
  }
  GreaterThan64OrdinalTable& set_v45(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(45));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v45(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v45() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v45(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(45));
    return *this;
  }

  const int64_t& v46() const {
    ZX_ASSERT(has_v46());
    return frame_ptr_->v46_.get_data();
  }
  int64_t& v46() {
    ZX_ASSERT(has_v46());
    return frame_ptr_->v46_.get_data();
  }
  bool has_v46() const {
    return max_ordinal_ >= 46 && frame_ptr_->v46_.has_data();
  }
  GreaterThan64OrdinalTable& set_v46(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(46));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v46(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v46() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v46(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(46));
    return *this;
  }

  const int64_t& v47() const {
    ZX_ASSERT(has_v47());
    return frame_ptr_->v47_.get_data();
  }
  int64_t& v47() {
    ZX_ASSERT(has_v47());
    return frame_ptr_->v47_.get_data();
  }
  bool has_v47() const {
    return max_ordinal_ >= 47 && frame_ptr_->v47_.has_data();
  }
  GreaterThan64OrdinalTable& set_v47(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(47));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v47(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v47() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v47(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(47));
    return *this;
  }

  const int64_t& v48() const {
    ZX_ASSERT(has_v48());
    return frame_ptr_->v48_.get_data();
  }
  int64_t& v48() {
    ZX_ASSERT(has_v48());
    return frame_ptr_->v48_.get_data();
  }
  bool has_v48() const {
    return max_ordinal_ >= 48 && frame_ptr_->v48_.has_data();
  }
  GreaterThan64OrdinalTable& set_v48(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(48));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v48(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v48() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v48(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(48));
    return *this;
  }

  const int64_t& v49() const {
    ZX_ASSERT(has_v49());
    return frame_ptr_->v49_.get_data();
  }
  int64_t& v49() {
    ZX_ASSERT(has_v49());
    return frame_ptr_->v49_.get_data();
  }
  bool has_v49() const {
    return max_ordinal_ >= 49 && frame_ptr_->v49_.has_data();
  }
  GreaterThan64OrdinalTable& set_v49(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(49));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v49(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v49() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v49(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(49));
    return *this;
  }

  const int64_t& v50() const {
    ZX_ASSERT(has_v50());
    return frame_ptr_->v50_.get_data();
  }
  int64_t& v50() {
    ZX_ASSERT(has_v50());
    return frame_ptr_->v50_.get_data();
  }
  bool has_v50() const {
    return max_ordinal_ >= 50 && frame_ptr_->v50_.has_data();
  }
  GreaterThan64OrdinalTable& set_v50(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(50));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v50(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v50() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v50(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(50));
    return *this;
  }

  const int64_t& v51() const {
    ZX_ASSERT(has_v51());
    return frame_ptr_->v51_.get_data();
  }
  int64_t& v51() {
    ZX_ASSERT(has_v51());
    return frame_ptr_->v51_.get_data();
  }
  bool has_v51() const {
    return max_ordinal_ >= 51 && frame_ptr_->v51_.has_data();
  }
  GreaterThan64OrdinalTable& set_v51(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(51));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v51(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v51() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v51(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(51));
    return *this;
  }

  const int64_t& v52() const {
    ZX_ASSERT(has_v52());
    return frame_ptr_->v52_.get_data();
  }
  int64_t& v52() {
    ZX_ASSERT(has_v52());
    return frame_ptr_->v52_.get_data();
  }
  bool has_v52() const {
    return max_ordinal_ >= 52 && frame_ptr_->v52_.has_data();
  }
  GreaterThan64OrdinalTable& set_v52(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(52));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v52(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v52() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v52(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(52));
    return *this;
  }

  const int64_t& v53() const {
    ZX_ASSERT(has_v53());
    return frame_ptr_->v53_.get_data();
  }
  int64_t& v53() {
    ZX_ASSERT(has_v53());
    return frame_ptr_->v53_.get_data();
  }
  bool has_v53() const {
    return max_ordinal_ >= 53 && frame_ptr_->v53_.has_data();
  }
  GreaterThan64OrdinalTable& set_v53(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(53));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v53(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v53() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v53(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(53));
    return *this;
  }

  const int64_t& v54() const {
    ZX_ASSERT(has_v54());
    return frame_ptr_->v54_.get_data();
  }
  int64_t& v54() {
    ZX_ASSERT(has_v54());
    return frame_ptr_->v54_.get_data();
  }
  bool has_v54() const {
    return max_ordinal_ >= 54 && frame_ptr_->v54_.has_data();
  }
  GreaterThan64OrdinalTable& set_v54(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(54));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v54(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v54() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v54(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(54));
    return *this;
  }

  const int64_t& v55() const {
    ZX_ASSERT(has_v55());
    return frame_ptr_->v55_.get_data();
  }
  int64_t& v55() {
    ZX_ASSERT(has_v55());
    return frame_ptr_->v55_.get_data();
  }
  bool has_v55() const {
    return max_ordinal_ >= 55 && frame_ptr_->v55_.has_data();
  }
  GreaterThan64OrdinalTable& set_v55(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(55));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v55(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v55() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v55(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(55));
    return *this;
  }

  const int64_t& v56() const {
    ZX_ASSERT(has_v56());
    return frame_ptr_->v56_.get_data();
  }
  int64_t& v56() {
    ZX_ASSERT(has_v56());
    return frame_ptr_->v56_.get_data();
  }
  bool has_v56() const {
    return max_ordinal_ >= 56 && frame_ptr_->v56_.has_data();
  }
  GreaterThan64OrdinalTable& set_v56(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(56));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v56(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v56() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v56(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(56));
    return *this;
  }

  const int64_t& v57() const {
    ZX_ASSERT(has_v57());
    return frame_ptr_->v57_.get_data();
  }
  int64_t& v57() {
    ZX_ASSERT(has_v57());
    return frame_ptr_->v57_.get_data();
  }
  bool has_v57() const {
    return max_ordinal_ >= 57 && frame_ptr_->v57_.has_data();
  }
  GreaterThan64OrdinalTable& set_v57(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(57));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v57(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v57() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v57(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(57));
    return *this;
  }

  const int64_t& v58() const {
    ZX_ASSERT(has_v58());
    return frame_ptr_->v58_.get_data();
  }
  int64_t& v58() {
    ZX_ASSERT(has_v58());
    return frame_ptr_->v58_.get_data();
  }
  bool has_v58() const {
    return max_ordinal_ >= 58 && frame_ptr_->v58_.has_data();
  }
  GreaterThan64OrdinalTable& set_v58(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(58));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v58(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v58() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v58(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(58));
    return *this;
  }

  const int64_t& v59() const {
    ZX_ASSERT(has_v59());
    return frame_ptr_->v59_.get_data();
  }
  int64_t& v59() {
    ZX_ASSERT(has_v59());
    return frame_ptr_->v59_.get_data();
  }
  bool has_v59() const {
    return max_ordinal_ >= 59 && frame_ptr_->v59_.has_data();
  }
  GreaterThan64OrdinalTable& set_v59(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(59));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v59(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v59() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v59(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(59));
    return *this;
  }

  const int64_t& v60() const {
    ZX_ASSERT(has_v60());
    return frame_ptr_->v60_.get_data();
  }
  int64_t& v60() {
    ZX_ASSERT(has_v60());
    return frame_ptr_->v60_.get_data();
  }
  bool has_v60() const {
    return max_ordinal_ >= 60 && frame_ptr_->v60_.has_data();
  }
  GreaterThan64OrdinalTable& set_v60(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(60));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v60(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v60() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v60(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(60));
    return *this;
  }

  const int64_t& v61() const {
    ZX_ASSERT(has_v61());
    return frame_ptr_->v61_.get_data();
  }
  int64_t& v61() {
    ZX_ASSERT(has_v61());
    return frame_ptr_->v61_.get_data();
  }
  bool has_v61() const {
    return max_ordinal_ >= 61 && frame_ptr_->v61_.has_data();
  }
  GreaterThan64OrdinalTable& set_v61(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(61));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v61(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v61() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v61(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(61));
    return *this;
  }

  const int64_t& v62() const {
    ZX_ASSERT(has_v62());
    return frame_ptr_->v62_.get_data();
  }
  int64_t& v62() {
    ZX_ASSERT(has_v62());
    return frame_ptr_->v62_.get_data();
  }
  bool has_v62() const {
    return max_ordinal_ >= 62 && frame_ptr_->v62_.has_data();
  }
  GreaterThan64OrdinalTable& set_v62(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(62));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v62(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v62() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v62(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(62));
    return *this;
  }

  const int64_t& v63() const {
    ZX_ASSERT(has_v63());
    return frame_ptr_->v63_.get_data();
  }
  int64_t& v63() {
    ZX_ASSERT(has_v63());
    return frame_ptr_->v63_.get_data();
  }
  bool has_v63() const {
    return max_ordinal_ >= 63 && frame_ptr_->v63_.has_data();
  }
  GreaterThan64OrdinalTable& set_v63(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(63));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v63(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v63() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v63(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(63));
    return *this;
  }

  const int64_t& v64() const {
    ZX_ASSERT(has_v64());
    return frame_ptr_->v64_.get_data();
  }
  int64_t& v64() {
    ZX_ASSERT(has_v64());
    return frame_ptr_->v64_.get_data();
  }
  bool has_v64() const {
    return max_ordinal_ >= 64 && frame_ptr_->v64_.has_data();
  }
  GreaterThan64OrdinalTable& set_v64(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(64));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v64(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v64() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v64(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(64));
    return *this;
  }

  const int64_t& v65() const {
    ZX_ASSERT(has_v65());
    return frame_ptr_->v65_.get_data();
  }
  int64_t& v65() {
    ZX_ASSERT(has_v65());
    return frame_ptr_->v65_.get_data();
  }
  bool has_v65() const {
    return max_ordinal_ >= 65 && frame_ptr_->v65_.has_data();
  }
  GreaterThan64OrdinalTable& set_v65(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v65_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(65));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v65(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v65_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v65() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v65_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v65(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v65_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(65));
    return *this;
  }

  const int64_t& v66() const {
    ZX_ASSERT(has_v66());
    return frame_ptr_->v66_.get_data();
  }
  int64_t& v66() {
    ZX_ASSERT(has_v66());
    return frame_ptr_->v66_.get_data();
  }
  bool has_v66() const {
    return max_ordinal_ >= 66 && frame_ptr_->v66_.has_data();
  }
  GreaterThan64OrdinalTable& set_v66(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v66_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(66));
    return *this;
  }
  GreaterThan64OrdinalTable& set_v66(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v66_.set_data(nullptr);
    return *this;
  }

  GreaterThan64OrdinalTable& clear_v66() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v66_.clear_data();
    return *this;
  }

  template <typename... Args>
  GreaterThan64OrdinalTable& set_v66(::fidl::AnyArena& allocator,
                                     Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v66_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(66));
    return *this;
  }

  GreaterThan64OrdinalTable() = default;
  explicit GreaterThan64OrdinalTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit GreaterThan64OrdinalTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~GreaterThan64OrdinalTable() = default;
  GreaterThan64OrdinalTable(const GreaterThan64OrdinalTable& other) noexcept =
      default;
  GreaterThan64OrdinalTable& operator=(
      const GreaterThan64OrdinalTable& other) noexcept = default;
  GreaterThan64OrdinalTable(GreaterThan64OrdinalTable&& other) noexcept =
      default;
  GreaterThan64OrdinalTable& operator=(
      GreaterThan64OrdinalTable&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &fidl_test_table_GreaterThan64OrdinalTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 1056;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;
    ::fidl::Envelope<int64_t> v1_;
    ::fidl::Envelope<int64_t> v2_;
    ::fidl::Envelope<int64_t> v3_;
    ::fidl::Envelope<int64_t> v4_;
    ::fidl::Envelope<int64_t> v5_;
    ::fidl::Envelope<int64_t> v6_;
    ::fidl::Envelope<int64_t> v7_;
    ::fidl::Envelope<int64_t> v8_;
    ::fidl::Envelope<int64_t> v9_;
    ::fidl::Envelope<int64_t> v10_;
    ::fidl::Envelope<int64_t> v11_;
    ::fidl::Envelope<int64_t> v12_;
    ::fidl::Envelope<int64_t> v13_;
    ::fidl::Envelope<int64_t> v14_;
    ::fidl::Envelope<int64_t> v15_;
    ::fidl::Envelope<int64_t> v16_;
    ::fidl::Envelope<int64_t> v17_;
    ::fidl::Envelope<int64_t> v18_;
    ::fidl::Envelope<int64_t> v19_;
    ::fidl::Envelope<int64_t> v20_;
    ::fidl::Envelope<int64_t> v21_;
    ::fidl::Envelope<int64_t> v22_;
    ::fidl::Envelope<int64_t> v23_;
    ::fidl::Envelope<int64_t> v24_;
    ::fidl::Envelope<int64_t> v25_;
    ::fidl::Envelope<int64_t> v26_;
    ::fidl::Envelope<int64_t> v27_;
    ::fidl::Envelope<int64_t> v28_;
    ::fidl::Envelope<int64_t> v29_;
    ::fidl::Envelope<int64_t> v30_;
    ::fidl::Envelope<int64_t> v31_;
    ::fidl::Envelope<int64_t> v32_;
    ::fidl::Envelope<int64_t> v33_;
    ::fidl::Envelope<int64_t> v34_;
    ::fidl::Envelope<int64_t> v35_;
    ::fidl::Envelope<int64_t> v36_;
    ::fidl::Envelope<int64_t> v37_;
    ::fidl::Envelope<int64_t> v38_;
    ::fidl::Envelope<int64_t> v39_;
    ::fidl::Envelope<int64_t> v40_;
    ::fidl::Envelope<int64_t> v41_;
    ::fidl::Envelope<int64_t> v42_;
    ::fidl::Envelope<int64_t> v43_;
    ::fidl::Envelope<int64_t> v44_;
    ::fidl::Envelope<int64_t> v45_;
    ::fidl::Envelope<int64_t> v46_;
    ::fidl::Envelope<int64_t> v47_;
    ::fidl::Envelope<int64_t> v48_;
    ::fidl::Envelope<int64_t> v49_;
    ::fidl::Envelope<int64_t> v50_;
    ::fidl::Envelope<int64_t> v51_;
    ::fidl::Envelope<int64_t> v52_;
    ::fidl::Envelope<int64_t> v53_;
    ::fidl::Envelope<int64_t> v54_;
    ::fidl::Envelope<int64_t> v55_;
    ::fidl::Envelope<int64_t> v56_;
    ::fidl::Envelope<int64_t> v57_;
    ::fidl::Envelope<int64_t> v58_;
    ::fidl::Envelope<int64_t> v59_;
    ::fidl::Envelope<int64_t> v60_;
    ::fidl::Envelope<int64_t> v61_;
    ::fidl::Envelope<int64_t> v62_;
    ::fidl::Envelope<int64_t> v63_;
    ::fidl::Envelope<int64_t> v64_;
    ::fidl::Envelope<int64_t> v65_;
    ::fidl::Envelope<int64_t> v66_;

    friend class GreaterThan64OrdinalTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class GreaterThan64OrdinalTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        GreaterThan64OrdinalTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        GreaterThan64OrdinalTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<GreaterThan64OrdinalTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class GreaterThan64OrdinalTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(GreaterThan64OrdinalTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      GreaterThan64OrdinalTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<1600> backing_buffer_;
  UnownedEncodedMessage message_;
};

class GreaterThan64OrdinalTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<GreaterThan64OrdinalTable> {
 public:
  using DecodedMessageBase<GreaterThan64OrdinalTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  GreaterThan64OrdinalTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<GreaterThan64OrdinalTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_table_EmptyTableTable;

class EmptyTable final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  class Frame_;

  EmptyTable() = default;
  explicit EmptyTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<Frame_>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit EmptyTable(::fidl::ObjectView<Frame_>&& frame)
      : frame_ptr_(std::move(frame)) {}
  ~EmptyTable() = default;
  EmptyTable(const EmptyTable& other) noexcept = default;
  EmptyTable& operator=(const EmptyTable& other) noexcept = default;
  EmptyTable(EmptyTable&& other) noexcept = default;
  EmptyTable& operator=(EmptyTable&& other) noexcept = default;

  static constexpr const fidl_type_t* Type = &fidl_test_table_EmptyTableTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<Frame_>(allocator);
  }
  void Init(::fidl::ObjectView<Frame_>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

  // Frame_s are managed automatically by the Arena class.
  // The only direct usage is when performance is key and a frame needs to be
  // allocated outside a Arena. Once created, a frame can only be used for one
  // single table.
  class Frame_ final {
   public:
    Frame_() = default;
    // In its intended usage, Frame_ will be referenced by an ObjectView. If the
    // ObjectView is assigned before a move or copy, then it will reference the
    // old invalid object. Because this is unsafe, copies are disallowed and
    // moves are only allowed by friend classes that operate safely.
    Frame_(const Frame_&) = delete;
    Frame_& operator=(const Frame_&) = delete;

   private:
    Frame_(Frame_&&) noexcept = default;
    Frame_& operator=(Frame_&&) noexcept = default;

    friend class EmptyTable;
  };

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<Frame_> frame_ptr_;
};

class EmptyTable::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        EmptyTable* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, EmptyTable* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<EmptyTable>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class EmptyTable::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(EmptyTable* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, EmptyTable* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class EmptyTable::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<EmptyTable> {
 public:
  using DecodedMessageBase<EmptyTable>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                bytes, byte_actual, handles, handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {}

  EmptyTable* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<EmptyTable*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

}  // namespace wire
}  // namespace fidl_test_table
namespace fidl {

template <>
struct IsFidlType<::fidl_test_table::wire::TableWithAttributes>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::TableWithAttributes>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_table::wire::TableWithAttributes>);

template <>
struct IsFidlType<::fidl_test_table::wire::SimpleTable>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::SimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_table::wire::SimpleTable>);

template <>
struct IsFidlType<::fidl_test_table::wire::ReverseOrdinalTable>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::ReverseOrdinalTable>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_table::wire::ReverseOrdinalTable>);

template <>
struct IsFidlType<::fidl_test_table::wire::OlderSimpleTable>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::OlderSimpleTable>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_table::wire::OlderSimpleTable>);

template <>
struct IsFidlType<::fidl_test_table::wire::NewerSimpleTable>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::NewerSimpleTable>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_table::wire::NewerSimpleTable>);

template <>
struct IsFidlType<::fidl_test_table::wire::GreaterThan64OrdinalTable>
    : public std::true_type {};
template <>
struct IsTable<::fidl_test_table::wire::GreaterThan64OrdinalTable>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_table::wire::GreaterThan64OrdinalTable>);

template <>
struct IsFidlType<::fidl_test_table::wire::EmptyTable> : public std::true_type {
};
template <>
struct IsTable<::fidl_test_table::wire::EmptyTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_table::wire::EmptyTable>);

}  // namespace fidl

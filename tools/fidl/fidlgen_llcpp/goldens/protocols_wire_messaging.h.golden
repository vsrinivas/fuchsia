// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/fidl.test.protocols/cpp/markers.h>
#include <fidl/fidl.test.protocols/cpp/wire_types.h>
#include <lib/fidl/llcpp/wire_messaging.h>

#ifdef __Fuchsia__

#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/sync_call.h>

#endif  // __Fuchsia__

namespace fidl_test_protocols {
class HandleRightsProtocol;

class WithAndWithoutRequestResponse;

class Transitional;

class MethodWithUnion;

class WithProtocolEnds;

class ManyParameters;

class WithErrorSyntax;

class DiscoverableProtocol;

class ChannelProtocol;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolNoResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolAnEventRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolAnEventEventTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::HandleRightsProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::HandleRightsProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                              NoResponseMethod>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& h)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(h)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& h)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(h)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                              NoResponseMethod>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& h)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                              NoResponseMethod>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                              ResponseMethod>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& h)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(h)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& h)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(h)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                              ResponseMethod>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& h)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
                ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireResponse(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                               ResponseMethod>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& h)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(h)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& h)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(h)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                               ResponseMethod>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& h)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
                ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::AnEvent>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireResponse(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolAnEventEventTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::AnEvent>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& h)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(h)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& h)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(h)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::AnEvent>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& h)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::AnEvent>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& h);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& h, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>|, avoiding
// setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::HandleRightsProtocol>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::HandleRightsProtocol>>::SyncEndpointVeneer;

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        _client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h));
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        _client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                 ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
  _client_end() const {
    return ::fidl::UnownedClientEnd<
        ::fidl_test_protocols::HandleRightsProtocol>(_channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::HandleRightsProtocol>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        this->client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h));
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        this->client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                 ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }
  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::zx::socket&& h);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::zx::socket&& h);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::HandleRightsProtocol;

  using NoResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(
      NoResponseMethodRequestView request,
      NoResponseMethodCompleter::Sync& _completer) = 0;

  using ResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequestView request,
                              ResponseMethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>*
          impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>*
          impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestNoResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          NoRequestNoResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          NoRequestEmptyResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          NoRequestWithResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestWithResponse>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView ret)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, ret) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView ret)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{ret};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestWithResponse>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView ret)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView ret)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestWithResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView arg)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, arg) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView arg)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{arg};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView arg)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView arg)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          WithRequestNoResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView arg)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, arg) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView arg)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{arg};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView arg)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView arg)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView arg)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, arg) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView arg)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{arg};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView arg)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView arg)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), arg) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>> {
 public:
  using DecodedMessageBase<
      ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                          WithRequestWithResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView ret)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, ret) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView ret)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{ret};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView ret)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView ret)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::
                               WithAndWithoutRequestResponse::OnEmptyResponse>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::
                               WithAndWithoutRequestResponse::OnEmptyResponse>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::
    DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnEmptyResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            OnEmptyResponse>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t MaxOutOfLineV1 = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl::StringView ret)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, ret) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::fidl::StringView ret)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{ret};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl::StringView ret)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::StringView ret)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), ret) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
    DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnWithResponse>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             ::fidl::StringView arg, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             ::fidl::StringView arg, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>>::
      SyncEndpointVeneer;

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>(_client_end());
  }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(_client_end());
  }

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(_client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(_client_end(), _response_buffer.data,
                                   _response_buffer.capacity);
  }

  // Request is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(_client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                        ::fidl::StringView arg) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(_client_end(), _request_buffer.data,
                                   _request_buffer.capacity, arg);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(_client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::BufferSpan _request_buffer,
                           ::fidl::StringView arg,
                           ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(_client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(::fidl::BufferSpan _request_buffer,
                          ::fidl::StringView arg,
                          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
  _client_end() const {
    return ::fidl::UnownedClientEnd<
        ::fidl_test_protocols::WithAndWithoutRequestResponse>(_channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::WireResponse<::fidl_test_protocols::
                               WithAndWithoutRequestResponse::OnEmptyResponse>*
          event) {}
  virtual void OnWithResponse(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          client_end);
};
template <>
class ::fidl::WireSyncClient<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
          client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>(this->client_end());
  }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(this->client_end());
  }

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(this->client_end(), _response_buffer.data,
                                   _response_buffer.capacity);
  }

  // Request is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                        ::fidl::StringView arg) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(this->client_end(), _request_buffer.data,
                                   _request_buffer.capacity, arg);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::BufferSpan _request_buffer,
                           ::fidl::StringView arg,
                           ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(::fidl::BufferSpan _request_buffer,
                          ::fidl::StringView arg,
                          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }
  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
      client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl::StringView ret);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::fidl::StringView ret);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl::StringView ret);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::fidl::StringView ret);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol =
      ::fidl_test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestNoResponse>;
  using NoRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseRequestView request,
      NoRequestNoResponseCompleter::Sync& _completer) = 0;

  using NoRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>;
  using NoRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseRequestView request,
      NoRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using NoRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;
  using NoRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseRequestView request,
      NoRequestWithResponseCompleter::Sync& _completer) = 0;

  using WithRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>;
  using WithRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>;

  virtual void WithRequestNoResponse(
      WithRequestNoResponseRequestView request,
      WithRequestNoResponseCompleter::Sync& _completer) = 0;

  using WithRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;
  using WithRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(
      WithRequestEmptyResponseRequestView request,
      WithRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using WithRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;
  using WithRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;

  virtual void WithRequestWithResponse(
      WithRequestWithResponseRequestView request,
      WithRequestWithResponseCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalOneWayResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalEventRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalEventEventTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::fidl_test_protocols::Transitional> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::Transitional>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::Transitional>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::Transitional>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireRequest(int64_t x) : x(x) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::Request>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t x)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, x) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t x)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{x};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::Request>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t x)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::Request>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::Transitional::Request>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t y;
  explicit WireResponse(int64_t y) : y(y) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalRequestResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Request>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t y)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, y) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t y)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{y};
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Request>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t y)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), y) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t y)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), y) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Request>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::Transitional::Request>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireRequest(int64_t x) : x(x) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::OneWay>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t x)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, x) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t x)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{x};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::OneWay>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t x)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::Transitional::OneWay>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::Transitional::OneWay>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireResponse(int64_t x) : x(x) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::fidl_test_protocols_TransitionalEventEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Event>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t x)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, x) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t x)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{x};
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Event>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t x)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), x) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::Transitional::Event>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::Transitional::Event>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t x,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
        bytes_);
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t x);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a |fidl::ClientEnd<::fidl_test_protocols::Transitional>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<::fidl_test_protocols::Transitional>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::Transitional>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::Transitional>>::SyncEndpointVeneer;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>(
        _client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request(::fidl::BufferSpan _request_buffer, int64_t x,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::Request>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, x,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay>(
        _client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      ::fidl::BufferSpan _request_buffer, int64_t x) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::OneWay>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, x);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::Transitional> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void Event(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>* event) {
  }
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::Transitional> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::Transitional> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::Transitional> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::Transitional>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::Transitional>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>(
        this->client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request(::fidl::BufferSpan _request_buffer, int64_t x,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::Request>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, x,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay>(
        this->client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      ::fidl::BufferSpan _request_buffer, int64_t x) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::OneWay>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, x);
  }
  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::Transitional>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::Transitional> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::Transitional::Request>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(int64_t y);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, int64_t y);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::Transitional::Request>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::Transitional;

  using RequestCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::Transitional::Request>;
  using RequestRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::Transitional::Request>;

  virtual void Request(RequestRequestView request,
                       RequestCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

  using OneWayCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::Transitional::OneWay>;
  using OneWayRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequestView request,
                      OneWayCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_MethodWithUnionUnionMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_MethodWithUnionUnionMethodResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::MethodWithUnion> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::MethodWithUnion>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::TheUnion u;
  explicit WireRequest(::fidl_test_protocols::wire::TheUnion u) : u(u) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 40;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasFlexibleEnvelope = true;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::TheUnion u)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, u) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::TheUnion u)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{u};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl_test_protocols::wire::TheUnion u)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), u) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::TheUnion u)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), u) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::MethodWithUnion::UnionMethod>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::MethodWithUnion::UnionMethod>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> _client,
      ::fidl_test_protocols::wire::TheUnion u);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl_test_protocols::wire::TheUnion u);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::MethodWithUnion>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::MethodWithUnion>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::MethodWithUnion>>::SyncEndpointVeneer;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(_client_end(), u);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::BufferSpan _request_buffer,
              ::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, u);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::MethodWithUnion> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::MethodWithUnion> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::MethodWithUnion> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(this->client_end(),
                                                             u);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::BufferSpan _request_buffer,
              ::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, u);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::MethodWithUnion;

  using UnionMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequestView request,
                           UnionMethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithProtocolEnds> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithProtocolEnds>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> in;
  explicit WireRequest(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(in)) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(in)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> out;
  explicit WireResponse(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsClientEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(out)) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(out)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> in;
  explicit WireRequest(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(in)) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(in)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> out;
  explicit WireResponse(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsServerEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(out)) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(out)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::ProtocolEnds in;
  explicit WireRequest(::fidl_test_protocols::wire::ProtocolEnds&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::ProtocolEnds&& in)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(in)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::ProtocolEnds&& in)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(in)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::
                              StructContainingEnds>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl_test_protocols::wire::ProtocolEnds&& in)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::ProtocolEnds&& in)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(in)) {
  }
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::
                              StructContainingEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::ProtocolEnds out;
  explicit WireResponse(::fidl_test_protocols::wire::ProtocolEnds&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::ProtocolEnds&& out)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(out)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size,
                        ::fidl_test_protocols::wire::ProtocolEnds&& out)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(out)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::fidl_test_protocols::wire::ProtocolEnds&& out)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::ProtocolEnds&& out)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(out)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::
                               StructContainingEnds>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl_test_protocols::wire::ProtocolEnds&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl_test_protocols::wire::ProtocolEnds&& in, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl_test_protocols::wire::ProtocolEnds&& in, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::WithProtocolEnds>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::WithProtocolEnds>>::SyncEndpointVeneer;

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(_client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(_client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl_test_protocols::wire::ProtocolEnds&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        _client_end(), std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl::BufferSpan _request_buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& in,
                       ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
  _client_end() const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithProtocolEnds> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithProtocolEnds> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::WithProtocolEnds> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(this->client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(this->client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl_test_protocols::wire::ProtocolEnds&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        this->client_end(), std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl::BufferSpan _request_buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& in,
                       ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl_test_protocols::wire::ProtocolEnds&& out);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::WithProtocolEnds;

  using ClientEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequestView request,
                          ClientEndsCompleter::Sync& _completer) = 0;

  using ServerEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequestView request,
                          ServerEndsCompleter::Sync& _completer) = 0;

  using StructContainingEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(
      StructContainingEndsRequestView request,
      StructContainingEndsCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ManyParametersFifteenRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ManyParametersFifteenResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::ManyParameters> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::ManyParameters>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  bool p1;
  bool p2;
  bool p3;
  bool p4;
  bool p5;
  bool p6;
  bool p7;
  bool p8;
  bool p9;
  bool p10;
  bool p11;
  bool p12;
  bool p13;
  bool p14;
  bool p15;
  explicit WireRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15)
      : p1(p1),
        p2(p2),
        p3(p3),
        p4(p4),
        p5(p5),
        p6(p6),
        p7(p7),
        p8(p8),
        p9(p9),
        p10(p10),
        p11(p11),
        p12(p12),
        p13(p13),
        p14(p14),
        p15(p15) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                        bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                        bool p13, bool p14, bool p15)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, p1, p2, p3,
                              p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14,
                              p15) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, bool p1, bool p2,
                        bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
                        bool p9, bool p10, bool p11, bool p12, bool p13,
                        bool p14, bool p15)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                                        p9, p10, p11, p12, p13, p14, p15};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ManyParameters::Fifteen>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(bool p1, bool p2, bool p3, bool p4, bool p5,
                               bool p6, bool p7, bool p8, bool p9, bool p10,
                               bool p11, bool p12, bool p13, bool p14, bool p15)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), p1, p2, p3, p4,
                 p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, bool p1, bool p2,
      bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
      bool p11, bool p12, bool p13, bool p14, bool p15)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), p1, p2, p3, p4,
                 p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ManyParameters::Fifteen>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::ManyParameters::Fifteen>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> _client,
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, bool p1,
      bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9,
      bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::ManyParameters>|, avoiding setting up
// a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::ManyParameters>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::ManyParameters>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::ManyParameters>>::SyncEndpointVeneer;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>(
        _client_end(), p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13,
        p14, p15);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2, bool p3,
          bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
          bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ManyParameters::Fifteen>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, p1, p2,
        p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::ManyParameters> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ManyParameters> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::ManyParameters> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>(
        this->client_end(), p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12,
        p13, p14, p15);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2, bool p3,
          bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
          bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ManyParameters::Fifteen>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, p1,
        p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::ManyParameters;

  using FifteenCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ManyParameters::Fifteen>;
  using FifteenRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequestView request,
                       FifteenCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithErrorSyntax> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithErrorSyntax>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::
                              ResponseAsStruct>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::
                              ResponseAsStruct>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
                ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  using Result =
      fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 40;
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr uint32_t MaxOutOfLineV1 = 24;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                               ResponseAsStruct>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, result) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{result};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                               ResponseAsStruct>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<64> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
                ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::
                              ErrorAsPrimitive>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::
                              ErrorAsPrimitive>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
                ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  using Result =
      fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 40;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                               ErrorAsPrimitive>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, result) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{result};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                               ErrorAsPrimitive>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
                ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  using Result = fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 40;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, result) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{result};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::
                              HandleInResult>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
                ::fidl_test_protocols::WithErrorSyntax::HandleInResult>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final {
  using Result = fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : result(std::move(result)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 40;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                               HandleInResult>::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(
      uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(result)) {}
  UnownedEncodedMessage(
      uint32_t _iovec_capacity, uint8_t* _backing_buffer,
      uint32_t _backing_buffer_size,
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(result)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(result)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()),
                 std::move(result)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::DecodedMessage
    final : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
                ::fidl_test_protocols::WithErrorSyntax::HandleInResult>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<64> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::WithErrorSyntax>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::WithErrorSyntax>>::SyncEndpointVeneer;

  // Allocates 72 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        _client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        _client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        _client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        _client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        _client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(_client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        _client_end(), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithErrorSyntax> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithErrorSyntax> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::WithErrorSyntax> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 72 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
          result);
  ::fidl::Result ReplySuccess(int64_t a, int64_t b, int64_t c);
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
          result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer, int64_t a, int64_t b,
                              int64_t c);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
          result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
          result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(::fidl_test_protocols::wire::ErrorEnum error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::zx::handle&& h);
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer, ::zx::handle&& h);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::WithErrorSyntax;

  using ResponseAsStructCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(
      ResponseAsStructRequestView request,
      ResponseAsStructCompleter::Sync& _completer) = 0;

  using ErrorAsPrimitiveCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(
      ErrorAsPrimitiveRequestView request,
      ErrorAsPrimitiveCompleter::Sync& _completer) = 0;

  using ErrorAsEnumCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequestView request,
                           ErrorAsEnumCompleter::Sync& _completer) = 0;

  using HandleInResultCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequestView request,
                              HandleInResultCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_DiscoverableProtocolMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_DiscoverableProtocolMethodResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::DiscoverableProtocol> {
  static constexpr char DiscoverableName[] =
      "fidl.test.protocols.DiscoverableProtocol";
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::DiscoverableProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::DiscoverableProtocol::Method>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::DiscoverableProtocol::Method>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::DiscoverableProtocol::Method>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::DiscoverableProtocol::Method>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          _client);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::DiscoverableProtocol::Method>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          _client);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>|, avoiding
// setting up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::DiscoverableProtocol>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::DiscoverableProtocol>>::SyncEndpointVeneer;

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
  Method() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::DiscoverableProtocol::Method>(_client_end());
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
  _client_end() const {
    return ::fidl::UnownedClientEnd<
        ::fidl_test_protocols::DiscoverableProtocol>(_channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::DiscoverableProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::DiscoverableProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::DiscoverableProtocol>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
  Method() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::DiscoverableProtocol::Method>(
        this->client_end());
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::DiscoverableProtocol;

  using MethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::DiscoverableProtocol::Method>;
  using MethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequestView request,
                      MethodCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodAResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolEventARequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolEventAEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketResponseTable;

}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::ChannelProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::ChannelProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static void Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t a, int64_t b)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, a, b) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t a, int64_t b)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{a, b};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t a, int64_t b)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
      int64_t b)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::MethodA>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MethodA>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::ChannelProtocol::MethodA>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireResponse(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolEventAEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t a, int64_t b)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, a, b) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t a, int64_t b)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{a, b};
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::EventA>::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t a, int64_t b)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
      int64_t b)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::EventA>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::EventA>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::EventA>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t PrimarySizeV1 = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t a, int64_t b)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, a, b) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t a, int64_t b)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{a, b};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t a, int64_t b)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
      int64_t b)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), a, b) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::MethodB>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MethodB>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::ChannelProtocol::MethodB>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t result;
  explicit WireResponse(int64_t result) : result(result) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodBResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        int64_t result)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, result) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, int64_t result)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{result};
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>(
        &_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>(
        response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(int64_t result)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t result)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), result) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MethodB>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MethodB>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::handle h;
  explicit WireRequest(::zx::handle&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::handle&& h)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(h)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::handle&& h)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(h)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(::zx::handle&& h)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::handle&& h)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(h)) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>::
    UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>::
    OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage()
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size())) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
          response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
          response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
#ifdef __Fuchsia__
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }
#endif  // __Fuchsia__
 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>>::DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket a;
  explicit WireRequest(::zx::socket&& a) : a(std::move(a)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& a)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(a)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& a)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireRequest _request{std::move(a)};
    message_.Encode<WireRequest>(&_request);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireRequest* request)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, request) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireRequest* request)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<WireRequest>(request);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& a)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(a)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& a)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(a)) {}
  explicit OwnedEncodedMessage(WireRequest* request)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      WireRequest* request)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), request) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireRequest<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>> {
 public:
  using DecodedMessageBase<::fidl::WireRequest<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket b;
  explicit WireResponse(::zx::socket&& b) : b(std::move(b)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMutateSocketResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t PrimarySizeV1 = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;

 public:
  class DecodedMessage;

 private:
  void _InitHeader();
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::UnownedEncodedMessage
    final {
 public:
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        ::zx::socket&& b)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size,
                              std::move(b)) {}
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, ::zx::socket&& b)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    FIDL_ALIGNDECL WireResponse _response{std::move(b)};
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>>(&_response);
  }
  UnownedEncodedMessage(uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
                        WireResponse* response)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                              _backing_buffer, _backing_buffer_size, response) {
  }
  UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                        uint32_t _backing_buffer_size, WireResponse* response)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .iovecs = iovecs_,
            .iovec_capacity = _iovec_capacity,
            .handles = handles_,
            .handle_capacity =
                std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
            .backing_buffer = _backing_buffer,
            .backing_buffer_capacity = _backing_buffer_size,
        }) {
    ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
    message_.Encode<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>>(response);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  zx_handle_disposition_t
      handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
  ::fidl::OutgoingMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::OwnedEncodedMessage
    final {
 public:
  explicit OwnedEncodedMessage(::zx::socket&& b)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(b)) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& b)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), std::move(b)) {}
  explicit OwnedEncodedMessage(
      ::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), response) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
  const char* status_string() const { return message_.status_string(); }
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }
  template <typename ChannelLike>
  void Write(ChannelLike&& client) {
    message_.Write(std::forward<ChannelLike>(client));
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>> {
 public:
  using DecodedMessageBase<::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>>::
      DecodedMessageBase;

  DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                 zx_handle_info_t* handles = nullptr,
                 uint32_t handle_actual = 0)
      : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual, handles,
                                                   handle_actual)) {}
  ~DecodedMessage() {
    if (ok() && (PrimaryObject() != nullptr)) {
      PrimaryObject()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t a,
      int64_t b);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t a,
      int64_t b, uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes_);
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::handle&& h);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::handle&& h, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::handle&& h, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::socket&& a);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::socket&& a, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& a, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireSyncClientImpl<
    ::fidl_test_protocols::ChannelProtocol>
    final : public ::fidl::internal::SyncEndpointVeneer<
                ::fidl::internal::WireSyncClientImpl<
                    ::fidl_test_protocols::ChannelProtocol>> {
 public:
  using ::fidl::internal::SyncEndpointVeneer<
      ::fidl::internal::WireSyncClientImpl<
          ::fidl_test_protocols::ChannelProtocol>>::SyncEndpointVeneer;

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>(
        _client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodA>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, a, b);
  }

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>(
        _client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodB>(
        _client_end(), _request_buffer.data, _request_buffer.capacity, a, b,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::zx::handle&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(_client_end(),
                                                            std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
             ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(_client_end(),
                                                              std::move(a));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
               ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        _client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(a), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client_end()
      const {
    return ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>(
        _channel());
  }
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::ChannelProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ChannelProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::ChannelProtocol> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>(
        this->client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodA>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, a,
        b);
  }

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>(
        this->client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodB>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, a,
        b, _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::zx::handle&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(this->client_end(),
                                                            std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
             ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        this->client_end(), std::move(a));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
               ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(a), _response_buffer.data, _response_buffer.capacity);
  }
  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::ChannelProtocol>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(int64_t result);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, int64_t result);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::MethodB>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::zx::socket&& b);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::zx::socket&& b);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::ChannelProtocol;

  using MethodACompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MethodA>;
  using MethodARequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequestView request,
                       MethodACompleter::Sync& _completer) = 0;

  using MethodBCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MethodB>;
  using MethodBRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequestView request,
                       MethodBCompleter::Sync& _completer) = 0;

  using TakeHandleCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequestView request,
                          TakeHandleCompleter::Sync& _completer) = 0;

  using MutateSocketCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequestView request,
                            MutateSocketCompleter::Sync& _completer) = 0;

 private:
  void dispatch_message(::fidl::IncomingMessage&& msg,
                        ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>) ==
    ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                            NoResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                            ResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                             ResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::HandleRightsProtocol::AnEvent>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::HandleRightsProtocol::AnEvent>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestNoResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestNoResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestEmptyResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestWithResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     NoRequestWithResponse>,
             ret) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestNoResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestNoResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestEmptyResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestEmptyResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestWithResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>,
             ret) == 16);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               OnEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             OnEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               OnWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             OnWithResponse>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::
                                 WithAndWithoutRequestResponse::OnWithResponse>,
        ret) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::Request>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>,
             x) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>,
             y) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::OneWay>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>,
             x) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Event>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>,
             x) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::MethodWithUnion::UnionMethod>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::MethodWithUnion::UnionMethod>,
                       u) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>,
                       in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>,
                       out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>,
                       in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>,
                       out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::
                            StructContainingEnds>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>,
             in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::
                             StructContainingEnds>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>,
             out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ManyParameters::Fifteen>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p1) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p2) == 17);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p3) == 18);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p4) == 19);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p5) == 20);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p6) == 21);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p7) == 22);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p8) == 23);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p9) == 24);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p10) == 25);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p11) == 26);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p12) == 27);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p13) == 28);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p14) == 29);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p15) == 30);

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>,
             result) == 16);

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
             result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>,
                       result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::HandleInResult>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::HandleInResult>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::HandleInResult>,
             result) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::DiscoverableProtocol::Method>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::DiscoverableProtocol::Method>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodA>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::EventA>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodB>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::MethodB>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>,
        result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::ChannelProtocol::TakeHandle>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>,
        h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::TakeHandle>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::ChannelProtocol::MutateSocket>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::ChannelProtocol::MutateSocket>,
             a) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::MutateSocket>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::ChannelProtocol::MutateSocket>,
             b) == 16);
#endif  // __Fuchsia__

}  // namespace fidl
#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoResponseMethod(::zx::socket&& h);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result NoResponseMethod(::fidl::BufferSpan _request_buffer,
                                  ::zx::socket&& h);
  // Asynchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ResponseMethod(
      ::zx::socket&& h,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
          _cb);

  void ResponseMethod(
      ::zx::socket&& h,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                                   ResponseMethod>* response)>
          _cb);

  // Asynchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ResponseMethod(
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          _context);

  // Synchronous variant of |ResponseMethod.ResponseMethod()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod_Sync(::zx::socket&& h);

  // Synchronous variant of |ResponseMethod.ResponseMethod()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod_Sync(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                      ::fidl::BufferSpan _response_buffer);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the HandleRightsProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::HandleRightsProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  fidl::Result AnEvent(::zx::socket&& h) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result AnEvent(::fidl::BufferSpan _buffer, ::zx::socket&& h) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

  fidl::Result AnEvent(::zx::socket&& h) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result AnEvent(::fidl::BufferSpan _buffer, ::zx::socket&& h) const;

 private:
  friend ServerBindingRef<::fidl_test_protocols::HandleRightsProtocol>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoRequestNoResponse();
  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestEmptyResponse()|. Allocates 16
  // bytes of request buffer on the stack. The callback is stored on the heap.
  void NoRequestEmptyResponse(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>
          _cb);

  void NoRequestEmptyResponse(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   NoRequestEmptyResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestEmptyResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  void NoRequestEmptyResponse(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* _context);

  // Synchronous variant of |NoRequestEmptyResponse.NoRequestEmptyResponse()|.
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse_Sync();
  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Allocates 16 bytes
  // of request buffer on the stack. The callback is stored on the heap.
  void NoRequestWithResponse(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>
          _cb);

  void NoRequestWithResponse(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   NoRequestWithResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  void NoRequestWithResponse(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* _context);

  // Synchronous variant of |NoRequestWithResponse.NoRequestWithResponse()|.
  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse_Sync();

  // Synchronous variant of |NoRequestWithResponse.NoRequestWithResponse()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse_Sync(::fidl::BufferSpan _response_buffer);

  // Request is heap-allocated.
  ::fidl::Result WithRequestNoResponse(::fidl::StringView arg);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                                       ::fidl::StringView arg);
  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. The request and
  // callback are allocated on the heap.
  void WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>
          _cb);

  void WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   WithRequestEmptyResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  void WithRequestEmptyResponse(
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* _context);

  // Synchronous variant of
  // |WithRequestEmptyResponse.WithRequestEmptyResponse()|.
  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse_Sync(::fidl::StringView arg);

  // Synchronous variant of
  // |WithRequestEmptyResponse.WithRequestEmptyResponse()|. Caller provides the
  // backing storage for FIDL message via request and response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse_Sync(::fidl::BufferSpan _request_buffer,
                                ::fidl::StringView arg,
                                ::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. The request and
  // callback are allocated on the heap.
  void WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>
          _cb);

  void WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   WithRequestWithResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  void WithRequestWithResponse(
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* _context);

  // Synchronous variant of |WithRequestWithResponse.WithRequestWithResponse()|.
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse_Sync(::fidl::StringView arg);

  // Synchronous variant of |WithRequestWithResponse.WithRequestWithResponse()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse_Sync(::fidl::BufferSpan _request_buffer,
                               ::fidl::StringView arg,
                               ::fidl::BufferSpan _response_buffer);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithAndWithoutRequestResponse protocol, and can send events in that
// protocol.
template <>
class ::fidl::WireEventSender<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
          server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  fidl::Result OnEmptyResponse() const;

  fidl::Result OnWithResponse(::fidl::StringView ret) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result OnWithResponse(::fidl::BufferSpan _buffer,
                              ::fidl::StringView ret) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
      server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

  fidl::Result OnEmptyResponse() const;

  fidl::Result OnWithResponse(::fidl::StringView ret) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result OnWithResponse(::fidl::BufferSpan _buffer,
                              ::fidl::StringView ret) const;

 private:
  friend ServerBindingRef<::fidl_test_protocols::WithAndWithoutRequestResponse>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<::fidl_test_protocols::Transitional::Request>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::Transitional>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |Transitional.Request()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void Request(
      int64_t x,
      ::fidl::WireClientCallback<::fidl_test_protocols::Transitional::Request>
          _cb);

  void Request(
      int64_t x,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
              response)>
          _cb);

  // Asynchronous variant of |Transitional.Request()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void Request(
      ::fidl::BufferSpan _request_buffer, int64_t x,
      ::fidl::WireResponseContext<::fidl_test_protocols::Transitional::Request>*
          _context);

  // Synchronous variant of |Request.Request()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request_Sync(
      int64_t x);

  // Synchronous variant of |Request.Request()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request_Sync(::fidl::BufferSpan _request_buffer, int64_t x,
               ::fidl::BufferSpan _response_buffer);

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result OneWay(int64_t x);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result OneWay(::fidl::BufferSpan _request_buffer, int64_t x);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the Transitional protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::Transitional> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::Transitional> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::Transitional>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::Transitional>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  fidl::Result Event(int64_t x) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result Event(::fidl::BufferSpan _buffer, int64_t x) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::Transitional> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::Transitional> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

  fidl::Result Event(int64_t x) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result Event(::fidl::BufferSpan _buffer, int64_t x) const;

 private:
  friend ServerBindingRef<::fidl_test_protocols::Transitional>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::MethodWithUnion>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result UnionMethod(::fidl_test_protocols::wire::TheUnion u);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result UnionMethod(::fidl::BufferSpan _request_buffer,
                             ::fidl_test_protocols::wire::TheUnion u);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the MethodWithUnion protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::MethodWithUnion> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::MethodWithUnion> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

 private:
  friend ServerBindingRef<::fidl_test_protocols::MethodWithUnion>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
          _cb);

  void ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* _context);

  // Synchronous variant of |ClientEnds.ClientEnds()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds_Sync(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);

  // Synchronous variant of |ClientEnds.ClientEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds_Sync(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
          _cb);

  void ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* _context);

  // Synchronous variant of |ServerEnds.ServerEnds()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds_Sync(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);

  // Synchronous variant of |ServerEnds.ServerEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds_Sync(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void StructContainingEnds(
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
          _cb);

  void StructContainingEnds(
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::
                                        StructContainingEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void StructContainingEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          _context);

  // Synchronous variant of |StructContainingEnds.StructContainingEnds()|.
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds_Sync(::fidl_test_protocols::wire::ProtocolEnds&& in);

  // Synchronous variant of |StructContainingEnds.StructContainingEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds_Sync(::fidl::BufferSpan _request_buffer,
                            ::fidl_test_protocols::wire::ProtocolEnds&& in,
                            ::fidl::BufferSpan _response_buffer);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithProtocolEnds protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::WithProtocolEnds> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithProtocolEnds> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

 private:
  friend ServerBindingRef<::fidl_test_protocols::WithProtocolEnds>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::ManyParameters>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                         bool p7, bool p8, bool p9, bool p10, bool p11,
                         bool p12, bool p13, bool p14, bool p15);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2,
                         bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
                         bool p9, bool p10, bool p11, bool p12, bool p13,
                         bool p14, bool p15);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the ManyParameters protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::ManyParameters> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::ManyParameters> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

 private:
  friend ServerBindingRef<::fidl_test_protocols::ManyParameters>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ResponseAsStruct(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
          _cb);

  void ResponseAsStruct(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        ResponseAsStruct>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ResponseAsStruct(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* _context);

  // Synchronous variant of |ResponseAsStruct.ResponseAsStruct()|.
  // Allocates 72 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct_Sync();

  // Synchronous variant of |ResponseAsStruct.ResponseAsStruct()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct_Sync(::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ErrorAsPrimitive(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
          _cb);

  void ErrorAsPrimitive(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        ErrorAsPrimitive>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ErrorAsPrimitive(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* _context);

  // Synchronous variant of |ErrorAsPrimitive.ErrorAsPrimitive()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive_Sync();

  // Synchronous variant of |ErrorAsPrimitive.ErrorAsPrimitive()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive_Sync(::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void ErrorAsEnum(::fidl::WireClientCallback<
                   ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
                       _cb);

  void ErrorAsEnum(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void ErrorAsEnum(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* _context);

  // Synchronous variant of |ErrorAsEnum.ErrorAsEnum()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum_Sync();

  // Synchronous variant of |ErrorAsEnum.ErrorAsEnum()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum_Sync(::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void HandleInResult(::fidl::WireClientCallback<
                      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
                          _cb);

  void HandleInResult(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        HandleInResult>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void HandleInResult(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* _context);

  // Synchronous variant of |HandleInResult.HandleInResult()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult_Sync();

  // Synchronous variant of |HandleInResult.HandleInResult()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult_Sync(::fidl::BufferSpan _response_buffer);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithErrorSyntax protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::WithErrorSyntax> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithErrorSyntax> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

 private:
  friend ServerBindingRef<::fidl_test_protocols::WithErrorSyntax>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Method();
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the DiscoverableProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::DiscoverableProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::DiscoverableProtocol> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

 private:
  friend ServerBindingRef<::fidl_test_protocols::DiscoverableProtocol>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::MethodB>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::ChannelProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result MethodA(int64_t a, int64_t b);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result MethodA(::fidl::BufferSpan _request_buffer, int64_t a,
                         int64_t b);
  // Asynchronous variant of |ChannelProtocol.MethodB()|.
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void MethodB(int64_t a, int64_t b,
               ::fidl::WireClientCallback<
                   ::fidl_test_protocols::ChannelProtocol::MethodB>
                   _cb);

  void MethodB(
      int64_t a, int64_t b,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
              response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.MethodB()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void MethodB(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
               ::fidl::WireResponseContext<
                   ::fidl_test_protocols::ChannelProtocol::MethodB>* _context);

  // Synchronous variant of |MethodB.MethodB()|.
  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB_Sync(int64_t a, int64_t b);

  // Synchronous variant of |MethodB.MethodB()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB_Sync(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
               ::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |ChannelProtocol.TakeHandle()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void TakeHandle(::zx::handle&& h,
                  ::fidl::WireClientCallback<
                      ::fidl_test_protocols::ChannelProtocol::TakeHandle>
                      _cb);

  void TakeHandle(
      ::zx::handle&& h,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::ChannelProtocol::TakeHandle>* response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.TakeHandle()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void TakeHandle(
      ::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>* _context);

  // Synchronous variant of |TakeHandle.TakeHandle()|.
  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle_Sync(::zx::handle&& h);

  // Synchronous variant of |TakeHandle.TakeHandle()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle_Sync(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
                  ::fidl::BufferSpan _response_buffer);
  // Asynchronous variant of |ChannelProtocol.MutateSocket()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  void MutateSocket(::zx::socket&& a,
                    ::fidl::WireClientCallback<
                        ::fidl_test_protocols::ChannelProtocol::MutateSocket>
                        _cb);

  void MutateSocket(
      ::zx::socket&& a,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.MutateSocket()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  void MutateSocket(
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* _context);

  // Synchronous variant of |MutateSocket.MutateSocket()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket_Sync(::zx::socket&& a);

  // Synchronous variant of |MutateSocket.MutateSocket()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket_Sync(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
                    ::fidl::BufferSpan _response_buffer);
  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the ChannelProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::ChannelProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  fidl::Result EventA(int64_t a, int64_t b) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result EventA(::fidl::BufferSpan _buffer, int64_t a, int64_t b) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::ChannelProtocol> {
 public:
  WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding>&& binding)
      : inner_(std::move(binding)) {}

  fidl::Result EventA(int64_t a, int64_t b) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  fidl::Result EventA(::fidl::BufferSpan _buffer, int64_t a, int64_t b) const;

 private:
  friend ServerBindingRef<::fidl_test_protocols::ChannelProtocol>;

  ::fidl::internal::WeakEventSenderInner inner_;
};
#endif  // __Fuchsia__

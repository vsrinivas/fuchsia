{{/*
// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Protocol:Caller:MessagingHeader" }}
{{- EnsureNamespace "" }}

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a |fidl::ClientEnd<{{ .WireType }}>|,
// avoiding setting up a client.
template<>
class {{ .WireSyncClientImpl }} final :
    public ::fidl::internal::SyncEndpointVeneer<{{ .WireSyncClientImpl.Self }}, {{ . }}> {
 public:
  {{/* Client-calling functions do not apply to events. */}}
  {{ range .ClientMethods }}
    {{ .Docs }}
    //{{ template "Method:ClientAllocationComment:Helper" . }}
    {{ .WireResult }} {{ .Name }}({{- RenderParams .RequestArgs }}) {
      {{ .WireRequest }} _request{ {{ RenderForwardParams .RequestArgs }} };
      return {{ .WireResult }}(_client_end(), &_request);
    }
{{ "" }}
  {{- end }}

 private:
  ::fidl::UnownedClientEnd<{{ . }}> _client_end() const {
    return ::fidl::UnownedClientEnd<{{ . }}>(_channel());
  }
};

template <>
class {{ .WireSyncBufferClientImpl }} final :
    public ::fidl::internal::SyncEndpointBufferVeneer<{{ .WireSyncBufferClientImpl }}> {
 public:
  {{/* Client-calling functions do not apply to events. */}}
  {{ range .ClientMethods }}
    {{- .Docs }}
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    {{ .WireUnownedResult }} {{ .Name }}({{ RenderParams .RequestArgs }}) {
      {{ .WireRequest }} _request{ {{ RenderForwardParams .RequestArgs }} };
      return {{ .WireUnownedResult }}(_client_end(), _allocator(), &_request);
    }
{{ "" }}
  {{- end }}
 private:
  ::fidl::UnownedClientEnd<{{ . }}> _client_end() const {
    return ::fidl::UnownedClientEnd<{{ . }}>(_channel());
  }
};
{{- end }}


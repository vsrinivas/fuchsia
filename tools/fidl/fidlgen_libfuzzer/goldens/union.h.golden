// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test/union/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using Union = ::fidl::test::union_::Union;
using StructWithNullableXUnion = ::fidl::test::union_::StructWithNullableXUnion;
using StrictUnion = ::fidl::test::union_::StrictUnion;
using StrictSimpleXUnion = ::fidl::test::union_::StrictSimpleXUnion;
using StrictFoo = ::fidl::test::union_::StrictFoo;
using StrictBoundedXUnion = ::fidl::test::union_::StrictBoundedXUnion;
using ReverseOrdinalUnion = ::fidl::test::union_::ReverseOrdinalUnion;
using Pizza = ::fidl::test::union_::Pizza;
using Pasta = ::fidl::test::union_::Pasta;
using StrictPizzaOrPasta = ::fidl::test::union_::StrictPizzaOrPasta;
using PizzaOrPasta = ::fidl::test::union_::PizzaOrPasta;
using FlexiblePizzaOrPasta = ::fidl::test::union_::FlexiblePizzaOrPasta;
using ExplicitPizzaOrPasta = ::fidl::test::union_::ExplicitPizzaOrPasta;
using OlderSimpleUnion = ::fidl::test::union_::OlderSimpleUnion;
using NullableUnionStruct = ::fidl::test::union_::NullableUnionStruct;
using NewerSimpleUnion = ::fidl::test::union_::NewerSimpleUnion;
using FlexibleUnion = ::fidl::test::union_::FlexibleUnion;
using FlexibleFoo = ::fidl::test::union_::FlexibleFoo;
using FieldCollision = ::fidl::test::union_::FieldCollision;
using ExplicitXUnion = ::fidl::test::union_::ExplicitXUnion;
using ExplicitUnion = ::fidl::test::union_::ExplicitUnion;
using ExplicitStrictFoo = ::fidl::test::union_::ExplicitStrictFoo;
using ExplicitFoo = ::fidl::test::union_::ExplicitFoo;
using Empty = ::fidl::test::union_::Empty;
using XUnionContainingEmptyStruct =
    ::fidl::test::union_::XUnionContainingEmptyStruct;

template <>
struct MinSize<Union> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<::std::string>(),
                      MinSize<::std::vector<::std::string>>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<Union> {
  static_assert(3 > 0, "xunion must have at least one member");

  Union operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Union>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    Union out;
    switch (selector % 3) {
      case 0: {
        out.set_Primitive(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_StringNeedsConstructor(Allocate<::std::string>{}(src, size));
        break;
      }
      case 2: {
        out.set_VectorStringAlsoNeedsConstructor(
            Allocate<::std::vector<::std::string>>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<StructWithNullableXUnion> {
  operator size_t() { return MinSize<::std::unique_ptr<OlderSimpleUnion>>(); }
};
template <>
struct Allocate<StructWithNullableXUnion> {
  StructWithNullableXUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableXUnion>());
    const size_t slack_per_member =
        (*size - MinSize<StructWithNullableXUnion>()) / 1;
    StructWithNullableXUnion out;
    size_t out_size;
    out_size =
        MinSize<::std::unique_ptr<OlderSimpleUnion>>() + slack_per_member;
    out.x1 = Allocate<::std::unique_ptr<OlderSimpleUnion>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StrictUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<::std::string>(),
                      MinSize<::std::vector<::std::string>>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<StrictUnion> {
  static_assert(3 > 0, "xunion must have at least one member");

  StrictUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StrictUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    StrictUnion out;
    switch (selector % 3) {
      case 0: {
        out.set_Primitive(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_StringNeedsConstructor(Allocate<::std::string>{}(src, size));
        break;
      }
      case 2: {
        out.set_VectorStringAlsoNeedsConstructor(
            Allocate<::std::vector<::std::string>>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<StrictSimpleXUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<float>(),
                      MinSize<::std::string>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<StrictSimpleXUnion> {
  static_assert(3 > 0, "xunion must have at least one member");

  StrictSimpleXUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StrictSimpleXUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    StrictSimpleXUnion out;
    switch (selector % 3) {
      case 0: {
        out.set_i(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_f(Allocate<float>{}(src, size));
        break;
      }
      case 2: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<StrictFoo> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::std::string>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<StrictFoo> {
  static_assert(2 > 0, "xunion must have at least one member");

  StrictFoo operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StrictFoo>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    StrictFoo out;
    switch (selector % 2) {
      case 0: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
      case 1: {
        out.set_i(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<StrictBoundedXUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::std::vector<uint8_t>>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<StrictBoundedXUnion> {
  static_assert(1 > 0, "xunion must have at least one member");

  StrictBoundedXUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StrictBoundedXUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    StrictBoundedXUnion out;
    switch (selector % 1) {
      case 0: {
        out.set_v(Allocate<::std::vector<uint8_t>>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ReverseOrdinalUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint32_t>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ReverseOrdinalUnion> {
  static_assert(2 > 0, "xunion must have at least one member");

  ReverseOrdinalUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ReverseOrdinalUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ReverseOrdinalUnion out;
    switch (selector % 2) {
      case 0: {
        out.set_second(Allocate<uint32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_first(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<Pizza> {
  operator size_t() { return MinSize<::std::vector<::std::string>>(); }
};
template <>
struct Allocate<Pizza> {
  Pizza operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Pizza>());
    const size_t slack_per_member = (*size - MinSize<Pizza>()) / 1;
    Pizza out;
    size_t out_size;
    out_size = MinSize<::std::vector<::std::string>>() + slack_per_member;
    out.toppings = Allocate<::std::vector<::std::string>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Pasta> {
  operator size_t() { return MinSize<::std::string>(); }
};
template <>
struct Allocate<Pasta> {
  Pasta operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Pasta>());
    const size_t slack_per_member = (*size - MinSize<Pasta>()) / 1;
    Pasta out;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.sauce = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StrictPizzaOrPasta> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<Pizza>(), MinSize<Pasta>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<StrictPizzaOrPasta> {
  static_assert(2 > 0, "xunion must have at least one member");

  StrictPizzaOrPasta operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StrictPizzaOrPasta>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    StrictPizzaOrPasta out;
    switch (selector % 2) {
      case 0: {
        out.set_pizza(Allocate<Pizza>{}(src, size));
        break;
      }
      case 1: {
        out.set_pasta(Allocate<Pasta>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<PizzaOrPasta> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<Pizza>(), MinSize<Pasta>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<PizzaOrPasta> {
  static_assert(2 > 0, "xunion must have at least one member");

  PizzaOrPasta operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<PizzaOrPasta>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    PizzaOrPasta out;
    switch (selector % 2) {
      case 0: {
        out.set_pizza(Allocate<Pizza>{}(src, size));
        break;
      }
      case 1: {
        out.set_pasta(Allocate<Pasta>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<FlexiblePizzaOrPasta> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<Pizza>(), MinSize<Pasta>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<FlexiblePizzaOrPasta> {
  static_assert(2 > 0, "xunion must have at least one member");

  FlexiblePizzaOrPasta operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FlexiblePizzaOrPasta>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    FlexiblePizzaOrPasta out;
    switch (selector % 2) {
      case 0: {
        out.set_pizza(Allocate<Pizza>{}(src, size));
        break;
      }
      case 1: {
        out.set_pasta(Allocate<Pasta>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ExplicitPizzaOrPasta> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<Pizza>(), MinSize<Pasta>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ExplicitPizzaOrPasta> {
  static_assert(2 > 0, "xunion must have at least one member");

  ExplicitPizzaOrPasta operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ExplicitPizzaOrPasta>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ExplicitPizzaOrPasta out;
    switch (selector % 2) {
      case 0: {
        out.set_pizza(Allocate<Pizza>{}(src, size));
        break;
      }
      case 1: {
        out.set_pasta(Allocate<Pasta>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<OlderSimpleUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int64_t>(), MinSize<float>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<OlderSimpleUnion> {
  static_assert(2 > 0, "xunion must have at least one member");

  OlderSimpleUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OlderSimpleUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    OlderSimpleUnion out;
    switch (selector % 2) {
      case 0: {
        out.set_i(Allocate<int64_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_f(Allocate<float>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<NullableUnionStruct> {
  operator size_t() { return MinSize<::std::unique_ptr<Union>>(); }
};
template <>
struct Allocate<NullableUnionStruct> {
  NullableUnionStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<NullableUnionStruct>());
    const size_t slack_per_member =
        (*size - MinSize<NullableUnionStruct>()) / 1;
    NullableUnionStruct out;
    size_t out_size;
    out_size = MinSize<::std::unique_ptr<Union>>() + slack_per_member;
    out.the_union = Allocate<::std::unique_ptr<Union>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<NewerSimpleUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int64_t>(), MinSize<::std::string>(),
                      MinSize<::std::vector<::std::string>>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<NewerSimpleUnion> {
  static_assert(3 > 0, "xunion must have at least one member");

  NewerSimpleUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<NewerSimpleUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    NewerSimpleUnion out;
    switch (selector % 3) {
      case 0: {
        out.set_i(Allocate<int64_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
      case 2: {
        out.set_v(Allocate<::std::vector<::std::string>>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<FlexibleUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<::std::string>(),
                      MinSize<::std::vector<::std::string>>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<FlexibleUnion> {
  static_assert(3 > 0, "xunion must have at least one member");

  FlexibleUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FlexibleUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    FlexibleUnion out;
    switch (selector % 3) {
      case 0: {
        out.set_Primitive(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_StringNeedsConstructor(Allocate<::std::string>{}(src, size));
        break;
      }
      case 2: {
        out.set_VectorStringAlsoNeedsConstructor(
            Allocate<::std::vector<::std::string>>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<FlexibleFoo> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::std::string>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<FlexibleFoo> {
  static_assert(2 > 0, "xunion must have at least one member");

  FlexibleFoo operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FlexibleFoo>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    FlexibleFoo out;
    switch (selector % 2) {
      case 0: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
      case 1: {
        out.set_i(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<FieldCollision> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<FieldCollision> {
  static_assert(1 > 0, "xunion must have at least one member");

  FieldCollision operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FieldCollision>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    FieldCollision out;
    switch (selector % 1) {
      case 0: {
        out.set_field_collision_tag(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ExplicitXUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int64_t>(), MinSize<float>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ExplicitXUnion> {
  static_assert(2 > 0, "xunion must have at least one member");

  ExplicitXUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ExplicitXUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ExplicitXUnion out;
    switch (selector % 2) {
      case 0: {
        out.set_i(Allocate<int64_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_f(Allocate<float>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ExplicitUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<::std::string>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ExplicitUnion> {
  static_assert(2 > 0, "xunion must have at least one member");

  ExplicitUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ExplicitUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ExplicitUnion out;
    switch (selector % 2) {
      case 0: {
        out.set_Primitive(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_StringNeedsConstructor(Allocate<::std::string>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ExplicitStrictFoo> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::std::string>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ExplicitStrictFoo> {
  static_assert(2 > 0, "xunion must have at least one member");

  ExplicitStrictFoo operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ExplicitStrictFoo>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ExplicitStrictFoo out;
    switch (selector % 2) {
      case 0: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
      case 1: {
        out.set_i(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ExplicitFoo> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::std::string>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<ExplicitFoo> {
  static_assert(2 > 0, "xunion must have at least one member");

  ExplicitFoo operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ExplicitFoo>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ExplicitFoo out;
    switch (selector % 2) {
      case 0: {
        out.set_s(Allocate<::std::string>{}(src, size));
        break;
      }
      case 1: {
        out.set_i(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<Empty> {
  operator size_t() { return MinSize<uint8_t>(); }
};
template <>
struct Allocate<Empty> {
  Empty operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Empty>());
    const size_t slack_per_member = (*size - MinSize<Empty>()) / 1;
    Empty out;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<XUnionContainingEmptyStruct> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<Empty>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<XUnionContainingEmptyStruct> {
  static_assert(1 > 0, "xunion must have at least one member");

  XUnionContainingEmptyStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<XUnionContainingEmptyStruct>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    XUnionContainingEmptyStruct out;
    switch (selector % 1) {
      case 0: {
        out.set_empty(Allocate<Empty>{}(src, size));
        break;
      }
    }

    return out;
  }
};

}  // namespace fuzzing

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <test/protocols/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using WithAndWithoutRequestResponseNoRequestWithResponseResponse = ::test::protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse;
using WithAndWithoutRequestResponseWithRequestNoResponseRequest = ::test::protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest;
using WithAndWithoutRequestResponseWithRequestEmptyResponseRequest = ::test::protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
using WithAndWithoutRequestResponseWithRequestWithResponseRequest = ::test::protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest;
using WithAndWithoutRequestResponseWithRequestWithResponseResponse = ::test::protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
using WithAndWithoutRequestResponseOnWithResponseRequest = ::test::protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
using ErrorEnum = ::test::protocols::ErrorEnum;
using WithErrorSyntax_ResponseAsStruct_Response = ::test::protocols::WithErrorSyntax_ResponseAsStruct_Response;
using WithErrorSyntax_ResponseAsStruct_Result = ::test::protocols::WithErrorSyntax_ResponseAsStruct_Result;
using WithErrorSyntaxResponseAsStructTopResponse = ::test::protocols::WithErrorSyntaxResponseAsStructTopResponse;
using WithErrorSyntax_ErrorAsPrimitive_Response = ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response;
using WithErrorSyntax_ErrorAsPrimitive_Result = ::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result;
using WithErrorSyntaxErrorAsPrimitiveTopResponse = ::test::protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;
using WithErrorSyntax_ErrorAsEnum_Response = ::test::protocols::WithErrorSyntax_ErrorAsEnum_Response;
using WithErrorSyntax_ErrorAsEnum_Result = ::test::protocols::WithErrorSyntax_ErrorAsEnum_Result;
using WithErrorSyntaxErrorAsEnumTopResponse = ::test::protocols::WithErrorSyntaxErrorAsEnumTopResponse;
using WithErrorSyntax_HandleInResult_Response = ::test::protocols::WithErrorSyntax_HandleInResult_Response;
using WithErrorSyntax_HandleInResult_Result = ::test::protocols::WithErrorSyntax_HandleInResult_Result;
using WithErrorSyntaxHandleInResultTopResponse = ::test::protocols::WithErrorSyntaxHandleInResultTopResponse;
using ChannelProtocolMethodARequest = ::test::protocols::ChannelProtocolMethodARequest;
using ChannelProtocolEventARequest = ::test::protocols::ChannelProtocolEventARequest;
using ChannelProtocolMethodBRequest = ::test::protocols::ChannelProtocolMethodBRequest;
using ChannelProtocolMethodBResponse = ::test::protocols::ChannelProtocolMethodBResponse;
using ChannelProtocolTakeHandleRequest = ::test::protocols::ChannelProtocolTakeHandleRequest;
using ChannelProtocolMutateSocketRequest = ::test::protocols::ChannelProtocolMutateSocketRequest;
using ChannelProtocolMutateSocketResponse = ::test::protocols::ChannelProtocolMutateSocketResponse;
using SyscallProtocolMethodCRequest = ::test::protocols::SyscallProtocolMethodCRequest;
using TransitionalRequestRequest = ::test::protocols::TransitionalRequestRequest;
using TransitionalRequestResponse = ::test::protocols::TransitionalRequestResponse;
using TransitionalOneWayRequest = ::test::protocols::TransitionalOneWayRequest;
using TransitionalEventRequest = ::test::protocols::TransitionalEventRequest;
using HandleRightsProtocolNoResponseMethodRequest = ::test::protocols::HandleRightsProtocolNoResponseMethodRequest;
using HandleRightsProtocolResponseMethodRequest = ::test::protocols::HandleRightsProtocolResponseMethodRequest;
using HandleRightsProtocolResponseMethodResponse = ::test::protocols::HandleRightsProtocolResponseMethodResponse;
using HandleRightsProtocolAnEventRequest = ::test::protocols::HandleRightsProtocolAnEventRequest;
using ProtocolEnds = ::test::protocols::ProtocolEnds;
using WithProtocolEndsClientEndsRequest = ::test::protocols::WithProtocolEndsClientEndsRequest;
using WithProtocolEndsClientEndsResponse = ::test::protocols::WithProtocolEndsClientEndsResponse;
using WithProtocolEndsServerEndsRequest = ::test::protocols::WithProtocolEndsServerEndsRequest;
using WithProtocolEndsServerEndsResponse = ::test::protocols::WithProtocolEndsServerEndsResponse;
using WithProtocolEndsStructContainingEndsRequest = ::test::protocols::WithProtocolEndsStructContainingEndsRequest;
using WithProtocolEndsStructContainingEndsResponse = ::test::protocols::WithProtocolEndsStructContainingEndsResponse;
using ManyParametersFifteenRequest = ::test::protocols::ManyParametersFifteenRequest;
using TheUnion = ::test::protocols::TheUnion;
using MethodWithUnionUnionMethodRequest = ::test::protocols::MethodWithUnionUnionMethodRequest;
using MethodWithUnionUnionMethodResponse = ::test::protocols::MethodWithUnionUnionMethodResponse;

template <>
struct MinSize<WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
  WithAndWithoutRequestResponseNoRequestWithResponseResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseNoRequestWithResponseResponse>());
    WithAndWithoutRequestResponseNoRequestWithResponseResponse out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseNoRequestWithResponseResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.ret = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  WithAndWithoutRequestResponseWithRequestNoResponseRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseWithRequestNoResponseRequest>());
    WithAndWithoutRequestResponseWithRequestNoResponseRequest out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseWithRequestNoResponseRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.arg = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>());
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.arg = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  WithAndWithoutRequestResponseWithRequestWithResponseRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseWithRequestWithResponseRequest>());
    WithAndWithoutRequestResponseWithRequestWithResponseRequest out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseWithRequestWithResponseRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.arg = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
  WithAndWithoutRequestResponseWithRequestWithResponseResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseWithRequestWithResponseResponse>());
    WithAndWithoutRequestResponseWithRequestWithResponseResponse out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseWithRequestWithResponseResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.ret = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithAndWithoutRequestResponseOnWithResponseRequest> {
  operator size_t() {
    return MinSize<::std::string>();
  }
};
template <>
struct Allocate<WithAndWithoutRequestResponseOnWithResponseRequest> {
  WithAndWithoutRequestResponseOnWithResponseRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithAndWithoutRequestResponseOnWithResponseRequest>());
    WithAndWithoutRequestResponseOnWithResponseRequest out;
    const size_t slack_per_member = (*size - MinSize<WithAndWithoutRequestResponseOnWithResponseRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.ret = Allocate<::std::string>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ErrorEnum> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<ErrorEnum> {
  ErrorEnum operator()(FuzzInput* src, size_t* size) {
    ErrorEnum out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 2) {
      case 0:
        out = ErrorEnum::ERR_FOO;
        break;
      case 1:
        out = ErrorEnum::ERR_BAR;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ResponseAsStruct_Response> {
  operator size_t() {
    return MinSize<int64_t>() + MinSize<int64_t>() + MinSize<int64_t>();
  }
};
template <>
struct Allocate<WithErrorSyntax_ResponseAsStruct_Response> {
  WithErrorSyntax_ResponseAsStruct_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ResponseAsStruct_Response>());
    WithErrorSyntax_ResponseAsStruct_Response out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntax_ResponseAsStruct_Response>()) / 3;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.a = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.b = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.c = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ResponseAsStruct_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<WithErrorSyntax_ResponseAsStruct_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  WithErrorSyntax_ResponseAsStruct_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ResponseAsStruct_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    WithErrorSyntax_ResponseAsStruct_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<WithErrorSyntaxResponseAsStructTopResponse> {
  operator size_t() {
    return MinSize<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>();
  }
};
template <>
struct Allocate<WithErrorSyntaxResponseAsStructTopResponse> {
  WithErrorSyntaxResponseAsStructTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntaxResponseAsStructTopResponse>());
    WithErrorSyntaxResponseAsStructTopResponse out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntaxResponseAsStructTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>() + slack_per_member;
    out.result = Allocate<::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ErrorAsPrimitive_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template <>
struct Allocate<WithErrorSyntax_ErrorAsPrimitive_Response> {
  WithErrorSyntax_ErrorAsPrimitive_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ErrorAsPrimitive_Response>());
    WithErrorSyntax_ErrorAsPrimitive_Response out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntax_ErrorAsPrimitive_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ErrorAsPrimitive_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<WithErrorSyntax_ErrorAsPrimitive_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  WithErrorSyntax_ErrorAsPrimitive_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ErrorAsPrimitive_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    WithErrorSyntax_ErrorAsPrimitive_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<WithErrorSyntaxErrorAsPrimitiveTopResponse> {
  operator size_t() {
    return MinSize<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>();
  }
};
template <>
struct Allocate<WithErrorSyntaxErrorAsPrimitiveTopResponse> {
  WithErrorSyntaxErrorAsPrimitiveTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntaxErrorAsPrimitiveTopResponse>());
    WithErrorSyntaxErrorAsPrimitiveTopResponse out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntaxErrorAsPrimitiveTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>() + slack_per_member;
    out.result = Allocate<::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ErrorAsEnum_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template <>
struct Allocate<WithErrorSyntax_ErrorAsEnum_Response> {
  WithErrorSyntax_ErrorAsEnum_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ErrorAsEnum_Response>());
    WithErrorSyntax_ErrorAsEnum_Response out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntax_ErrorAsEnum_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_ErrorAsEnum_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>(), MinSize<::test::protocols::ErrorEnum>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<WithErrorSyntax_ErrorAsEnum_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  WithErrorSyntax_ErrorAsEnum_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_ErrorAsEnum_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    WithErrorSyntax_ErrorAsEnum_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<::test::protocols::ErrorEnum>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<WithErrorSyntaxErrorAsEnumTopResponse> {
  operator size_t() {
    return MinSize<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>();
  }
};
template <>
struct Allocate<WithErrorSyntaxErrorAsEnumTopResponse> {
  WithErrorSyntaxErrorAsEnumTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntaxErrorAsEnumTopResponse>());
    WithErrorSyntaxErrorAsEnumTopResponse out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntaxErrorAsEnumTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>() + slack_per_member;
    out.result = Allocate<::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_HandleInResult_Response> {
  operator size_t() {
    return MinSize<::zx::handle>();
  }
};
template <>
struct Allocate<WithErrorSyntax_HandleInResult_Response> {
  WithErrorSyntax_HandleInResult_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_HandleInResult_Response>());
    WithErrorSyntax_HandleInResult_Response out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntax_HandleInResult_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.h = Allocate<::zx::handle>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithErrorSyntax_HandleInResult_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::protocols::WithErrorSyntax_HandleInResult_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<WithErrorSyntax_HandleInResult_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  WithErrorSyntax_HandleInResult_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntax_HandleInResult_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    WithErrorSyntax_HandleInResult_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::protocols::WithErrorSyntax_HandleInResult_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<WithErrorSyntaxHandleInResultTopResponse> {
  operator size_t() {
    return MinSize<::test::protocols::WithErrorSyntax_HandleInResult_Result>();
  }
};
template <>
struct Allocate<WithErrorSyntaxHandleInResultTopResponse> {
  WithErrorSyntaxHandleInResultTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithErrorSyntaxHandleInResultTopResponse>());
    WithErrorSyntaxHandleInResultTopResponse out;
    const size_t slack_per_member = (*size - MinSize<WithErrorSyntaxHandleInResultTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::WithErrorSyntax_HandleInResult_Result>() + slack_per_member;
    out.result = Allocate<::test::protocols::WithErrorSyntax_HandleInResult_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolMethodARequest> {
  operator size_t() {
    return MinSize<int64_t>() + MinSize<int64_t>();
  }
};
template <>
struct Allocate<ChannelProtocolMethodARequest> {
  ChannelProtocolMethodARequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolMethodARequest>());
    ChannelProtocolMethodARequest out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolMethodARequest>()) / 2;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.a = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.b = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolEventARequest> {
  operator size_t() {
    return MinSize<int64_t>() + MinSize<int64_t>();
  }
};
template <>
struct Allocate<ChannelProtocolEventARequest> {
  ChannelProtocolEventARequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolEventARequest>());
    ChannelProtocolEventARequest out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolEventARequest>()) / 2;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.a = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.b = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolMethodBRequest> {
  operator size_t() {
    return MinSize<int64_t>() + MinSize<int64_t>();
  }
};
template <>
struct Allocate<ChannelProtocolMethodBRequest> {
  ChannelProtocolMethodBRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolMethodBRequest>());
    ChannelProtocolMethodBRequest out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolMethodBRequest>()) / 2;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.a = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.b = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolMethodBResponse> {
  operator size_t() {
    return MinSize<int64_t>();
  }
};
template <>
struct Allocate<ChannelProtocolMethodBResponse> {
  ChannelProtocolMethodBResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolMethodBResponse>());
    ChannelProtocolMethodBResponse out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolMethodBResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.result = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolTakeHandleRequest> {
  operator size_t() {
    return MinSize<::zx::handle>();
  }
};
template <>
struct Allocate<ChannelProtocolTakeHandleRequest> {
  ChannelProtocolTakeHandleRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolTakeHandleRequest>());
    ChannelProtocolTakeHandleRequest out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolTakeHandleRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.h = Allocate<::zx::handle>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolMutateSocketRequest> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<ChannelProtocolMutateSocketRequest> {
  ChannelProtocolMutateSocketRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolMutateSocketRequest>());
    ChannelProtocolMutateSocketRequest out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolMutateSocketRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.a = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ChannelProtocolMutateSocketResponse> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<ChannelProtocolMutateSocketResponse> {
  ChannelProtocolMutateSocketResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ChannelProtocolMutateSocketResponse>());
    ChannelProtocolMutateSocketResponse out;
    const size_t slack_per_member = (*size - MinSize<ChannelProtocolMutateSocketResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.b = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SyscallProtocolMethodCRequest> {
  operator size_t() {
    return MinSize<int64_t>() + MinSize<int64_t>();
  }
};
template <>
struct Allocate<SyscallProtocolMethodCRequest> {
  SyscallProtocolMethodCRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SyscallProtocolMethodCRequest>());
    SyscallProtocolMethodCRequest out;
    const size_t slack_per_member = (*size - MinSize<SyscallProtocolMethodCRequest>()) / 2;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.a = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.b = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TransitionalRequestRequest> {
  operator size_t() {
    return MinSize<int64_t>();
  }
};
template <>
struct Allocate<TransitionalRequestRequest> {
  TransitionalRequestRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TransitionalRequestRequest>());
    TransitionalRequestRequest out;
    const size_t slack_per_member = (*size - MinSize<TransitionalRequestRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.x = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TransitionalRequestResponse> {
  operator size_t() {
    return MinSize<int64_t>();
  }
};
template <>
struct Allocate<TransitionalRequestResponse> {
  TransitionalRequestResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TransitionalRequestResponse>());
    TransitionalRequestResponse out;
    const size_t slack_per_member = (*size - MinSize<TransitionalRequestResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.y = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TransitionalOneWayRequest> {
  operator size_t() {
    return MinSize<int64_t>();
  }
};
template <>
struct Allocate<TransitionalOneWayRequest> {
  TransitionalOneWayRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TransitionalOneWayRequest>());
    TransitionalOneWayRequest out;
    const size_t slack_per_member = (*size - MinSize<TransitionalOneWayRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.x = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TransitionalEventRequest> {
  operator size_t() {
    return MinSize<int64_t>();
  }
};
template <>
struct Allocate<TransitionalEventRequest> {
  TransitionalEventRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TransitionalEventRequest>());
    TransitionalEventRequest out;
    const size_t slack_per_member = (*size - MinSize<TransitionalEventRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int64_t>() + slack_per_member;
    out.x = Allocate<int64_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<HandleRightsProtocolNoResponseMethodRequest> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<HandleRightsProtocolNoResponseMethodRequest> {
  HandleRightsProtocolNoResponseMethodRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<HandleRightsProtocolNoResponseMethodRequest>());
    HandleRightsProtocolNoResponseMethodRequest out;
    const size_t slack_per_member = (*size - MinSize<HandleRightsProtocolNoResponseMethodRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.h = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<HandleRightsProtocolResponseMethodRequest> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<HandleRightsProtocolResponseMethodRequest> {
  HandleRightsProtocolResponseMethodRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<HandleRightsProtocolResponseMethodRequest>());
    HandleRightsProtocolResponseMethodRequest out;
    const size_t slack_per_member = (*size - MinSize<HandleRightsProtocolResponseMethodRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.h = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<HandleRightsProtocolResponseMethodResponse> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<HandleRightsProtocolResponseMethodResponse> {
  HandleRightsProtocolResponseMethodResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<HandleRightsProtocolResponseMethodResponse>());
    HandleRightsProtocolResponseMethodResponse out;
    const size_t slack_per_member = (*size - MinSize<HandleRightsProtocolResponseMethodResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.h = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<HandleRightsProtocolAnEventRequest> {
  operator size_t() {
    return MinSize<::zx::socket>();
  }
};
template <>
struct Allocate<HandleRightsProtocolAnEventRequest> {
  HandleRightsProtocolAnEventRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<HandleRightsProtocolAnEventRequest>());
    HandleRightsProtocolAnEventRequest out;
    const size_t slack_per_member = (*size - MinSize<HandleRightsProtocolAnEventRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.h = Allocate<::zx::socket>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ProtocolEnds> {
  operator size_t() {
    return MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>() + MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>();
  }
};
template <>
struct Allocate<ProtocolEnds> {
  ProtocolEnds operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ProtocolEnds>());
    ProtocolEnds out;
    const size_t slack_per_member = (*size - MinSize<ProtocolEnds>()) / 4;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.client = Allocate<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.server = Allocate<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.client_opt = Allocate<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.server_opt = Allocate<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsClientEndsRequest> {
  operator size_t() {
    return MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>();
  }
};
template <>
struct Allocate<WithProtocolEndsClientEndsRequest> {
  WithProtocolEndsClientEndsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsClientEndsRequest>());
    WithProtocolEndsClientEndsRequest out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsClientEndsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.in = Allocate<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsClientEndsResponse> {
  operator size_t() {
    return MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>();
  }
};
template <>
struct Allocate<WithProtocolEndsClientEndsResponse> {
  WithProtocolEndsClientEndsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsClientEndsResponse>());
    WithProtocolEndsClientEndsResponse out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsClientEndsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.out = Allocate<::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsServerEndsRequest> {
  operator size_t() {
    return MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>();
  }
};
template <>
struct Allocate<WithProtocolEndsServerEndsRequest> {
  WithProtocolEndsServerEndsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsServerEndsRequest>());
    WithProtocolEndsServerEndsRequest out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsServerEndsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.in = Allocate<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsServerEndsResponse> {
  operator size_t() {
    return MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>();
  }
};
template <>
struct Allocate<WithProtocolEndsServerEndsResponse> {
  WithProtocolEndsServerEndsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsServerEndsResponse>());
    WithProtocolEndsServerEndsResponse out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsServerEndsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>() + slack_per_member;
    out.out = Allocate<::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsStructContainingEndsRequest> {
  operator size_t() {
    return MinSize<::test::protocols::ProtocolEnds>();
  }
};
template <>
struct Allocate<WithProtocolEndsStructContainingEndsRequest> {
  WithProtocolEndsStructContainingEndsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsStructContainingEndsRequest>());
    WithProtocolEndsStructContainingEndsRequest out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsStructContainingEndsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::ProtocolEnds>() + slack_per_member;
    out.in = Allocate<::test::protocols::ProtocolEnds>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<WithProtocolEndsStructContainingEndsResponse> {
  operator size_t() {
    return MinSize<::test::protocols::ProtocolEnds>();
  }
};
template <>
struct Allocate<WithProtocolEndsStructContainingEndsResponse> {
  WithProtocolEndsStructContainingEndsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<WithProtocolEndsStructContainingEndsResponse>());
    WithProtocolEndsStructContainingEndsResponse out;
    const size_t slack_per_member = (*size - MinSize<WithProtocolEndsStructContainingEndsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::ProtocolEnds>() + slack_per_member;
    out.out = Allocate<::test::protocols::ProtocolEnds>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ManyParametersFifteenRequest> {
  operator size_t() {
    return MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>() + MinSize<bool>();
  }
};
template <>
struct Allocate<ManyParametersFifteenRequest> {
  ManyParametersFifteenRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ManyParametersFifteenRequest>());
    ManyParametersFifteenRequest out;
    const size_t slack_per_member = (*size - MinSize<ManyParametersFifteenRequest>()) / 15;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.p1 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p2 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p3 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p4 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p5 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p6 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p7 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p8 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p9 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p10 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p11 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p12 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p13 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p14 = Allocate<bool>{}(src, &out_size);
    out_size = MinSize<bool>() + slack_per_member;
    out.p15 = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TheUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<TheUnion> {
  static_assert(1 > 0, "xunion must have at least one member");

  TheUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TheUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    TheUnion out;
    switch (selector % 1) {
      case 0: {
        out.set_v(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<MethodWithUnionUnionMethodRequest> {
  operator size_t() {
    return MinSize<::test::protocols::TheUnion>();
  }
};
template <>
struct Allocate<MethodWithUnionUnionMethodRequest> {
  MethodWithUnionUnionMethodRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<MethodWithUnionUnionMethodRequest>());
    MethodWithUnionUnionMethodRequest out;
    const size_t slack_per_member = (*size - MinSize<MethodWithUnionUnionMethodRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::protocols::TheUnion>() + slack_per_member;
    out.u = Allocate<::test::protocols::TheUnion>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<MethodWithUnionUnionMethodResponse> {
  operator size_t() {
    return MinSize<::std::unique_ptr<::test::protocols::TheUnion>>();
  }
};
template <>
struct Allocate<MethodWithUnionUnionMethodResponse> {
  MethodWithUnionUnionMethodResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<MethodWithUnionUnionMethodResponse>());
    MethodWithUnionUnionMethodResponse out;
    const size_t slack_per_member = (*size - MinSize<MethodWithUnionUnionMethodResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::unique_ptr<::test::protocols::TheUnion>>() + slack_per_member;
    out.u = Allocate<::std::unique_ptr<::test::protocols::TheUnion>>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing

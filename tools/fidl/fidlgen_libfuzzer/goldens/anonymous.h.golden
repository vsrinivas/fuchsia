// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test/anonymous/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using UnionMember = ::fidl::test::anonymous::UnionMember;
using TableData = ::fidl::test::anonymous::TableData;
using TableMember = ::fidl::test::anonymous::TableMember;
using SomeProtocol_SomeMethod_Error =
    ::fidl::test::anonymous::SomeProtocol_SomeMethod_Error;
using Op = ::fidl::test::anonymous::Op;
using OverrideTest = ::fidl::test::anonymous::OverrideTest;
using Flags = ::fidl::test::anonymous::Flags;
using FunctionApplication = ::fidl::test::anonymous::FunctionApplication;
using Expression = ::fidl::test::anonymous::Expression;
using BitsMember = ::fidl::test::anonymous::BitsMember;
using SomeProtocol_SomeMethod_Response =
    ::fidl::test::anonymous::SomeProtocol_SomeMethod_Response;
using SomeProtocol_SomeMethod_Result =
    ::fidl::test::anonymous::SomeProtocol_SomeMethod_Result;

template <>
struct MinSize<UnionMember> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint8_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<UnionMember> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnionMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnionMember>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnionMember out;
    switch (selector % 1) {
      case 0: {
        out.set_union_data(Allocate<uint8_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<TableData> {
  operator size_t() { return MinSize<uint8_t>(); }
};
template <>
struct Allocate<TableData> {
  TableData operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TableData>());
    TableData out;
    const size_t slack_per_member = (*size - MinSize<TableData>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.data = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TableMember> {
  operator size_t() {
    return MinSize<::std::vector<::fidl::test::anonymous::TableData>>();
  }
};
template <>
struct Allocate<TableMember> {
  TableMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TableMember>());
    TableMember out;
    const size_t slack_per_member = (*size - MinSize<TableMember>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::vector<::fidl::test::anonymous::TableData>>() +
               slack_per_member;
    out.set_table_data(
        Allocate<::std::vector<::fidl::test::anonymous::TableData>>{}(
            src, &out_size));
    return out;
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Error> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Error> {
  SomeProtocol_SomeMethod_Error operator()(FuzzInput* src, size_t* size) {
    SomeProtocol_SomeMethod_Error out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 2) {
      case 0:
        out = SomeProtocol_SomeMethod_Error::ERROR_ONE;
        break;
      case 1:
        out = SomeProtocol_SomeMethod_Error::ERROR_TWO;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<Op> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<Op> {
  Op operator()(FuzzInput* src, size_t* size) {
    Op out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 3) {
      case 0:
        out = Op::ADD;
        break;
      case 1:
        out = Op::MUL;
        break;
      case 2:
        out = Op::DIV;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<OverrideTest> {
  operator size_t() {
    return MinSize<::fidl::test::anonymous::Op>() +
           MinSize<::std::unique_ptr<::fidl::test::anonymous::Expression>>() +
           MinSize<::std::unique_ptr<::fidl::test::anonymous::Expression>>();
  }
};
template <>
struct Allocate<OverrideTest> {
  OverrideTest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OverrideTest>());
    OverrideTest out;
    const size_t slack_per_member = (*size - MinSize<OverrideTest>()) / 3;
    size_t out_size;
    out_size = MinSize<::fidl::test::anonymous::Op>() + slack_per_member;
    out.op = Allocate<::fidl::test::anonymous::Op>{}(src, &out_size);
    out_size =
        MinSize<::std::unique_ptr<::fidl::test::anonymous::Expression>>() +
        slack_per_member;
    out.left =
        Allocate<::std::unique_ptr<::fidl::test::anonymous::Expression>>{}(
            src, &out_size);
    out_size =
        MinSize<::std::unique_ptr<::fidl::test::anonymous::Expression>>() +
        slack_per_member;
    out.right =
        Allocate<::std::unique_ptr<::fidl::test::anonymous::Expression>>{}(
            src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Flags> {
  operator size_t() { return sizeof(uint16_t); }
};
template <>
struct Allocate<Flags> {
  Flags operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= sizeof(uint16_t));
    return Flags(
        *reinterpret_cast<const uint16_t*>(src->TakeBytes(sizeof(uint16_t))));
  }
};
template <>
struct MinSize<FunctionApplication> {
  operator size_t() {
    return MinSize<::std::string>() +
           MinSize<::std::vector<
               ::std::unique_ptr<::fidl::test::anonymous::Expression>>>() +
           MinSize<::fidl::test::anonymous::Flags>();
  }
};
template <>
struct Allocate<FunctionApplication> {
  FunctionApplication operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FunctionApplication>());
    FunctionApplication out;
    const size_t slack_per_member =
        (*size - MinSize<FunctionApplication>()) / 3;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.set_func(Allocate<::std::string>{}(src, &out_size));
    out_size = MinSize<::std::vector<
                   ::std::unique_ptr<::fidl::test::anonymous::Expression>>>() +
               slack_per_member;
    out.set_args(Allocate<::std::vector<
                     ::std::unique_ptr<::fidl::test::anonymous::Expression>>>{}(
        src, &out_size));
    out_size = MinSize<::fidl::test::anonymous::Flags>() + slack_per_member;
    out.set_flags(Allocate<::fidl::test::anonymous::Flags>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<Expression> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint64_t>(),
                      MinSize<::fidl::test::anonymous::OverrideTest>(),
                      MinSize<::fidl::test::anonymous::FunctionApplication>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<Expression> {
  static_assert(3 > 0, "xunion must have at least one member");

  Expression operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Expression>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    Expression out;
    switch (selector % 3) {
      case 0: {
        out.set_value(Allocate<uint64_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_bin_op(
            Allocate<::fidl::test::anonymous::OverrideTest>{}(src, size));
        break;
      }
      case 2: {
        out.set_function_application(
            Allocate<::fidl::test::anonymous::FunctionApplication>{}(src,
                                                                     size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<BitsMember> {
  operator size_t() { return sizeof(uint32_t); }
};
template <>
struct Allocate<BitsMember> {
  BitsMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= sizeof(uint32_t));
    return BitsMember(
        *reinterpret_cast<const uint32_t*>(src->TakeBytes(sizeof(uint32_t))));
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Response> {
  operator size_t() { return MinSize<::fidl::test::anonymous::BitsMember>(); }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Response> {
  SomeProtocol_SomeMethod_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocol_SomeMethod_Response>());
    SomeProtocol_SomeMethod_Response out;
    const size_t slack_per_member =
        (*size - MinSize<SomeProtocol_SomeMethod_Response>()) / 1;
    size_t out_size;
    out_size =
        MinSize<::fidl::test::anonymous::BitsMember>() + slack_per_member;
    out.bits_member =
        Allocate<::fidl::test::anonymous::BitsMember>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Result> {
  operator size_t() {
    size_t sizes[] = {
        0, MinSize<::fidl::test::anonymous::SomeProtocol_SomeMethod_Response>(),
        MinSize<::fidl::test::anonymous::SomeProtocol_SomeMethod_Error>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  SomeProtocol_SomeMethod_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocol_SomeMethod_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    SomeProtocol_SomeMethod_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<
                ::fidl::test::anonymous::SomeProtocol_SomeMethod_Response>{}(
                src, size));
        break;
      }
      case 1: {
        out.set_err(
            Allocate<::fidl::test::anonymous::SomeProtocol_SomeMethod_Error>{}(
                src, size));
        break;
      }
    }

    return out;
  }
};

}  // namespace fuzzing

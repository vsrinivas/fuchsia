

#![cfg(test)]
#![allow(unused_imports)]

use {
    assert_matches::assert_matches,
    fidl::{AsHandleRef, Error, Handle, HandleDisposition, HandleInfo, HandleOp, ObjectType, Rights, UnknownData},
    fidl::encoding::{Context, Decodable, Decoder, Encoder, WireFormatVersion},
    fidl_test_conformance as test_conformance,
    fuchsia_zircon_status::Status,
    gidl_util::{HandleDef, HandleSubtype, create_handles, copy_handle, copy_handles_at, disown_vec, get_info_handle_valid},
};

const _V1_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V1 };
const _V2_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V2 };


#[test]
fn test_golden_bool_struct_v1_encode() {
    let value = &mut test_conformance::GoldenBoolStruct { v: true };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_bool_struct_v2_encode() {
    let value = &mut test_conformance::GoldenBoolStruct { v: true };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_int_struct_v1_encode() {
    let value = &mut test_conformance::GoldenIntStruct { v: 1i16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_int_struct_v2_encode() {
    let value = &mut test_conformance::GoldenIntStruct { v: 1i16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_uint_struct_v1_encode() {
    let value = &mut test_conformance::GoldenUintStruct { v: 1u16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_uint_struct_v2_encode() {
    let value = &mut test_conformance::GoldenUintStruct { v: 1u16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_float_struct_v1_encode() {
    let value = &mut test_conformance::GoldenFloatStruct { v: 0f32 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_float_struct_v2_encode() {
    let value = &mut test_conformance::GoldenFloatStruct { v: 0f32 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_double_struct_v1_encode() {
    let value = &mut test_conformance::GoldenDoubleStruct { v: 0f64 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_double_struct_v2_encode() {
    let value = &mut test_conformance::GoldenDoubleStruct { v: 0f64 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_string_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStringStruct { v: String::from("abcd") };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_string_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStringStruct { v: String::from("abcd") };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_string_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_string_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_string_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_string_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_enum_struct_v1_encode() {
    let value = &mut test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_enum_struct_v2_encode() {
    let value = &mut test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_bits_struct_v1_encode() {
    let value = &mut test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_bits_struct_v2_encode() {
    let value = &mut test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_table_struct_v1_encode() {
    let value = &mut test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), unknown_data: None, ..test_conformance::GoldenTable::EMPTY } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_table_struct_v2_encode() {
    let value = &mut test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), unknown_data: None, ..test_conformance::GoldenTable::EMPTY } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_union_struct_v1_encode() {
    let value = &mut test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_union_struct_v2_encode() {
    let value = &mut test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_union_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_union_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_union_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_union_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_array_struct_v1_encode() {
    let value = &mut test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_array_struct_v2_encode() {
    let value = &mut test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_struct_array_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_struct_array_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_vector_struct_v1_encode() {
    let value = &mut test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_vector_struct_v2_encode() {
    let value = &mut test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_struct_vector_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_struct_vector_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_handle_basic_rights_struct_v1_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Channel,
	rights: Rights::from_bits(61454).unwrap(),
},
]);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let expected_handles = disown_vec(unsafe { copy_handles_at(handle_defs, &[
0,]) });
    let expected_handles = expected_handles.as_ref();
    let value = &mut test_conformance::GoldenHandleBasicRightsStruct { v: unsafe { copy_handle(&handle_defs[0]) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    let handles = handle_dispositions.drain(..).map(|h| match h.handle_op {
        HandleOp::Move(hdl) => hdl,
        _ => panic!("unknown handle op"),
    }).collect::<Vec<Handle>>();
    assert_eq!(&handles, expected_handles);
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_handle_basic_rights_struct_v2_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Channel,
	rights: Rights::from_bits(61454).unwrap(),
},
]);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let expected_handles = disown_vec(unsafe { copy_handles_at(handle_defs, &[
0,]) });
    let expected_handles = expected_handles.as_ref();
    let value = &mut test_conformance::GoldenHandleBasicRightsStruct { v: unsafe { copy_handle(&handle_defs[0]) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    let handles = handle_dispositions.drain(..).map(|h| match h.handle_op {
        HandleOp::Move(hdl) => hdl,
        _ => panic!("unknown handle op"),
    }).collect::<Vec<Handle>>();
    assert_eq!(&handles, expected_handles);
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_nullable_handle_struct_non_null_v1_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let expected_handles = disown_vec(unsafe { copy_handles_at(handle_defs, &[
0,]) });
    let expected_handles = expected_handles.as_ref();
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: Some(unsafe { copy_handle(&handle_defs[0]) }) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    let handles = handle_dispositions.drain(..).map(|h| match h.handle_op {
        HandleOp::Move(hdl) => hdl,
        _ => panic!("unknown handle op"),
    }).collect::<Vec<Handle>>();
    assert_eq!(&handles, expected_handles);
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_nullable_handle_struct_non_null_v2_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let expected_handles = disown_vec(unsafe { copy_handles_at(handle_defs, &[
0,]) });
    let expected_handles = expected_handles.as_ref();
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: Some(unsafe { copy_handle(&handle_defs[0]) }) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    let handles = handle_dispositions.drain(..).map(|h| match h.handle_op {
        HandleOp::Move(hdl) => hdl,
        _ => panic!("unknown handle op"),
    }).collect::<Vec<Handle>>();
    assert_eq!(&handles, expected_handles);
}

#[test]
fn test_golden_nullable_handle_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}

#[test]
fn test_golden_nullable_handle_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert!(handle_dispositions.is_empty());
}



#[test]
fn test_golden_bool_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenBoolStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBoolStruct { v: true });
}

#[test]
fn test_golden_bool_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenBoolStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBoolStruct { v: true });
}

#[test]
fn test_golden_int_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenIntStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenIntStruct { v: 1i16 });
}

#[test]
fn test_golden_int_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenIntStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenIntStruct { v: 1i16 });
}

#[test]
fn test_golden_uint_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenUintStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUintStruct { v: 1u16 });
}

#[test]
fn test_golden_uint_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenUintStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUintStruct { v: 1u16 });
}

#[test]
fn test_golden_float_struct_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenFloatStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenFloatStruct { v: 0f32 });
}

#[test]
fn test_golden_float_struct_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenFloatStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenFloatStruct { v: 0f32 });
}

#[test]
fn test_golden_double_struct_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenDoubleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenDoubleStruct { v: 0f64 });
}

#[test]
fn test_golden_double_struct_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenDoubleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenDoubleStruct { v: 0f64 });
}

#[test]
fn test_golden_string_struct_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStringStruct { v: String::from("abcd") });
}

#[test]
fn test_golden_string_struct_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStringStruct { v: String::from("abcd") });
}

#[test]
fn test_golden_nullable_string_struct_non_null_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) });
}

#[test]
fn test_golden_nullable_string_struct_non_null_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) });
}

#[test]
fn test_golden_nullable_string_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: None });
}

#[test]
fn test_golden_nullable_string_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: None });
}

#[test]
fn test_golden_enum_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenEnumStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() });
}

#[test]
fn test_golden_enum_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenEnumStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() });
}

#[test]
fn test_golden_bits_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenBitsStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } });
}

#[test]
fn test_golden_bits_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenBitsStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } });
}

#[test]
fn test_golden_table_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenTableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), unknown_data: None, ..test_conformance::GoldenTable::EMPTY } });
}

#[test]
fn test_golden_table_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenTableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), unknown_data: None, ..test_conformance::GoldenTable::EMPTY } });
}

#[test]
fn test_golden_union_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) });
}

#[test]
fn test_golden_union_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) });
}

#[test]
fn test_golden_nullable_union_struct_non_null_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) });
}

#[test]
fn test_golden_nullable_union_struct_non_null_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) });
}

#[test]
fn test_golden_nullable_union_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: None });
}

#[test]
fn test_golden_nullable_union_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: None });
}

#[test]
fn test_golden_byte_array_struct_v1_decode() {
    let bytes = &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenByteArrayStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_array_struct_v2_decode() {
    let bytes = &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenByteArrayStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_struct_array_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStructArrayStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_struct_array_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStructArrayStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_byte_vector_struct_v1_decode() {
    let bytes = &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_vector_struct_v2_decode() {
    let bytes = &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) });
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) });
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: None });
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: None });
}

#[test]
fn test_golden_struct_vector_struct_v1_decode() {
    let bytes = &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStructVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_struct_vector_struct_v2_decode() {
    let bytes = &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStructVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_nullable_struct_non_null_v1_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) });
}

#[test]
fn test_golden_nullable_struct_non_null_v2_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) });
}

#[test]
fn test_golden_nullable_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: None });
}

#[test]
fn test_golden_nullable_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: None });
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_nullable_handle_struct_non_null_v1_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
];
    let handle_definitions = &[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
];
    let handle_defs = create_handles(handle_definitions);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let mut handles = unsafe { copy_handles_at(handle_defs, &[
0,]) };
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    // Forget handles before dropping the expected value, to avoid double closing them.
    struct ForgetHandles(test_conformance::GoldenNullableHandleStruct);
    impl std::ops::Drop for ForgetHandles {
        #[allow(unused_parens)]
        fn drop(&mut self) {
            std::mem::forget(std::mem::replace((&mut self.0.v).as_mut().unwrap(), Handle::invalid().into()));
        }
    }
    let expected_value = ForgetHandles(test_conformance::GoldenNullableHandleStruct { v: Some(unsafe { copy_handle(&handle_defs[0]) }) });
    assert_eq!(value, &expected_value.0);
}
#[cfg(target_os = "fuchsia")]
#[test]
fn test_golden_nullable_handle_struct_non_null_v2_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
];
    let handle_definitions = &[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
];
    let handle_defs = create_handles(handle_definitions);
    let handle_defs = disown_vec(handle_defs);
    let handle_defs = handle_defs.as_ref();
    let mut handles = unsafe { copy_handles_at(handle_defs, &[
0,]) };
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    // Forget handles before dropping the expected value, to avoid double closing them.
    struct ForgetHandles(test_conformance::GoldenNullableHandleStruct);
    impl std::ops::Drop for ForgetHandles {
        #[allow(unused_parens)]
        fn drop(&mut self) {
            std::mem::forget(std::mem::replace((&mut self.0.v).as_mut().unwrap(), Handle::invalid().into()));
        }
    }
    let expected_value = ForgetHandles(test_conformance::GoldenNullableHandleStruct { v: Some(unsafe { copy_handle(&handle_defs[0]) }) });
    assert_eq!(value, &expected_value.0);
}

#[test]
fn test_golden_nullable_handle_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableHandleStruct { v: None });
}

#[test]
fn test_golden_nullable_handle_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_definitions: Vec<HandleDef> = Vec::new();
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).zip(handle_definitions.iter()).map(|(h, hd)| {
        HandleInfo {
            handle: h,
            object_type: match hd.subtype {
                HandleSubtype::Event => ObjectType::EVENT,
                HandleSubtype::Channel => ObjectType::CHANNEL,
            },
            rights: hd.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableHandleStruct { v: None });
}





#[test]
fn test_golden_string_struct_null_body_v1_decode_failure() {
    let bytes = &[
0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).map(|h: fidl::Handle| {
        let info = h.as_handle_ref().basic_info().unwrap();
        HandleInfo {
            handle: h,
            object_type: info.object_type,
            rights: info.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    match Decoder::decode_with_context(_V1_CONTEXT, bytes, &mut handle_infos, value) {
        Err(err) => assert_matches!(err, Error::UnexpectedNullRef { .. }),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}

#[test]
fn test_golden_string_struct_null_body_v2_decode_failure() {
    let bytes = &[
0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let mut handles = Vec::new();
    let mut handle_infos : Vec::<_> = handles.drain(..).map(|h: fidl::Handle| {
        let info = h.as_handle_ref().basic_info().unwrap();
        HandleInfo {
            handle: h,
            object_type: info.object_type,
            rights: info.rights,
        }
    }).collect();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    match Decoder::decode_with_context(_V2_CONTEXT, bytes, &mut handle_infos, value) {
        Err(err) => assert_matches!(err, Error::UnexpectedNullRef { .. }),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}


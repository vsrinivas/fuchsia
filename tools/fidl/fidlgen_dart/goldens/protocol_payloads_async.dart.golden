// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.12

library fidl_test_protocolpayloads_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_test_protocolpayloads_imported/fidl_async.dart'
    as lib$test_protocolpayloads_imported;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

enum MainProtocolOnAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnAnonWithErrorResultTag>
    _MainProtocolOnAnonWithErrorResultTag_map = {
  1: MainProtocolOnAnonWithErrorResultTag.response,
  2: MainProtocolOnAnonWithErrorResultTag.err,
};

class MainProtocolOnAnonWithErrorResult extends $fidl.Union {
  const MainProtocolOnAnonWithErrorResult.withResponse(
      MainProtocolOnAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnAnonWithErrorResultTag get $tag =>
      _MainProtocolOnAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolOnAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnImportWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnImportWithErrorResultTag>
    _MainProtocolOnImportWithErrorResultTag_map = {
  1: MainProtocolOnImportWithErrorResultTag.response,
  2: MainProtocolOnImportWithErrorResultTag.err,
};

class MainProtocolOnImportWithErrorResult extends $fidl.Union {
  const MainProtocolOnImportWithErrorResult.withResponse(
      lib$test_protocolpayloads_imported.ImportStructPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnImportWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnImportWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnImportWithErrorResultTag get $tag =>
      _MainProtocolOnImportWithErrorResultTag_map[_ordinal]!;

  lib$test_protocolpayloads_imported.ImportStructPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnImportWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnImportWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnImportWithErrorResult>
    kMainProtocol_OnImportWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocolpayloads_imported.kImportStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnImportWithErrorResult>
    kMainProtocol_OnImportWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocolpayloads_imported.kImportStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnLocalWithErrorResultTag>
    _MainProtocolOnLocalWithErrorResultTag_map = {
  1: MainProtocolOnLocalWithErrorResultTag.response,
  2: MainProtocolOnLocalWithErrorResultTag.err,
};

class MainProtocolOnLocalWithErrorResult extends $fidl.Union {
  const MainProtocolOnLocalWithErrorResult.withResponse(
      LocalStructPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnLocalWithErrorResultTag get $tag =>
      _MainProtocolOnLocalWithErrorResultTag_map[_ordinal]!;

  LocalStructPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnLocalWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayAnonWithErrorResultTag>
    _MainProtocolTwoWayAnonWithErrorResultTag_map = {
  1: MainProtocolTwoWayAnonWithErrorResultTag.response,
  2: MainProtocolTwoWayAnonWithErrorResultTag.err,
};

class MainProtocolTwoWayAnonWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayAnonWithErrorResult.withResponse(
      MainProtocolTwoWayAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonWithErrorResultTag get $tag =>
      _MainProtocolTwoWayAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolTwoWayAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolTwoWayAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayImportWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayImportWithErrorResultTag>
    _MainProtocolTwoWayImportWithErrorResultTag_map = {
  1: MainProtocolTwoWayImportWithErrorResultTag.response,
  2: MainProtocolTwoWayImportWithErrorResultTag.err,
};

class MainProtocolTwoWayImportWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayImportWithErrorResult.withResponse(
      lib$test_protocolpayloads_imported.ImportStructPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayImportWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayImportWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayImportWithErrorResultTag get $tag =>
      _MainProtocolTwoWayImportWithErrorResultTag_map[_ordinal]!;

  lib$test_protocolpayloads_imported.ImportStructPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayImportWithErrorResult _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayImportWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayImportWithErrorResult>
    kMainProtocol_TwoWayImportWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocolpayloads_imported.kImportStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayImportWithErrorResult>
    kMainProtocol_TwoWayImportWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocolpayloads_imported.kImportStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayLocalWithErrorResultTag>
    _MainProtocolTwoWayLocalWithErrorResultTag_map = {
  1: MainProtocolTwoWayLocalWithErrorResultTag.response,
  2: MainProtocolTwoWayLocalWithErrorResultTag.err,
};

class MainProtocolTwoWayLocalWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayLocalWithErrorResult.withResponse(
      LocalStructPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayLocalWithErrorResultTag get $tag =>
      _MainProtocolTwoWayLocalWithErrorResultTag_map[_ordinal]!;

  LocalStructPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayLocalWithErrorResult _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalStructPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

class LocalStructPayload extends $fidl.Struct {
  const LocalStructPayload({
    required this.a,
    required this.b,
  });
  LocalStructPayload.clone(
    LocalStructPayload $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  LocalStructPayload $cloneWith({
    int? a,
    int? b,
  }) {
    return LocalStructPayload(
      a: a ?? this.a,
      b: b ?? this.b,
    );
  }

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
    $fieldType1.encode($encoder, b, $offset + 4, $depth);
  }

  static LocalStructPayload _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return LocalStructPayload(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 4, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<LocalStructPayload> kLocalStructPayload_Type =
    $fidl.StructType<LocalStructPayload>(
        inlineSize: 8, structDecode: LocalStructPayload._structDecode);

class MainProtocolOnAnonWithErrorResponse extends $fidl.Struct {
  const MainProtocolOnAnonWithErrorResponse({
    required this.a,
    required this.b,
  });
  MainProtocolOnAnonWithErrorResponse.clone(
    MainProtocolOnAnonWithErrorResponse $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  MainProtocolOnAnonWithErrorResponse $cloneWith({
    int? a,
    int? b,
  }) {
    return MainProtocolOnAnonWithErrorResponse(
      a: a ?? this.a,
      b: b ?? this.b,
    );
  }

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
    $fieldType1.encode($encoder, b, $offset + 4, $depth);
  }

  static MainProtocolOnAnonWithErrorResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return MainProtocolOnAnonWithErrorResponse(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 4, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<MainProtocolOnAnonWithErrorResponse>
    kMainProtocol_OnAnonWithError_Response_Type =
    $fidl.StructType<MainProtocolOnAnonWithErrorResponse>(
        inlineSize: 8,
        structDecode: MainProtocolOnAnonWithErrorResponse._structDecode);

class MainProtocolTwoWayAnonWithErrorResponse extends $fidl.Struct {
  const MainProtocolTwoWayAnonWithErrorResponse({
    required this.a,
    required this.b,
  });
  MainProtocolTwoWayAnonWithErrorResponse.clone(
    MainProtocolTwoWayAnonWithErrorResponse $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  MainProtocolTwoWayAnonWithErrorResponse $cloneWith({
    int? a,
    int? b,
  }) {
    return MainProtocolTwoWayAnonWithErrorResponse(
      a: a ?? this.a,
      b: b ?? this.b,
    );
  }

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
    $fieldType1.encode($encoder, b, $offset + 4, $depth);
  }

  static MainProtocolTwoWayAnonWithErrorResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return MainProtocolTwoWayAnonWithErrorResponse(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 4, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<MainProtocolTwoWayAnonWithErrorResponse>
    kMainProtocol_TwoWayAnonWithError_Response_Type =
    $fidl.StructType<MainProtocolTwoWayAnonWithErrorResponse>(
        inlineSize: 8,
        structDecode: MainProtocolTwoWayAnonWithErrorResponse._structDecode);

// oneWayComposed: (int a)
const int _kMainProtocol_OneWayComposed_Ordinal = 0x241e4384443ccb10;
const $fidl.MethodType _kMainProtocol_OneWayComposed_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayComposed",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 0,
);
// twoWayComposed: (int a) -> (int a)
const int _kMainProtocol_TwoWayComposed_Ordinal = 0x2348a1331ca4cfb0;
const $fidl.MethodType _kMainProtocol_TwoWayComposed_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  name: r"MainProtocol.TwoWayComposed",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);
// twoWayComposedWithError: (int a) -> (int a)
const int _kMainProtocol_TwoWayComposedWithError_Ordinal = 0x6a9be48b574d1557;
const $fidl.MethodType _kMainProtocol_TwoWayComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocolpayloads_imported
                .ComposedProtocolTwoWayComposedWithErrorResult>(
        type: lib$test_protocolpayloads_imported
            .kComposedProtocol_TwoWayComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayComposedWithError",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 16,
);
// onComposed:  -> (int a)
const int _kMainProtocol_OnComposed_Ordinal = 0x19fbe2b2f6f9273a;
const $fidl.MethodType _kMainProtocol_OnComposed_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  name: r"MainProtocol.OnComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 4,
);
// onComposedWithError:  -> (int a)
const int _kMainProtocol_OnComposedWithError_Ordinal = 0x63774db677215e98;
const $fidl.MethodType _kMainProtocol_OnComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocolpayloads_imported
                .ComposedProtocolOnComposedWithErrorResult>(
        type: lib$test_protocolpayloads_imported
            .kComposedProtocol_OnComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayLocal: (int a, int b)
const int _kMainProtocol_OneWayLocal_Ordinal = 0x6b9feaf9305b0715;
const $fidl.MethodType _kMainProtocol_OneWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: [],
  name: r"MainProtocol.OneWayLocal",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 0,
);
// twoWayLocal: (int a, int b) -> (int a, int b)
const int _kMainProtocol_TwoWayLocal_Ordinal = 0x743776548de3af0f;
const $fidl.MethodType _kMainProtocol_TwoWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  name: r"MainProtocol.TwoWayLocal",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 8,
);
// twoWayLocalWithError: (int a, int b) -> (int a, int b)
const int _kMainProtocol_TwoWayLocalWithError_Ordinal = 0x2839c029915cb8fc;
const $fidl.MethodType _kMainProtocol_TwoWayLocalWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayLocalWithErrorResult>(
        type: kMainProtocol_TwoWayLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayLocalWithError",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 16,
);
// onLocal:  -> (int a, int b)
const int _kMainProtocol_OnLocal_Ordinal = 0x4745f7438cd80819;
const $fidl.MethodType _kMainProtocol_OnLocal_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  name: r"MainProtocol.OnLocal",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 8,
);
// onLocalWithError:  -> (int a, int b)
const int _kMainProtocol_OnLocalWithError_Ordinal = 0x4ecd4b3982e221af;
const $fidl.MethodType _kMainProtocol_OnLocalWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnLocalWithErrorResult>(
        type: kMainProtocol_OnLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnLocalWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayImport: (int a)
const int _kMainProtocol_OneWayImport_Ordinal = 0x2e6b091ae4cee40c;
const $fidl.MethodType _kMainProtocol_OneWayImport_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayImport",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 0,
);
// twoWayImport: (int a) -> (int a)
const int _kMainProtocol_TwoWayImport_Ordinal = 0x20f4a8f65ff69473;
const $fidl.MethodType _kMainProtocol_TwoWayImport_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  name: r"MainProtocol.TwoWayImport",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);
// twoWayImportWithError: (int a) -> (int a)
const int _kMainProtocol_TwoWayImportWithError_Ordinal = 0x3b7b706d42eb9bbd;
const $fidl.MethodType _kMainProtocol_TwoWayImportWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayImportWithErrorResult>(
        type: kMainProtocol_TwoWayImportWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayImportWithError",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 16,
);
// onImport:  -> (int a)
const int _kMainProtocol_OnImport_Ordinal = 0x1bb4f4c30b6f8909;
const $fidl.MethodType _kMainProtocol_OnImport_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 0),
  ],
  name: r"MainProtocol.OnImport",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 4,
);
// onImportWithError:  -> (int a)
const int _kMainProtocol_OnImportWithError_Ordinal = 0x6292b793d728f205;
const $fidl.MethodType _kMainProtocol_OnImportWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnImportWithErrorResult>(
        type: kMainProtocol_OnImportWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnImportWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayAnon: (int a, int b)
const int _kMainProtocol_OneWayAnon_Ordinal = 0xb43565c01ab54ac;
const $fidl.MethodType _kMainProtocol_OneWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: [],
  name: r"MainProtocol.OneWayAnon",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 0,
);
// twoWayAnon: (int a, int b) -> (int a, int b)
const int _kMainProtocol_TwoWayAnon_Ordinal = 0x8bdc969ff7dd759;
const $fidl.MethodType _kMainProtocol_TwoWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  name: r"MainProtocol.TwoWayAnon",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 8,
);
// twoWayAnonWithError: (int a, int b) -> (int a, int b)
const int _kMainProtocol_TwoWayAnonWithError_Ordinal = 0x5862bf8170c87a36;
const $fidl.MethodType _kMainProtocol_TwoWayAnonWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonWithErrorResult>(
        type: kMainProtocol_TwoWayAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonWithError",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 16,
);
// onAnon:  -> (int a, int b)
const int _kMainProtocol_OnAnon_Ordinal = 0x42d321dacc4df000;
const $fidl.MethodType _kMainProtocol_OnAnon_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
  ],
  name: r"MainProtocol.OnAnon",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 8,
);
// onAnonWithError:  -> (int a, int b)
const int _kMainProtocol_OnAnonWithError_Ordinal = 0x45bc24ef47b44a02;
const $fidl.MethodType _kMainProtocol_OnAnonWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnAnonWithErrorResult>(
        type: kMainProtocol_OnAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnonWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

class MainProtocol$TwoWayLocal$Response {
  final int a;
  final int b;
  MainProtocol$TwoWayLocal$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$TwoWayLocalWithError$Response {
  final int a;
  final int b;
  MainProtocol$TwoWayLocalWithError$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$OnLocal$Response {
  final int a;
  final int b;
  MainProtocol$OnLocal$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$OnLocalWithError$Response {
  final int a;
  final int b;
  MainProtocol$OnLocalWithError$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$TwoWayAnon$Response {
  final int a;
  final int b;
  MainProtocol$TwoWayAnon$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$TwoWayAnonWithError$Response {
  final int a;
  final int b;
  MainProtocol$TwoWayAnonWithError$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$OnAnon$Response {
  final int a;
  final int b;
  MainProtocol$OnAnon$Response(
    this.a,
    this.b,
  );
}

class MainProtocol$OnAnonWithError$Response {
  final int a;
  final int b;
  MainProtocol$OnAnonWithError$Response(
    this.a,
    this.b,
  );
}

abstract class MainProtocol {
  $fidl.ServiceData? get $serviceData => MainProtocolData();
  $async.Future<void> oneWayComposed(int a);
  $async.Future<int> twoWayComposed(int a);
  $async.Future<int> twoWayComposedWithError(int a);
  $async.Stream<int>? get onComposed;
  $async.Stream<int>? get onComposedWithError;
  $async.Future<void> oneWayLocal(int a, int b);
  $async.Future<MainProtocol$TwoWayLocal$Response> twoWayLocal(int a, int b);
  $async.Future<MainProtocol$TwoWayLocalWithError$Response>
      twoWayLocalWithError(int a, int b);
  $async.Stream<MainProtocol$OnLocal$Response>? get onLocal;
  $async.Stream<MainProtocol$OnLocalWithError$Response>? get onLocalWithError;
  $async.Future<void> oneWayImport(int a);
  $async.Future<int> twoWayImport(int a);
  $async.Future<int> twoWayImportWithError(int a);
  $async.Stream<int>? get onImport;
  $async.Stream<int>? get onImportWithError;
  $async.Future<void> oneWayAnon(int a, int b);
  $async.Future<MainProtocol$TwoWayAnon$Response> twoWayAnon(int a, int b);
  $async.Future<MainProtocol$TwoWayAnonWithError$Response> twoWayAnonWithError(
      int a, int b);
  $async.Stream<MainProtocol$OnAnon$Response>? get onAnon;
  $async.Stream<MainProtocol$OnAnonWithError$Response>? get onAnonWithError;
} // TODO: Remove ServiceData for non-service

class MainProtocolData implements $fidl.ServiceData<MainProtocol> {
  const MainProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return MainProtocolBinding();
  }
}

class MainProtocolProxy extends $fidl.AsyncProxy<MainProtocol>
    implements MainProtocol {
  MainProtocolProxy()
      : super($fidl.AsyncProxyController<MainProtocol>(
            $interfaceName: r'MainProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _onComposedEventStreamController.close();
      _onComposedWithErrorEventStreamController.close();
      _onLocalEventStreamController.close();
      _onLocalWithErrorEventStreamController.close();
      _onImportEventStreamController.close();
      _onImportWithErrorEventStreamController.close();
      _onAnonEventStreamController.close();
      _onAnonWithErrorEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kMainProtocol_OnComposed_Ordinal:
        final String _name = _kMainProtocol_OnComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onComposedEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onComposedEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnComposedWithError_Ordinal:
        final String _name = _kMainProtocol_OnComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocolpayloads_imported
                  .ComposedProtocolOnComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocolpayloads_imported
                  .ComposedProtocolOnComposedWithErrorResultTag.response) {
            _onComposedWithErrorEventStreamController
                .add($response.response!.a);
          } else {
            _onComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnLocal_Ordinal:
        final String _name = _kMainProtocol_OnLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onLocalEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocal_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocol$OnLocal$Response $response = $fidl
              .decodeMessageWithCallback<MainProtocol$OnLocal$Response>(
                  $message,
                  _kMainProtocol_OnLocal_Type.responseInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return MainProtocol$OnLocal$Response(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });

          _onLocalEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnLocalWithError_Ordinal:
        final String _name = _kMainProtocol_OnLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onLocalWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocalWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnLocalWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnLocalWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolOnLocalWithErrorResultTag.response) {
            _onLocalWithErrorEventStreamController
                .add(MainProtocol$OnLocalWithError$Response(
              $response.response!.a,
              $response.response!.b,
            ));
          } else {
            _onLocalWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnImport_Ordinal:
        final String _name = _kMainProtocol_OnImport_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onImportEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnImport_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnImport_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onImportEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnImportWithError_Ordinal:
        final String _name = _kMainProtocol_OnImportWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onImportWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnImportWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnImportWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnImportWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolOnImportWithErrorResultTag.response) {
            _onImportWithErrorEventStreamController.add($response.response!.a);
          } else {
            _onImportWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnAnon_Ordinal:
        final String _name = _kMainProtocol_OnAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnon_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocol$OnAnon$Response $response = $fidl
              .decodeMessageWithCallback<MainProtocol$OnAnon$Response>(
                  $message,
                  _kMainProtocol_OnAnon_Type.responseInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return MainProtocol$OnAnon$Response(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });

          _onAnonEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnAnonWithError_Ordinal:
        final String _name = _kMainProtocol_OnAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnAnonWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnAnonWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag == MainProtocolOnAnonWithErrorResultTag.response) {
            _onAnonWithErrorEventStreamController
                .add(MainProtocol$OnAnonWithError$Response(
              $response.response!.a,
              $response.response!.b,
            ));
          } else {
            _onAnonWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kMainProtocol_TwoWayComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayComposedWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocolpayloads_imported
                  .ComposedProtocolTwoWayComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocolpayloads_imported
                  .ComposedProtocolTwoWayComposedWithErrorResultTag.response) {
            $completer.complete($response.response!.a);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocol$TwoWayLocal$Response $response = $fidl
              .decodeMessageWithCallback<MainProtocol$TwoWayLocal$Response>(
                  $message,
                  _kMainProtocol_TwoWayLocal_Type.responseInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return MainProtocol$TwoWayLocal$Response(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayLocalWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayLocalWithErrorResultTag.response) {
            $completer.complete(MainProtocol$TwoWayLocalWithError$Response(
              $response.response!.a,
              $response.response!.b,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayImport_Ordinal:
        final String _name = _kMainProtocol_TwoWayImport_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImport_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayImport_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayImportWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayImportWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImportWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayImportWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayImportWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayImportWithErrorResultTag.response) {
            $completer.complete($response.response!.a);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocol$TwoWayAnon$Response $response = $fidl
              .decodeMessageWithCallback<MainProtocol$TwoWayAnon$Response>(
                  $message,
                  _kMainProtocol_TwoWayAnon_Type.responseInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return MainProtocol$TwoWayAnon$Response(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayAnonWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayAnonWithErrorResultTag.response) {
            $completer.complete(MainProtocol$TwoWayAnonWithError$Response(
              $response.response!.a,
              $response.response!.b,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> oneWayComposed(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayComposed_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_OneWayComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<int> twoWayComposed(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayComposed_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> twoWayComposedWithError(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayComposedWithError_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onComposedEventStreamController =
      $async.StreamController<int>.broadcast();
  @override
  $async.Stream<int> get onComposed => _onComposedEventStreamController.stream;

  final _onComposedWithErrorEventStreamController =
      $async.StreamController<int>.broadcast();
  @override
  $async.Stream<int> get onComposedWithError =>
      _onComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayLocal(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<MainProtocol$TwoWayLocal$Response> twoWayLocal(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<MainProtocol$TwoWayLocal$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<MainProtocol$TwoWayLocalWithError$Response>
      twoWayLocalWithError(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocalWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocalWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayLocalWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<MainProtocol$TwoWayLocalWithError$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onLocalEventStreamController =
      $async.StreamController<MainProtocol$OnLocal$Response>.broadcast();
  @override
  $async.Stream<MainProtocol$OnLocal$Response> get onLocal =>
      _onLocalEventStreamController.stream;

  final _onLocalWithErrorEventStreamController = $async
      .StreamController<MainProtocol$OnLocalWithError$Response>.broadcast();
  @override
  $async.Stream<MainProtocol$OnLocalWithError$Response> get onLocalWithError =>
      _onLocalWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayImport(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayImport_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayImport_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayImport_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<int> twoWayImport(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayImport_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayImport_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayImport_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> twoWayImportWithError(int a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayImportWithError_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayImportWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayImportWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onImportEventStreamController =
      $async.StreamController<int>.broadcast();
  @override
  $async.Stream<int> get onImport => _onImportEventStreamController.stream;

  final _onImportWithErrorEventStreamController =
      $async.StreamController<int>.broadcast();
  @override
  $async.Stream<int> get onImportWithError =>
      _onImportWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayAnon(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<MainProtocol$TwoWayAnon$Response> twoWayAnon(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<MainProtocol$TwoWayAnon$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<MainProtocol$TwoWayAnonWithError$Response> twoWayAnonWithError(
      int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnonWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<MainProtocol$TwoWayAnonWithError$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonEventStreamController =
      $async.StreamController<MainProtocol$OnAnon$Response>.broadcast();
  @override
  $async.Stream<MainProtocol$OnAnon$Response> get onAnon =>
      _onAnonEventStreamController.stream;

  final _onAnonWithErrorEventStreamController = $async
      .StreamController<MainProtocol$OnAnonWithError$Response>.broadcast();
  @override
  $async.Stream<MainProtocol$OnAnonWithError$Response> get onAnonWithError =>
      _onAnonWithErrorEventStreamController.stream;
}

class MainProtocolBinding extends $fidl.AsyncBinding<MainProtocol> {
  MainProtocolBinding() : super(r"MainProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _onComposed_stream = impl.onComposed;
        if (_onComposed_stream != null) {
          $subscriptions.add(_onComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnComposed_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnComposed_Type.name, _e, close);
          }));
        }
        final _onComposedWithError_stream = impl.onComposedWithError;
        if (_onComposedWithError_stream != null) {
          $subscriptions.add(_onComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (int $responseValue,
                      $async.EventSink<
                              lib$test_protocolpayloads_imported
                                  .ComposedProtocolOnComposedWithErrorResult>
                          $sink) {
            $sink.add(lib$test_protocolpayloads_imported
                    .ComposedProtocolOnComposedWithErrorResult
                .withResponse(
                    lib$test_protocolpayloads_imported.ImportStructPayload(
                        a: $responseValue)));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          lib$test_protocolpayloads_imported
                              .ComposedProtocolOnComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(lib$test_protocolpayloads_imported
                      .ComposedProtocolOnComposedWithErrorResult
                  .withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnComposedWithError_Type.name, _e, close);
          }));
        }
        final _onLocal_stream = impl.onLocal;
        if (_onLocal_stream != null) {
          $subscriptions.add(_onLocal_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocal_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocal_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kMainProtocol_OnLocal_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0]
                  .encode($encoder, $response.a, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.b, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnLocal_Type.name, _e, close);
          }));
        }
        final _onLocalWithError_stream = impl.onLocalWithError;
        if (_onLocalWithError_stream != null) {
          $subscriptions.add(_onLocalWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (MainProtocol$OnLocalWithError$Response $responseValue,
                      $async.EventSink<MainProtocolOnLocalWithErrorResult>
                          $sink) {
            $sink.add(MainProtocolOnLocalWithErrorResult.withResponse(
                LocalStructPayload(
              a: $responseValue.a,
              b: $responseValue.b,
            )));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnLocalWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(
                  MainProtocolOnLocalWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocalWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnLocalWithError_Type.name, _e, close);
          }));
        }
        final _onImport_stream = impl.onImport;
        if (_onImport_stream != null) {
          $subscriptions.add(_onImport_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnImport_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnImport_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnImport_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnImport_Type.name, _e, close);
          }));
        }
        final _onImportWithError_stream = impl.onImportWithError;
        if (_onImportWithError_stream != null) {
          $subscriptions.add(_onImportWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData: (int
                      $responseValue,
                  $async.EventSink<MainProtocolOnImportWithErrorResult> $sink) {
            $sink.add(MainProtocolOnImportWithErrorResult.withResponse(
                lib$test_protocolpayloads_imported.ImportStructPayload(
                    a: $responseValue)));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnImportWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(
                  MainProtocolOnImportWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnImportWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnImportWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnImportWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnImportWithError_Type.name, _e, close);
          }));
        }
        final _onAnon_stream = impl.onAnon;
        if (_onAnon_stream != null) {
          $subscriptions.add(_onAnon_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnAnon_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnon_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kMainProtocol_OnAnon_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0]
                  .encode($encoder, $response.a, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.b, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnAnon_Type.name, _e, close);
          }));
        }
        final _onAnonWithError_stream = impl.onAnonWithError;
        if (_onAnonWithError_stream != null) {
          $subscriptions.add(_onAnonWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (MainProtocol$OnAnonWithError$Response $responseValue,
                      $async.EventSink<MainProtocolOnAnonWithErrorResult>
                          $sink) {
            $sink.add(MainProtocolOnAnonWithErrorResult.withResponse(
                MainProtocolOnAnonWithErrorResponse(
              a: $responseValue.a,
              b: $responseValue.b,
            )));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnAnonWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink
                  .add(MainProtocolOnAnonWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnAnonWithError_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonWithError_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kMainProtocol_OneWayComposed_Ordinal:
        final String _name = _kMainProtocol_OneWayComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kMainProtocol_TwoWayComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayComposed_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayComposedWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kMainProtocol_TwoWayComposedWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayComposedWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return lib$test_protocolpayloads_imported
                    .ComposedProtocolTwoWayComposedWithErrorResult
                .withResponse(
                    lib$test_protocolpayloads_imported.ImportStructPayload(
                        a: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return lib$test_protocolpayloads_imported
                      .ComposedProtocolTwoWayComposedWithErrorResult
                  .withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayLocal_Ordinal:
        final String _name = _kMainProtocol_OneWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayLocal_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayLocal(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocol$TwoWayLocal$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<MainProtocol$TwoWayLocal$Response>>(
                  $message,
                  _kMainProtocol_TwoWayLocal_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayLocal(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocal_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocal_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kMainProtocol_TwoWayLocal_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0]
                  .encode($encoder, $response.a, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.b, $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocol$TwoWayLocalWithError$Response>
              $future = $fidl.decodeMessageWithCallback<
                      $async
                          .Future<MainProtocol$TwoWayLocalWithError$Response>>(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayLocalWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayLocalWithErrorResult.withResponse(
                LocalStructPayload(
              a: $responseValue.a,
              b: $responseValue.b,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayLocalWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayLocalWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayImport_Ordinal:
        final String _name = _kMainProtocol_OneWayImport_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayImport_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayImport_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayImport(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayImport_Ordinal:
        final String _name = _kMainProtocol_TwoWayImport_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImport_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kMainProtocol_TwoWayImport_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayImport(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayImport_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayImport_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayImport_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayImportWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayImportWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImportWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kMainProtocol_TwoWayImportWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayImportWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayImportWithErrorResult.withResponse(
                lib$test_protocolpayloads_imported.ImportStructPayload(
                    a: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayImportWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayImportWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayImportWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayImportWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayAnon_Ordinal:
        final String _name = _kMainProtocol_OneWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayAnon_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayAnon(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocol$TwoWayAnon$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<MainProtocol$TwoWayAnon$Response>>(
                  $message,
                  _kMainProtocol_TwoWayAnon_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayAnon(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnon_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnon_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kMainProtocol_TwoWayAnon_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0]
                  .encode($encoder, $response.a, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.b, $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocol$TwoWayAnonWithError$Response>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<MainProtocol$TwoWayAnonWithError$Response>>(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayAnonWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayAnonWithErrorResult.withResponse(
                MainProtocolTwoWayAnonWithErrorResponse(
              a: $responseValue.a,
              b: $responseValue.b,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayAnonWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for MainProtocolBinding');
    }
  }
}

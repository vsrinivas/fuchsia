// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.12

library fidl_test_protocollayouts_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_test_protocollayouts_imported/fidl_async.dart'
    as lib$test_protocollayouts_imported;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

enum LocalUnionPayloadTag {
  $unknown,
  b, // 0x1
}

const Map<int, LocalUnionPayloadTag> _LocalUnionPayloadTag_map = {
  1: LocalUnionPayloadTag.b,
};

class LocalUnionPayload extends $fidl.Union {
  const LocalUnionPayload.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const LocalUnionPayload.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  LocalUnionPayload._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  LocalUnionPayloadTag get $tag =>
      _LocalUnionPayloadTag_map[_ordinal] ?? LocalUnionPayloadTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static LocalUnionPayload _ctor(int ordinal, Object data) {
    return LocalUnionPayload._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<LocalUnionPayload> kLocalUnionPayload_Type =
    $fidl.UnionType<LocalUnionPayload>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: LocalUnionPayload._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<LocalUnionPayload> kLocalUnionPayload_OptType =
    $fidl.NullableUnionType<LocalUnionPayload>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: LocalUnionPayload._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolOnAnonRequestTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolOnAnonRequestTag> _MainProtocolOnAnonRequestTag_map =
    {
  1: MainProtocolOnAnonRequestTag.b,
};

class MainProtocolOnAnonRequest extends $fidl.Union {
  const MainProtocolOnAnonRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolOnAnonRequest.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolOnAnonRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnAnonRequestTag get $tag =>
      _MainProtocolOnAnonRequestTag_map[_ordinal] ??
      MainProtocolOnAnonRequestTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnAnonRequest _ctor(int ordinal, Object data) {
    return MainProtocolOnAnonRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnAnonRequest>
    kMainProtocolOnAnonRequest_Type =
    $fidl.UnionType<MainProtocolOnAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolOnAnonRequest._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnAnonRequest>
    kMainProtocolOnAnonRequest_OptType =
    $fidl.NullableUnionType<MainProtocolOnAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolOnAnonRequest._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolTwoWayAnonRequestTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolTwoWayAnonRequestTag>
    _MainProtocolTwoWayAnonRequestTag_map = {
  1: MainProtocolTwoWayAnonRequestTag.b,
};

class MainProtocolTwoWayAnonRequest extends $fidl.Union {
  const MainProtocolTwoWayAnonRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolTwoWayAnonRequest.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolTwoWayAnonRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonRequestTag get $tag =>
      _MainProtocolTwoWayAnonRequestTag_map[_ordinal] ??
      MainProtocolTwoWayAnonRequestTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonRequest _ctor(int ordinal, Object data) {
    return MainProtocolTwoWayAnonRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonRequest>
    kMainProtocolTwoWayAnonRequest_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonRequest._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonRequest>
    kMainProtocolTwoWayAnonRequest_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonRequest._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolOnAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnAnonWithErrorResultTag>
    _MainProtocolOnAnonWithErrorResultTag_map = {
  1: MainProtocolOnAnonWithErrorResultTag.response,
  2: MainProtocolOnAnonWithErrorResultTag.err,
};

class MainProtocolOnAnonWithErrorResult extends $fidl.Union {
  const MainProtocolOnAnonWithErrorResult.withResponse(
      MainProtocolOnAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnAnonWithErrorResultTag get $tag =>
      _MainProtocolOnAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolOnAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnImportWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnImportWithErrorResultTag>
    _MainProtocolOnImportWithErrorResultTag_map = {
  1: MainProtocolOnImportWithErrorResultTag.response,
  2: MainProtocolOnImportWithErrorResultTag.err,
};

class MainProtocolOnImportWithErrorResult extends $fidl.Union {
  const MainProtocolOnImportWithErrorResult.withResponse(
      lib$test_protocollayouts_imported.ImportTablePayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnImportWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnImportWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnImportWithErrorResultTag get $tag =>
      _MainProtocolOnImportWithErrorResultTag_map[_ordinal]!;

  lib$test_protocollayouts_imported.ImportTablePayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnImportWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnImportWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnImportWithErrorResult>
    kMainProtocol_OnImportWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocollayouts_imported.kImportTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnImportWithErrorResult>
    kMainProtocol_OnImportWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocollayouts_imported.kImportTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnLocalWithErrorResultTag>
    _MainProtocolOnLocalWithErrorResultTag_map = {
  1: MainProtocolOnLocalWithErrorResultTag.response,
  2: MainProtocolOnLocalWithErrorResultTag.err,
};

class MainProtocolOnLocalWithErrorResult extends $fidl.Union {
  const MainProtocolOnLocalWithErrorResult.withResponse(LocalTablePayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnLocalWithErrorResultTag get $tag =>
      _MainProtocolOnLocalWithErrorResultTag_map[_ordinal]!;

  LocalTablePayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnLocalWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayAnonWithErrorResponseTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolTwoWayAnonWithErrorResponseTag>
    _MainProtocolTwoWayAnonWithErrorResponseTag_map = {
  1: MainProtocolTwoWayAnonWithErrorResponseTag.b,
};

class MainProtocolTwoWayAnonWithErrorResponse extends $fidl.Union {
  const MainProtocolTwoWayAnonWithErrorResponse.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolTwoWayAnonWithErrorResponse.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolTwoWayAnonWithErrorResponse._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonWithErrorResponseTag get $tag =>
      _MainProtocolTwoWayAnonWithErrorResponseTag_map[_ordinal] ??
      MainProtocolTwoWayAnonWithErrorResponseTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonWithErrorResponse _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayAnonWithErrorResponse._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResponse>
    kMainProtocol_TwoWayAnonWithError_Response_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResponse._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResponse>
    kMainProtocol_TwoWayAnonWithError_Response_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResponse._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolTwoWayAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayAnonWithErrorResultTag>
    _MainProtocolTwoWayAnonWithErrorResultTag_map = {
  1: MainProtocolTwoWayAnonWithErrorResultTag.response,
  2: MainProtocolTwoWayAnonWithErrorResultTag.err,
};

class MainProtocolTwoWayAnonWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayAnonWithErrorResult.withResponse(
      MainProtocolTwoWayAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonWithErrorResultTag get $tag =>
      _MainProtocolTwoWayAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolTwoWayAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolTwoWayAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayImportWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayImportWithErrorResultTag>
    _MainProtocolTwoWayImportWithErrorResultTag_map = {
  1: MainProtocolTwoWayImportWithErrorResultTag.response,
  2: MainProtocolTwoWayImportWithErrorResultTag.err,
};

class MainProtocolTwoWayImportWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayImportWithErrorResult.withResponse(
      lib$test_protocollayouts_imported.ImportUnionPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayImportWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayImportWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayImportWithErrorResultTag get $tag =>
      _MainProtocolTwoWayImportWithErrorResultTag_map[_ordinal]!;

  lib$test_protocollayouts_imported.ImportUnionPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayImportWithErrorResult _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayImportWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayImportWithErrorResult>
    kMainProtocol_TwoWayImportWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayImportWithErrorResult>
    kMainProtocol_TwoWayImportWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayImportWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayImportWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayLocalWithErrorResultTag>
    _MainProtocolTwoWayLocalWithErrorResultTag_map = {
  1: MainProtocolTwoWayLocalWithErrorResultTag.response,
  2: MainProtocolTwoWayLocalWithErrorResultTag.err,
};

class MainProtocolTwoWayLocalWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayLocalWithErrorResult.withResponse(
      LocalUnionPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayLocalWithErrorResultTag get $tag =>
      _MainProtocolTwoWayLocalWithErrorResultTag_map[_ordinal]!;

  LocalUnionPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayLocalWithErrorResult _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kLocalUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

class LocalTablePayload extends $fidl.Table {
  const LocalTablePayload({
    this.$unknownData,
    this.a,
  });

  LocalTablePayload._(Map<int, dynamic> argv, this.$unknownData) : a = argv[1];

  LocalTablePayload $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return LocalTablePayload(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static LocalTablePayload _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      LocalTablePayload._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<LocalTablePayload> kLocalTablePayload_Type =
    $fidl.TableType<LocalTablePayload>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: LocalTablePayload._ctor,
  resource: false,
);

class MainProtocolOneWayAnonRequest extends $fidl.Table {
  const MainProtocolOneWayAnonRequest({
    this.$unknownData,
    this.a,
  });

  MainProtocolOneWayAnonRequest._(Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolOneWayAnonRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolOneWayAnonRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolOneWayAnonRequest _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolOneWayAnonRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolOneWayAnonRequest>
    kMainProtocolOneWayAnonRequest_Type =
    $fidl.TableType<MainProtocolOneWayAnonRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolOneWayAnonRequest._ctor,
  resource: false,
);

class MainProtocolTwoWayAnonResponse extends $fidl.Table {
  const MainProtocolTwoWayAnonResponse({
    this.$unknownData,
    this.a,
  });

  MainProtocolTwoWayAnonResponse._(Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolTwoWayAnonResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolTwoWayAnonResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolTwoWayAnonResponse _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolTwoWayAnonResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolTwoWayAnonResponse>
    kMainProtocolTwoWayAnonResponse_Type =
    $fidl.TableType<MainProtocolTwoWayAnonResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolTwoWayAnonResponse._ctor,
  resource: false,
);

class MainProtocolTwoWayAnonWithErrorRequest extends $fidl.Table {
  const MainProtocolTwoWayAnonWithErrorRequest({
    this.$unknownData,
    this.a,
  });

  MainProtocolTwoWayAnonWithErrorRequest._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolTwoWayAnonWithErrorRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolTwoWayAnonWithErrorRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolTwoWayAnonWithErrorRequest _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolTwoWayAnonWithErrorRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolTwoWayAnonWithErrorRequest>
    kMainProtocolTwoWayAnonWithErrorRequest_Type =
    $fidl.TableType<MainProtocolTwoWayAnonWithErrorRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolTwoWayAnonWithErrorRequest._ctor,
  resource: false,
);

class MainProtocolOnAnonWithErrorResponse extends $fidl.Table {
  const MainProtocolOnAnonWithErrorResponse({
    this.$unknownData,
    this.a,
  });

  MainProtocolOnAnonWithErrorResponse._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolOnAnonWithErrorResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolOnAnonWithErrorResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolOnAnonWithErrorResponse _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolOnAnonWithErrorResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolOnAnonWithErrorResponse>
    kMainProtocol_OnAnonWithError_Response_Type =
    $fidl.TableType<MainProtocolOnAnonWithErrorResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolOnAnonWithErrorResponse._ctor,
  resource: false,
);

// oneWayAnonComposed: (lib$test_protocollayouts_imported.ComposedProtocolOneWayAnonComposedRequest payload)
const int _kMainProtocol_OneWayAnonComposed_Ordinal = 0x67da05e1ae3f5e1;
const $fidl.MethodType _kMainProtocol_OneWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolOneWayAnonComposedRequest>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocolOneWayAnonComposedRequest_Type,
        offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayAnonComposed: (lib$test_protocollayouts_imported.ComposedProtocolTwoWayAnonComposedRequest payload) -> (lib$test_protocollayouts_imported.ComposedProtocolTwoWayAnonComposedResponse payload)
const int _kMainProtocol_TwoWayAnonComposed_Ordinal = 0x16afa17ea70d3370;
const $fidl.MethodType _kMainProtocol_TwoWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolTwoWayAnonComposedRequest>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocolTwoWayAnonComposedRequest_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolTwoWayAnonComposedResponse>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocolTwoWayAnonComposedResponse_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayAnonComposedWithError: (lib$test_protocollayouts_imported.ComposedProtocolTwoWayAnonComposedWithErrorRequest payload) -> (lib$test_protocollayouts_imported.ComposedProtocolTwoWayAnonComposedWithErrorResponse payload)
const int _kMainProtocol_TwoWayAnonComposedWithError_Ordinal =
    0x2ed33746b7bb119d;
const $fidl.MethodType _kMainProtocol_TwoWayAnonComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolTwoWayAnonComposedWithErrorRequest>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocolTwoWayAnonComposedWithErrorRequest_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolTwoWayAnonComposedWithErrorResult>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocol_TwoWayAnonComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onAnonComposed:  -> (lib$test_protocollayouts_imported.ComposedProtocolOnAnonComposedRequest payload)
const int _kMainProtocol_OnAnonComposed_Ordinal = 0x7fa8a0bf08128a0b;
const $fidl.MethodType _kMainProtocol_OnAnonComposed_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolOnAnonComposedRequest>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocolOnAnonComposedRequest_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnAnonComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onAnonComposedWithError:  -> (lib$test_protocollayouts_imported.ComposedProtocolOnAnonComposedWithErrorResponse payload)
const int _kMainProtocol_OnAnonComposedWithError_Ordinal = 0x9e24af9a2790a3b;
const $fidl.MethodType _kMainProtocol_OnAnonComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolOnAnonComposedWithErrorResult>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocol_OnAnonComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnAnonComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayNamedComposed: (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_OneWayNamedComposed_Ordinal = 0x5d78ce13958eee58;
const $fidl.MethodType _kMainProtocol_OneWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayNamedComposed: (lib$test_protocollayouts_imported.ImportUnionPayload payload) -> (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_TwoWayNamedComposed_Ordinal = 0xf67f27cae663810;
const $fidl.MethodType _kMainProtocol_TwoWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportUnionPayload>(
        type: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayNamedComposedWithError: (lib$test_protocollayouts_imported.ImportTablePayload payload) -> (lib$test_protocollayouts_imported.ImportUnionPayload payload)
const int _kMainProtocol_TwoWayNamedComposedWithError_Ordinal =
    0x30dac4182813ef7f;
const $fidl.MethodType _kMainProtocol_TwoWayNamedComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolTwoWayNamedComposedWithErrorResult>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocol_TwoWayNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayNamedComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onNamedComposed:  -> (lib$test_protocollayouts_imported.ImportUnionPayload payload)
const int _kMainProtocol_OnNamedComposed_Ordinal = 0x5e68f92a5b28cdea;
const $fidl.MethodType _kMainProtocol_OnNamedComposed_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportUnionPayload>(
        type: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnNamedComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onNamedComposedWithError:  -> (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_OnNamedComposedWithError_Ordinal = 0x67eb74dad2a05c0b;
const $fidl.MethodType _kMainProtocol_OnNamedComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<
            lib$test_protocollayouts_imported
                .ComposedProtocolOnNamedComposedWithErrorResult>(
        type: lib$test_protocollayouts_imported
            .kComposedProtocol_OnNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnNamedComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayImport: (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_OneWayImport_Ordinal = 0x530db65f2691d3b;
const $fidl.MethodType _kMainProtocol_OneWayImport_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayImport",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayImport: (lib$test_protocollayouts_imported.ImportUnionPayload payload) -> (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_TwoWayImport_Ordinal = 0x2bf680c8f0d40604;
const $fidl.MethodType _kMainProtocol_TwoWayImport_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportUnionPayload>(
        type: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayImport",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayImportWithError: (lib$test_protocollayouts_imported.ImportTablePayload payload) -> (lib$test_protocollayouts_imported.ImportUnionPayload payload)
const int _kMainProtocol_TwoWayImportWithError_Ordinal = 0x432093586084ff0a;
const $fidl.MethodType _kMainProtocol_TwoWayImportWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportTablePayload>(
        type: lib$test_protocollayouts_imported.kImportTablePayload_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayImportWithErrorResult>(
        type: kMainProtocol_TwoWayImportWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayImportWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onImport:  -> (lib$test_protocollayouts_imported.ImportUnionPayload payload)
const int _kMainProtocol_OnImport_Ordinal = 0x5b61e3156b09acd0;
const $fidl.MethodType _kMainProtocol_OnImport_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<lib$test_protocollayouts_imported.ImportUnionPayload>(
        type: lib$test_protocollayouts_imported.kImportUnionPayload_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnImport",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onImportWithError:  -> (lib$test_protocollayouts_imported.ImportTablePayload payload)
const int _kMainProtocol_OnImportWithError_Ordinal = 0xf988d72f8ee4fd7;
const $fidl.MethodType _kMainProtocol_OnImportWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnImportWithErrorResult>(
        type: kMainProtocol_OnImportWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnImportWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayLocal: (LocalTablePayload payload)
const int _kMainProtocol_OneWayLocal_Ordinal = 0x54759b55efd60f43;
const $fidl.MethodType _kMainProtocol_OneWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<LocalTablePayload>(
        type: kLocalTablePayload_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayLocal",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayLocal: (LocalUnionPayload payload) -> (LocalTablePayload payload)
const int _kMainProtocol_TwoWayLocal_Ordinal = 0x6bbeeb18f39c539b;
const $fidl.MethodType _kMainProtocol_TwoWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<LocalUnionPayload>(
        type: kLocalUnionPayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<LocalTablePayload>(
        type: kLocalTablePayload_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayLocal",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayLocalWithError: (LocalTablePayload payload) -> (LocalUnionPayload payload)
const int _kMainProtocol_TwoWayLocalWithError_Ordinal = 0x4dd8e7287c4c9b57;
const $fidl.MethodType _kMainProtocol_TwoWayLocalWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<LocalTablePayload>(
        type: kLocalTablePayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayLocalWithErrorResult>(
        type: kMainProtocol_TwoWayLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayLocalWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onLocal:  -> (LocalUnionPayload payload)
const int _kMainProtocol_OnLocal_Ordinal = 0x3a46c48153f0437c;
const $fidl.MethodType _kMainProtocol_OnLocal_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<LocalUnionPayload>(
        type: kLocalUnionPayload_Type, offset: 0),
  ],
  name: r"MainProtocol.OnLocal",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onLocalWithError:  -> (LocalTablePayload payload)
const int _kMainProtocol_OnLocalWithError_Ordinal = 0x79ac5bbdc7114e24;
const $fidl.MethodType _kMainProtocol_OnLocalWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnLocalWithErrorResult>(
        type: kMainProtocol_OnLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnLocalWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayAnon: (MainProtocolOneWayAnonRequest payload)
const int _kMainProtocol_OneWayAnon_Ordinal = 0x3a552f30c77c76ec;
const $fidl.MethodType _kMainProtocol_OneWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOneWayAnonRequest>(
        type: kMainProtocolOneWayAnonRequest_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayAnon",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayAnon: (MainProtocolTwoWayAnonRequest payload) -> (MainProtocolTwoWayAnonResponse payload)
const int _kMainProtocol_TwoWayAnon_Ordinal = 0x672eb5e71efdabcf;
const $fidl.MethodType _kMainProtocol_TwoWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonRequest>(
        type: kMainProtocolTwoWayAnonRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonResponse>(
        type: kMainProtocolTwoWayAnonResponse_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnon",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayAnonWithError: (MainProtocolTwoWayAnonWithErrorRequest payload) -> (MainProtocolTwoWayAnonWithErrorResponse payload)
const int _kMainProtocol_TwoWayAnonWithError_Ordinal = 0x6bd5fcf6f7b46df1;
const $fidl.MethodType _kMainProtocol_TwoWayAnonWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonWithErrorRequest>(
        type: kMainProtocolTwoWayAnonWithErrorRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonWithErrorResult>(
        type: kMainProtocol_TwoWayAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onAnon:  -> (MainProtocolOnAnonRequest payload)
const int _kMainProtocol_OnAnon_Ordinal = 0x64f7b1ec1ba0810b;
const $fidl.MethodType _kMainProtocol_OnAnon_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnAnonRequest>(
        type: kMainProtocolOnAnonRequest_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnon",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onAnonWithError:  -> (MainProtocolOnAnonWithErrorResponse payload)
const int _kMainProtocol_OnAnonWithError_Ordinal = 0x32f63a6e25a83699;
const $fidl.MethodType _kMainProtocol_OnAnonWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnAnonWithErrorResult>(
        type: kMainProtocol_OnAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnonWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

abstract class MainProtocol {
  $fidl.ServiceData? get $serviceData => MainProtocolData();
  $async.Future<void> oneWayAnonComposed(
      lib$test_protocollayouts_imported
              .ComposedProtocolOneWayAnonComposedRequest
          payload);
  $async.Future<
      lib$test_protocollayouts_imported
          .ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      lib$test_protocollayouts_imported
              .ComposedProtocolTwoWayAnonComposedRequest
          payload);
  $async.Future<
          lib$test_protocollayouts_imported
              .ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayAnonComposedWithErrorRequest
              payload);
  $async.Stream<
      lib$test_protocollayouts_imported
          .ComposedProtocolOnAnonComposedRequest>? get onAnonComposed;
  $async.Stream<
          lib$test_protocollayouts_imported
              .ComposedProtocolOnAnonComposedWithErrorResponse>?
      get onAnonComposedWithError;
  $async.Future<void> oneWayNamedComposed(
      lib$test_protocollayouts_imported.ImportTablePayload payload);
  $async.Future<lib$test_protocollayouts_imported.ImportTablePayload>
      twoWayNamedComposed(
          lib$test_protocollayouts_imported.ImportUnionPayload payload);
  $async.Future<lib$test_protocollayouts_imported.ImportUnionPayload>
      twoWayNamedComposedWithError(
          lib$test_protocollayouts_imported.ImportTablePayload payload);
  $async.Stream<lib$test_protocollayouts_imported.ImportUnionPayload>?
      get onNamedComposed;
  $async.Stream<lib$test_protocollayouts_imported.ImportTablePayload>?
      get onNamedComposedWithError;
  $async.Future<void> oneWayImport(
      lib$test_protocollayouts_imported.ImportTablePayload payload);
  $async.Future<lib$test_protocollayouts_imported.ImportTablePayload>
      twoWayImport(
          lib$test_protocollayouts_imported.ImportUnionPayload payload);
  $async.Future<lib$test_protocollayouts_imported.ImportUnionPayload>
      twoWayImportWithError(
          lib$test_protocollayouts_imported.ImportTablePayload payload);
  $async.Stream<lib$test_protocollayouts_imported.ImportUnionPayload>?
      get onImport;
  $async.Stream<lib$test_protocollayouts_imported.ImportTablePayload>?
      get onImportWithError;
  $async.Future<void> oneWayLocal(LocalTablePayload payload);
  $async.Future<LocalTablePayload> twoWayLocal(LocalUnionPayload payload);
  $async.Future<LocalUnionPayload> twoWayLocalWithError(
      LocalTablePayload payload);
  $async.Stream<LocalUnionPayload>? get onLocal;
  $async.Stream<LocalTablePayload>? get onLocalWithError;
  $async.Future<void> oneWayAnon(MainProtocolOneWayAnonRequest payload);
  $async.Future<MainProtocolTwoWayAnonResponse> twoWayAnon(
      MainProtocolTwoWayAnonRequest payload);
  $async.Future<MainProtocolTwoWayAnonWithErrorResponse> twoWayAnonWithError(
      MainProtocolTwoWayAnonWithErrorRequest payload);
  $async.Stream<MainProtocolOnAnonRequest>? get onAnon;
  $async.Stream<MainProtocolOnAnonWithErrorResponse>? get onAnonWithError;
} // TODO: Remove ServiceData for non-service

class MainProtocolData implements $fidl.ServiceData<MainProtocol> {
  const MainProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return MainProtocolBinding();
  }
}

class MainProtocolProxy extends $fidl.AsyncProxy<MainProtocol>
    implements MainProtocol {
  MainProtocolProxy()
      : super($fidl.AsyncProxyController<MainProtocol>(
            $interfaceName: r'MainProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _onAnonComposedEventStreamController.close();
      _onAnonComposedWithErrorEventStreamController.close();
      _onNamedComposedEventStreamController.close();
      _onNamedComposedWithErrorEventStreamController.close();
      _onImportEventStreamController.close();
      _onImportWithErrorEventStreamController.close();
      _onLocalEventStreamController.close();
      _onLocalWithErrorEventStreamController.close();
      _onAnonEventStreamController.close();
      _onAnonWithErrorEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kMainProtocol_OnAnonComposed_Ordinal:
        final String _name = _kMainProtocol_OnAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonComposedEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnAnonComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onAnonComposedEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnAnonComposedWithError_Ordinal:
        final String _name = _kMainProtocol_OnAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocollayouts_imported
                  .ComposedProtocolOnAnonComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnAnonComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocollayouts_imported
                  .ComposedProtocolOnAnonComposedWithErrorResultTag.response) {
            _onAnonComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onAnonComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnNamedComposed_Ordinal:
        final String _name = _kMainProtocol_OnNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnNamedComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnNamedComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onNamedComposedEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnNamedComposedWithError_Ordinal:
        final String _name = _kMainProtocol_OnNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnNamedComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocollayouts_imported
                  .ComposedProtocolOnNamedComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnNamedComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocollayouts_imported
                  .ComposedProtocolOnNamedComposedWithErrorResultTag.response) {
            _onNamedComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onNamedComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnImport_Ordinal:
        final String _name = _kMainProtocol_OnImport_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onImportEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnImport_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnImport_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onImportEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnImportWithError_Ordinal:
        final String _name = _kMainProtocol_OnImportWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onImportWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnImportWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnImportWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnImportWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolOnImportWithErrorResultTag.response) {
            _onImportWithErrorEventStreamController.add($response.response!);
          } else {
            _onImportWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnLocal_Ordinal:
        final String _name = _kMainProtocol_OnLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onLocalEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocal_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnLocal_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onLocalEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnLocalWithError_Ordinal:
        final String _name = _kMainProtocol_OnLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onLocalWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocalWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnLocalWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnLocalWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolOnLocalWithErrorResultTag.response) {
            _onLocalWithErrorEventStreamController.add($response.response!);
          } else {
            _onLocalWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnAnon_Ordinal:
        final String _name = _kMainProtocol_OnAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnon_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnAnon_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onAnonEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnAnonWithError_Ordinal:
        final String _name = _kMainProtocol_OnAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolOnAnonWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnAnonWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag == MainProtocolOnAnonWithErrorResultTag.response) {
            _onAnonWithErrorEventStreamController.add($response.response!);
          } else {
            _onAnonWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kMainProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayAnonComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayAnonComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayAnonComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayAnonComposedWithErrorResultTag
                  .response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposed_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayNamedComposed_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposedWithError_Type.response!;
          // ignore: prefer_const_declarations
          final lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayNamedComposedWithErrorResult
              $response = $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayNamedComposedWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayNamedComposedWithErrorResultTag
                  .response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayImport_Ordinal:
        final String _name = _kMainProtocol_TwoWayImport_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImport_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayImport_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayImportWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayImportWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImportWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayImportWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayImportWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayImportWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayLocal_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayLocalWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayLocalWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayAnon_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.response!;
          // ignore: prefer_const_declarations
          final MainProtocolTwoWayAnonWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              MainProtocolTwoWayAnonWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> oneWayAnonComposed(
      lib$test_protocollayouts_imported
              .ComposedProtocolOneWayAnonComposedRequest
          payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_OneWayAnonComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_OneWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<
      lib$test_protocollayouts_imported
          .ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      lib$test_protocollayouts_imported
              .ComposedProtocolTwoWayAnonComposedRequest
          payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnonComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported
            .ComposedProtocolTwoWayAnonComposedResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<
          lib$test_protocollayouts_imported
              .ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayAnonComposedWithErrorRequest
              payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayAnonComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported
            .ComposedProtocolTwoWayAnonComposedWithErrorResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonComposedEventStreamController = $async.StreamController<
      lib$test_protocollayouts_imported
          .ComposedProtocolOnAnonComposedRequest>.broadcast();
  @override
  $async.Stream<
      lib$test_protocollayouts_imported
          .ComposedProtocolOnAnonComposedRequest> get onAnonComposed =>
      _onAnonComposedEventStreamController.stream;

  final _onAnonComposedWithErrorEventStreamController = $async.StreamController<
      lib$test_protocollayouts_imported
          .ComposedProtocolOnAnonComposedWithErrorResponse>.broadcast();
  @override
  $async.Stream<
          lib$test_protocollayouts_imported
              .ComposedProtocolOnAnonComposedWithErrorResponse>
      get onAnonComposedWithError =>
          _onAnonComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayNamedComposed(
      lib$test_protocollayouts_imported.ImportTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_OneWayNamedComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_OneWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<lib$test_protocollayouts_imported.ImportTablePayload>
      twoWayNamedComposed(
          lib$test_protocollayouts_imported.ImportUnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayNamedComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported.ImportTablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<lib$test_protocollayouts_imported.ImportUnionPayload>
      twoWayNamedComposedWithError(
          lib$test_protocollayouts_imported.ImportTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayNamedComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayNamedComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayNamedComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported.ImportUnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onNamedComposedEventStreamController = $async.StreamController<
      lib$test_protocollayouts_imported.ImportUnionPayload>.broadcast();
  @override
  $async.Stream<lib$test_protocollayouts_imported.ImportUnionPayload>
      get onNamedComposed => _onNamedComposedEventStreamController.stream;

  final _onNamedComposedWithErrorEventStreamController =
      $async.StreamController<
          lib$test_protocollayouts_imported.ImportTablePayload>.broadcast();
  @override
  $async.Stream<lib$test_protocollayouts_imported.ImportTablePayload>
      get onNamedComposedWithError =>
          _onNamedComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayImport(
      lib$test_protocollayouts_imported.ImportTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayImport_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayImport_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayImport_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<lib$test_protocollayouts_imported.ImportTablePayload>
      twoWayImport(
          lib$test_protocollayouts_imported.ImportUnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayImport_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayImport_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayImport_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported.ImportTablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<lib$test_protocollayouts_imported.ImportUnionPayload>
      twoWayImportWithError(
          lib$test_protocollayouts_imported.ImportTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayImportWithError_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayImportWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayImportWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<
        lib$test_protocollayouts_imported.ImportUnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onImportEventStreamController = $async.StreamController<
      lib$test_protocollayouts_imported.ImportUnionPayload>.broadcast();
  @override
  $async.Stream<lib$test_protocollayouts_imported.ImportUnionPayload>
      get onImport => _onImportEventStreamController.stream;

  final _onImportWithErrorEventStreamController = $async.StreamController<
      lib$test_protocollayouts_imported.ImportTablePayload>.broadcast();
  @override
  $async.Stream<lib$test_protocollayouts_imported.ImportTablePayload>
      get onImportWithError => _onImportWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayLocal(LocalTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<LocalTablePayload> twoWayLocal(LocalUnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<LocalTablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<LocalUnionPayload> twoWayLocalWithError(
      LocalTablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocalWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocalWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayLocalWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<LocalUnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onLocalEventStreamController =
      $async.StreamController<LocalUnionPayload>.broadcast();
  @override
  $async.Stream<LocalUnionPayload> get onLocal =>
      _onLocalEventStreamController.stream;

  final _onLocalWithErrorEventStreamController =
      $async.StreamController<LocalTablePayload>.broadcast();
  @override
  $async.Stream<LocalTablePayload> get onLocalWithError =>
      _onLocalWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayAnon(MainProtocolOneWayAnonRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<MainProtocolTwoWayAnonResponse> twoWayAnon(
      MainProtocolTwoWayAnonRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<MainProtocolTwoWayAnonResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<MainProtocolTwoWayAnonWithErrorResponse> twoWayAnonWithError(
      MainProtocolTwoWayAnonWithErrorRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnonWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<MainProtocolTwoWayAnonWithErrorResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonEventStreamController =
      $async.StreamController<MainProtocolOnAnonRequest>.broadcast();
  @override
  $async.Stream<MainProtocolOnAnonRequest> get onAnon =>
      _onAnonEventStreamController.stream;

  final _onAnonWithErrorEventStreamController =
      $async.StreamController<MainProtocolOnAnonWithErrorResponse>.broadcast();
  @override
  $async.Stream<MainProtocolOnAnonWithErrorResponse> get onAnonWithError =>
      _onAnonWithErrorEventStreamController.stream;
}

class MainProtocolBinding extends $fidl.AsyncBinding<MainProtocol> {
  MainProtocolBinding() : super(r"MainProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _onAnonComposed_stream = impl.onAnonComposed;
        if (_onAnonComposed_stream != null) {
          $subscriptions.add(_onAnonComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnAnonComposed_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonComposed_Type.name, _e, close);
          }));
        }
        final _onAnonComposedWithError_stream = impl.onAnonComposedWithError;
        if (_onAnonComposedWithError_stream != null) {
          $subscriptions.add(_onAnonComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (lib$test_protocollayouts_imported
                              .ComposedProtocolOnAnonComposedWithErrorResponse
                          $responseValue,
                      $async.EventSink<
                              lib$test_protocollayouts_imported
                                  .ComposedProtocolOnAnonComposedWithErrorResult>
                          $sink) {
            $sink.add(lib$test_protocollayouts_imported
                    .ComposedProtocolOnAnonComposedWithErrorResult
                .withResponse($responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          lib$test_protocollayouts_imported
                              .ComposedProtocolOnAnonComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(lib$test_protocollayouts_imported
                      .ComposedProtocolOnAnonComposedWithErrorResult
                  .withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnAnonComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonComposedWithError_Type.name, _e, close);
          }));
        }
        final _onNamedComposed_stream = impl.onNamedComposed;
        if (_onNamedComposed_stream != null) {
          $subscriptions.add(_onNamedComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnNamedComposed_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnNamedComposed_Type.name, _e, close);
          }));
        }
        final _onNamedComposedWithError_stream = impl.onNamedComposedWithError;
        if (_onNamedComposedWithError_stream != null) {
          $subscriptions.add(_onNamedComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (lib$test_protocollayouts_imported.ImportTablePayload
                          $responseValue,
                      $async.EventSink<
                              lib$test_protocollayouts_imported
                                  .ComposedProtocolOnNamedComposedWithErrorResult>
                          $sink) {
            $sink.add(lib$test_protocollayouts_imported
                    .ComposedProtocolOnNamedComposedWithErrorResult
                .withResponse($responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          lib$test_protocollayouts_imported
                              .ComposedProtocolOnNamedComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(lib$test_protocollayouts_imported
                      .ComposedProtocolOnNamedComposedWithErrorResult
                  .withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnNamedComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnNamedComposedWithError_Type.name, _e, close);
          }));
        }
        final _onImport_stream = impl.onImport;
        if (_onImport_stream != null) {
          $subscriptions.add(_onImport_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnImport_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnImport_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnImport_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnImport_Type.name, _e, close);
          }));
        }
        final _onImportWithError_stream = impl.onImportWithError;
        if (_onImportWithError_stream != null) {
          $subscriptions.add(_onImportWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (lib$test_protocollayouts_imported.ImportTablePayload
                          $responseValue,
                      $async.EventSink<MainProtocolOnImportWithErrorResult>
                          $sink) {
            $sink.add(MainProtocolOnImportWithErrorResult.withResponse(
                $responseValue));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnImportWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(
                  MainProtocolOnImportWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnImportWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnImportWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnImportWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnImportWithError_Type.name, _e, close);
          }));
        }
        final _onLocal_stream = impl.onLocal;
        if (_onLocal_stream != null) {
          $subscriptions.add(_onLocal_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocal_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocal_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnLocal_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnLocal_Type.name, _e, close);
          }));
        }
        final _onLocalWithError_stream = impl.onLocalWithError;
        if (_onLocalWithError_stream != null) {
          $subscriptions.add(_onLocalWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (LocalTablePayload $responseValue,
                      $async.EventSink<MainProtocolOnLocalWithErrorResult>
                          $sink) {
            $sink.add(MainProtocolOnLocalWithErrorResult.withResponse(
                $responseValue));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnLocalWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(
                  MainProtocolOnLocalWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocalWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnLocalWithError_Type.name, _e, close);
          }));
        }
        final _onAnon_stream = impl.onAnon;
        if (_onAnon_stream != null) {
          $subscriptions.add(_onAnon_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnAnon_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnon_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnon_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnAnon_Type.name, _e, close);
          }));
        }
        final _onAnonWithError_stream = impl.onAnonWithError;
        if (_onAnonWithError_stream != null) {
          $subscriptions.add(_onAnonWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (MainProtocolOnAnonWithErrorResponse $responseValue,
                      $async.EventSink<MainProtocolOnAnonWithErrorResult>
                          $sink) {
            $sink.add(
                MainProtocolOnAnonWithErrorResult.withResponse($responseValue));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnAnonWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink
                  .add(MainProtocolOnAnonWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnAnonWithError_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonWithError_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kMainProtocol_OneWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_OneWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayAnonComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayAnonComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<
              lib$test_protocollayouts_imported
                  .ComposedProtocolTwoWayAnonComposedResponse> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ComposedProtocolTwoWayAnonComposedResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayAnonComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<
                  lib$test_protocollayouts_imported
                      .ComposedProtocolTwoWayAnonComposedWithErrorResponse>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ComposedProtocolTwoWayAnonComposedWithErrorResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonComposedWithError_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.twoWayAnonComposedWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return lib$test_protocollayouts_imported
                    .ComposedProtocolTwoWayAnonComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return lib$test_protocollayouts_imported
                      .ComposedProtocolTwoWayAnonComposedWithErrorResult
                  .withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_OneWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayNamedComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayNamedComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<lib$test_protocollayouts_imported.ImportTablePayload>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ImportTablePayload>>(
                  $message,
                  _kMainProtocol_TwoWayNamedComposed_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayNamedComposed(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayNamedComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<lib$test_protocollayouts_imported.ImportUnionPayload>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ImportUnionPayload>>(
                  $message,
                  _kMainProtocol_TwoWayNamedComposedWithError_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.twoWayNamedComposedWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return lib$test_protocollayouts_imported
                    .ComposedProtocolTwoWayNamedComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return lib$test_protocollayouts_imported
                      .ComposedProtocolTwoWayNamedComposedWithErrorResult
                  .withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayNamedComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayImport_Ordinal:
        final String _name = _kMainProtocol_OneWayImport_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayImport_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayImport_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayImport(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayImport_Ordinal:
        final String _name = _kMainProtocol_TwoWayImport_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImport_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<lib$test_protocollayouts_imported.ImportTablePayload>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ImportTablePayload>>(
                  $message,
                  _kMainProtocol_TwoWayImport_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayImport(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayImport_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayImport_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayImport_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayImportWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayImportWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayImportWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<lib$test_protocollayouts_imported.ImportUnionPayload>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          lib$test_protocollayouts_imported
                              .ImportUnionPayload>>(
                  $message,
                  _kMainProtocol_TwoWayImportWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayImportWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayImportWithErrorResult.withResponse(
                $responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayImportWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayImportWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayImportWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayImportWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayLocal_Ordinal:
        final String _name = _kMainProtocol_OneWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayLocal_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayLocal(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<LocalTablePayload> $future = $fidl
              .decodeMessageWithCallback<$async.Future<LocalTablePayload>>(
                  $message,
                  _kMainProtocol_TwoWayLocal_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayLocal(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocal_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocal_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayLocal_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<LocalUnionPayload> $future = $fidl
              .decodeMessageWithCallback<$async.Future<LocalUnionPayload>>(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayLocalWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayLocalWithErrorResult.withResponse(
                $responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayLocalWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayLocalWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayAnon_Ordinal:
        final String _name = _kMainProtocol_OneWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayAnon_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWayAnon(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocolTwoWayAnonResponse> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<MainProtocolTwoWayAnonResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnon_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayAnon(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnon_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnon_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnon_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocolTwoWayAnonWithErrorResponse> $future =
              $fidl.decodeMessageWithCallback<
                      $async.Future<MainProtocolTwoWayAnonWithErrorResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.twoWayAnonWithError(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayAnonWithErrorResult.withResponse(
                $responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayAnonWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for MainProtocolBinding');
    }
  }
}

// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.10

library fidl_fidl_test_encapsulatedstructs_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings

class Int8Int32 extends $fidl.Struct {
  const Int8Int32({
    required this.a,
    required this.b,
  });
  Int8Int32.clone(
    Int8Int32 $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int8Type();
  static const $fieldType1 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, a, $offset + 0);
    $fieldType1.encode($encoder, b, $offset + 4);
  }

  @override
  String toString() {
    return r'Int8Int32' r'(a: ' + a.toString() + r', b: ' + b.toString() + r')';
  }

  static Int8Int32 _structDecode($fidl.Decoder $decoder, int $offset) {
    return Int8Int32(
        a: $fieldType0.decode($decoder, $offset + 0),
        b: $fieldType1.decode($decoder, $offset + 4));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Int8Int32> kInt8Int32_Type = $fidl.StructType<Int8Int32>(
  inlineSize: 8,
  structDecode: Int8Int32._structDecode,
);

class Int16Int8 extends $fidl.Struct {
  const Int16Int8({
    required this.a,
    required this.b,
  });
  Int16Int8.clone(
    Int16Int8 $orig, {
    int? a,
    int? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final int a;
  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int16Type();
  static const $fieldType1 = $fidl.Int8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, a, $offset + 0);
    $fieldType1.encode($encoder, b, $offset + 2);
  }

  @override
  String toString() {
    return r'Int16Int8' r'(a: ' + a.toString() + r', b: ' + b.toString() + r')';
  }

  static Int16Int8 _structDecode($fidl.Decoder $decoder, int $offset) {
    return Int16Int8(
        a: $fieldType0.decode($decoder, $offset + 0),
        b: $fieldType1.decode($decoder, $offset + 2));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Int16Int8> kInt16Int8_Type = $fidl.StructType<Int16Int8>(
  inlineSize: 4,
  structDecode: Int16Int8._structDecode,
);

class ArrayInt16Int8 extends $fidl.Struct {
  const ArrayInt16Int8({
    required this.arr,
  });
  ArrayInt16Int8.clone(
    ArrayInt16Int8 $orig, {
    List<Int16Int8>? arr,
  }) : this(
          arr: arr ?? $orig.arr,
        );

  final List<Int16Int8> arr;

  @override
  List<Object?> get $fields {
    return <Object?>[
      arr,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<Int16Int8, List<Int16Int8>>(
      element: kInt16Int8_Type, elementCount: 3);

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, arr, $offset + 0);
  }

  @override
  String toString() {
    return r'ArrayInt16Int8' r'(arr: ' + arr.toString() + r')';
  }

  static ArrayInt16Int8 _structDecode($fidl.Decoder $decoder, int $offset) {
    return ArrayInt16Int8(arr: $fieldType0.decode($decoder, $offset + 0));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ArrayInt16Int8> kArrayInt16Int8_Type =
    $fidl.StructType<ArrayInt16Int8>(
  inlineSize: 12,
  structDecode: ArrayInt16Int8._structDecode,
);

class StructPaddingTestStruct extends $fidl.Struct {
  const StructPaddingTestStruct({
    required this.trailing,
    required this.inner,
    required this.array,
  });
  StructPaddingTestStruct.clone(
    StructPaddingTestStruct $orig, {
    Int16Int8? trailing,
    Int8Int32? inner,
    ArrayInt16Int8? array,
  }) : this(
          trailing: trailing ?? $orig.trailing,
          inner: inner ?? $orig.inner,
          array: array ?? $orig.array,
        );

  final Int16Int8 trailing;
  final Int8Int32 inner;
  final ArrayInt16Int8 array;

  @override
  List<Object?> get $fields {
    return <Object?>[
      trailing,
      inner,
      array,
    ];
  }

  static const $fieldType0 = kInt16Int8_Type;
  static const $fieldType1 = kInt8Int32_Type;
  static const $fieldType2 = kArrayInt16Int8_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, trailing, $offset + 0);
    $fieldType1.encode($encoder, inner, $offset + 4);
    $fieldType2.encode($encoder, array, $offset + 12);
  }

  @override
  String toString() {
    return r'StructPaddingTestStruct' r'(trailing: ' +
        trailing.toString() +
        r', inner: ' +
        inner.toString() +
        r', array: ' +
        array.toString() +
        r')';
  }

  static StructPaddingTestStruct _structDecode(
      $fidl.Decoder $decoder, int $offset) {
    return StructPaddingTestStruct(
        trailing: $fieldType0.decode($decoder, $offset + 0),
        inner: $fieldType1.decode($decoder, $offset + 4),
        array: $fieldType2.decode($decoder, $offset + 12));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructPaddingTestStruct> kStructPaddingTestStruct_Type =
    $fidl.StructType<StructPaddingTestStruct>(
  inlineSize: 24,
  structDecode: StructPaddingTestStruct._structDecode,
);

class NonInlineStructTestStruct extends $fidl.Struct {
  const NonInlineStructTestStruct({
    this.element,
    required this.h,
  });
  NonInlineStructTestStruct.clone(
    NonInlineStructTestStruct $orig, {
    Int16Int8? element,
    $zircon.Handle? h,
  }) : this(
          element: element ?? $orig.element,
          h: h ?? $orig.h,
        );

  NonInlineStructTestStruct.cloneWithout(
    NonInlineStructTestStruct $orig, {
    bool element = false,
  }) : this(
          element: element ? null : $orig.element,
          h: $orig.h,
        );

  final Int16Int8? element;
  final $zircon.Handle h;

  @override
  List<Object?> get $fields {
    return <Object?>[
      element,
      h,
    ];
  }

  static const $fieldType0 =
      $fidl.PointerType<Int16Int8>(element: kInt16Int8_Type);
  static const $fieldType1 = $fidl.HandleType();

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, element, $offset + 0);
    $fieldType1.encode($encoder, h, $offset + 8);
  }

  @override
  String toString() {
    return r'NonInlineStructTestStruct' r'(element: ' +
        element.toString() +
        r', h: ' +
        h.toString() +
        r')';
  }

  static NonInlineStructTestStruct _structDecode(
      $fidl.Decoder $decoder, int $offset) {
    return NonInlineStructTestStruct(
        element: $fieldType0.decode($decoder, $offset + 0),
        h: $fieldType1.decode($decoder, $offset + 8));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NonInlineStructTestStruct>
    kNonInlineStructTestStruct_Type =
    $fidl.StructType<NonInlineStructTestStruct>(
  inlineSize: 16,
  structDecode: NonInlineStructTestStruct._structDecode,
);

class TopLevelStruct extends $fidl.Struct {
  const TopLevelStruct({
    required this.a,
    required this.b,
  });
  TopLevelStruct.clone(
    TopLevelStruct $orig, {
    StructPaddingTestStruct? a,
    NonInlineStructTestStruct? b,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
        );

  final StructPaddingTestStruct a;
  final NonInlineStructTestStruct b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
    ];
  }

  static const $fieldType0 = kStructPaddingTestStruct_Type;
  static const $fieldType1 = kNonInlineStructTestStruct_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, a, $offset + 0);
    $fieldType1.encode($encoder, b, $offset + 24);
  }

  @override
  String toString() {
    return r'TopLevelStruct' r'(a: ' +
        a.toString() +
        r', b: ' +
        b.toString() +
        r')';
  }

  static TopLevelStruct _structDecode($fidl.Decoder $decoder, int $offset) {
    return TopLevelStruct(
        a: $fieldType0.decode($decoder, $offset + 0),
        b: $fieldType1.decode($decoder, $offset + 24));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<TopLevelStruct> kTopLevelStruct_Type =
    $fidl.StructType<TopLevelStruct>(
  inlineSize: 40,
  structDecode: TopLevelStruct._structDecode,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();

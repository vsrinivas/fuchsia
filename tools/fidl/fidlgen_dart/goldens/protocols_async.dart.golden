// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.12

library fidl_test_protocols_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_zx/fidl_async.dart' as lib$zx;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

class ErrorEnum extends $fidl.Enum {
  static const Map<int, ErrorEnum> _values = {
    0x1: errFoo,
    0x2: errBar,
  };
  factory ErrorEnum(int _v) {
    if (!_values.containsKey(_v)) {
      throw $fidl.FidlError('Invalid strict enum value: $_v',
          $fidl.FidlErrorCode.fidlInvalidEnumValue);
    }
    return _values[_v]!;
  }
  static const ErrorEnum errFoo = ErrorEnum._(0x1);
  static const ErrorEnum errBar = ErrorEnum._(0x2);

  const ErrorEnum._(this.$value);

  @override
  final int $value;

  static const Map<String, ErrorEnum> $valuesMap = {
    r'errFoo': errFoo,
    r'errBar': errBar,
  };

  static const List<ErrorEnum> $values = [
    errFoo,
    errBar,
  ];

  static ErrorEnum? $valueOf(String name) => $valuesMap[name];

  @override
  bool isUnknown() {
    return false;
  }

  static ErrorEnum _ctor(int v) => ErrorEnum(v);
}

const $fidl.EnumType<ErrorEnum> kErrorEnum_Type = $fidl.EnumType<ErrorEnum>(
    type: $fidl.Uint32Type(),
    values: {0x1: null, 0x2: null},
    ctor: ErrorEnum._ctor);

enum TheUnionTag {
  $unknown,
  v, // 0x1
}

const Map<int, TheUnionTag> _TheUnionTag_map = {
  1: TheUnionTag.v,
};

class TheUnion extends $fidl.Union {
  const TheUnion.withV(int value)
      : _ordinal = 1,
        _data = value;
  const TheUnion.with$UnknownData(this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  TheUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  TheUnionTag get $tag => _TheUnionTag_map[_ordinal] ?? TheUnionTag.$unknown;

  int? get v {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static TheUnion _ctor(int ordinal, Object data) {
    return TheUnion._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<TheUnion> kTheUnion_Type = $fidl.UnionType<TheUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
  },
  ctor: TheUnion._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<TheUnion> kTheUnion_OptType =
    $fidl.NullableUnionType<TheUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
  },
  ctor: TheUnion._ctor,
  flexible: true,
  resource: false,
);

enum WithErrorSyntaxErrorAsEnumResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, WithErrorSyntaxErrorAsEnumResultTag>
    _WithErrorSyntaxErrorAsEnumResultTag_map = {
  1: WithErrorSyntaxErrorAsEnumResultTag.response,
  2: WithErrorSyntaxErrorAsEnumResultTag.err,
};

class WithErrorSyntaxErrorAsEnumResult extends $fidl.Union {
  const WithErrorSyntaxErrorAsEnumResult.withResponse(
      WithErrorSyntaxErrorAsEnumResponse value)
      : _ordinal = 1,
        _data = value;

  const WithErrorSyntaxErrorAsEnumResult.withErr(ErrorEnum value)
      : _ordinal = 2,
        _data = value;

  WithErrorSyntaxErrorAsEnumResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  WithErrorSyntaxErrorAsEnumResultTag get $tag =>
      _WithErrorSyntaxErrorAsEnumResultTag_map[_ordinal]!;

  WithErrorSyntaxErrorAsEnumResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  ErrorEnum? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static WithErrorSyntaxErrorAsEnumResult _ctor(int ordinal, Object data) {
    return WithErrorSyntaxErrorAsEnumResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<WithErrorSyntaxErrorAsEnumResult>
    kWithErrorSyntax_ErrorAsEnum_Result_Type =
    $fidl.UnionType<WithErrorSyntaxErrorAsEnumResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ErrorAsEnum_Response_Type,
    2: kErrorEnum_Type,
  },
  ctor: WithErrorSyntaxErrorAsEnumResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<WithErrorSyntaxErrorAsEnumResult>
    kWithErrorSyntax_ErrorAsEnum_Result_OptType =
    $fidl.NullableUnionType<WithErrorSyntaxErrorAsEnumResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ErrorAsEnum_Response_Type,
    2: kErrorEnum_Type,
  },
  ctor: WithErrorSyntaxErrorAsEnumResult._ctor,
  flexible: false,
  resource: false,
);

enum WithErrorSyntaxErrorAsPrimitiveResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, WithErrorSyntaxErrorAsPrimitiveResultTag>
    _WithErrorSyntaxErrorAsPrimitiveResultTag_map = {
  1: WithErrorSyntaxErrorAsPrimitiveResultTag.response,
  2: WithErrorSyntaxErrorAsPrimitiveResultTag.err,
};

class WithErrorSyntaxErrorAsPrimitiveResult extends $fidl.Union {
  const WithErrorSyntaxErrorAsPrimitiveResult.withResponse(
      WithErrorSyntaxErrorAsPrimitiveResponse value)
      : _ordinal = 1,
        _data = value;

  const WithErrorSyntaxErrorAsPrimitiveResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  WithErrorSyntaxErrorAsPrimitiveResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  WithErrorSyntaxErrorAsPrimitiveResultTag get $tag =>
      _WithErrorSyntaxErrorAsPrimitiveResultTag_map[_ordinal]!;

  WithErrorSyntaxErrorAsPrimitiveResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static WithErrorSyntaxErrorAsPrimitiveResult _ctor(int ordinal, Object data) {
    return WithErrorSyntaxErrorAsPrimitiveResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<WithErrorSyntaxErrorAsPrimitiveResult>
    kWithErrorSyntax_ErrorAsPrimitive_Result_Type =
    $fidl.UnionType<WithErrorSyntaxErrorAsPrimitiveResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ErrorAsPrimitive_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxErrorAsPrimitiveResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<WithErrorSyntaxErrorAsPrimitiveResult>
    kWithErrorSyntax_ErrorAsPrimitive_Result_OptType =
    $fidl.NullableUnionType<WithErrorSyntaxErrorAsPrimitiveResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ErrorAsPrimitive_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxErrorAsPrimitiveResult._ctor,
  flexible: false,
  resource: false,
);

enum WithErrorSyntaxHandleInResultResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, WithErrorSyntaxHandleInResultResultTag>
    _WithErrorSyntaxHandleInResultResultTag_map = {
  1: WithErrorSyntaxHandleInResultResultTag.response,
  2: WithErrorSyntaxHandleInResultResultTag.err,
};

class WithErrorSyntaxHandleInResultResult extends $fidl.Union {
  const WithErrorSyntaxHandleInResultResult.withResponse(
      WithErrorSyntaxHandleInResultResponse value)
      : _ordinal = 1,
        _data = value;

  const WithErrorSyntaxHandleInResultResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  WithErrorSyntaxHandleInResultResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  WithErrorSyntaxHandleInResultResultTag get $tag =>
      _WithErrorSyntaxHandleInResultResultTag_map[_ordinal]!;

  WithErrorSyntaxHandleInResultResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static WithErrorSyntaxHandleInResultResult _ctor(int ordinal, Object data) {
    return WithErrorSyntaxHandleInResultResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<WithErrorSyntaxHandleInResultResult>
    kWithErrorSyntax_HandleInResult_Result_Type =
    $fidl.UnionType<WithErrorSyntaxHandleInResultResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_HandleInResult_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxHandleInResultResult._ctor,
  flexible: false,
  resource: true,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<WithErrorSyntaxHandleInResultResult>
    kWithErrorSyntax_HandleInResult_Result_OptType =
    $fidl.NullableUnionType<WithErrorSyntaxHandleInResultResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_HandleInResult_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxHandleInResultResult._ctor,
  flexible: false,
  resource: true,
);

enum WithErrorSyntaxResponseAsStructResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, WithErrorSyntaxResponseAsStructResultTag>
    _WithErrorSyntaxResponseAsStructResultTag_map = {
  1: WithErrorSyntaxResponseAsStructResultTag.response,
  2: WithErrorSyntaxResponseAsStructResultTag.err,
};

class WithErrorSyntaxResponseAsStructResult extends $fidl.Union {
  const WithErrorSyntaxResponseAsStructResult.withResponse(
      WithErrorSyntaxResponseAsStructResponse value)
      : _ordinal = 1,
        _data = value;

  const WithErrorSyntaxResponseAsStructResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  WithErrorSyntaxResponseAsStructResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  WithErrorSyntaxResponseAsStructResultTag get $tag =>
      _WithErrorSyntaxResponseAsStructResultTag_map[_ordinal]!;

  WithErrorSyntaxResponseAsStructResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static WithErrorSyntaxResponseAsStructResult _ctor(int ordinal, Object data) {
    return WithErrorSyntaxResponseAsStructResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<WithErrorSyntaxResponseAsStructResult>
    kWithErrorSyntax_ResponseAsStruct_Result_Type =
    $fidl.UnionType<WithErrorSyntaxResponseAsStructResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ResponseAsStruct_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxResponseAsStructResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<WithErrorSyntaxResponseAsStructResult>
    kWithErrorSyntax_ResponseAsStruct_Result_OptType =
    $fidl.NullableUnionType<WithErrorSyntaxResponseAsStructResult>(
  members: <int, $fidl.FidlType>{
    1: kWithErrorSyntax_ResponseAsStruct_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: WithErrorSyntaxResponseAsStructResult._ctor,
  flexible: false,
  resource: false,
);

class ProtocolEnds extends $fidl.Struct {
  const ProtocolEnds({
    required this.client,
    required this.server,
    this.clientOpt,
    this.serverOpt,
  });
  ProtocolEnds.clone(
    ProtocolEnds $orig, {
    $fidl.InterfaceHandle<DiscoverableProtocol>? client,
    $fidl.InterfaceRequest<DiscoverableProtocol>? server,
    $fidl.InterfaceHandle<DiscoverableProtocol>? clientOpt,
    $fidl.InterfaceRequest<DiscoverableProtocol>? serverOpt,
  }) : this(
          client: client ?? $orig.client,
          server: server ?? $orig.server,
          clientOpt: clientOpt ?? $orig.clientOpt,
          serverOpt: serverOpt ?? $orig.serverOpt,
        );

  ProtocolEnds.cloneWithout(
    ProtocolEnds $orig, {
    bool clientOpt = false,
    bool serverOpt = false,
  }) : this(
          client: $orig.client,
          server: $orig.server,
          clientOpt: clientOpt ? null : $orig.clientOpt,
          serverOpt: serverOpt ? null : $orig.serverOpt,
        );

  ProtocolEnds $cloneWith({
    $fidl.InterfaceHandle<DiscoverableProtocol>? client,
    $fidl.InterfaceRequest<DiscoverableProtocol>? server,
    $fidl.OptionalNullable<$fidl.InterfaceHandle<DiscoverableProtocol>?>
        clientOpt = const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<$fidl.InterfaceRequest<DiscoverableProtocol>?>
        serverOpt = const $fidl.OptionalNullable.undefined(),
  }) {
    return ProtocolEnds(
      client: client ?? this.client,
      server: server ?? this.server,
      clientOpt: clientOpt.or(this.clientOpt),
      serverOpt: serverOpt.or(this.serverOpt),
    );
  }

  final $fidl.InterfaceHandle<DiscoverableProtocol> client;
  final $fidl.InterfaceRequest<DiscoverableProtocol> server;
  final $fidl.InterfaceHandle<DiscoverableProtocol>? clientOpt;
  final $fidl.InterfaceRequest<DiscoverableProtocol>? serverOpt;

  @override
  List<Object?> get $fields {
    return <Object?>[
      client,
      server,
      clientOpt,
      serverOpt,
    ];
  }

  static const $fieldType0 = $fidl.InterfaceHandleType<DiscoverableProtocol>();
  static const $fieldType1 = $fidl.InterfaceRequestType<DiscoverableProtocol>();
  static const $fieldType2 =
      $fidl.NullableInterfaceHandleType<DiscoverableProtocol>();
  static const $fieldType3 =
      $fidl.NullableInterfaceRequestType<DiscoverableProtocol>();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, client, $offset + 0, $depth);
    $fieldType1.encode($encoder, server, $offset + 4, $depth);
    $fieldType2.encode($encoder, clientOpt, $offset + 8, $depth);
    $fieldType3.encode($encoder, serverOpt, $offset + 12, $depth);
  }

  static ProtocolEnds _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return ProtocolEnds(
            client: $fieldType0.decode($decoder, $offset + 0, $depth),
            server: $fieldType1.decode($decoder, $offset + 4, $depth),
            clientOpt: $fieldType2.decode($decoder, $offset + 8, $depth),
            serverOpt: $fieldType3.decode($decoder, $offset + 12, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ProtocolEnds> kProtocolEnds_Type =
    $fidl.StructType<ProtocolEnds>(
        inlineSize: 16, structDecode: ProtocolEnds._structDecode);

class WithErrorSyntaxErrorAsEnumResponse extends $fidl.Struct {
  const WithErrorSyntaxErrorAsEnumResponse({
    this.reserved = 0x0,
  });
  WithErrorSyntaxErrorAsEnumResponse.clone(
    WithErrorSyntaxErrorAsEnumResponse $orig, {
    int? reserved,
  }) : this(
          reserved: reserved ?? $orig.reserved,
        );

  WithErrorSyntaxErrorAsEnumResponse $cloneWith({
    int? reserved,
  }) {
    return WithErrorSyntaxErrorAsEnumResponse(
      reserved: reserved ?? this.reserved,
    );
  }

  final int reserved;

  @override
  List<Object?> get $fields {
    return <Object?>[
      reserved,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, reserved, $offset + 0, $depth);
  }

  static WithErrorSyntaxErrorAsEnumResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 0, 1);
        return WithErrorSyntaxErrorAsEnumResponse(
            reserved: $fieldType0.decode($decoder, $offset + 0, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<WithErrorSyntaxErrorAsEnumResponse>
    kWithErrorSyntax_ErrorAsEnum_Response_Type =
    $fidl.StructType<WithErrorSyntaxErrorAsEnumResponse>(
        inlineSize: 1,
        structDecode: WithErrorSyntaxErrorAsEnumResponse._structDecode);

class WithErrorSyntaxErrorAsPrimitiveResponse extends $fidl.Struct {
  const WithErrorSyntaxErrorAsPrimitiveResponse({
    this.reserved = 0x0,
  });
  WithErrorSyntaxErrorAsPrimitiveResponse.clone(
    WithErrorSyntaxErrorAsPrimitiveResponse $orig, {
    int? reserved,
  }) : this(
          reserved: reserved ?? $orig.reserved,
        );

  WithErrorSyntaxErrorAsPrimitiveResponse $cloneWith({
    int? reserved,
  }) {
    return WithErrorSyntaxErrorAsPrimitiveResponse(
      reserved: reserved ?? this.reserved,
    );
  }

  final int reserved;

  @override
  List<Object?> get $fields {
    return <Object?>[
      reserved,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, reserved, $offset + 0, $depth);
  }

  static WithErrorSyntaxErrorAsPrimitiveResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 0, 1);
        return WithErrorSyntaxErrorAsPrimitiveResponse(
            reserved: $fieldType0.decode($decoder, $offset + 0, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<WithErrorSyntaxErrorAsPrimitiveResponse>
    kWithErrorSyntax_ErrorAsPrimitive_Response_Type =
    $fidl.StructType<WithErrorSyntaxErrorAsPrimitiveResponse>(
        inlineSize: 1,
        structDecode: WithErrorSyntaxErrorAsPrimitiveResponse._structDecode);

class WithErrorSyntaxHandleInResultResponse extends $fidl.Struct {
  const WithErrorSyntaxHandleInResultResponse({
    required this.h,
  });
  WithErrorSyntaxHandleInResultResponse.clone(
    WithErrorSyntaxHandleInResultResponse $orig, {
    $zircon.Handle? h,
  }) : this(
          h: h ?? $orig.h,
        );

  WithErrorSyntaxHandleInResultResponse $cloneWith({
    $zircon.Handle? h,
  }) {
    return WithErrorSyntaxHandleInResultResponse(
      h: h ?? this.h,
    );
  }

  final $zircon.Handle h;

  @override
  List<Object?> get $fields {
    return <Object?>[
      h,
    ];
  }

  static const $fieldType0 =
      $fidl.HandleType(objectType: 0, rights: 2147483648);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, h, $offset + 0, $depth);
  }

  static WithErrorSyntaxHandleInResultResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return WithErrorSyntaxHandleInResultResponse(
            h: $fieldType0.decode($decoder, $offset + 0, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<WithErrorSyntaxHandleInResultResponse>
    kWithErrorSyntax_HandleInResult_Response_Type =
    $fidl.StructType<WithErrorSyntaxHandleInResultResponse>(
        inlineSize: 4,
        structDecode: WithErrorSyntaxHandleInResultResponse._structDecode);

class WithErrorSyntaxResponseAsStructResponse extends $fidl.Struct {
  const WithErrorSyntaxResponseAsStructResponse({
    required this.a,
    required this.b,
    required this.c,
  });
  WithErrorSyntaxResponseAsStructResponse.clone(
    WithErrorSyntaxResponseAsStructResponse $orig, {
    int? a,
    int? b,
    int? c,
  }) : this(
          a: a ?? $orig.a,
          b: b ?? $orig.b,
          c: c ?? $orig.c,
        );

  WithErrorSyntaxResponseAsStructResponse $cloneWith({
    int? a,
    int? b,
    int? c,
  }) {
    return WithErrorSyntaxResponseAsStructResponse(
      a: a ?? this.a,
      b: b ?? this.b,
      c: c ?? this.c,
    );
  }

  final int a;
  final int b;
  final int c;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
      b,
      c,
    ];
  }

  static const $fieldType0 = $fidl.Int64Type();
  static const $fieldType1 = $fidl.Int64Type();
  static const $fieldType2 = $fidl.Int64Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
    $fieldType1.encode($encoder, b, $offset + 8, $depth);
    $fieldType2.encode($encoder, c, $offset + 16, $depth);
  }

  static WithErrorSyntaxResponseAsStructResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v1:
      case $fidl.WireFormat.v2:
        return WithErrorSyntaxResponseAsStructResponse(
            a: $fieldType0.decode($decoder, $offset + 0, $depth),
            b: $fieldType1.decode($decoder, $offset + 8, $depth),
            c: $fieldType2.decode($decoder, $offset + 16, $depth));
      default:
        throw $fidl.FidlError('unknown wire format');
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<WithErrorSyntaxResponseAsStructResponse>
    kWithErrorSyntax_ResponseAsStruct_Response_Type =
    $fidl.StructType<WithErrorSyntaxResponseAsStructResponse>(
        inlineSize: 24,
        structDecode: WithErrorSyntaxResponseAsStructResponse._structDecode);

abstract class AnotherDiscoverableProtocol extends $fidl.Service {
  static const String $serviceName = "fake.library.FakeProtocol";
  @override
  $fidl.ServiceData? get $serviceData => AnotherDiscoverableProtocolData();
} // TODO: Remove ServiceData for non-service

class AnotherDiscoverableProtocolData
    implements $fidl.ServiceData<AnotherDiscoverableProtocol> {
  const AnotherDiscoverableProtocolData();

  @override
  String getName() {
    return AnotherDiscoverableProtocol.$serviceName;
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return AnotherDiscoverableProtocolBinding();
  }
}

class AnotherDiscoverableProtocolProxy
    extends $fidl.AsyncProxy<AnotherDiscoverableProtocol>
    implements AnotherDiscoverableProtocol {
  AnotherDiscoverableProtocolProxy()
      : super($fidl.AsyncProxyController<AnotherDiscoverableProtocol>(
            $serviceName: "fake.library.FakeProtocol",
            $interfaceName: r'AnotherDiscoverableProtocol')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  $fidl.ServiceData get $serviceData => AnotherDiscoverableProtocolData();

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }
}

class AnotherDiscoverableProtocolBinding
    extends $fidl.AsyncBinding<AnotherDiscoverableProtocol> {
  AnotherDiscoverableProtocolBinding() : super(r"AnotherDiscoverableProtocol");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for AnotherDiscoverableProtocolBinding');
    }
  }
}

// methodA: (int a, int b)
const int _kChannelProtocol_MethodA_Ordinal = 0x2bc8d7d32bc66ba2;
const $fidl.MethodType _kChannelProtocol_MethodA_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 8),
  ],
  response: [],
  name: r"ChannelProtocol.MethodA",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// eventA:  -> (int a, int b)
const int _kChannelProtocol_EventA_Ordinal = 0x1ed0a220297145ce;
const $fidl.MethodType _kChannelProtocol_EventA_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 8),
  ],
  name: r"ChannelProtocol.EventA",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// methodB: (int a, int b) -> (int result)
const int _kChannelProtocol_MethodB_Ordinal = 0x7b8dd3d6c741c9c6;
const $fidl.MethodType _kChannelProtocol_MethodB_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 8),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  name: r"ChannelProtocol.MethodB",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 8,
);
// takeHandle: ($zircon.Handle h) -> ()
const int _kChannelProtocol_TakeHandle_Ordinal = 0x836fa31201a0a65;
const $fidl.MethodType _kChannelProtocol_TakeHandle_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Handle>(
        type: $fidl.HandleType(objectType: 0, rights: 2147483648), offset: 0),
  ],
  response: [],
  name: r"ChannelProtocol.TakeHandle",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 0,
);
// mutateSocket: ($zircon.Socket a) -> ($zircon.Socket b)
const int _kChannelProtocol_MutateSocket_Ordinal = 0x66dbcccc06f7f14f;
const $fidl.MethodType _kChannelProtocol_MutateSocket_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 2147483648), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 2147483648), offset: 0),
  ],
  name: r"ChannelProtocol.MutateSocket",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);

class ChannelProtocol$EventA$Response {
  final int a;
  final int b;
  ChannelProtocol$EventA$Response(
    this.a,
    this.b,
  );
}

abstract class ChannelProtocol {
  $fidl.ServiceData? get $serviceData => ChannelProtocolData();
  $async.Future<void> methodA(int a, int b);
  $async.Stream<ChannelProtocol$EventA$Response>? get eventA;
  $async.Future<int> methodB(int a, int b);
  $async.Future<void> takeHandle($zircon.Handle h);
  $async.Future<$zircon.Socket> mutateSocket($zircon.Socket a);
} // TODO: Remove ServiceData for non-service

class ChannelProtocolData implements $fidl.ServiceData<ChannelProtocol> {
  const ChannelProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return ChannelProtocolBinding();
  }
}

class ChannelProtocolProxy extends $fidl.AsyncProxy<ChannelProtocol>
    implements ChannelProtocol {
  ChannelProtocolProxy()
      : super($fidl.AsyncProxyController<ChannelProtocol>(
            $interfaceName: r'ChannelProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _eventAEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kChannelProtocol_EventA_Ordinal:
        final String _name = _kChannelProtocol_EventA_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _eventAEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_EventA_Type.response!;
          // ignore: prefer_const_declarations
          final ChannelProtocol$EventA$Response $response = $fidl
              .decodeMessageWithCallback<ChannelProtocol$EventA$Response>(
                  $message,
                  _kChannelProtocol_EventA_Type.responseInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return ChannelProtocol$EventA$Response(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });

          _eventAEventStreamController.add($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kChannelProtocol_MethodB_Ordinal:
        final String _name = _kChannelProtocol_MethodB_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_MethodB_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kChannelProtocol_MethodB_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kChannelProtocol_TakeHandle_Ordinal:
        final String _name = _kChannelProtocol_TakeHandle_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_TakeHandle_Type.response!;
          // ignore: prefer_const_declarations
          final $response = null;

          $completer.complete($response);
        });
        break;
      case _kChannelProtocol_MutateSocket_Ordinal:
        final String _name = _kChannelProtocol_MutateSocket_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_MutateSocket_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kChannelProtocol_MutateSocket_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> methodA(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kChannelProtocol_MethodA_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kChannelProtocol_MethodA_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kChannelProtocol_MethodA_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  final _eventAEventStreamController =
      $async.StreamController<ChannelProtocol$EventA$Response>.broadcast();
  @override
  $async.Stream<ChannelProtocol$EventA$Response> get eventA =>
      _eventAEventStreamController.stream;

  @override
  $async.Future<int> methodB(int a, int b) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kChannelProtocol_MethodB_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kChannelProtocol_MethodB_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kChannelProtocol_MethodB_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, b, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<void> takeHandle($zircon.Handle h) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kChannelProtocol_TakeHandle_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kChannelProtocol_TakeHandle_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kChannelProtocol_TakeHandle_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, h, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<void>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<$zircon.Socket> mutateSocket($zircon.Socket a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kChannelProtocol_MutateSocket_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kChannelProtocol_MutateSocket_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kChannelProtocol_MutateSocket_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<$zircon.Socket>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }
}

class ChannelProtocolBinding extends $fidl.AsyncBinding<ChannelProtocol> {
  ChannelProtocolBinding() : super(r"ChannelProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _eventA_stream = impl.eventA;
        if (_eventA_stream != null) {
          $subscriptions.add(_eventA_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kChannelProtocol_EventA_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kChannelProtocol_EventA_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kChannelProtocol_EventA_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0]
                  .encode($encoder, $response.a, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.b, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kChannelProtocol_EventA_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kChannelProtocol_MethodA_Ordinal:
        final String _name = _kChannelProtocol_MethodA_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_MethodA_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kChannelProtocol_MethodA_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.methodA(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kChannelProtocol_MethodB_Ordinal:
        final String _name = _kChannelProtocol_MethodB_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_MethodB_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kChannelProtocol_MethodB_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.methodB(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kChannelProtocol_MethodB_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kChannelProtocol_MethodB_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kChannelProtocol_MethodB_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kChannelProtocol_TakeHandle_Ordinal:
        final String _name = _kChannelProtocol_TakeHandle_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_TakeHandle_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kChannelProtocol_TakeHandle_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.takeHandle(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kChannelProtocol_TakeHandle_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kChannelProtocol_MutateSocket_Ordinal:
        final String _name = _kChannelProtocol_MutateSocket_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kChannelProtocol_MutateSocket_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<$zircon.Socket> $future = $fidl
              .decodeMessageWithCallback<$async.Future<$zircon.Socket>>(
                  $message,
                  _kChannelProtocol_MutateSocket_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.mutateSocket(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kChannelProtocol_MutateSocket_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kChannelProtocol_MutateSocket_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kChannelProtocol_MutateSocket_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for ChannelProtocolBinding');
    }
  }
}

// method: ()
const int _kDiscoverableProtocol_Method_Ordinal = 0x2ff5ba3a2bd170eb;
const $fidl.MethodType _kDiscoverableProtocol_Method_Type = $fidl.MethodType(
  request: [],
  response: [],
  name: r"DiscoverableProtocol.Method",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);

abstract class DiscoverableProtocol extends $fidl.Service {
  static const String $serviceName = "test.protocols.DiscoverableProtocol";
  @override
  $fidl.ServiceData? get $serviceData => DiscoverableProtocolData();
  $async.Future<void> method();
} // TODO: Remove ServiceData for non-service

class DiscoverableProtocolData
    implements $fidl.ServiceData<DiscoverableProtocol> {
  const DiscoverableProtocolData();

  @override
  String getName() {
    return DiscoverableProtocol.$serviceName;
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return DiscoverableProtocolBinding();
  }
}

class DiscoverableProtocolProxy extends $fidl.AsyncProxy<DiscoverableProtocol>
    implements DiscoverableProtocol {
  DiscoverableProtocolProxy()
      : super($fidl.AsyncProxyController<DiscoverableProtocol>(
            $serviceName: "test.protocols.DiscoverableProtocol",
            $interfaceName: r'DiscoverableProtocol')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  $fidl.ServiceData get $serviceData => DiscoverableProtocolData();

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> method() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kDiscoverableProtocol_Method_Ordinal, 0, $fidl.CallStrictness.strict);
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }
}

class DiscoverableProtocolBinding
    extends $fidl.AsyncBinding<DiscoverableProtocol> {
  DiscoverableProtocolBinding() : super(r"DiscoverableProtocol");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kDiscoverableProtocol_Method_Ordinal:
        final String _name = _kDiscoverableProtocol_Method_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDiscoverableProtocol_Method_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kDiscoverableProtocol_Method_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.method();
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for DiscoverableProtocolBinding');
    }
  }
}

// noResponseMethod: ($zircon.Socket h)
const int _kHandleRightsProtocol_NoResponseMethod_Ordinal = 0x10078afd320d2bfd;
const $fidl.MethodType _kHandleRightsProtocol_NoResponseMethod_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 3), offset: 0),
  ],
  response: [],
  name: r"HandleRightsProtocol.NoResponseMethod",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 0,
);
// responseMethod: ($zircon.Socket h) -> ($zircon.Socket h)
const int _kHandleRightsProtocol_ResponseMethod_Ordinal = 0x52a8f194ac143547;
const $fidl.MethodType _kHandleRightsProtocol_ResponseMethod_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 3), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 2), offset: 0),
  ],
  name: r"HandleRightsProtocol.ResponseMethod",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);
// anEvent:  -> ($zircon.Socket h)
const int _kHandleRightsProtocol_AnEvent_Ordinal = 0x69dad41418eb133;
const $fidl.MethodType _kHandleRightsProtocol_AnEvent_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Socket>(
        type: $fidl.SocketType(objectType: 14, rights: 3), offset: 0),
  ],
  name: r"HandleRightsProtocol.AnEvent",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 4,
);

abstract class HandleRightsProtocol {
  $fidl.ServiceData? get $serviceData => HandleRightsProtocolData();
  $async.Future<void> noResponseMethod($zircon.Socket h);
  $async.Future<$zircon.Socket> responseMethod($zircon.Socket h);
  $async.Stream<$zircon.Socket>? get anEvent;
} // TODO: Remove ServiceData for non-service

class HandleRightsProtocolData
    implements $fidl.ServiceData<HandleRightsProtocol> {
  const HandleRightsProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return HandleRightsProtocolBinding();
  }
}

class HandleRightsProtocolProxy extends $fidl.AsyncProxy<HandleRightsProtocol>
    implements HandleRightsProtocol {
  HandleRightsProtocolProxy()
      : super($fidl.AsyncProxyController<HandleRightsProtocol>(
            $interfaceName: r'HandleRightsProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _anEventEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kHandleRightsProtocol_AnEvent_Ordinal:
        final String _name = _kHandleRightsProtocol_AnEvent_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _anEventEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kHandleRightsProtocol_AnEvent_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kHandleRightsProtocol_AnEvent_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _anEventEventStreamController.add($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kHandleRightsProtocol_ResponseMethod_Ordinal:
        final String _name = _kHandleRightsProtocol_ResponseMethod_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kHandleRightsProtocol_ResponseMethod_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kHandleRightsProtocol_ResponseMethod_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> noResponseMethod($zircon.Socket h) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kHandleRightsProtocol_NoResponseMethod_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kHandleRightsProtocol_NoResponseMethod_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kHandleRightsProtocol_NoResponseMethod_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, h, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<$zircon.Socket> responseMethod($zircon.Socket h) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kHandleRightsProtocol_ResponseMethod_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kHandleRightsProtocol_ResponseMethod_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kHandleRightsProtocol_ResponseMethod_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, h, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<$zircon.Socket>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _anEventEventStreamController =
      $async.StreamController<$zircon.Socket>.broadcast();
  @override
  $async.Stream<$zircon.Socket> get anEvent =>
      _anEventEventStreamController.stream;
}

class HandleRightsProtocolBinding
    extends $fidl.AsyncBinding<HandleRightsProtocol> {
  HandleRightsProtocolBinding() : super(r"HandleRightsProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _anEvent_stream = impl.anEvent;
        if (_anEvent_stream != null) {
          $subscriptions.add(_anEvent_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kHandleRightsProtocol_AnEvent_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kHandleRightsProtocol_AnEvent_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kHandleRightsProtocol_AnEvent_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kHandleRightsProtocol_AnEvent_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kHandleRightsProtocol_NoResponseMethod_Ordinal:
        final String _name = _kHandleRightsProtocol_NoResponseMethod_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kHandleRightsProtocol_NoResponseMethod_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kHandleRightsProtocol_NoResponseMethod_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.noResponseMethod(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kHandleRightsProtocol_ResponseMethod_Ordinal:
        final String _name = _kHandleRightsProtocol_ResponseMethod_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kHandleRightsProtocol_ResponseMethod_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<$zircon.Socket> $future = $fidl
              .decodeMessageWithCallback<$async.Future<$zircon.Socket>>(
                  $message,
                  _kHandleRightsProtocol_ResponseMethod_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.responseMethod(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kHandleRightsProtocol_ResponseMethod_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kHandleRightsProtocol_ResponseMethod_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kHandleRightsProtocol_ResponseMethod_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for HandleRightsProtocolBinding');
    }
  }
}

// fifteen: (bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15)
const int _kManyParameters_Fifteen_Ordinal = 0x59233bcecd338967;
const $fidl.MethodType _kManyParameters_Fifteen_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 1),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 2),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 3),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 4),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 5),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 6),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 7),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 8),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 9),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 10),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 11),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 12),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 13),
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 14),
  ],
  response: [],
  name: r"ManyParameters.Fifteen",
  requestInlineSizeV2: 15,
  responseInlineSizeV2: 0,
);

abstract class ManyParameters {
  $fidl.ServiceData? get $serviceData => ManyParametersData();
  $async.Future<void> fifteen(
      bool p1,
      bool p2,
      bool p3,
      bool p4,
      bool p5,
      bool p6,
      bool p7,
      bool p8,
      bool p9,
      bool p10,
      bool p11,
      bool p12,
      bool p13,
      bool p14,
      bool p15);
} // TODO: Remove ServiceData for non-service

class ManyParametersData implements $fidl.ServiceData<ManyParameters> {
  const ManyParametersData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return ManyParametersBinding();
  }
}

class ManyParametersProxy extends $fidl.AsyncProxy<ManyParameters>
    implements ManyParameters {
  ManyParametersProxy()
      : super($fidl.AsyncProxyController<ManyParameters>(
            $interfaceName: r'ManyParameters')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> fifteen(
      bool p1,
      bool p2,
      bool p3,
      bool p4,
      bool p5,
      bool p6,
      bool p7,
      bool p8,
      bool p9,
      bool p10,
      bool p11,
      bool p12,
      bool p13,
      bool p14,
      bool p15) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kManyParameters_Fifteen_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kManyParameters_Fifteen_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kManyParameters_Fifteen_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, p1, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, p2, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, p3, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, p4, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, p5, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, p6, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, p7, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, p8, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, p9, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, p10, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, p11, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, p12, $fidl.kMessageHeaderSize, 1);
      $types[12].encode($encoder, p13, $fidl.kMessageHeaderSize, 1);
      $types[13].encode($encoder, p14, $fidl.kMessageHeaderSize, 1);
      $types[14].encode($encoder, p15, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }
}

class ManyParametersBinding extends $fidl.AsyncBinding<ManyParameters> {
  ManyParametersBinding() : super(r"ManyParameters");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kManyParameters_Fifteen_Ordinal:
        final String _name = _kManyParameters_Fifteen_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kManyParameters_Fifteen_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kManyParameters_Fifteen_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.fifteen(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[1].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[2].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[3].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[4].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[5].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[6].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[7].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[8].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[9].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[10].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[11].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[12].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[13].decode(decoder, $fidl.kMessageHeaderSize, 1),
              $types[14].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for ManyParametersBinding');
    }
  }
}

// unionMethod: (TheUnion u) -> (TheUnion? u)
const int _kMethodWithUnion_UnionMethod_Ordinal = 0x393e7f5b2b821218;
const $fidl.MethodType _kMethodWithUnion_UnionMethod_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TheUnion>(type: kTheUnion_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<TheUnion?>(type: kTheUnion_OptType, offset: 0),
  ],
  name: r"MethodWithUnion.UnionMethod",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);

abstract class MethodWithUnion {
  $fidl.ServiceData? get $serviceData => MethodWithUnionData();
  $async.Future<TheUnion?> unionMethod(TheUnion u);
} // TODO: Remove ServiceData for non-service

class MethodWithUnionData implements $fidl.ServiceData<MethodWithUnion> {
  const MethodWithUnionData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return MethodWithUnionBinding();
  }
}

class MethodWithUnionProxy extends $fidl.AsyncProxy<MethodWithUnion>
    implements MethodWithUnion {
  MethodWithUnionProxy()
      : super($fidl.AsyncProxyController<MethodWithUnion>(
            $interfaceName: r'MethodWithUnion')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kMethodWithUnion_UnionMethod_Ordinal:
        final String _name = _kMethodWithUnion_UnionMethod_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMethodWithUnion_UnionMethod_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kMethodWithUnion_UnionMethod_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<TheUnion?> unionMethod(TheUnion u) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMethodWithUnion_UnionMethod_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMethodWithUnion_UnionMethod_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMethodWithUnion_UnionMethod_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, u, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<TheUnion?>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }
}

class MethodWithUnionBinding extends $fidl.AsyncBinding<MethodWithUnion> {
  MethodWithUnionBinding() : super(r"MethodWithUnion");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kMethodWithUnion_UnionMethod_Ordinal:
        final String _name = _kMethodWithUnion_UnionMethod_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMethodWithUnion_UnionMethod_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<TheUnion?> $future = $fidl
              .decodeMessageWithCallback<$async.Future<TheUnion?>>(
                  $message,
                  _kMethodWithUnion_UnionMethod_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.unionMethod(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMethodWithUnion_UnionMethod_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMethodWithUnion_UnionMethod_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMethodWithUnion_UnionMethod_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for MethodWithUnionBinding');
    }
  }
}

// request: (int x) -> (int y)
const int _kTransitional_Request_Ordinal = 0x512cc1ba467fef08;
const $fidl.MethodType _kTransitional_Request_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  name: r"Transitional.Request",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 8,
);
// oneWay: (int x)
const int _kTransitional_OneWay_Ordinal = 0x3c2ee8512dc7f7e7;
const $fidl.MethodType _kTransitional_OneWay_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  response: [],
  name: r"Transitional.OneWay",
  requestInlineSizeV2: 8,
  responseInlineSizeV2: 0,
);
// event:  -> (int x)
const int _kTransitional_Event_Ordinal = 0x76113c4b4d484841;
const $fidl.MethodType _kTransitional_Event_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 0),
  ],
  name: r"Transitional.Event",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 8,
);

abstract class Transitional {
  $fidl.ServiceData? get $serviceData => TransitionalData();
  $async.Future<int> request(int x) {
    return $async.Future.error(UnimplementedError(), StackTrace.current);
  }

  $async.Future<void> oneWay(int x) {
    return $async.Future.error(UnimplementedError(), StackTrace.current);
  }

  $async.Stream<int>? get event {
    return $async.Stream.empty();
  }
} // TODO: Remove ServiceData for non-service

class TransitionalData implements $fidl.ServiceData<Transitional> {
  const TransitionalData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return TransitionalBinding();
  }
}

class TransitionalProxy extends $fidl.AsyncProxy<Transitional>
    implements Transitional {
  TransitionalProxy()
      : super($fidl.AsyncProxyController<Transitional>(
            $interfaceName: r'Transitional')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _eventEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kTransitional_Event_Ordinal:
        final String _name = _kTransitional_Event_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _eventEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kTransitional_Event_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kTransitional_Event_Type.responseInlineSize($message.wireFormat),
              $types[0]);

          _eventEventStreamController.add($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kTransitional_Request_Ordinal:
        final String _name = _kTransitional_Request_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kTransitional_Request_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kTransitional_Request_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<int> request(int x) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kTransitional_Request_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types = _kTransitional_Request_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kTransitional_Request_Type.requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, x, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<void> oneWay(int x) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kTransitional_OneWay_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types = _kTransitional_OneWay_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kTransitional_OneWay_Type.requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, x, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  final _eventEventStreamController = $async.StreamController<int>.broadcast();
  @override
  $async.Stream<int> get event => _eventEventStreamController.stream;
}

class TransitionalBinding extends $fidl.AsyncBinding<Transitional> {
  TransitionalBinding() : super(r"Transitional") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _event_stream = impl.event;
        if (_event_stream != null) {
          $subscriptions.add(_event_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kTransitional_Event_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kTransitional_Event_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kTransitional_Event_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kTransitional_Event_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kTransitional_Request_Ordinal:
        final String _name = _kTransitional_Request_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kTransitional_Request_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kTransitional_Request_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.request(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kTransitional_Request_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kTransitional_Request_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kTransitional_Request_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kTransitional_OneWay_Ordinal:
        final String _name = _kTransitional_OneWay_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kTransitional_OneWay_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kTransitional_OneWay_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.oneWay(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for TransitionalBinding');
    }
  }
}

// noRequestNoResponse: ()
const int _kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
    0x4b212a6c8c5f7bab;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_NoRequestNoResponse_Type = $fidl.MethodType(
  request: [],
  response: [],
  name: r"WithAndWithoutRequestResponse.NoRequestNoResponse",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);
// noRequestEmptyResponse: () -> ()
const int _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
    0x16a329d17f458668;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type =
    $fidl.MethodType(
  request: [],
  response: [],
  name: r"WithAndWithoutRequestResponse.NoRequestEmptyResponse",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);
// noRequestWithResponse: () -> (String ret)
const int _kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
    0x7d6b2fcf0e2a65bd;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  name: r"WithAndWithoutRequestResponse.NoRequestWithResponse",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// withRequestNoResponse: (String arg)
const int _kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
    0x65ab625138c50a77;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  response: [],
  name: r"WithAndWithoutRequestResponse.WithRequestNoResponse",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// withRequestEmptyResponse: (String arg) -> ()
const int _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
    0x27ee4d2bd405df5f;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  response: [],
  name: r"WithAndWithoutRequestResponse.WithRequestEmptyResponse",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// withRequestWithResponse: (String arg) -> (String ret)
const int _kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
    0x590e91945d58f5b1;
const $fidl.MethodType
    _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  name: r"WithAndWithoutRequestResponse.WithRequestWithResponse",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onEmptyResponse:  -> ()
const int _kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
    0x4ae85a2b8d7c2e56;
const $fidl.MethodType _kWithAndWithoutRequestResponse_OnEmptyResponse_Type =
    $fidl.MethodType(
  request: [],
  response: [],
  name: r"WithAndWithoutRequestResponse.OnEmptyResponse",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);
// onWithResponse:  -> (String ret)
const int _kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
    0x50a6f21a322f31a8;
const $fidl.MethodType _kWithAndWithoutRequestResponse_OnWithResponse_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 0),
  ],
  name: r"WithAndWithoutRequestResponse.OnWithResponse",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

abstract class WithAndWithoutRequestResponse {
  $fidl.ServiceData? get $serviceData => WithAndWithoutRequestResponseData();
  $async.Future<void> noRequestNoResponse();
  $async.Future<void> noRequestEmptyResponse();
  $async.Future<String> noRequestWithResponse();
  $async.Future<void> withRequestNoResponse(String arg);
  $async.Future<void> withRequestEmptyResponse(String arg);
  $async.Future<String> withRequestWithResponse(String arg);
  $async.Stream<void>? get onEmptyResponse;
  $async.Stream<String>? get onWithResponse;
} // TODO: Remove ServiceData for non-service

class WithAndWithoutRequestResponseData
    implements $fidl.ServiceData<WithAndWithoutRequestResponse> {
  const WithAndWithoutRequestResponseData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return WithAndWithoutRequestResponseBinding();
  }
}

class WithAndWithoutRequestResponseProxy
    extends $fidl.AsyncProxy<WithAndWithoutRequestResponse>
    implements WithAndWithoutRequestResponse {
  WithAndWithoutRequestResponseProxy()
      : super($fidl.AsyncProxyController<WithAndWithoutRequestResponse>(
            $interfaceName: r'WithAndWithoutRequestResponse')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _onEmptyResponseEventStreamController.close();
      _onWithResponseEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_OnEmptyResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onEmptyResponseEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_OnEmptyResponse_Type.response!;
          // ignore: prefer_const_declarations
          final $response = null;

          _onEmptyResponseEventStreamController.add($response);
        });
        break;
      case _kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_OnWithResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onWithResponseEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_OnWithResponse_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithAndWithoutRequestResponse_OnWithResponse_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          _onWithResponseEventStreamController.add($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type
                  .response!;
          // ignore: prefer_const_declarations
          final $response = null;

          $completer.complete($response);
        });
        break;
      case _kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                  .response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type
                  .response!;
          // ignore: prefer_const_declarations
          final $response = null;

          $completer.complete($response);
        });
        break;
      case _kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                  .response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> noRequestNoResponse() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<void> noRequestEmptyResponse() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final $completer = $async.Completer<void>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<String> noRequestWithResponse() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final $completer = $async.Completer<String>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<void> withRequestNoResponse(String arg) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arg, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<void> withRequestEmptyResponse(String arg) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arg, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<void>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<String> withRequestWithResponse(String arg) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arg, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<String>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onEmptyResponseEventStreamController =
      $async.StreamController<void>.broadcast();
  @override
  $async.Stream<void> get onEmptyResponse =>
      _onEmptyResponseEventStreamController.stream;

  final _onWithResponseEventStreamController =
      $async.StreamController<String>.broadcast();
  @override
  $async.Stream<String> get onWithResponse =>
      _onWithResponseEventStreamController.stream;
}

class WithAndWithoutRequestResponseBinding
    extends $fidl.AsyncBinding<WithAndWithoutRequestResponse> {
  WithAndWithoutRequestResponseBinding()
      : super(r"WithAndWithoutRequestResponse") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _onEmptyResponse_stream = impl.onEmptyResponse;
        if (_onEmptyResponse_stream != null) {
          $subscriptions.add(_onEmptyResponse_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithAndWithoutRequestResponse_OnEmptyResponse_Type.response!;

            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kWithAndWithoutRequestResponse_OnEmptyResponse_Type.name,
                _e,
                close);
          }));
        }
        final _onWithResponse_stream = impl.onWithResponse;
        if (_onWithResponse_stream != null) {
          $subscriptions.add(_onWithResponse_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_OnWithResponse_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithAndWithoutRequestResponse_OnWithResponse_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithAndWithoutRequestResponse_OnWithResponse_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kWithAndWithoutRequestResponse_OnWithResponse_Type.name,
                _e,
                close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_NoRequestNoResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_NoRequestNoResponse_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithAndWithoutRequestResponse_NoRequestNoResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.noRequestNoResponse();
          });
        }, close);
        break;
      case _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.noRequestEmptyResponse();
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<String> $future = $fidl
              .decodeMessageWithCallback<$async.Future<String>>(
                  $message,
                  _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.noRequestWithResponse();
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                    .response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithAndWithoutRequestResponse_NoRequestWithResponse_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithAndWithoutRequestResponse_WithRequestNoResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.withRequestNoResponse(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
        }, close);
        break;
      case _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.withRequestEmptyResponse(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal:
        final String _name =
            _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<String> $future = $fidl
              .decodeMessageWithCallback<$async.Future<String>>(
                  $message,
                  _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.withRequestWithResponse(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                    .response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithAndWithoutRequestResponse_WithRequestWithResponse_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for WithAndWithoutRequestResponseBinding');
    }
  }
}

// responseAsStruct: () -> (int a, int b, int c)
const int _kWithErrorSyntax_ResponseAsStruct_Ordinal = 0x3b902a6d8d24693;
const $fidl.MethodType _kWithErrorSyntax_ResponseAsStruct_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<WithErrorSyntaxResponseAsStructResult>(
        type: kWithErrorSyntax_ResponseAsStruct_Result_Type, offset: 0),
  ],
  name: r"WithErrorSyntax.ResponseAsStruct",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// errorAsPrimitive: () -> ()
const int _kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 0x602fd6bd920135e7;
const $fidl.MethodType _kWithErrorSyntax_ErrorAsPrimitive_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<WithErrorSyntaxErrorAsPrimitiveResult>(
        type: kWithErrorSyntax_ErrorAsPrimitive_Result_Type, offset: 0),
  ],
  name: r"WithErrorSyntax.ErrorAsPrimitive",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// errorAsEnum: () -> ()
const int _kWithErrorSyntax_ErrorAsEnum_Ordinal = 0x4c371e1673212f43;
const $fidl.MethodType _kWithErrorSyntax_ErrorAsEnum_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<WithErrorSyntaxErrorAsEnumResult>(
        type: kWithErrorSyntax_ErrorAsEnum_Result_Type, offset: 0),
  ],
  name: r"WithErrorSyntax.ErrorAsEnum",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// handleInResult: () -> ($zircon.Handle h)
const int _kWithErrorSyntax_HandleInResult_Ordinal = 0x13092c5b835b0cbf;
const $fidl.MethodType _kWithErrorSyntax_HandleInResult_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<WithErrorSyntaxHandleInResultResult>(
        type: kWithErrorSyntax_HandleInResult_Result_Type, offset: 0),
  ],
  name: r"WithErrorSyntax.HandleInResult",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

class WithErrorSyntax$ResponseAsStruct$Response {
  final int a;
  final int b;
  final int c;
  WithErrorSyntax$ResponseAsStruct$Response(
    this.a,
    this.b,
    this.c,
  );
}

abstract class WithErrorSyntax {
  $fidl.ServiceData? get $serviceData => WithErrorSyntaxData();
  $async.Future<WithErrorSyntax$ResponseAsStruct$Response> responseAsStruct();
  $async.Future<void> errorAsPrimitive();
  $async.Future<void> errorAsEnum();
  $async.Future<$zircon.Handle> handleInResult();
} // TODO: Remove ServiceData for non-service

class WithErrorSyntaxData implements $fidl.ServiceData<WithErrorSyntax> {
  const WithErrorSyntaxData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return WithErrorSyntaxBinding();
  }
}

class WithErrorSyntaxProxy extends $fidl.AsyncProxy<WithErrorSyntax>
    implements WithErrorSyntax {
  WithErrorSyntaxProxy()
      : super($fidl.AsyncProxyController<WithErrorSyntax>(
            $interfaceName: r'WithErrorSyntax')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kWithErrorSyntax_ResponseAsStruct_Ordinal:
        final String _name = _kWithErrorSyntax_ResponseAsStruct_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ResponseAsStruct_Type.response!;
          // ignore: prefer_const_declarations
          final WithErrorSyntaxResponseAsStructResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kWithErrorSyntax_ResponseAsStruct_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              WithErrorSyntaxResponseAsStructResultTag.response) {
            $completer.complete(WithErrorSyntax$ResponseAsStruct$Response(
              $response.response!.a,
              $response.response!.b,
              $response.response!.c,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
        final String _name = _kWithErrorSyntax_ErrorAsPrimitive_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ErrorAsPrimitive_Type.response!;
          // ignore: prefer_const_declarations
          final WithErrorSyntaxErrorAsPrimitiveResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kWithErrorSyntax_ErrorAsPrimitive_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              WithErrorSyntaxErrorAsPrimitiveResultTag.response) {
            $completer.complete(null);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kWithErrorSyntax_ErrorAsEnum_Ordinal:
        final String _name = _kWithErrorSyntax_ErrorAsEnum_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ErrorAsEnum_Type.response!;
          // ignore: prefer_const_declarations
          final WithErrorSyntaxErrorAsEnumResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kWithErrorSyntax_ErrorAsEnum_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag == WithErrorSyntaxErrorAsEnumResultTag.response) {
            $completer.complete(null);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kWithErrorSyntax_HandleInResult_Ordinal:
        final String _name = _kWithErrorSyntax_HandleInResult_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_HandleInResult_Type.response!;
          // ignore: prefer_const_declarations
          final WithErrorSyntaxHandleInResultResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kWithErrorSyntax_HandleInResult_Type
                      .responseInlineSize($message.wireFormat),
                  $types[0]);

          if ($response.$tag ==
              WithErrorSyntaxHandleInResultResultTag.response) {
            $completer.complete($response.response!.h);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<WithErrorSyntax$ResponseAsStruct$Response> responseAsStruct() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kWithErrorSyntax_ResponseAsStruct_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final $completer =
        $async.Completer<WithErrorSyntax$ResponseAsStruct$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<void> errorAsPrimitive() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kWithErrorSyntax_ErrorAsPrimitive_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final $completer = $async.Completer<void>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<void> errorAsEnum() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithErrorSyntax_ErrorAsEnum_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<void>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<$zircon.Handle> handleInResult() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kWithErrorSyntax_HandleInResult_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final $completer = $async.Completer<$zircon.Handle>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }
}

class WithErrorSyntaxBinding extends $fidl.AsyncBinding<WithErrorSyntax> {
  WithErrorSyntaxBinding() : super(r"WithErrorSyntax");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kWithErrorSyntax_ResponseAsStruct_Ordinal:
        final String _name = _kWithErrorSyntax_ResponseAsStruct_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ResponseAsStruct_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<WithErrorSyntax$ResponseAsStruct$Response>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<WithErrorSyntax$ResponseAsStruct$Response>>(
                  $message,
                  _kWithErrorSyntax_ResponseAsStruct_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.responseAsStruct();
          });
          $future.then(($responseValue) {
            return WithErrorSyntaxResponseAsStructResult.withResponse(
                WithErrorSyntaxResponseAsStructResponse(
              a: $responseValue.a,
              b: $responseValue.b,
              c: $responseValue.c,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return WithErrorSyntaxResponseAsStructResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithErrorSyntax_ResponseAsStruct_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithErrorSyntax_ResponseAsStruct_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithErrorSyntax_ResponseAsStruct_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithErrorSyntax_ErrorAsPrimitive_Ordinal:
        final String _name = _kWithErrorSyntax_ErrorAsPrimitive_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ErrorAsPrimitive_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithErrorSyntax_ErrorAsPrimitive_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.errorAsPrimitive();
          });
          $future.then(($responseValue) {
            return WithErrorSyntaxErrorAsPrimitiveResult.withResponse(
                WithErrorSyntaxErrorAsPrimitiveResponse());
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return WithErrorSyntaxErrorAsPrimitiveResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithErrorSyntax_ErrorAsPrimitive_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithErrorSyntax_ErrorAsPrimitive_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithErrorSyntax_ErrorAsEnum_Ordinal:
        final String _name = _kWithErrorSyntax_ErrorAsEnum_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_ErrorAsEnum_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kWithErrorSyntax_ErrorAsEnum_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.errorAsEnum();
          });
          $future.then(($responseValue) {
            return WithErrorSyntaxErrorAsEnumResult.withResponse(
                WithErrorSyntaxErrorAsEnumResponse());
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return WithErrorSyntaxErrorAsEnumResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kWithErrorSyntax_ErrorAsEnum_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithErrorSyntax_ErrorAsEnum_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithErrorSyntax_ErrorAsEnum_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithErrorSyntax_HandleInResult_Ordinal:
        final String _name = _kWithErrorSyntax_HandleInResult_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithErrorSyntax_HandleInResult_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<$zircon.Handle> $future = $fidl
              .decodeMessageWithCallback<$async.Future<$zircon.Handle>>(
                  $message,
                  _kWithErrorSyntax_HandleInResult_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.handleInResult();
          });
          $future.then(($responseValue) {
            return WithErrorSyntaxHandleInResultResult.withResponse(
                WithErrorSyntaxHandleInResultResponse(h: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return WithErrorSyntaxHandleInResultResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithErrorSyntax_HandleInResult_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithErrorSyntax_HandleInResult_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithErrorSyntax_HandleInResult_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for WithErrorSyntaxBinding');
    }
  }
}

// clientEnds: ($fidl.InterfaceHandle<DiscoverableProtocol> in$) -> ($fidl.InterfaceHandle<DiscoverableProtocol>? out)
const int _kWithProtocolEnds_ClientEnds_Ordinal = 0x51780563edb15042;
const $fidl.MethodType _kWithProtocolEnds_ClientEnds_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$fidl.InterfaceHandle<DiscoverableProtocol>>(
        type: $fidl.InterfaceHandleType<DiscoverableProtocol>(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$fidl.InterfaceHandle<DiscoverableProtocol>?>(
        type: $fidl.NullableInterfaceHandleType<DiscoverableProtocol>(),
        offset: 0),
  ],
  name: r"WithProtocolEnds.ClientEnds",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);
// serverEnds: ($fidl.InterfaceRequest<DiscoverableProtocol>? in$) -> ($fidl.InterfaceRequest<DiscoverableProtocol> out)
const int _kWithProtocolEnds_ServerEnds_Ordinal = 0x70a02c2ba2228a33;
const $fidl.MethodType _kWithProtocolEnds_ServerEnds_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$fidl.InterfaceRequest<DiscoverableProtocol>?>(
        type: $fidl.NullableInterfaceRequestType<DiscoverableProtocol>(),
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$fidl.InterfaceRequest<DiscoverableProtocol>>(
        type: $fidl.InterfaceRequestType<DiscoverableProtocol>(), offset: 0),
  ],
  name: r"WithProtocolEnds.ServerEnds",
  requestInlineSizeV2: 4,
  responseInlineSizeV2: 4,
);
// structContainingEnds: (ProtocolEnds in$) -> (ProtocolEnds out)
const int _kWithProtocolEnds_StructContainingEnds_Ordinal = 0x3893f0baad26f5d5;
const $fidl.MethodType _kWithProtocolEnds_StructContainingEnds_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolEnds>(type: kProtocolEnds_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolEnds>(type: kProtocolEnds_Type, offset: 0),
  ],
  name: r"WithProtocolEnds.StructContainingEnds",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);

abstract class WithProtocolEnds {
  $fidl.ServiceData? get $serviceData => WithProtocolEndsData();
  $async.Future<$fidl.InterfaceHandle<DiscoverableProtocol>?> clientEnds(
      $fidl.InterfaceHandle<DiscoverableProtocol> in$);
  $async.Future<$fidl.InterfaceRequest<DiscoverableProtocol>> serverEnds(
      $fidl.InterfaceRequest<DiscoverableProtocol>? in$);
  $async.Future<ProtocolEnds> structContainingEnds(ProtocolEnds in$);
} // TODO: Remove ServiceData for non-service

class WithProtocolEndsData implements $fidl.ServiceData<WithProtocolEnds> {
  const WithProtocolEndsData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return WithProtocolEndsBinding();
  }
}

class WithProtocolEndsProxy extends $fidl.AsyncProxy<WithProtocolEnds>
    implements WithProtocolEnds {
  WithProtocolEndsProxy()
      : super($fidl.AsyncProxyController<WithProtocolEnds>(
            $interfaceName: r'WithProtocolEnds')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kWithProtocolEnds_ClientEnds_Ordinal:
        final String _name = _kWithProtocolEnds_ClientEnds_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_ClientEnds_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithProtocolEnds_ClientEnds_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kWithProtocolEnds_ServerEnds_Ordinal:
        final String _name = _kWithProtocolEnds_ServerEnds_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_ServerEnds_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithProtocolEnds_ServerEnds_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      case _kWithProtocolEnds_StructContainingEnds_Ordinal:
        final String _name = _kWithProtocolEnds_StructContainingEnds_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_StructContainingEnds_Type.response!;
          // ignore: prefer_const_declarations
          final $response = $fidl.decodeMessage(
              $message,
              _kWithProtocolEnds_StructContainingEnds_Type
                  .responseInlineSize($message.wireFormat),
              $types[0]);

          $completer.complete($response);
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<$fidl.InterfaceHandle<DiscoverableProtocol>?> clientEnds(
      $fidl.InterfaceHandle<DiscoverableProtocol> in$) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithProtocolEnds_ClientEnds_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithProtocolEnds_ClientEnds_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithProtocolEnds_ClientEnds_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, in$, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<$fidl.InterfaceHandle<DiscoverableProtocol>?>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<$fidl.InterfaceRequest<DiscoverableProtocol>> serverEnds(
      $fidl.InterfaceRequest<DiscoverableProtocol>? in$) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithProtocolEnds_ServerEnds_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithProtocolEnds_ServerEnds_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithProtocolEnds_ServerEnds_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, in$, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<$fidl.InterfaceRequest<DiscoverableProtocol>>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<ProtocolEnds> structContainingEnds(ProtocolEnds in$) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kWithProtocolEnds_StructContainingEnds_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kWithProtocolEnds_StructContainingEnds_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kWithProtocolEnds_StructContainingEnds_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, in$, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<ProtocolEnds>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }
}

class WithProtocolEndsBinding extends $fidl.AsyncBinding<WithProtocolEnds> {
  WithProtocolEndsBinding() : super(r"WithProtocolEnds");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    switch ($message.ordinal) {
      case _kWithProtocolEnds_ClientEnds_Ordinal:
        final String _name = _kWithProtocolEnds_ClientEnds_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_ClientEnds_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<$fidl.InterfaceHandle<DiscoverableProtocol>?>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          $fidl.InterfaceHandle<DiscoverableProtocol>?>>(
                  $message,
                  _kWithProtocolEnds_ClientEnds_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.clientEnds(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kWithProtocolEnds_ClientEnds_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithProtocolEnds_ClientEnds_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithProtocolEnds_ClientEnds_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithProtocolEnds_ServerEnds_Ordinal:
        final String _name = _kWithProtocolEnds_ServerEnds_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_ServerEnds_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<$fidl.InterfaceRequest<DiscoverableProtocol>>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<
                          $fidl.InterfaceRequest<DiscoverableProtocol>>>(
                  $message,
                  _kWithProtocolEnds_ServerEnds_Type.requestInlineSize(
                      $message.wireFormat), ($fidl.Decoder decoder) {
            return _impl.serverEnds(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kWithProtocolEnds_ServerEnds_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithProtocolEnds_ServerEnds_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithProtocolEnds_ServerEnds_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kWithProtocolEnds_StructContainingEnds_Ordinal:
        final String _name = _kWithProtocolEnds_StructContainingEnds_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kWithProtocolEnds_StructContainingEnds_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<ProtocolEnds> $future = $fidl
              .decodeMessageWithCallback<$async.Future<ProtocolEnds>>(
                  $message,
                  _kWithProtocolEnds_StructContainingEnds_Type
                      .requestInlineSize($message.wireFormat),
                  ($fidl.Decoder decoder) {
            return _impl.structContainingEnds(
              $types[0].decode(decoder, $fidl.kMessageHeaderSize, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kWithProtocolEnds_StructContainingEnds_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kWithProtocolEnds_StructContainingEnds_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kWithProtocolEnds_StructContainingEnds_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for WithProtocolEndsBinding');
    }
  }
}

// WARNING: This file is machine generated by fidlgen_dart.
// @dart = 2.10

library fidl_fidl_test_handles_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings

class ObjType extends $fidl.Enum {
  factory ObjType(int _v) {
    switch (_v) {
      case 0x0:
        return none;
      case 0x1:
        return process;
      case 0x2:
        return thread;
      case 0x3:
        return vmo;
      case 0x4:
        return channel;
      case 0x5:
        return event;
      case 0x6:
        return port;
      case 0x9:
        return interrupt;
      case 0xb:
        return pciDevice;
      case 0xc:
        return log;
      case 0xe:
        return socket;
      case 0xf:
        return resource;
      case 0x10:
        return eventpair;
      case 0x11:
        return job;
      case 0x12:
        return vmar;
      case 0x13:
        return fifo;
      case 0x14:
        return guest;
      case 0x15:
        return vcpu;
      case 0x16:
        return timer;
      case 0x17:
        return iommu;
      case 0x18:
        return bti;
      case 0x19:
        return profile;
      case 0x1a:
        return pmt;
      case 0x1b:
        return suspendToken;
      case 0x1c:
        return pager;
      case 0x1d:
        return exception;
      case 0x1e:
        return clock;
      case 0x1f:
        return stream;
      case 0x20:
        return msiAllocation;
      case 0x21:
        return msiInterrupt;
      default:
        throw $fidl.FidlError('Invalid strict enum value: $_v',
            $fidl.FidlErrorCode.fidlInvalidEnumValue);
    }
  }
  static const ObjType none = ObjType._(0x0);
  static const ObjType process = ObjType._(0x1);
  static const ObjType thread = ObjType._(0x2);
  static const ObjType vmo = ObjType._(0x3);
  static const ObjType channel = ObjType._(0x4);
  static const ObjType event = ObjType._(0x5);
  static const ObjType port = ObjType._(0x6);
  static const ObjType interrupt = ObjType._(0x9);
  static const ObjType pciDevice = ObjType._(0xb);
  static const ObjType log = ObjType._(0xc);
  static const ObjType socket = ObjType._(0xe);
  static const ObjType resource = ObjType._(0xf);
  static const ObjType eventpair = ObjType._(0x10);
  static const ObjType job = ObjType._(0x11);
  static const ObjType vmar = ObjType._(0x12);
  static const ObjType fifo = ObjType._(0x13);
  static const ObjType guest = ObjType._(0x14);
  static const ObjType vcpu = ObjType._(0x15);
  static const ObjType timer = ObjType._(0x16);
  static const ObjType iommu = ObjType._(0x17);
  static const ObjType bti = ObjType._(0x18);
  static const ObjType profile = ObjType._(0x19);
  static const ObjType pmt = ObjType._(0x1a);
  static const ObjType suspendToken = ObjType._(0x1b);
  static const ObjType pager = ObjType._(0x1c);
  static const ObjType exception = ObjType._(0x1d);
  static const ObjType clock = ObjType._(0x1e);
  static const ObjType stream = ObjType._(0x1f);
  static const ObjType msiAllocation = ObjType._(0x20);
  static const ObjType msiInterrupt = ObjType._(0x21);

  const ObjType._(this.$value);

  @override
  final int $value;

  static const Map<String, ObjType> $valuesMap = {
    r'none': none,
    r'process': process,
    r'thread': thread,
    r'vmo': vmo,
    r'channel': channel,
    r'event': event,
    r'port': port,
    r'interrupt': interrupt,
    r'pciDevice': pciDevice,
    r'log': log,
    r'socket': socket,
    r'resource': resource,
    r'eventpair': eventpair,
    r'job': job,
    r'vmar': vmar,
    r'fifo': fifo,
    r'guest': guest,
    r'vcpu': vcpu,
    r'timer': timer,
    r'iommu': iommu,
    r'bti': bti,
    r'profile': profile,
    r'pmt': pmt,
    r'suspendToken': suspendToken,
    r'pager': pager,
    r'exception': exception,
    r'clock': clock,
    r'stream': stream,
    r'msiAllocation': msiAllocation,
    r'msiInterrupt': msiInterrupt,
  };

  static const List<ObjType> $values = [
    none,
    process,
    thread,
    vmo,
    channel,
    event,
    port,
    interrupt,
    pciDevice,
    log,
    socket,
    resource,
    eventpair,
    job,
    vmar,
    fifo,
    guest,
    vcpu,
    timer,
    iommu,
    bti,
    profile,
    pmt,
    suspendToken,
    pager,
    exception,
    clock,
    stream,
    msiAllocation,
    msiInterrupt,
  ];

  static ObjType? $valueOf(String name) => $valuesMap[name];

  @override
  bool isUnknown() {
    return false;
  }

  @override
  String toString() {
    switch ($value) {
      case 0x0:
        return r'ObjType.none';
      case 0x1:
        return r'ObjType.process';
      case 0x2:
        return r'ObjType.thread';
      case 0x3:
        return r'ObjType.vmo';
      case 0x4:
        return r'ObjType.channel';
      case 0x5:
        return r'ObjType.event';
      case 0x6:
        return r'ObjType.port';
      case 0x9:
        return r'ObjType.interrupt';
      case 0xb:
        return r'ObjType.pciDevice';
      case 0xc:
        return r'ObjType.log';
      case 0xe:
        return r'ObjType.socket';
      case 0xf:
        return r'ObjType.resource';
      case 0x10:
        return r'ObjType.eventpair';
      case 0x11:
        return r'ObjType.job';
      case 0x12:
        return r'ObjType.vmar';
      case 0x13:
        return r'ObjType.fifo';
      case 0x14:
        return r'ObjType.guest';
      case 0x15:
        return r'ObjType.vcpu';
      case 0x16:
        return r'ObjType.timer';
      case 0x17:
        return r'ObjType.iommu';
      case 0x18:
        return r'ObjType.bti';
      case 0x19:
        return r'ObjType.profile';
      case 0x1a:
        return r'ObjType.pmt';
      case 0x1b:
        return r'ObjType.suspendToken';
      case 0x1c:
        return r'ObjType.pager';
      case 0x1d:
        return r'ObjType.exception';
      case 0x1e:
        return r'ObjType.clock';
      case 0x1f:
        return r'ObjType.stream';
      case 0x20:
        return r'ObjType.msiAllocation';
      case 0x21:
        return r'ObjType.msiInterrupt';
      default:
        return r'ObjType.' '${$value}';
    }
  }

  static ObjType _ctor(int v) => ObjType(v);
}

const $fidl.EnumType<ObjType> kobj_type_Type = $fidl.EnumType<ObjType>(
    type: $fidl.Uint32Type(),
    values: {
      0x0: null,
      0x1: null,
      0x2: null,
      0x3: null,
      0x4: null,
      0x5: null,
      0x6: null,
      0x9: null,
      0xb: null,
      0xc: null,
      0xe: null,
      0xf: null,
      0x10: null,
      0x11: null,
      0x12: null,
      0x13: null,
      0x14: null,
      0x15: null,
      0x16: null,
      0x17: null,
      0x18: null,
      0x19: null,
      0x1a: null,
      0x1b: null,
      0x1c: null,
      0x1d: null,
      0x1e: null,
      0x1f: null,
      0x20: null,
      0x21: null
    },
    ctor: ObjType._ctor);

class Handles extends $fidl.Struct {
  const Handles({
    required this.plainHandle,
    required this.btiHandle,
    required this.channelHandle,
    required this.clockHandle,
    required this.debuglogHandle,
    required this.eventHandle,
    required this.eventpairHandle,
    required this.exceptionHandle,
    required this.fifoHandle,
    required this.guestHandle,
    required this.interruptHandle,
    required this.iommuHandle,
    required this.jobHandle,
    required this.pagerHandle,
    required this.pcideviceHandle,
    required this.pmtHandle,
    required this.portHandle,
    required this.processHandle,
    required this.profileHandle,
    required this.resourceHandle,
    required this.socketHandle,
    required this.suspendtokenHandle,
    required this.threadHandle,
    required this.timerHandle,
    required this.vcpuHandle,
    required this.vmarHandle,
    required this.vmoHandle,
    required this.rightsHandle,
    required this.aliasedPlainHandleField,
    required this.aliasedSubtypeHandleField,
    required this.aliasedRightsHandleField,
    required this.someProtocol,
    required this.requestSomeProtocol,
  });
  Handles.clone(
    Handles $orig, {
    $zircon.Handle? plainHandle,
    $zircon.Handle? btiHandle,
    $zircon.Channel? channelHandle,
    $zircon.Handle? clockHandle,
    $zircon.Handle? debuglogHandle,
    $zircon.Handle? eventHandle,
    $zircon.EventPair? eventpairHandle,
    $zircon.Handle? exceptionHandle,
    $zircon.Handle? fifoHandle,
    $zircon.Handle? guestHandle,
    $zircon.Handle? interruptHandle,
    $zircon.Handle? iommuHandle,
    $zircon.Handle? jobHandle,
    $zircon.Handle? pagerHandle,
    $zircon.Handle? pcideviceHandle,
    $zircon.Handle? pmtHandle,
    $zircon.Handle? portHandle,
    $zircon.Handle? processHandle,
    $zircon.Handle? profileHandle,
    $zircon.Handle? resourceHandle,
    $zircon.Socket? socketHandle,
    $zircon.Handle? suspendtokenHandle,
    $zircon.Handle? threadHandle,
    $zircon.Handle? timerHandle,
    $zircon.Handle? vcpuHandle,
    $zircon.Handle? vmarHandle,
    $zircon.Vmo? vmoHandle,
    $zircon.Vmo? rightsHandle,
    $zircon.Handle? aliasedPlainHandleField,
    $zircon.Vmo? aliasedSubtypeHandleField,
    $zircon.Vmo? aliasedRightsHandleField,
    $fidl.InterfaceHandle<SomeProtocol>? someProtocol,
    $fidl.InterfaceRequest<SomeProtocol>? requestSomeProtocol,
  }) : this(
          plainHandle: plainHandle ?? $orig.plainHandle,
          btiHandle: btiHandle ?? $orig.btiHandle,
          channelHandle: channelHandle ?? $orig.channelHandle,
          clockHandle: clockHandle ?? $orig.clockHandle,
          debuglogHandle: debuglogHandle ?? $orig.debuglogHandle,
          eventHandle: eventHandle ?? $orig.eventHandle,
          eventpairHandle: eventpairHandle ?? $orig.eventpairHandle,
          exceptionHandle: exceptionHandle ?? $orig.exceptionHandle,
          fifoHandle: fifoHandle ?? $orig.fifoHandle,
          guestHandle: guestHandle ?? $orig.guestHandle,
          interruptHandle: interruptHandle ?? $orig.interruptHandle,
          iommuHandle: iommuHandle ?? $orig.iommuHandle,
          jobHandle: jobHandle ?? $orig.jobHandle,
          pagerHandle: pagerHandle ?? $orig.pagerHandle,
          pcideviceHandle: pcideviceHandle ?? $orig.pcideviceHandle,
          pmtHandle: pmtHandle ?? $orig.pmtHandle,
          portHandle: portHandle ?? $orig.portHandle,
          processHandle: processHandle ?? $orig.processHandle,
          profileHandle: profileHandle ?? $orig.profileHandle,
          resourceHandle: resourceHandle ?? $orig.resourceHandle,
          socketHandle: socketHandle ?? $orig.socketHandle,
          suspendtokenHandle: suspendtokenHandle ?? $orig.suspendtokenHandle,
          threadHandle: threadHandle ?? $orig.threadHandle,
          timerHandle: timerHandle ?? $orig.timerHandle,
          vcpuHandle: vcpuHandle ?? $orig.vcpuHandle,
          vmarHandle: vmarHandle ?? $orig.vmarHandle,
          vmoHandle: vmoHandle ?? $orig.vmoHandle,
          rightsHandle: rightsHandle ?? $orig.rightsHandle,
          aliasedPlainHandleField:
              aliasedPlainHandleField ?? $orig.aliasedPlainHandleField,
          aliasedSubtypeHandleField:
              aliasedSubtypeHandleField ?? $orig.aliasedSubtypeHandleField,
          aliasedRightsHandleField:
              aliasedRightsHandleField ?? $orig.aliasedRightsHandleField,
          someProtocol: someProtocol ?? $orig.someProtocol,
          requestSomeProtocol: requestSomeProtocol ?? $orig.requestSomeProtocol,
        );

  final $zircon.Handle plainHandle;
  final $zircon.Handle btiHandle;
  final $zircon.Channel channelHandle;
  final $zircon.Handle clockHandle;
  final $zircon.Handle debuglogHandle;
  final $zircon.Handle eventHandle;
  final $zircon.EventPair eventpairHandle;
  final $zircon.Handle exceptionHandle;
  final $zircon.Handle fifoHandle;
  final $zircon.Handle guestHandle;
  final $zircon.Handle interruptHandle;
  final $zircon.Handle iommuHandle;
  final $zircon.Handle jobHandle;
  final $zircon.Handle pagerHandle;
  final $zircon.Handle pcideviceHandle;
  final $zircon.Handle pmtHandle;
  final $zircon.Handle portHandle;
  final $zircon.Handle processHandle;
  final $zircon.Handle profileHandle;
  final $zircon.Handle resourceHandle;
  final $zircon.Socket socketHandle;
  final $zircon.Handle suspendtokenHandle;
  final $zircon.Handle threadHandle;
  final $zircon.Handle timerHandle;
  final $zircon.Handle vcpuHandle;
  final $zircon.Handle vmarHandle;
  final $zircon.Vmo vmoHandle;
  final $zircon.Vmo rightsHandle;
  final $zircon.Handle aliasedPlainHandleField;
  final $zircon.Vmo aliasedSubtypeHandleField;
  final $zircon.Vmo aliasedRightsHandleField;
  final $fidl.InterfaceHandle<SomeProtocol> someProtocol;
  final $fidl.InterfaceRequest<SomeProtocol> requestSomeProtocol;

  @override
  List<Object?> get $fields {
    return <Object?>[
      plainHandle,
      btiHandle,
      channelHandle,
      clockHandle,
      debuglogHandle,
      eventHandle,
      eventpairHandle,
      exceptionHandle,
      fifoHandle,
      guestHandle,
      interruptHandle,
      iommuHandle,
      jobHandle,
      pagerHandle,
      pcideviceHandle,
      pmtHandle,
      portHandle,
      processHandle,
      profileHandle,
      resourceHandle,
      socketHandle,
      suspendtokenHandle,
      threadHandle,
      timerHandle,
      vcpuHandle,
      vmarHandle,
      vmoHandle,
      rightsHandle,
      aliasedPlainHandleField,
      aliasedSubtypeHandleField,
      aliasedRightsHandleField,
      someProtocol,
      requestSomeProtocol,
    ];
  }

  static const $fieldType0 = $fidl.HandleType();
  static const $fieldType1 = $fidl.HandleType();
  static const $fieldType2 = $fidl.ChannelType();
  static const $fieldType3 = $fidl.HandleType();
  static const $fieldType4 = $fidl.HandleType();
  static const $fieldType5 = $fidl.HandleType();
  static const $fieldType6 = $fidl.EventPairType();
  static const $fieldType7 = $fidl.HandleType();
  static const $fieldType8 = $fidl.HandleType();
  static const $fieldType9 = $fidl.HandleType();
  static const $fieldType10 = $fidl.HandleType();
  static const $fieldType11 = $fidl.HandleType();
  static const $fieldType12 = $fidl.HandleType();
  static const $fieldType13 = $fidl.HandleType();
  static const $fieldType14 = $fidl.HandleType();
  static const $fieldType15 = $fidl.HandleType();
  static const $fieldType16 = $fidl.HandleType();
  static const $fieldType17 = $fidl.HandleType();
  static const $fieldType18 = $fidl.HandleType();
  static const $fieldType19 = $fidl.HandleType();
  static const $fieldType20 = $fidl.SocketType();
  static const $fieldType21 = $fidl.HandleType();
  static const $fieldType22 = $fidl.HandleType();
  static const $fieldType23 = $fidl.HandleType();
  static const $fieldType24 = $fidl.HandleType();
  static const $fieldType25 = $fidl.HandleType();
  static const $fieldType26 = $fidl.VmoType();
  static const $fieldType27 = $fidl.VmoType();
  static const $fieldType28 = $fidl.HandleType();
  static const $fieldType29 = $fidl.VmoType();
  static const $fieldType30 = $fidl.VmoType();
  static const $fieldType31 = $fidl.InterfaceHandleType<SomeProtocol>();
  static const $fieldType32 = $fidl.InterfaceRequestType<SomeProtocol>();

  @override
  void $encode($fidl.Encoder $encoder, int $offset) {
    $fieldType0.encode($encoder, plainHandle, $offset + 0);
    $fieldType1.encode($encoder, btiHandle, $offset + 4);
    $fieldType2.encode($encoder, channelHandle, $offset + 8);
    $fieldType3.encode($encoder, clockHandle, $offset + 12);
    $fieldType4.encode($encoder, debuglogHandle, $offset + 16);
    $fieldType5.encode($encoder, eventHandle, $offset + 20);
    $fieldType6.encode($encoder, eventpairHandle, $offset + 24);
    $fieldType7.encode($encoder, exceptionHandle, $offset + 28);
    $fieldType8.encode($encoder, fifoHandle, $offset + 32);
    $fieldType9.encode($encoder, guestHandle, $offset + 36);
    $fieldType10.encode($encoder, interruptHandle, $offset + 40);
    $fieldType11.encode($encoder, iommuHandle, $offset + 44);
    $fieldType12.encode($encoder, jobHandle, $offset + 48);
    $fieldType13.encode($encoder, pagerHandle, $offset + 52);
    $fieldType14.encode($encoder, pcideviceHandle, $offset + 56);
    $fieldType15.encode($encoder, pmtHandle, $offset + 60);
    $fieldType16.encode($encoder, portHandle, $offset + 64);
    $fieldType17.encode($encoder, processHandle, $offset + 68);
    $fieldType18.encode($encoder, profileHandle, $offset + 72);
    $fieldType19.encode($encoder, resourceHandle, $offset + 76);
    $fieldType20.encode($encoder, socketHandle, $offset + 80);
    $fieldType21.encode($encoder, suspendtokenHandle, $offset + 84);
    $fieldType22.encode($encoder, threadHandle, $offset + 88);
    $fieldType23.encode($encoder, timerHandle, $offset + 92);
    $fieldType24.encode($encoder, vcpuHandle, $offset + 96);
    $fieldType25.encode($encoder, vmarHandle, $offset + 100);
    $fieldType26.encode($encoder, vmoHandle, $offset + 104);
    $fieldType27.encode($encoder, rightsHandle, $offset + 108);
    $fieldType28.encode($encoder, aliasedPlainHandleField, $offset + 112);
    $fieldType29.encode($encoder, aliasedSubtypeHandleField, $offset + 116);
    $fieldType30.encode($encoder, aliasedRightsHandleField, $offset + 120);
    $fieldType31.encode($encoder, someProtocol, $offset + 124);
    $fieldType32.encode($encoder, requestSomeProtocol, $offset + 128);
  }

  @override
  String toString() {
    return r'Handles' r'(plainHandle: ' +
        plainHandle.toString() +
        r', btiHandle: ' +
        btiHandle.toString() +
        r', channelHandle: ' +
        channelHandle.toString() +
        r', clockHandle: ' +
        clockHandle.toString() +
        r', debuglogHandle: ' +
        debuglogHandle.toString() +
        r', eventHandle: ' +
        eventHandle.toString() +
        r', eventpairHandle: ' +
        eventpairHandle.toString() +
        r', exceptionHandle: ' +
        exceptionHandle.toString() +
        r', fifoHandle: ' +
        fifoHandle.toString() +
        r', guestHandle: ' +
        guestHandle.toString() +
        r', interruptHandle: ' +
        interruptHandle.toString() +
        r', iommuHandle: ' +
        iommuHandle.toString() +
        r', jobHandle: ' +
        jobHandle.toString() +
        r', pagerHandle: ' +
        pagerHandle.toString() +
        r', pcideviceHandle: ' +
        pcideviceHandle.toString() +
        r', pmtHandle: ' +
        pmtHandle.toString() +
        r', portHandle: ' +
        portHandle.toString() +
        r', processHandle: ' +
        processHandle.toString() +
        r', profileHandle: ' +
        profileHandle.toString() +
        r', resourceHandle: ' +
        resourceHandle.toString() +
        r', socketHandle: ' +
        socketHandle.toString() +
        r', suspendtokenHandle: ' +
        suspendtokenHandle.toString() +
        r', threadHandle: ' +
        threadHandle.toString() +
        r', timerHandle: ' +
        timerHandle.toString() +
        r', vcpuHandle: ' +
        vcpuHandle.toString() +
        r', vmarHandle: ' +
        vmarHandle.toString() +
        r', vmoHandle: ' +
        vmoHandle.toString() +
        r', rightsHandle: ' +
        rightsHandle.toString() +
        r', aliasedPlainHandleField: ' +
        aliasedPlainHandleField.toString() +
        r', aliasedSubtypeHandleField: ' +
        aliasedSubtypeHandleField.toString() +
        r', aliasedRightsHandleField: ' +
        aliasedRightsHandleField.toString() +
        r', someProtocol: ' +
        someProtocol.toString() +
        r', requestSomeProtocol: ' +
        requestSomeProtocol.toString() +
        r')';
  }

  static Handles _structDecode($fidl.Decoder $decoder, int $offset) {
    return Handles(
        plainHandle: $fieldType0.decode($decoder, $offset + 0),
        btiHandle: $fieldType1.decode($decoder, $offset + 4),
        channelHandle: $fieldType2.decode($decoder, $offset + 8),
        clockHandle: $fieldType3.decode($decoder, $offset + 12),
        debuglogHandle: $fieldType4.decode($decoder, $offset + 16),
        eventHandle: $fieldType5.decode($decoder, $offset + 20),
        eventpairHandle: $fieldType6.decode($decoder, $offset + 24),
        exceptionHandle: $fieldType7.decode($decoder, $offset + 28),
        fifoHandle: $fieldType8.decode($decoder, $offset + 32),
        guestHandle: $fieldType9.decode($decoder, $offset + 36),
        interruptHandle: $fieldType10.decode($decoder, $offset + 40),
        iommuHandle: $fieldType11.decode($decoder, $offset + 44),
        jobHandle: $fieldType12.decode($decoder, $offset + 48),
        pagerHandle: $fieldType13.decode($decoder, $offset + 52),
        pcideviceHandle: $fieldType14.decode($decoder, $offset + 56),
        pmtHandle: $fieldType15.decode($decoder, $offset + 60),
        portHandle: $fieldType16.decode($decoder, $offset + 64),
        processHandle: $fieldType17.decode($decoder, $offset + 68),
        profileHandle: $fieldType18.decode($decoder, $offset + 72),
        resourceHandle: $fieldType19.decode($decoder, $offset + 76),
        socketHandle: $fieldType20.decode($decoder, $offset + 80),
        suspendtokenHandle: $fieldType21.decode($decoder, $offset + 84),
        threadHandle: $fieldType22.decode($decoder, $offset + 88),
        timerHandle: $fieldType23.decode($decoder, $offset + 92),
        vcpuHandle: $fieldType24.decode($decoder, $offset + 96),
        vmarHandle: $fieldType25.decode($decoder, $offset + 100),
        vmoHandle: $fieldType26.decode($decoder, $offset + 104),
        rightsHandle: $fieldType27.decode($decoder, $offset + 108),
        aliasedPlainHandleField: $fieldType28.decode($decoder, $offset + 112),
        aliasedSubtypeHandleField: $fieldType29.decode($decoder, $offset + 116),
        aliasedRightsHandleField: $fieldType30.decode($decoder, $offset + 120),
        someProtocol: $fieldType31.decode($decoder, $offset + 124),
        requestSomeProtocol: $fieldType32.decode($decoder, $offset + 128));
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Handles> kHandles_Type = $fidl.StructType<Handles>(
  inlineSize: 132,
  structDecode: Handles._structDecode,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();

abstract class SomeProtocol {
  $fidl.ServiceData? get $serviceData => SomeProtocolData();
}

// TODO: Remove ServiceData for non-service
class SomeProtocolData implements $fidl.ServiceData<SomeProtocol> {
  const SomeProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return SomeProtocolBinding();
  }
}

class SomeProtocolProxy extends $fidl.AsyncProxy<SomeProtocol>
    implements SomeProtocol {
  SomeProtocolProxy()
      : super($fidl.AsyncProxyController<SomeProtocol>(
            $interfaceName: r'SomeProtocol')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.Message $message) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }

  void _handleResponse($fidl.Message $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }
}

class SomeProtocolBinding extends $fidl.AsyncBinding<SomeProtocol> {
  SomeProtocolBinding() : super(r"SomeProtocol");

  @override
  void handleMessage($fidl.Message $message, $fidl.MessageSink $respond) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for SomeProtocolBinding');
    }
  }
}

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace fidl {
namespace test {
namespace padding {

class Padding7ByteMiddle;
class Padding7ByteEnd;
class Padding6ByteMiddle;
class Padding6ByteEnd;
class Padding5ByteMiddle;
class Padding5ByteEnd;
class Padding4ByteMiddle;
class Padding4ByteEnd;
class Padding4ByteAlignmentLength12;
class Padding3ByteMiddle;
class Padding3ByteEnd;
class Padding2ByteMiddle;
class Padding2ByteEnd;
class Padding2ByteAlignmentLength6;
class Padding1ByteMiddle;
class Padding1ByteEnd;

class Padding7ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t a{};

  uint64_t b{};

  static inline ::std::unique_ptr<Padding7ByteMiddle> New() {
    return ::std::make_unique<Padding7ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding7ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding7ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding7ByteMiddle& _value,
    ::fidl::test::padding::Padding7ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding7ByteMiddlePtr = ::std::unique_ptr<Padding7ByteMiddle>;

class Padding7ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint64_t a{};

  uint8_t b{};

  static inline ::std::unique_ptr<Padding7ByteEnd> New() {
    return ::std::make_unique<Padding7ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding7ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding7ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding7ByteEnd& _value,
                         ::fidl::test::padding::Padding7ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding7ByteEndPtr = ::std::unique_ptr<Padding7ByteEnd>;

class Padding6ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint16_t a{};

  uint64_t b{};

  static inline ::std::unique_ptr<Padding6ByteMiddle> New() {
    return ::std::make_unique<Padding6ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding6ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding6ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding6ByteMiddle& _value,
    ::fidl::test::padding::Padding6ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding6ByteMiddlePtr = ::std::unique_ptr<Padding6ByteMiddle>;

class Padding6ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint64_t a{};

  uint16_t b{};

  static inline ::std::unique_ptr<Padding6ByteEnd> New() {
    return ::std::make_unique<Padding6ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding6ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding6ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding6ByteEnd& _value,
                         ::fidl::test::padding::Padding6ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding6ByteEndPtr = ::std::unique_ptr<Padding6ByteEnd>;

class Padding5ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint16_t a{};

  uint8_t b{};

  uint64_t c{};

  static inline ::std::unique_ptr<Padding5ByteMiddle> New() {
    return ::std::make_unique<Padding5ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding5ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding5ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding5ByteMiddle& _value,
    ::fidl::test::padding::Padding5ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding5ByteMiddlePtr = ::std::unique_ptr<Padding5ByteMiddle>;

class Padding5ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint64_t a{};

  uint16_t b{};

  uint8_t c{};

  static inline ::std::unique_ptr<Padding5ByteEnd> New() {
    return ::std::make_unique<Padding5ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding5ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding5ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding5ByteEnd& _value,
                         ::fidl::test::padding::Padding5ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding5ByteEndPtr = ::std::unique_ptr<Padding5ByteEnd>;

class Padding4ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint32_t a{};

  uint64_t b{};

  static inline ::std::unique_ptr<Padding4ByteMiddle> New() {
    return ::std::make_unique<Padding4ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding4ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding4ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding4ByteMiddle& _value,
    ::fidl::test::padding::Padding4ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding4ByteMiddlePtr = ::std::unique_ptr<Padding4ByteMiddle>;

class Padding4ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint64_t a{};

  uint32_t b{};

  static inline ::std::unique_ptr<Padding4ByteEnd> New() {
    return ::std::make_unique<Padding4ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding4ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding4ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding4ByteEnd& _value,
                         ::fidl::test::padding::Padding4ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding4ByteEndPtr = ::std::unique_ptr<Padding4ByteEnd>;

class Padding4ByteAlignmentLength12 final {
 public:
  static const fidl_type_t* FidlType;

  uint32_t a{};

  uint8_t b{};

  uint16_t c{};

  uint16_t d{};

  static inline ::std::unique_ptr<Padding4ByteAlignmentLength12> New() {
    return ::std::make_unique<Padding4ByteAlignmentLength12>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder,
                     Padding4ByteAlignmentLength12* value, size_t _offset);
  zx_status_t Clone(Padding4ByteAlignmentLength12* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding4ByteAlignmentLength12& _value,
    ::fidl::test::padding::Padding4ByteAlignmentLength12* _result) {
  return _value.Clone(_result);
}

using Padding4ByteAlignmentLength12Ptr =
    ::std::unique_ptr<Padding4ByteAlignmentLength12>;

class Padding3ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t a{};

  uint32_t b{};

  static inline ::std::unique_ptr<Padding3ByteMiddle> New() {
    return ::std::make_unique<Padding3ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding3ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding3ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding3ByteMiddle& _value,
    ::fidl::test::padding::Padding3ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding3ByteMiddlePtr = ::std::unique_ptr<Padding3ByteMiddle>;

class Padding3ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint32_t a{};

  uint8_t b{};

  static inline ::std::unique_ptr<Padding3ByteEnd> New() {
    return ::std::make_unique<Padding3ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding3ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding3ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding3ByteEnd& _value,
                         ::fidl::test::padding::Padding3ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding3ByteEndPtr = ::std::unique_ptr<Padding3ByteEnd>;

class Padding2ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint16_t a{};

  uint32_t b{};

  static inline ::std::unique_ptr<Padding2ByteMiddle> New() {
    return ::std::make_unique<Padding2ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding2ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding2ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding2ByteMiddle& _value,
    ::fidl::test::padding::Padding2ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding2ByteMiddlePtr = ::std::unique_ptr<Padding2ByteMiddle>;

class Padding2ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint32_t a{};

  uint16_t b{};

  static inline ::std::unique_ptr<Padding2ByteEnd> New() {
    return ::std::make_unique<Padding2ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding2ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding2ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding2ByteEnd& _value,
                         ::fidl::test::padding::Padding2ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding2ByteEndPtr = ::std::unique_ptr<Padding2ByteEnd>;

class Padding2ByteAlignmentLength6 final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t a{};

  uint16_t b{};

  uint8_t c{};

  static inline ::std::unique_ptr<Padding2ByteAlignmentLength6> New() {
    return ::std::make_unique<Padding2ByteAlignmentLength6>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder,
                     Padding2ByteAlignmentLength6* value, size_t _offset);
  zx_status_t Clone(Padding2ByteAlignmentLength6* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding2ByteAlignmentLength6& _value,
    ::fidl::test::padding::Padding2ByteAlignmentLength6* _result) {
  return _value.Clone(_result);
}

using Padding2ByteAlignmentLength6Ptr =
    ::std::unique_ptr<Padding2ByteAlignmentLength6>;

class Padding1ByteMiddle final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t a{};

  uint16_t b{};

  static inline ::std::unique_ptr<Padding1ByteMiddle> New() {
    return ::std::make_unique<Padding1ByteMiddle>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding1ByteMiddle* value,
                     size_t _offset);
  zx_status_t Clone(Padding1ByteMiddle* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding1ByteMiddle& _value,
    ::fidl::test::padding::Padding1ByteMiddle* _result) {
  return _value.Clone(_result);
}

using Padding1ByteMiddlePtr = ::std::unique_ptr<Padding1ByteMiddle>;

class Padding1ByteEnd final {
 public:
  static const fidl_type_t* FidlType;

  uint16_t a{};

  uint8_t b{};

  static inline ::std::unique_ptr<Padding1ByteEnd> New() {
    return ::std::make_unique<Padding1ByteEnd>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Padding1ByteEnd* value,
                     size_t _offset);
  zx_status_t Clone(Padding1ByteEnd* result) const;
};

inline zx_status_t Clone(const ::fidl::test::padding::Padding1ByteEnd& _value,
                         ::fidl::test::padding::Padding1ByteEnd* _result) {
  return _value.Clone(_result);
}

using Padding1ByteEndPtr = ::std::unique_ptr<Padding1ByteEnd>;
}  // namespace padding
}  // namespace test
}  // namespace fidl
namespace fidl {

template <>
struct CodingTraits<::fidl::test::padding::Padding7ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding7ByteMiddle,
                                   16> {};

template <>
struct HasPadding<::fidl::test::padding::Padding7ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding7ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding7ByteMiddle>::value &&
          IsMemcpyCompatible<uint64_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding7ByteMiddle& value,
                         ::fidl::test::padding::Padding7ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding7ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding7ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding7ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding7ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding7ByteEnd, 16> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding7ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding7ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding7ByteEnd>::value &&
          IsMemcpyCompatible<uint64_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding7ByteEnd& value,
                         ::fidl::test::padding::Padding7ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding7ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding7ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding7ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding6ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding6ByteMiddle,
                                   16> {};

template <>
struct HasPadding<::fidl::test::padding::Padding6ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding6ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding6ByteMiddle>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint64_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding6ByteMiddle& value,
                         ::fidl::test::padding::Padding6ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding6ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding6ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding6ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding6ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding6ByteEnd, 16> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding6ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding6ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding6ByteEnd>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint64_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding6ByteEnd& value,
                         ::fidl::test::padding::Padding6ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding6ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding6ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding6ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding5ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding5ByteMiddle,
                                   16> {};

template <>
struct HasPadding<::fidl::test::padding::Padding5ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding5ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding5ByteMiddle>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint64_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding5ByteMiddle& value,
                         ::fidl::test::padding::Padding5ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding5ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding5ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding5ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding5ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding5ByteEnd, 16> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding5ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding5ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding5ByteEnd>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint64_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding5ByteEnd& value,
                         ::fidl::test::padding::Padding5ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding5ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding5ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding5ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding4ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding4ByteMiddle,
                                   16> {};

template <>
struct HasPadding<::fidl::test::padding::Padding4ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding4ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding4ByteMiddle>::value &&
          IsMemcpyCompatible<uint32_t>::value &&
          IsMemcpyCompatible<uint64_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding4ByteMiddle& value,
                         ::fidl::test::padding::Padding4ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding4ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding4ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding4ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding4ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding4ByteEnd, 16> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding4ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding4ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding4ByteEnd>::value &&
          IsMemcpyCompatible<uint32_t>::value &&
          IsMemcpyCompatible<uint64_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding4ByteEnd& value,
                         ::fidl::test::padding::Padding4ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding4ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding4ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding4ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding4ByteAlignmentLength12>
    : public EncodableCodingTraits<
          ::fidl::test::padding::Padding4ByteAlignmentLength12, 12> {};

template <>
struct HasPadding<::fidl::test::padding::Padding4ByteAlignmentLength12>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding4ByteAlignmentLength12>
    : public internal::BoolConstant<
          !HasPadding<
              ::fidl::test::padding::Padding4ByteAlignmentLength12>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint32_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding4ByteAlignmentLength12& value,
    ::fidl::test::padding::Padding4ByteAlignmentLength12* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding4ByteAlignmentLength12> {
  bool operator()(
      const ::fidl::test::padding::Padding4ByteAlignmentLength12& _lhs,
      const ::fidl::test::padding::Padding4ByteAlignmentLength12& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.d, _rhs.d)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding3ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding3ByteMiddle,
                                   8> {};

template <>
struct HasPadding<::fidl::test::padding::Padding3ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding3ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding3ByteMiddle>::value &&
          IsMemcpyCompatible<uint32_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding3ByteMiddle& value,
                         ::fidl::test::padding::Padding3ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding3ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding3ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding3ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding3ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding3ByteEnd, 8> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding3ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding3ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding3ByteEnd>::value &&
          IsMemcpyCompatible<uint32_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding3ByteEnd& value,
                         ::fidl::test::padding::Padding3ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding3ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding3ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding3ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding2ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding2ByteMiddle,
                                   8> {};

template <>
struct HasPadding<::fidl::test::padding::Padding2ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding2ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding2ByteMiddle>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint32_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding2ByteMiddle& value,
                         ::fidl::test::padding::Padding2ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding2ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding2ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding2ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding2ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding2ByteEnd, 8> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding2ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding2ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding2ByteEnd>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint32_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding2ByteEnd& value,
                         ::fidl::test::padding::Padding2ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding2ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding2ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding2ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding2ByteAlignmentLength6>
    : public EncodableCodingTraits<
          ::fidl::test::padding::Padding2ByteAlignmentLength6, 6> {};

template <>
struct HasPadding<::fidl::test::padding::Padding2ByteAlignmentLength6>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding2ByteAlignmentLength6>
    : public internal::BoolConstant<
          !HasPadding<
              ::fidl::test::padding::Padding2ByteAlignmentLength6>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::padding::Padding2ByteAlignmentLength6& value,
    ::fidl::test::padding::Padding2ByteAlignmentLength6* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding2ByteAlignmentLength6> {
  bool operator()(
      const ::fidl::test::padding::Padding2ByteAlignmentLength6& _lhs,
      const ::fidl::test::padding::Padding2ByteAlignmentLength6& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding1ByteMiddle>
    : public EncodableCodingTraits<::fidl::test::padding::Padding1ByteMiddle,
                                   4> {};

template <>
struct HasPadding<::fidl::test::padding::Padding1ByteMiddle>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding1ByteMiddle>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding1ByteMiddle>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding1ByteMiddle& value,
                         ::fidl::test::padding::Padding1ByteMiddle* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding1ByteMiddle> {
  bool operator()(const ::fidl::test::padding::Padding1ByteMiddle& _lhs,
                  const ::fidl::test::padding::Padding1ByteMiddle& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::padding::Padding1ByteEnd>
    : public EncodableCodingTraits<::fidl::test::padding::Padding1ByteEnd, 4> {
};

template <>
struct HasPadding<::fidl::test::padding::Padding1ByteEnd>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::padding::Padding1ByteEnd>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::padding::Padding1ByteEnd>::value &&
          IsMemcpyCompatible<uint16_t>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::fidl::test::padding::Padding1ByteEnd& value,
                         ::fidl::test::padding::Padding1ByteEnd* result) {
  return ::fidl::test::padding::Clone(value, result);
}

template <>
struct Equality<::fidl::test::padding::Padding1ByteEnd> {
  bool operator()(const ::fidl::test::padding::Padding1ByteEnd& _lhs,
                  const ::fidl::test::padding::Padding1ByteEnd& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
}  // namespace fidl

//
// Proxies and stubs declarations
//
namespace fidl {
namespace test {
namespace padding {}  // namespace padding
}  // namespace test
}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/natural_types_header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace fidl {
namespace test {
namespace encapsulatedstructs {

class NonInlineStructTestStruct;
class Int8Int32;
class Int16Int8;
class ArrayInt16Int8;
class StructPaddingTestStruct;
class TopLevelStruct;

#ifdef __Fuchsia__
class NonInlineStructTestStruct final {
 public:
  static const fidl_type_t* FidlType;

  ::std::unique_ptr<Int16Int8> element{};

  ::zx::handle h{};

  static inline ::std::unique_ptr<NonInlineStructTestStruct> New() {
    return ::std::make_unique<NonInlineStructTestStruct>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder,
                     NonInlineStructTestStruct* value, size_t _offset);
  zx_status_t Clone(NonInlineStructTestStruct* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct& _value,
    ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct* _result) {
  return _value.Clone(_result);
}

using NonInlineStructTestStructPtr =
    ::std::unique_ptr<NonInlineStructTestStruct>;
#endif  // __Fuchsia__

class Int8Int32 final {
 public:
  static const fidl_type_t* FidlType;

  int8_t a{};

  int32_t b{};

  static inline ::std::unique_ptr<Int8Int32> New() {
    return ::std::make_unique<Int8Int32>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Int8Int32* value,
                     size_t _offset);
  zx_status_t Clone(Int8Int32* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::Int8Int32& _value,
    ::fidl::test::encapsulatedstructs::Int8Int32* _result) {
  return _value.Clone(_result);
}

using Int8Int32Ptr = ::std::unique_ptr<Int8Int32>;

class Int16Int8 final {
 public:
  static const fidl_type_t* FidlType;

  int16_t a{};

  int8_t b{};

  static inline ::std::unique_ptr<Int16Int8> New() {
    return ::std::make_unique<Int16Int8>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, Int16Int8* value,
                     size_t _offset);
  zx_status_t Clone(Int16Int8* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::Int16Int8& _value,
    ::fidl::test::encapsulatedstructs::Int16Int8* _result) {
  return _value.Clone(_result);
}

using Int16Int8Ptr = ::std::unique_ptr<Int16Int8>;

class ArrayInt16Int8 final {
 public:
  static const fidl_type_t* FidlType;

  ::std::array<Int16Int8, 3> arr{};

  static inline ::std::unique_ptr<ArrayInt16Int8> New() {
    return ::std::make_unique<ArrayInt16Int8>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, ArrayInt16Int8* value,
                     size_t _offset);
  zx_status_t Clone(ArrayInt16Int8* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::ArrayInt16Int8& _value,
    ::fidl::test::encapsulatedstructs::ArrayInt16Int8* _result) {
  return _value.Clone(_result);
}

using ArrayInt16Int8Ptr = ::std::unique_ptr<ArrayInt16Int8>;

class StructPaddingTestStruct final {
 public:
  static const fidl_type_t* FidlType;

  Int16Int8 trailing{};

  Int8Int32 inner{};

  ArrayInt16Int8 array{};

  static inline ::std::unique_ptr<StructPaddingTestStruct> New() {
    return ::std::make_unique<StructPaddingTestStruct>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, StructPaddingTestStruct* value,
                     size_t _offset);
  zx_status_t Clone(StructPaddingTestStruct* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::StructPaddingTestStruct& _value,
    ::fidl::test::encapsulatedstructs::StructPaddingTestStruct* _result) {
  return _value.Clone(_result);
}

using StructPaddingTestStructPtr = ::std::unique_ptr<StructPaddingTestStruct>;

#ifdef __Fuchsia__
class TopLevelStruct final {
 public:
  static const fidl_type_t* FidlType;

  StructPaddingTestStruct a{};

  NonInlineStructTestStruct b{};

  static inline ::std::unique_ptr<TopLevelStruct> New() {
    return ::std::make_unique<TopLevelStruct>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset);
  static void Decode(::fidl::Decoder* _decoder, TopLevelStruct* value,
                     size_t _offset);
  zx_status_t Clone(TopLevelStruct* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::TopLevelStruct& _value,
    ::fidl::test::encapsulatedstructs::TopLevelStruct* _result) {
  return _value.Clone(_result);
}

using TopLevelStructPtr = ::std::unique_ptr<TopLevelStruct>;
#endif  // __Fuchsia__

}  // namespace encapsulatedstructs
}  // namespace test
}  // namespace fidl
namespace fidl {

#ifdef __Fuchsia__
template <>
struct CodingTraits<
    ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct>
    : public EncodableCodingTraits<
          ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct, 16> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::NonInlineStructTestStruct>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::encapsulatedstructs::
                          NonInlineStructTestStruct>::value &&
          IsMemcpyCompatible<::std::unique_ptr<
              ::fidl::test::encapsulatedstructs::Int16Int8>>::value &&
          IsMemcpyCompatible<::zx::handle>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct& value,
    ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::NonInlineStructTestStruct> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct& _lhs,
      const ::fidl::test::encapsulatedstructs::NonInlineStructTestStruct& _rhs)
      const {
    if (!::fidl::Equals(_lhs.element, _rhs.element)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.h, _rhs.h)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<::fidl::test::encapsulatedstructs::Int8Int32>
    : public EncodableCodingTraits<::fidl::test::encapsulatedstructs::Int8Int32,
                                   8> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::Int8Int32>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::encapsulatedstructs::Int8Int32>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::encapsulatedstructs::Int8Int32>::value &&
          IsMemcpyCompatible<int32_t>::value &&
          IsMemcpyCompatible<int8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::Int8Int32& value,
    ::fidl::test::encapsulatedstructs::Int8Int32* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::Int8Int32> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::Int8Int32& _lhs,
      const ::fidl::test::encapsulatedstructs::Int8Int32& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::encapsulatedstructs::Int16Int8>
    : public EncodableCodingTraits<::fidl::test::encapsulatedstructs::Int16Int8,
                                   4> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::Int16Int8>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::encapsulatedstructs::Int16Int8>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::encapsulatedstructs::Int16Int8>::value &&
          IsMemcpyCompatible<int16_t>::value &&
          IsMemcpyCompatible<int8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::Int16Int8& value,
    ::fidl::test::encapsulatedstructs::Int16Int8* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::Int16Int8> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::Int16Int8& _lhs,
      const ::fidl::test::encapsulatedstructs::Int16Int8& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::encapsulatedstructs::ArrayInt16Int8>
    : public EncodableCodingTraits<
          ::fidl::test::encapsulatedstructs::ArrayInt16Int8, 12> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::ArrayInt16Int8>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::encapsulatedstructs::ArrayInt16Int8>
    : public internal::BoolConstant<
          !HasPadding<
              ::fidl::test::encapsulatedstructs::ArrayInt16Int8>::value &&
          IsMemcpyCompatible<::std::array<
              ::fidl::test::encapsulatedstructs::Int16Int8, 3>>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::ArrayInt16Int8& value,
    ::fidl::test::encapsulatedstructs::ArrayInt16Int8* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::ArrayInt16Int8> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::ArrayInt16Int8& _lhs,
      const ::fidl::test::encapsulatedstructs::ArrayInt16Int8& _rhs) const {
    if (!::fidl::Equals(_lhs.arr, _rhs.arr)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::fidl::test::encapsulatedstructs::StructPaddingTestStruct>
    : public EncodableCodingTraits<
          ::fidl::test::encapsulatedstructs::StructPaddingTestStruct, 24> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::StructPaddingTestStruct>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::encapsulatedstructs::StructPaddingTestStruct>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::encapsulatedstructs::
                          StructPaddingTestStruct>::value &&
          IsMemcpyCompatible<
              ::fidl::test::encapsulatedstructs::ArrayInt16Int8>::value &&
          IsMemcpyCompatible<
              ::fidl::test::encapsulatedstructs::Int16Int8>::value &&
          IsMemcpyCompatible<
              ::fidl::test::encapsulatedstructs::Int8Int32>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::StructPaddingTestStruct& value,
    ::fidl::test::encapsulatedstructs::StructPaddingTestStruct* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::StructPaddingTestStruct> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::StructPaddingTestStruct& _lhs,
      const ::fidl::test::encapsulatedstructs::StructPaddingTestStruct& _rhs)
      const {
    if (!::fidl::Equals(_lhs.trailing, _rhs.trailing)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.inner, _rhs.inner)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array, _rhs.array)) {
      return false;
    }
    return true;
  }
};
#ifdef __Fuchsia__
template <>
struct CodingTraits<::fidl::test::encapsulatedstructs::TopLevelStruct>
    : public EncodableCodingTraits<
          ::fidl::test::encapsulatedstructs::TopLevelStruct, 40> {};

template <>
struct HasPadding<::fidl::test::encapsulatedstructs::TopLevelStruct>
    : public std::true_type {};

template <>
struct IsMemcpyCompatible<::fidl::test::encapsulatedstructs::TopLevelStruct>
    : public internal::BoolConstant<
          !HasPadding<
              ::fidl::test::encapsulatedstructs::TopLevelStruct>::value &&
          IsMemcpyCompatible<::fidl::test::encapsulatedstructs::
                                 NonInlineStructTestStruct>::value &&
          IsMemcpyCompatible<::fidl::test::encapsulatedstructs::
                                 StructPaddingTestStruct>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::encapsulatedstructs::TopLevelStruct& value,
    ::fidl::test::encapsulatedstructs::TopLevelStruct* result) {
  return ::fidl::test::encapsulatedstructs::Clone(value, result);
}

template <>
struct Equality<::fidl::test::encapsulatedstructs::TopLevelStruct> {
  bool operator()(
      const ::fidl::test::encapsulatedstructs::TopLevelStruct& _lhs,
      const ::fidl::test::encapsulatedstructs::TopLevelStruct& _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__
}  // namespace fidl

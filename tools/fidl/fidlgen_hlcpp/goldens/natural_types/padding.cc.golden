// WARNING: This file is machine generated by fidlgen.

#include <fidl/test/padding/cpp/natural_types.h>

#include "lib/fidl/cpp/internal/natural_types_implementation.h"

//
// Domain objects definitions (i.e. "natural types" in unified bindings)
//
namespace fidl {
namespace test {
namespace padding {

extern "C" const fidl_type_t fidl_test_padding_Padding7ByteMiddleTable;
const fidl_type_t* Padding7ByteMiddle::FidlType =
    &fidl_test_padding_Padding7ByteMiddleTable;

void Padding7ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding7ByteMiddle>(_offset), this,
           sizeof(Padding7ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding7ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding7ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding7ByteMiddle>(_offset),
           sizeof(Padding7ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding7ByteMiddle::Clone(Padding7ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding7ByteEndTable;
const fidl_type_t* Padding7ByteEnd::FidlType =
    &fidl_test_padding_Padding7ByteEndTable;

void Padding7ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding7ByteEnd>(_offset), this,
           sizeof(Padding7ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding7ByteEnd::Decode(::fidl::Decoder* _decoder, Padding7ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding7ByteEnd>(_offset),
           sizeof(Padding7ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding7ByteEnd::Clone(Padding7ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding6ByteMiddleTable;
const fidl_type_t* Padding6ByteMiddle::FidlType =
    &fidl_test_padding_Padding6ByteMiddleTable;

void Padding6ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding6ByteMiddle>(_offset), this,
           sizeof(Padding6ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding6ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding6ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding6ByteMiddle>(_offset),
           sizeof(Padding6ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding6ByteMiddle::Clone(Padding6ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding6ByteEndTable;
const fidl_type_t* Padding6ByteEnd::FidlType =
    &fidl_test_padding_Padding6ByteEndTable;

void Padding6ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding6ByteEnd>(_offset), this,
           sizeof(Padding6ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding6ByteEnd::Decode(::fidl::Decoder* _decoder, Padding6ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding6ByteEnd>(_offset),
           sizeof(Padding6ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding6ByteEnd::Clone(Padding6ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding5ByteMiddleTable;
const fidl_type_t* Padding5ByteMiddle::FidlType =
    &fidl_test_padding_Padding5ByteMiddleTable;

void Padding5ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding5ByteMiddle>(_offset), this,
           sizeof(Padding5ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
    ::fidl::Encode(_encoder, &c, _offset + 8);
  }
}

void Padding5ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding5ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding5ByteMiddle>(_offset),
           sizeof(Padding5ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
    ::fidl::Decode(_decoder, &_value->c, _offset + 8);
  }
}

zx_status_t Padding5ByteMiddle::Clone(Padding5ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding5ByteEndTable;
const fidl_type_t* Padding5ByteEnd::FidlType =
    &fidl_test_padding_Padding5ByteEndTable;

void Padding5ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding5ByteEnd>(_offset), this,
           sizeof(Padding5ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
    ::fidl::Encode(_encoder, &c, _offset + 10);
  }
}

void Padding5ByteEnd::Decode(::fidl::Decoder* _decoder, Padding5ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding5ByteEnd>(_offset),
           sizeof(Padding5ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
    ::fidl::Decode(_decoder, &_value->c, _offset + 10);
  }
}

zx_status_t Padding5ByteEnd::Clone(Padding5ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding4ByteMiddleTable;
const fidl_type_t* Padding4ByteMiddle::FidlType =
    &fidl_test_padding_Padding4ByteMiddleTable;

void Padding4ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteMiddle>(_offset), this,
           sizeof(Padding4ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding4ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding4ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding4ByteMiddle>(_offset),
           sizeof(Padding4ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding4ByteMiddle::Clone(Padding4ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding4ByteEndTable;
const fidl_type_t* Padding4ByteEnd::FidlType =
    &fidl_test_padding_Padding4ByteEndTable;

void Padding4ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteEnd>(_offset), this,
           sizeof(Padding4ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding4ByteEnd::Decode(::fidl::Decoder* _decoder, Padding4ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding4ByteEnd>(_offset),
           sizeof(Padding4ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding4ByteEnd::Clone(Padding4ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t
    fidl_test_padding_Padding4ByteAlignmentLength12Table;
const fidl_type_t* Padding4ByteAlignmentLength12::FidlType =
    &fidl_test_padding_Padding4ByteAlignmentLength12Table;

void Padding4ByteAlignmentLength12::Encode(::fidl::Encoder* _encoder,
                                           size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteAlignmentLength12>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteAlignmentLength12>(_offset),
           this, sizeof(Padding4ByteAlignmentLength12));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
    ::fidl::Encode(_encoder, &c, _offset + 6);
    ::fidl::Encode(_encoder, &d, _offset + 8);
  }
}

void Padding4ByteAlignmentLength12::Decode(
    ::fidl::Decoder* _decoder, Padding4ByteAlignmentLength12* _value,
    size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteAlignmentLength12>::value) {
    memcpy(_value,
           _decoder->template GetPtr<Padding4ByteAlignmentLength12>(_offset),
           sizeof(Padding4ByteAlignmentLength12));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
    ::fidl::Decode(_decoder, &_value->c, _offset + 6);
    ::fidl::Decode(_decoder, &_value->d, _offset + 8);
  }
}

zx_status_t Padding4ByteAlignmentLength12::Clone(
    Padding4ByteAlignmentLength12* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(d, &_result->d);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding3ByteMiddleTable;
const fidl_type_t* Padding3ByteMiddle::FidlType =
    &fidl_test_padding_Padding3ByteMiddleTable;

void Padding3ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding3ByteMiddle>(_offset), this,
           sizeof(Padding3ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding3ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding3ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding3ByteMiddle>(_offset),
           sizeof(Padding3ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding3ByteMiddle::Clone(Padding3ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding3ByteEndTable;
const fidl_type_t* Padding3ByteEnd::FidlType =
    &fidl_test_padding_Padding3ByteEndTable;

void Padding3ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding3ByteEnd>(_offset), this,
           sizeof(Padding3ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding3ByteEnd::Decode(::fidl::Decoder* _decoder, Padding3ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding3ByteEnd>(_offset),
           sizeof(Padding3ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding3ByteEnd::Clone(Padding3ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding2ByteMiddleTable;
const fidl_type_t* Padding2ByteMiddle::FidlType =
    &fidl_test_padding_Padding2ByteMiddleTable;

void Padding2ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteMiddle>(_offset), this,
           sizeof(Padding2ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding2ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding2ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding2ByteMiddle>(_offset),
           sizeof(Padding2ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding2ByteMiddle::Clone(Padding2ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding2ByteEndTable;
const fidl_type_t* Padding2ByteEnd::FidlType =
    &fidl_test_padding_Padding2ByteEndTable;

void Padding2ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteEnd>(_offset), this,
           sizeof(Padding2ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding2ByteEnd::Decode(::fidl::Decoder* _decoder, Padding2ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding2ByteEnd>(_offset),
           sizeof(Padding2ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding2ByteEnd::Clone(Padding2ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t
    fidl_test_padding_Padding2ByteAlignmentLength6Table;
const fidl_type_t* Padding2ByteAlignmentLength6::FidlType =
    &fidl_test_padding_Padding2ByteAlignmentLength6Table;

void Padding2ByteAlignmentLength6::Encode(::fidl::Encoder* _encoder,
                                          size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteAlignmentLength6>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteAlignmentLength6>(_offset),
           this, sizeof(Padding2ByteAlignmentLength6));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
    ::fidl::Encode(_encoder, &c, _offset + 4);
  }
}

void Padding2ByteAlignmentLength6::Decode(::fidl::Decoder* _decoder,
                                          Padding2ByteAlignmentLength6* _value,
                                          size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteAlignmentLength6>::value) {
    memcpy(_value,
           _decoder->template GetPtr<Padding2ByteAlignmentLength6>(_offset),
           sizeof(Padding2ByteAlignmentLength6));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
    ::fidl::Decode(_decoder, &_value->c, _offset + 4);
  }
}

zx_status_t Padding2ByteAlignmentLength6::Clone(
    Padding2ByteAlignmentLength6* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding1ByteMiddleTable;
const fidl_type_t* Padding1ByteMiddle::FidlType =
    &fidl_test_padding_Padding1ByteMiddleTable;

void Padding1ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding1ByteMiddle>(_offset), this,
           sizeof(Padding1ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
  }
}

void Padding1ByteMiddle::Decode(::fidl::Decoder* _decoder,
                                Padding1ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding1ByteMiddle>(_offset),
           sizeof(Padding1ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
  }
}

zx_status_t Padding1ByteMiddle::Clone(Padding1ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
extern "C" const fidl_type_t fidl_test_padding_Padding1ByteEndTable;
const fidl_type_t* Padding1ByteEnd::FidlType =
    &fidl_test_padding_Padding1ByteEndTable;

void Padding1ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding1ByteEnd>(_offset), this,
           sizeof(Padding1ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
  }
}

void Padding1ByteEnd::Decode(::fidl::Decoder* _decoder, Padding1ByteEnd* _value,
                             size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding1ByteEnd>(_offset),
           sizeof(Padding1ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
  }
}

zx_status_t Padding1ByteEnd::Clone(Padding1ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK) return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK) return _status;
  return ZX_OK;
}
}  // namespace padding
}  // namespace test
}  // namespace fidl

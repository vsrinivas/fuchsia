// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

namespace test {
namespace unknowninteractions {

//
// Domain objects declarations
//

class UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsProtocolStrictTwoWayTableResponse;

class UnknownInteractionsProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWay_Response;

class UnknownInteractionsProtocol_FlexibleTwoWay_Result;

class UnknownInteractionsProtocolFlexibleTwoWayTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayFields_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayFields_Result;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result;

class UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayTable_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayTable_Result;

class UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Result;

class UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result;

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result;

class UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse;

class UnknownInteractionsProtocolStrictEventFieldsRequest;

class UnknownInteractionsProtocolStrictEventUnionRequest;

class UnknownInteractionsProtocolStrictEventTableRequest;

class UnknownInteractionsProtocol_StrictEventErr_Response;

class UnknownInteractionsProtocol_StrictEventErr_Result;

class UnknownInteractionsProtocolStrictEventErrRequest;

class UnknownInteractionsProtocol_StrictEventFieldsErr_Response;

class UnknownInteractionsProtocol_StrictEventFieldsErr_Result;

class UnknownInteractionsProtocolStrictEventFieldsErrRequest;

class UnknownInteractionsProtocol_StrictEventUnionErr_Response;

class UnknownInteractionsProtocol_StrictEventUnionErr_Result;

class UnknownInteractionsProtocolStrictEventUnionErrRequest;

class UnknownInteractionsProtocol_StrictEventTableErr_Response;

class UnknownInteractionsProtocol_StrictEventTableErr_Result;

class UnknownInteractionsProtocolStrictEventTableErrRequest;

class UnknownInteractionsProtocolFlexibleEventFieldsRequest;

class UnknownInteractionsProtocolFlexibleEventUnionRequest;

class UnknownInteractionsProtocolFlexibleEventTableRequest;

class UnknownInteractionsProtocol_FlexibleEventErr_Response;

class UnknownInteractionsProtocol_FlexibleEventErr_Result;

class UnknownInteractionsProtocolFlexibleEventErrRequest;

class UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response;

class UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result;

class UnknownInteractionsProtocolFlexibleEventFieldsErrRequest;

class UnknownInteractionsProtocol_FlexibleEventUnionErr_Response;

class UnknownInteractionsProtocol_FlexibleEventUnionErr_Result;

class UnknownInteractionsProtocolFlexibleEventUnionErrRequest;

class UnknownInteractionsProtocol_FlexibleEventTableErr_Response;

class UnknownInteractionsProtocol_FlexibleEventTableErr_Result;

class UnknownInteractionsProtocolFlexibleEventTableErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsProtocol;
using UnknownInteractionsProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsProtocol>;
#endif  // __Fuchsia__


class UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse;

class UnknownInteractionsAjarProtocolStrictEventFieldsRequest;

class UnknownInteractionsAjarProtocolStrictEventUnionRequest;

class UnknownInteractionsAjarProtocolStrictEventTableRequest;

class UnknownInteractionsAjarProtocol_StrictEventErr_Response;

class UnknownInteractionsAjarProtocol_StrictEventErr_Result;

class UnknownInteractionsAjarProtocolStrictEventErrRequest;

class UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response;

class UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result;

class UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest;

class UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response;

class UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result;

class UnknownInteractionsAjarProtocolStrictEventUnionErrRequest;

class UnknownInteractionsAjarProtocol_StrictEventTableErr_Response;

class UnknownInteractionsAjarProtocol_StrictEventTableErr_Result;

class UnknownInteractionsAjarProtocolStrictEventTableErrRequest;

class UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;

class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

class UnknownInteractionsAjarProtocolFlexibleEventTableRequest;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Response;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Result;

class UnknownInteractionsAjarProtocolFlexibleEventErrRequest;

class UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response;

class UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result;

class UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest;

class UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response;

class UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result;

class UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest;

class UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response;

class UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result;

class UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsAjarProtocol;
using UnknownInteractionsAjarProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsAjarProtocol>;
#endif  // __Fuchsia__


class UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse;

class UnknownInteractionsClosedProtocolStrictEventFieldsRequest;

class UnknownInteractionsClosedProtocolStrictEventUnionRequest;

class UnknownInteractionsClosedProtocolStrictEventTableRequest;

class UnknownInteractionsClosedProtocol_StrictEventErr_Response;

class UnknownInteractionsClosedProtocol_StrictEventErr_Result;

class UnknownInteractionsClosedProtocolStrictEventErrRequest;

class UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response;

class UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result;

class UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest;

class UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response;

class UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result;

class UnknownInteractionsClosedProtocolStrictEventUnionErrRequest;

class UnknownInteractionsClosedProtocol_StrictEventTableErr_Response;

class UnknownInteractionsClosedProtocol_StrictEventTableErr_Result;

class UnknownInteractionsClosedProtocolStrictEventTableErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsClosedProtocol;
using UnknownInteractionsClosedProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsClosedProtocol>;
#endif  // __Fuchsia__


class UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse;


class UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsProtocolStrictTwoWayUnionResponse(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocolStrictTwoWayTableResponse();
  UnknownInteractionsProtocolStrictTwoWayTableResponse(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsProtocolStrictTwoWayTableResponse();
  UnknownInteractionsProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsProtocol_StrictTwoWayErr_Result(UnknownInteractionsProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWay_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWay_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWay_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWay_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWay_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWay_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWay_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWay_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWay_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWay_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWay_Result();

  UnknownInteractionsProtocol_FlexibleTwoWay_Result(UnknownInteractionsProtocol_FlexibleTwoWay_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWay_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWay_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWay_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWay_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWay_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWay_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayFields_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWayFields_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWayFields_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWayFields_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayFields_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayFields_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayFields_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayFields_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayFields_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result(UnknownInteractionsProtocol_FlexibleTwoWayFields_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayFields_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayFields_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayFields_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayFields_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response();
  ~UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response();

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response&&);
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& operator=(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& set_some_field(int32_t value);
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayUnion_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayUnion_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayTable_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocol_FlexibleTwoWayTable_Response();
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Response(UnknownInteractionsProtocol_FlexibleTwoWayTable_Response&& other);
  ~UnknownInteractionsProtocol_FlexibleTwoWayTable_Response();
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& operator=(UnknownInteractionsProtocol_FlexibleTwoWayTable_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayTable_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayTable_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocol_FlexibleTwoWayTable_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayTable_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayTable_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result(UnknownInteractionsProtocol_FlexibleTwoWayTable_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayTable_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayTable_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayTable_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayTable_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayTableTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayErr_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithErr(int32_t&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result WithErr(int32_t&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response();
  ~UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response();

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response&&);
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& operator=(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result WithErr(int32_t&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>;


class UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response();
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response&& other);
  ~UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response();
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& operator=(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocol_FlexibleTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>;


class UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result WithErr(int32_t&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>;


class UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>;


class UnknownInteractionsProtocolStrictEventFieldsRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventFieldsRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventFieldsRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventFieldsRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventFieldsRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventFieldsRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventFieldsRequest>;


class UnknownInteractionsProtocolStrictEventUnionRequest final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocolStrictEventUnionRequest();
  ~UnknownInteractionsProtocolStrictEventUnionRequest();

  UnknownInteractionsProtocolStrictEventUnionRequest(UnknownInteractionsProtocolStrictEventUnionRequest&&);
  UnknownInteractionsProtocolStrictEventUnionRequest& operator=(UnknownInteractionsProtocolStrictEventUnionRequest&&);

  
  static UnknownInteractionsProtocolStrictEventUnionRequest WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventUnionRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventUnionRequest>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventUnionRequest* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventUnionRequest* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocolStrictEventUnionRequest& set_some_field(int32_t value);
  UnknownInteractionsProtocolStrictEventUnionRequest& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocolStrictEventUnionRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventUnionRequest>;


class UnknownInteractionsProtocolStrictEventTableRequest final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocolStrictEventTableRequest& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocolStrictEventTableRequest();
  UnknownInteractionsProtocolStrictEventTableRequest(UnknownInteractionsProtocolStrictEventTableRequest&& other);
  ~UnknownInteractionsProtocolStrictEventTableRequest();
  UnknownInteractionsProtocolStrictEventTableRequest& operator=(UnknownInteractionsProtocolStrictEventTableRequest&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventTableRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventTableRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventTableRequest* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventTableRequest* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocolStrictEventTableRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventTableRequest>;


class UnknownInteractionsProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Response>;


class UnknownInteractionsProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventErr_Result();
  ~UnknownInteractionsProtocol_StrictEventErr_Result();

  UnknownInteractionsProtocol_StrictEventErr_Result(UnknownInteractionsProtocol_StrictEventErr_Result&&);
  UnknownInteractionsProtocol_StrictEventErr_Result& operator=(UnknownInteractionsProtocol_StrictEventErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>;
  
  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Result>;


class UnknownInteractionsProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventErrRequest>;


class UnknownInteractionsProtocol_StrictEventFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictEventFieldsErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictEventFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsProtocol_StrictEventFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictEventFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventFieldsErr_Response>;


class UnknownInteractionsProtocol_StrictEventFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventFieldsErr_Result();
  ~UnknownInteractionsProtocol_StrictEventFieldsErr_Result();

  UnknownInteractionsProtocol_StrictEventFieldsErr_Result(UnknownInteractionsProtocol_StrictEventFieldsErr_Result&&);
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result& operator=(UnknownInteractionsProtocol_StrictEventFieldsErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictEventFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response&&);
  static UnknownInteractionsProtocol_StrictEventFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>;
  
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictEventFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventFieldsErr_Result>;


class UnknownInteractionsProtocolStrictEventFieldsErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventFieldsErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventFieldsErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventFieldsErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventFieldsErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventFieldsErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventFieldsErrRequest>;


class UnknownInteractionsProtocol_StrictEventUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventUnionErr_Response();
  ~UnknownInteractionsProtocol_StrictEventUnionErr_Response();

  UnknownInteractionsProtocol_StrictEventUnionErr_Response(UnknownInteractionsProtocol_StrictEventUnionErr_Response&&);
  UnknownInteractionsProtocol_StrictEventUnionErr_Response& operator=(UnknownInteractionsProtocol_StrictEventUnionErr_Response&&);

  
  static UnknownInteractionsProtocol_StrictEventUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocol_StrictEventUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsProtocol_StrictEventUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventUnionErr_Response>;


class UnknownInteractionsProtocol_StrictEventUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventUnionErr_Result();
  ~UnknownInteractionsProtocol_StrictEventUnionErr_Result();

  UnknownInteractionsProtocol_StrictEventUnionErr_Result(UnknownInteractionsProtocol_StrictEventUnionErr_Result&&);
  UnknownInteractionsProtocol_StrictEventUnionErr_Result& operator=(UnknownInteractionsProtocol_StrictEventUnionErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictEventUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response&&);
  static UnknownInteractionsProtocol_StrictEventUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictEventUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictEventUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>;
  
  UnknownInteractionsProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictEventUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>&& result)
    : UnknownInteractionsProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictEventUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventUnionErr_Result>;


class UnknownInteractionsProtocolStrictEventUnionErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventUnionErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventUnionErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventUnionErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventUnionErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventUnionErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventUnionErrRequest>;


class UnknownInteractionsProtocol_StrictEventTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocol_StrictEventTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocol_StrictEventTableErr_Response();
  UnknownInteractionsProtocol_StrictEventTableErr_Response(UnknownInteractionsProtocol_StrictEventTableErr_Response&& other);
  ~UnknownInteractionsProtocol_StrictEventTableErr_Response();
  UnknownInteractionsProtocol_StrictEventTableErr_Response& operator=(UnknownInteractionsProtocol_StrictEventTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocol_StrictEventTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventTableErr_Response>;


class UnknownInteractionsProtocol_StrictEventTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventTableErr_Result();
  ~UnknownInteractionsProtocol_StrictEventTableErr_Result();

  UnknownInteractionsProtocol_StrictEventTableErr_Result(UnknownInteractionsProtocol_StrictEventTableErr_Result&&);
  UnknownInteractionsProtocol_StrictEventTableErr_Result& operator=(UnknownInteractionsProtocol_StrictEventTableErr_Result&&);

  
  static UnknownInteractionsProtocol_StrictEventTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response&&);
  static UnknownInteractionsProtocol_StrictEventTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictEventTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictEventTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>;
  
  UnknownInteractionsProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictEventTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response>&& result)
    : UnknownInteractionsProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_StrictEventTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventTableErr_Result>;


class UnknownInteractionsProtocolStrictEventTableErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventTableErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventTableErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventTableErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventTableErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventTableErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventTableErrRequest>;


class UnknownInteractionsProtocolFlexibleEventFieldsRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventFieldsRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventFieldsRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventFieldsRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventFieldsRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventFieldsRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventFieldsRequest>;


class UnknownInteractionsProtocolFlexibleEventUnionRequest final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocolFlexibleEventUnionRequest();
  ~UnknownInteractionsProtocolFlexibleEventUnionRequest();

  UnknownInteractionsProtocolFlexibleEventUnionRequest(UnknownInteractionsProtocolFlexibleEventUnionRequest&&);
  UnknownInteractionsProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsProtocolFlexibleEventUnionRequest&&);

  
  static UnknownInteractionsProtocolFlexibleEventUnionRequest WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventUnionRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventUnionRequest>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventUnionRequest* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventUnionRequest* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocolFlexibleEventUnionRequest& set_some_field(int32_t value);
  UnknownInteractionsProtocolFlexibleEventUnionRequest& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocolFlexibleEventUnionRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventUnionRequest>;


class UnknownInteractionsProtocolFlexibleEventTableRequest final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocolFlexibleEventTableRequest& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocolFlexibleEventTableRequest();
  UnknownInteractionsProtocolFlexibleEventTableRequest(UnknownInteractionsProtocolFlexibleEventTableRequest&& other);
  ~UnknownInteractionsProtocolFlexibleEventTableRequest();
  UnknownInteractionsProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsProtocolFlexibleEventTableRequest&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventTableRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventTableRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventTableRequest* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventTableRequest* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocolFlexibleEventTableRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventTableRequest>;


class UnknownInteractionsProtocol_FlexibleEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleEventErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Response>;


class UnknownInteractionsProtocol_FlexibleEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventErr_Result();
  ~UnknownInteractionsProtocol_FlexibleEventErr_Result();

  UnknownInteractionsProtocol_FlexibleEventErr_Result(UnknownInteractionsProtocol_FlexibleEventErr_Result&&);
  UnknownInteractionsProtocol_FlexibleEventErr_Result& operator=(UnknownInteractionsProtocol_FlexibleEventErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Result>;


class UnknownInteractionsProtocolFlexibleEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventErrRequest>;


class UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleEventFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>;


class UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result();
  ~UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result();

  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result&&);
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& operator=(UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>;


class UnknownInteractionsProtocolFlexibleEventFieldsErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventFieldsErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventFieldsErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventFieldsErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>;


class UnknownInteractionsProtocol_FlexibleEventUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response();
  ~UnknownInteractionsProtocol_FlexibleEventUnionErr_Response();

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response(UnknownInteractionsProtocol_FlexibleEventUnionErr_Response&&);
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& operator=(UnknownInteractionsProtocol_FlexibleEventUnionErr_Response&&);

  
  static UnknownInteractionsProtocol_FlexibleEventUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>;


class UnknownInteractionsProtocol_FlexibleEventUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result();
  ~UnknownInteractionsProtocol_FlexibleEventUnionErr_Result();

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(UnknownInteractionsProtocol_FlexibleEventUnionErr_Result&&);
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& operator=(UnknownInteractionsProtocol_FlexibleEventUnionErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleEventUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleEventUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>&& result)
    : UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>;


class UnknownInteractionsProtocolFlexibleEventUnionErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventUnionErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventUnionErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventUnionErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventUnionErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventUnionErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventUnionErrRequest>;


class UnknownInteractionsProtocol_FlexibleEventTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsProtocol_FlexibleEventTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsProtocol_FlexibleEventTableErr_Response();
  UnknownInteractionsProtocol_FlexibleEventTableErr_Response(UnknownInteractionsProtocol_FlexibleEventTableErr_Response&& other);
  ~UnknownInteractionsProtocol_FlexibleEventTableErr_Response();
  UnknownInteractionsProtocol_FlexibleEventTableErr_Response& operator=(UnknownInteractionsProtocol_FlexibleEventTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsProtocol_FlexibleEventTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventTableErr_Response>;


class UnknownInteractionsProtocol_FlexibleEventTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventTableErr_Result();
  ~UnknownInteractionsProtocol_FlexibleEventTableErr_Result();

  UnknownInteractionsProtocol_FlexibleEventTableErr_Result(UnknownInteractionsProtocol_FlexibleEventTableErr_Result&&);
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result& operator=(UnknownInteractionsProtocol_FlexibleEventTableErr_Result&&);

  
  static UnknownInteractionsProtocol_FlexibleEventTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleEventTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>;
  
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response>&& result)
    : UnknownInteractionsProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsProtocol_FlexibleEventTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventTableErr_Result>;


class UnknownInteractionsProtocolFlexibleEventTableErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventTableErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventTableErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventTableErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventTableErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventTableErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventTableErrRequest>;

#ifdef __Fuchsia__

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


class UnknownInteractionsProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleOneWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayFields(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayUnion(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayTable(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayFieldsErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayUnionErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayTableErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
};
  
  
  
  namespace _internal {__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponseTable;
  
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableErrRequestTable;
  
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableErrRequestTable;

}  // namespace _internal
class UnknownInteractionsProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse* UnknownInteractionsProtocolStrictTwoWayUnionResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolStrictTwoWayUnionResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse* UnknownInteractionsProtocolStrictTwoWayTableResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolStrictTwoWayTableResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWay(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayFields(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest* UnknownInteractionsProtocolStrictEventUnionRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolStrictEventUnionRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest* UnknownInteractionsProtocolStrictEventTableRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolStrictEventTableRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEvent(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest* UnknownInteractionsProtocolFlexibleEventUnionRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolFlexibleEventUnionRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest* UnknownInteractionsProtocolFlexibleEventTableRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsProtocolFlexibleEventTableRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__



class UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse();
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsAjarProtocolStrictTwoWayTableResponse();
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>;


class UnknownInteractionsAjarProtocolStrictEventFieldsRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventFieldsRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventFieldsRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventFieldsRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>;


class UnknownInteractionsAjarProtocolStrictEventUnionRequest final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocolStrictEventUnionRequest();
  ~UnknownInteractionsAjarProtocolStrictEventUnionRequest();

  UnknownInteractionsAjarProtocolStrictEventUnionRequest(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&);
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& operator=(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&);

  
  static UnknownInteractionsAjarProtocolStrictEventUnionRequest WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventUnionRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventUnionRequest>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventUnionRequest* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventUnionRequest* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocolStrictEventUnionRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventUnionRequest>;


class UnknownInteractionsAjarProtocolStrictEventTableRequest final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocolStrictEventTableRequest& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocolStrictEventTableRequest();
  UnknownInteractionsAjarProtocolStrictEventTableRequest(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other);
  ~UnknownInteractionsAjarProtocolStrictEventTableRequest();
  UnknownInteractionsAjarProtocolStrictEventTableRequest& operator=(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventTableRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventTableRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventTableRequest* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventTableRequest* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocolStrictEventTableRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventTableRequest>;


class UnknownInteractionsAjarProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Response>;


class UnknownInteractionsAjarProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictEventErr_Result();

  UnknownInteractionsAjarProtocol_StrictEventErr_Result(UnknownInteractionsAjarProtocol_StrictEventErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictEventErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Result>;


class UnknownInteractionsAjarProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventErrRequest>;


class UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictEventFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>;


class UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result();

  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>;


class UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventFieldsErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>;


class UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response();
  ~UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response();

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response&&);
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& operator=(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response&&);

  
  static UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>;


class UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result();

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>;


class UnknownInteractionsAjarProtocolStrictEventUnionErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventUnionErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventUnionErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventUnionErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>;


class UnknownInteractionsAjarProtocol_StrictEventTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocol_StrictEventTableErr_Response();
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Response(UnknownInteractionsAjarProtocol_StrictEventTableErr_Response&& other);
  ~UnknownInteractionsAjarProtocol_StrictEventTableErr_Response();
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& operator=(UnknownInteractionsAjarProtocol_StrictEventTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocol_StrictEventTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>;


class UnknownInteractionsAjarProtocol_StrictEventTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictEventTableErr_Result();

  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(UnknownInteractionsAjarProtocol_StrictEventTableErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictEventTableErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_StrictEventTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictEventTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>;
  
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>;


class UnknownInteractionsAjarProtocolStrictEventTableErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventTableErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventTableErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventTableErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventTableErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventTableErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventTableErrRequest>;


class UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventFieldsRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>;


class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest();
  ~UnknownInteractionsAjarProtocolFlexibleEventUnionRequest();

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&);
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&);

  
  static UnknownInteractionsAjarProtocolFlexibleEventUnionRequest WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocolFlexibleEventUnionRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>;


class UnknownInteractionsAjarProtocolFlexibleEventTableRequest final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocolFlexibleEventTableRequest();
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other);
  ~UnknownInteractionsAjarProtocolFlexibleEventTableRequest();
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventTableRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventTableRequest* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventTableRequest* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocolFlexibleEventTableRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventTableRequest>;


class UnknownInteractionsAjarProtocol_FlexibleEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_FlexibleEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_FlexibleEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>;


class UnknownInteractionsAjarProtocol_FlexibleEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result();
  ~UnknownInteractionsAjarProtocol_FlexibleEventErr_Result();

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result&&);
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& operator=(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_FlexibleEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response&&);
  static UnknownInteractionsAjarProtocol_FlexibleEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>;
  
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>;


class UnknownInteractionsAjarProtocolFlexibleEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventErrRequest>;


class UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>;


class UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result();
  ~UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result();

  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result&&);
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& operator=(UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response&&);
  static UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>;
  
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>;


class UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>;


class UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response();
  ~UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response();

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response&&);
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& operator=(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response&&);

  
  static UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>;


class UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result();
  ~UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result();

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result&&);
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& operator=(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response&&);
  static UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>;
  
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>;


class UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>;


class UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response();
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response&& other);
  ~UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response();
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& operator=(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarProtocol_FlexibleEventTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>;


class UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result();
  ~UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result();

  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result&&);
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& operator=(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result&&);

  
  static UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response&&);
  static UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>;
  
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>;


class UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventTableErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>;

#ifdef __Fuchsia__

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


class UnknownInteractionsAjarProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleOneWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
};
  
  
  
  namespace _internal {__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponseTable;
  
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableErrRequestTable;
  
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableErrRequestTable;

}  // namespace _internal
class UnknownInteractionsAjarProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* UnknownInteractionsAjarProtocolStrictTwoWayTableResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest* UnknownInteractionsAjarProtocolStrictEventUnionRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolStrictEventUnionRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest* UnknownInteractionsAjarProtocolStrictEventTableRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolStrictEventTableRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEvent(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* UnknownInteractionsAjarProtocolFlexibleEventUnionRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest* UnknownInteractionsAjarProtocolFlexibleEventTableRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsAjarProtocolFlexibleEventTableRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__



class UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse();
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsClosedProtocolStrictTwoWayTableResponse();
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>;


class UnknownInteractionsClosedProtocolStrictEventFieldsRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventFieldsRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventFieldsRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventFieldsRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventFieldsRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>;


class UnknownInteractionsClosedProtocolStrictEventUnionRequest final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocolStrictEventUnionRequest();
  ~UnknownInteractionsClosedProtocolStrictEventUnionRequest();

  UnknownInteractionsClosedProtocolStrictEventUnionRequest(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&);
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& operator=(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&);

  
  static UnknownInteractionsClosedProtocolStrictEventUnionRequest WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventUnionRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventUnionRequest>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventUnionRequest* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventUnionRequest* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& set_some_field(int32_t value);
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocolStrictEventUnionRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventUnionRequest>;


class UnknownInteractionsClosedProtocolStrictEventTableRequest final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedProtocolStrictEventTableRequest& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedProtocolStrictEventTableRequest();
  UnknownInteractionsClosedProtocolStrictEventTableRequest(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other);
  ~UnknownInteractionsClosedProtocolStrictEventTableRequest();
  UnknownInteractionsClosedProtocolStrictEventTableRequest& operator=(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventTableRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventTableRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventTableRequest* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventTableRequest* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedProtocolStrictEventTableRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventTableRequest>;


class UnknownInteractionsClosedProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Response>;


class UnknownInteractionsClosedProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictEventErr_Result();

  UnknownInteractionsClosedProtocol_StrictEventErr_Result(UnknownInteractionsClosedProtocol_StrictEventErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictEventErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Result>;


class UnknownInteractionsClosedProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventErrRequest>;


class UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictEventFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>;


class UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result();

  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>;


class UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventFieldsErrRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>;


class UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response();
  ~UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response();

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response&&);
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& operator=(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response&&);

  
  static UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>;


class UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result();

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>;


class UnknownInteractionsClosedProtocolStrictEventUnionErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventUnionErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventUnionErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventUnionErrRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>;


class UnknownInteractionsClosedProtocol_StrictEventTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedProtocol_StrictEventTableErr_Response();
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Response(UnknownInteractionsClosedProtocol_StrictEventTableErr_Response&& other);
  ~UnknownInteractionsClosedProtocol_StrictEventTableErr_Response();
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& operator=(UnknownInteractionsClosedProtocol_StrictEventTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedProtocol_StrictEventTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>;


class UnknownInteractionsClosedProtocol_StrictEventTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictEventTableErr_Result();

  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(UnknownInteractionsClosedProtocol_StrictEventTableErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictEventTableErr_Result&&);

  
  static UnknownInteractionsClosedProtocol_StrictEventTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictEventTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>;
  
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedProtocol_StrictEventTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>;


class UnknownInteractionsClosedProtocolStrictEventTableErrRequest final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventTableErrRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventTableErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventTableErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventTableErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventTableErrRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventTableErrRequest>;

#ifdef __Fuchsia__

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


class UnknownInteractionsClosedProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
};
  
  
  namespace _internal {__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponseTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponseTable;
  
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionErrRequestTable;
  __LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableErrRequestTable;

}  // namespace _internal
class UnknownInteractionsClosedProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* UnknownInteractionsClosedProtocolStrictTwoWayTableResponse) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFields(::fidl::MessageEncoder* _encoder, int32_t* some_field) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(4);
    ::fidl::Encode(_encoder, some_field, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnion(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest* UnknownInteractionsClosedProtocolStrictEventUnionRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsClosedProtocolStrictEventUnionRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTable(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest* UnknownInteractionsClosedProtocolStrictEventTableRequest) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, UnknownInteractionsClosedProtocolStrictEventTableRequest, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventFieldsErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventUnionErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventTableErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__



class UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsDriverProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& set_some_field(int32_t value);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response();
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response&& other);
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response();
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response response_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithErr(int32_t&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>;
  
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result WithErr(int32_t&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>;
  
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result WithErr(int32_t&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>;
  
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response();
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response&& other);
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response();
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>;


class UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result&&);

  
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result WithErr(int32_t&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result WithTransportErr(::fidl::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr; }
  
  ::fidl::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr);
    return transport_err_;
  }
  
  const ::fidl::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& set_transport_err(::fidl::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>;
  
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response response_;
    int32_t err_;
    ::fidl::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse();
  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&);
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&);

  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& set_some_field(int32_t value);
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other);
  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse();
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple(
    );
  }
  
  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result&&);

  
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>;
  
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) { }
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response() = default;
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response(int32_t v) : some_field(std::move(v)) {}
  int32_t ResultValue_() { return std::move(some_field); }
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response(::std::tuple<int32_t> _value_tuple) {
    std::tie(some_field) = std::move(_value_tuple);
  }
  operator ::std::tuple<int32_t>() && {
    return std::make_tuple(std::move(some_field)
    );
  }
  
  int32_t some_field{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result&&);

  
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response&&);
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>;
  
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::ok_result<int32_t>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result(fpromise::result<int32_t, int32_t>(std::move(result))) { }
  operator fpromise::result<int32_t, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<int32_t> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response&&);

  
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response WithSomeField(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kSomeField = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_some_field() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField; }
  
  int32_t& some_field() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField);
    return some_field_;
  }
  
  const int32_t& some_field() const {
    ZX_ASSERT(is_some_field());
    return some_field_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& set_some_field(int32_t value);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag Which() const {
    
    switch (tag_) {
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid:
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag(tag_);
      default:
        return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid);
  union {
    int32_t some_field_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result&&);

  
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response&&);
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>;
  
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;
  
  const int32_t& some_field() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return some_field_value_.value;
  }
  bool has_some_field() const {
    return field_presence_.IsSet<0>();
  }
  
  int32_t* mutable_some_field() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value);
    }
    return &some_field_value_.value;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& set_some_field(int32_t _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&some_field_value_.value, std::move(_value));
    } else {
      some_field_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_some_field() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&some_field_value_.value);
  }

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response&& other);
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response();
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response&& other);

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response* _value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
    case 1:
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<1> field_presence_;
  union ValueUnion_some_field {
    ValueUnion_some_field() {}
    ~ValueUnion_some_field() {}

    int32_t value;
  };
  ValueUnion_some_field some_field_value_;
};

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>;


class UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result&&);

  
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response&&);
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse; }
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse);
    return response_;
  }
  
  const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr; }
  
  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr);
    return err_;
  }
  
  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag Which() const {
    
    return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag(tag_);
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>;
  
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(fpromise::ok_result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(fpromise::error_result<int32_t>&& result)
    : UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result(fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response, int32_t>(std::move(result))) { }
  operator fpromise::result<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>;


}  // namespace unknowninteractions
}  // namespace test
namespace fidl {
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest);

    ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest);

    ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response, 1> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response, 4> {};




template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>::value
    && IsMemcpyCompatible<int32_t>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.some_field, _rhs.some_field)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response::Tag::kSomeField:
        return ::fidl::Equals(_lhs.some_field_, _rhs.some_field_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response, 16> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response& _rhs) const {
    if (_lhs.has_some_field()) {
      if (!_rhs.has_some_field()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.some_field(), _rhs.some_field())) {
        return false;
      }
    } else if (_rhs.has_some_field()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      
      default:
        return false;
      }
    }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse, 16> {};


template<>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> : public internal::BoolConstant<
    !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>::value
    && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>::value> {};


inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template<>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace unknowninteractions {
#ifdef __Fuchsia__

using UnknownInteractionsProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsProtocol>;
class UnknownInteractionsProtocol_Proxy;
class UnknownInteractionsProtocol_Stub;
class UnknownInteractionsProtocol_EventSender;
class UnknownInteractionsProtocol_Sync;
using UnknownInteractionsProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsProtocol>;
class UnknownInteractionsProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsProtocol_StrictOneWay_Ordinal = 0x4e7273b964d117a6lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleOneWay_Ordinal = 0x818bb3a7a910446lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWay_Ordinal = 0x734c996b0f37b942lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayFields_Ordinal = 0x334f4e7fff460ae3lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayUnion_Ordinal = 0x2212805eca592cadlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayTable_Ordinal = 0x746ebf8659ff23b7lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayErr_Ordinal = 0x6d1c6002c51bb967lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayFieldsErr_Ordinal = 0x2182a49480e5bd2blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayUnionErr_Ordinal = 0x453af745d38b20calu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayTableErr_Ordinal = 0x4c26c7ab89cb68d8lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWay_Ordinal = 0x4a5bb3397008b7clu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayFields_Ordinal = 0x3b13f82f44813a32lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayFields_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayUnion_Ordinal = 0x44301e4e8d514fb6lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayTable_Ordinal = 0x7f492934b6c76187lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayTable_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayErr_Ordinal = 0x61240f878cc37c07lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Ordinal = 0xf2b9611a9089b05lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Ordinal = 0x2172940a75f107d7lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayTableErr_Ordinal = 0x6d8aab48e1693bf2lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEvent_Ordinal = 0x9842669255c4fc1lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventFields_Ordinal = 0x7b75ae46520ee732lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventUnion_Ordinal = 0x3663b5197598cbdalu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventTable_Ordinal = 0x25a10039a9f96910lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventErr_Ordinal = 0x3d956048f723bc6dlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventFieldsErr_Ordinal = 0x72c0566865e53c8blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventUnionErr_Ordinal = 0x40f96851e6f82abblu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventTableErr_Ordinal = 0x6ca24cbed7b2784alu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEvent_Ordinal = 0x61bb1fab7d767866lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventFields_Ordinal = 0x3226dff9b0c1d801lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventFields_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventUnion_Ordinal = 0x22afd161ca71e467lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventTable_Ordinal = 0x4f72dd46888b89e0lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventTable_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventErr_Ordinal = 0x4bda3e6fb22bb5a9lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventFieldsErr_Ordinal = 0xf370ade2f7c7a4alu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventUnionErr_Ordinal = 0xc94989e5f6707eclu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventTableErr_Ordinal = 0x4dca02085aeb2d43lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;}  // namespace internal
#endif  // __Fuchsia__


#ifdef __Fuchsia__

using UnknownInteractionsAjarProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsAjarProtocol>;
class UnknownInteractionsAjarProtocol_Proxy;
class UnknownInteractionsAjarProtocol_Stub;
class UnknownInteractionsAjarProtocol_EventSender;
class UnknownInteractionsAjarProtocol_Sync;
using UnknownInteractionsAjarProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsAjarProtocol>;
class UnknownInteractionsAjarProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictOneWay_Ordinal = 0xd4663d6b2b5048blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleOneWay_Ordinal = 0x2275b8171ae4834flu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWay_Ordinal = 0x50e66d328336038lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayFields_Ordinal = 0x1947e36d61e4493alu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayUnion_Ordinal = 0x5177371967e0e6d1lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayTable_Ordinal = 0x6f8f9343b34e2ed4lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayErr_Ordinal = 0x5b47637577c69006lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Ordinal = 0x844ff7bb3f186d9lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Ordinal = 0x2cbfd5a859d4ac95lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Ordinal = 0x30c9e1b3da57dc37lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEvent_Ordinal = 0x6022ae999e9dc2b0lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventFields_Ordinal = 0x510586752445c769lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventUnion_Ordinal = 0x57794b4cc91f816flu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventTable_Ordinal = 0x92639249201f89dlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventErr_Ordinal = 0x715bfcab27f735edlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventFieldsErr_Ordinal = 0x3ae22659224effb9lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventUnionErr_Ordinal = 0xab5b2d1199942blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventTableErr_Ordinal = 0x6c6abc426c7c8406lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEvent_Ordinal = 0x11c9ba570ce71df3lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventFields_Ordinal = 0x3ba8fd32bf87d862lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventFields_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventUnion_Ordinal = 0x7c3823f47ce0fcadlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventTable_Ordinal = 0x9ca944d1d6436b0lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventTable_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventErr_Ordinal = 0x4fbe0d51e074e5bclu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Ordinal = 0x22a3e45e944031c4lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Ordinal = 0xc1637e7694d6680lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventTableErr_Ordinal = 0x6e69d4c524bf3a27lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;}  // namespace internal
#endif  // __Fuchsia__


#ifdef __Fuchsia__

using UnknownInteractionsClosedProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsClosedProtocol>;
class UnknownInteractionsClosedProtocol_Proxy;
class UnknownInteractionsClosedProtocol_Stub;
class UnknownInteractionsClosedProtocol_EventSender;
class UnknownInteractionsClosedProtocol_Sync;
using UnknownInteractionsClosedProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsClosedProtocol>;
class UnknownInteractionsClosedProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictOneWay_Ordinal = 0x59282385962da24lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWay_Ordinal = 0x5eda305d6b22f1f7lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayFields_Ordinal = 0x1323afa3e0541253lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayUnion_Ordinal = 0x68b32554eb0f6fa7lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayTable_Ordinal = 0x6e4a94d44b69e785lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayErr_Ordinal = 0x4fa35d5433db4d3alu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Ordinal = 0xb22aebf23bb58fdlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Ordinal = 0xcd65d4d29a43c80lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Ordinal = 0x117dde20b92f7b90lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEvent_Ordinal = 0xa8ee6ee302f693blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventFields_Ordinal = 0x5d7c57b62e9c3a74lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventFields_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventUnion_Ordinal = 0x3b8475deeb4a9d64lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventUnion_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventTable_Ordinal = 0x27da43fc85a7f5belu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventTable_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventErr_Ordinal = 0x12b105b1430a1201lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventFieldsErr_Ordinal = 0x2d16399d2e8a5c96lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventFieldsErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventUnionErr_Ordinal = 0x6dcf67f2a1d16034lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventUnionErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventTableErr_Ordinal = 0x4e90e92eafa9eefalu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventTableErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Sync;
  virtual ~UnknownInteractionsProtocol();
      
  virtual void StrictOneWay() = 0;
      
  virtual void FlexibleOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;
      
  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayFieldsCallback =
      fit::function<void(int32_t)>;
      
  virtual void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) = 0;
  using StrictTwoWayUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse)>;
      
  virtual void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) = 0;
  using StrictTwoWayTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse)>;
      
  virtual void StrictTwoWayTable(StrictTwoWayTableCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result)>;
      
  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using StrictTwoWayFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result)>;
      
  virtual void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) = 0;
  using StrictTwoWayUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result)>;
      
  virtual void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) = 0;
  using StrictTwoWayTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result)>;
      
  virtual void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) = 0;
  using FlexibleTwoWayCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result)>;
      
  virtual void FlexibleTwoWay(FlexibleTwoWayCallback callback) = 0;
  using FlexibleTwoWayFieldsCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result)>;
      
  virtual void FlexibleTwoWayFields(FlexibleTwoWayFieldsCallback callback) = 0;
  using FlexibleTwoWayUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result)>;
      
  virtual void FlexibleTwoWayUnion(FlexibleTwoWayUnionCallback callback) = 0;
  using FlexibleTwoWayTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result)>;
      
  virtual void FlexibleTwoWayTable(FlexibleTwoWayTableCallback callback) = 0;
  using FlexibleTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result)>;
      
  virtual void FlexibleTwoWayErr(FlexibleTwoWayErrCallback callback) = 0;
  using FlexibleTwoWayFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result)>;
      
  virtual void FlexibleTwoWayFieldsErr(FlexibleTwoWayFieldsErrCallback callback) = 0;
  using FlexibleTwoWayUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result)>;
      
  virtual void FlexibleTwoWayUnionErr(FlexibleTwoWayUnionErrCallback callback) = 0;
  using FlexibleTwoWayTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result)>;
      
  virtual void FlexibleTwoWayTableErr(FlexibleTwoWayTableErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventFieldsCallback =
      fit::function<void(int32_t)>;
  using StrictEventUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest)>;
  using StrictEventTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest)>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result)>;
  using StrictEventFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result)>;
  using StrictEventUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result)>;
  using StrictEventTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result)>;
  using FlexibleEventCallback =
      fit::function<void()>;
  using FlexibleEventFieldsCallback =
      fit::function<void(int32_t)>;
  using FlexibleEventUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest)>;
  using FlexibleEventTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest)>;
  using FlexibleEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result)>;
  using FlexibleEventFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result)>;
  using FlexibleEventUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result)>;
  using FlexibleEventTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result)>;
};

class UnknownInteractionsProtocol_RequestDecoder {
 public:
  UnknownInteractionsProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void FlexibleOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields() = 0;
  virtual void StrictTwoWayUnion() = 0;
  virtual void StrictTwoWayTable() = 0;
  virtual void StrictTwoWayErr() = 0;
  virtual void StrictTwoWayFieldsErr() = 0;
  virtual void StrictTwoWayUnionErr() = 0;
  virtual void StrictTwoWayTableErr() = 0;
  virtual void FlexibleTwoWay() = 0;
  virtual void FlexibleTwoWayFields() = 0;
  virtual void FlexibleTwoWayUnion() = 0;
  virtual void FlexibleTwoWayTable() = 0;
  virtual void FlexibleTwoWayErr() = 0;
  virtual void FlexibleTwoWayFieldsErr() = 0;
  virtual void FlexibleTwoWayUnionErr() = 0;
  virtual void FlexibleTwoWayTableErr() = 0;
};

class UnknownInteractionsProtocol_ResponseDecoder {
 public:
  UnknownInteractionsProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields(int32_t some_field) = 0;
  virtual void StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse UnknownInteractionsProtocolStrictTwoWayUnionResponse) = 0;
  virtual void StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse UnknownInteractionsProtocolStrictTwoWayTableResponse) = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result result) = 0;
  virtual void StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result result) = 0;
  virtual void StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result result) = 0;
  virtual void FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result result) = 0;
  virtual void FlexibleTwoWayFields(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result result) = 0;
  virtual void FlexibleTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result result) = 0;
  virtual void FlexibleTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result result) = 0;
  virtual void FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result result) = 0;
  virtual void FlexibleTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result result) = 0;
  virtual void FlexibleTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result result) = 0;
  virtual void FlexibleTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest UnknownInteractionsProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest UnknownInteractionsProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventFields(int32_t some_field) = 0;
  virtual void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest UnknownInteractionsProtocolFlexibleEventUnionRequest) = 0;
  virtual void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest UnknownInteractionsProtocolFlexibleEventTableRequest) = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) = 0;
  virtual void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result result) = 0;
  virtual void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result result) = 0;
  virtual void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result result) = 0;
};

class UnknownInteractionsProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest UnknownInteractionsProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest UnknownInteractionsProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventFields(int32_t some_field) = 0;
  virtual void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest UnknownInteractionsProtocolFlexibleEventUnionRequest) = 0;
  virtual void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest UnknownInteractionsProtocolFlexibleEventTableRequest) = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) = 0;
  virtual void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result result) = 0;
  virtual void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result result) = 0;
  virtual void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result result) = 0;
};

class UnknownInteractionsProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsProtocol_SyncProxy;
  virtual ~UnknownInteractionsProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t FlexibleOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayFields(int32_t* out_some_field) = 0;
  virtual zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsProtocolStrictTwoWayUnionResponse) = 0;
  virtual zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse* out_UnknownInteractionsProtocolStrictTwoWayTableResponse) = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayFields(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* out_result) = 0;
};

class UnknownInteractionsProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsProtocol {
 public:
  explicit UnknownInteractionsProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleOneWay
  void FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayFields
  void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayUnion
  void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayTable
  void StrictTwoWayTable(StrictTwoWayTableCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayFieldsErr
  void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayUnionErr
  void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayTableErr
  void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWay
  void FlexibleTwoWay(FlexibleTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayFields
  void FlexibleTwoWayFields(FlexibleTwoWayFieldsCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayUnion
  void FlexibleTwoWayUnion(FlexibleTwoWayUnionCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayTable
  void FlexibleTwoWayTable(FlexibleTwoWayTableCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayErr
  void FlexibleTwoWayErr(FlexibleTwoWayErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayFieldsErr
  void FlexibleTwoWayFieldsErr(FlexibleTwoWayFieldsErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayUnionErr
  void FlexibleTwoWayUnionErr(FlexibleTwoWayUnionErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayTableErr
  void FlexibleTwoWayTableErr(FlexibleTwoWayTableErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventFieldsCallback StrictEventFields;
  StrictEventUnionCallback StrictEventUnion;
  StrictEventTableCallback StrictEventTable;
  StrictEventErrCallback StrictEventErr;
  StrictEventFieldsErrCallback StrictEventFieldsErr;
  StrictEventUnionErrCallback StrictEventUnionErr;
  StrictEventTableErrCallback StrictEventTableErr;
  FlexibleEventCallback FlexibleEvent;
  FlexibleEventFieldsCallback FlexibleEventFields;
  FlexibleEventUnionCallback FlexibleEventUnion;
  FlexibleEventTableCallback FlexibleEventTable;
  FlexibleEventErrCallback FlexibleEventErr;
  FlexibleEventFieldsErrCallback FlexibleEventFieldsErr;
  FlexibleEventUnionErrCallback FlexibleEventUnionErr;
  FlexibleEventTableErrCallback FlexibleEventTableErr;

 private:
  UnknownInteractionsProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy&) = delete;
  UnknownInteractionsProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsProtocol UnknownInteractionsProtocol_clazz;
  explicit UnknownInteractionsProtocol_Stub(::test::unknowninteractions::UnknownInteractionsProtocol_Stub::UnknownInteractionsProtocol_clazz* impl);
  ~UnknownInteractionsProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventFields(int32_t some_field) override;
  void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest UnknownInteractionsProtocolStrictEventUnionRequest) override;
  void StrictEventTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest UnknownInteractionsProtocolStrictEventTableRequest) override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) override;
  void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result result) override;
  void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result result) override;
  void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result result) override;
  void FlexibleEvent() override;
  void FlexibleEventFields(int32_t some_field) override;
  void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest UnknownInteractionsProtocolFlexibleEventUnionRequest) override;
  void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest UnknownInteractionsProtocolFlexibleEventTableRequest) override;
  void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) override;
  void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result result) override;
  void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result result) override;
  void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsProtocol_Stub::UnknownInteractionsProtocol_clazz* impl_;
};

class UnknownInteractionsProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsProtocol_Sync {
 public:
  explicit UnknownInteractionsProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleOneWay
  zx_status_t FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayFields
  zx_status_t StrictTwoWayFields(int32_t* out_some_field) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayUnion
  zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsProtocolStrictTwoWayUnionResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayTable
  zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse* out_UnknownInteractionsProtocolStrictTwoWayTableResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayFieldsErr
  zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayUnionErr
  zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayTableErr
  zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWay
  zx_status_t FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayFields
  zx_status_t FlexibleTwoWayFields(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayUnion
  zx_status_t FlexibleTwoWayUnion(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayTable
  zx_status_t FlexibleTwoWayTable(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayErr
  zx_status_t FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayFieldsErr
  zx_status_t FlexibleTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayUnionErr
  zx_status_t FlexibleTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayTableErr
  zx_status_t FlexibleTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsAjarProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Sync;
  virtual ~UnknownInteractionsAjarProtocol();
      
  virtual void StrictOneWay() = 0;
      
  virtual void FlexibleOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;
      
  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayFieldsCallback =
      fit::function<void(int32_t)>;
      
  virtual void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) = 0;
  using StrictTwoWayUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse)>;
      
  virtual void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) = 0;
  using StrictTwoWayTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse)>;
      
  virtual void StrictTwoWayTable(StrictTwoWayTableCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result)>;
      
  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using StrictTwoWayFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result)>;
      
  virtual void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) = 0;
  using StrictTwoWayUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result)>;
      
  virtual void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) = 0;
  using StrictTwoWayTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result)>;
      
  virtual void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventFieldsCallback =
      fit::function<void(int32_t)>;
  using StrictEventUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest)>;
  using StrictEventTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest)>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result)>;
  using StrictEventFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result)>;
  using StrictEventUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result)>;
  using StrictEventTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result)>;
  using FlexibleEventCallback =
      fit::function<void()>;
  using FlexibleEventFieldsCallback =
      fit::function<void(int32_t)>;
  using FlexibleEventUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest)>;
  using FlexibleEventTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest)>;
  using FlexibleEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result)>;
  using FlexibleEventFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result)>;
  using FlexibleEventUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result)>;
  using FlexibleEventTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result)>;
};

class UnknownInteractionsAjarProtocol_RequestDecoder {
 public:
  UnknownInteractionsAjarProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsAjarProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void FlexibleOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields() = 0;
  virtual void StrictTwoWayUnion() = 0;
  virtual void StrictTwoWayTable() = 0;
  virtual void StrictTwoWayErr() = 0;
  virtual void StrictTwoWayFieldsErr() = 0;
  virtual void StrictTwoWayUnionErr() = 0;
  virtual void StrictTwoWayTableErr() = 0;
};

class UnknownInteractionsAjarProtocol_ResponseDecoder {
 public:
  UnknownInteractionsAjarProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsAjarProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields(int32_t some_field) = 0;
  virtual void StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) = 0;
  virtual void StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse UnknownInteractionsAjarProtocolStrictTwoWayTableResponse) = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result result) = 0;
  virtual void StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result result) = 0;
  virtual void StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest UnknownInteractionsAjarProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest UnknownInteractionsAjarProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventFields(int32_t some_field) = 0;
  virtual void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest UnknownInteractionsAjarProtocolFlexibleEventUnionRequest) = 0;
  virtual void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest UnknownInteractionsAjarProtocolFlexibleEventTableRequest) = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) = 0;
  virtual void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result result) = 0;
  virtual void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result result) = 0;
  virtual void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result result) = 0;
};

class UnknownInteractionsAjarProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsAjarProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest UnknownInteractionsAjarProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest UnknownInteractionsAjarProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventFields(int32_t some_field) = 0;
  virtual void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest UnknownInteractionsAjarProtocolFlexibleEventUnionRequest) = 0;
  virtual void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest UnknownInteractionsAjarProtocolFlexibleEventTableRequest) = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) = 0;
  virtual void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result result) = 0;
  virtual void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result result) = 0;
  virtual void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result result) = 0;
};

class UnknownInteractionsAjarProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_SyncProxy;
  virtual ~UnknownInteractionsAjarProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t FlexibleOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayFields(int32_t* out_some_field) = 0;
  virtual zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) = 0;
  virtual zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* out_UnknownInteractionsAjarProtocolStrictTwoWayTableResponse) = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* out_result) = 0;
};

class UnknownInteractionsAjarProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsAjarProtocol {
 public:
  explicit UnknownInteractionsAjarProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsAjarProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.FlexibleOneWay
  void FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayFields
  void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayUnion
  void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayTable
  void StrictTwoWayTable(StrictTwoWayTableCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayFieldsErr
  void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayUnionErr
  void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayTableErr
  void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventFieldsCallback StrictEventFields;
  StrictEventUnionCallback StrictEventUnion;
  StrictEventTableCallback StrictEventTable;
  StrictEventErrCallback StrictEventErr;
  StrictEventFieldsErrCallback StrictEventFieldsErr;
  StrictEventUnionErrCallback StrictEventUnionErr;
  StrictEventTableErrCallback StrictEventTableErr;
  FlexibleEventCallback FlexibleEvent;
  FlexibleEventFieldsCallback FlexibleEventFields;
  FlexibleEventUnionCallback FlexibleEventUnion;
  FlexibleEventTableCallback FlexibleEventTable;
  FlexibleEventErrCallback FlexibleEventErr;
  FlexibleEventFieldsErrCallback FlexibleEventFieldsErr;
  FlexibleEventUnionErrCallback FlexibleEventUnionErr;
  FlexibleEventTableErrCallback FlexibleEventTableErr;

 private:
  UnknownInteractionsAjarProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy&) = delete;
  UnknownInteractionsAjarProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsAjarProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsAjarProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsAjarProtocol UnknownInteractionsAjarProtocol_clazz;
  explicit UnknownInteractionsAjarProtocol_Stub(::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub::UnknownInteractionsAjarProtocol_clazz* impl);
  ~UnknownInteractionsAjarProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventFields(int32_t some_field) override;
  void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest UnknownInteractionsAjarProtocolStrictEventUnionRequest) override;
  void StrictEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest UnknownInteractionsAjarProtocolStrictEventTableRequest) override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) override;
  void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result result) override;
  void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result result) override;
  void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result result) override;
  void FlexibleEvent() override;
  void FlexibleEventFields(int32_t some_field) override;
  void FlexibleEventUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest UnknownInteractionsAjarProtocolFlexibleEventUnionRequest) override;
  void FlexibleEventTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest UnknownInteractionsAjarProtocolFlexibleEventTableRequest) override;
  void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) override;
  void FlexibleEventFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result result) override;
  void FlexibleEventUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result result) override;
  void FlexibleEventTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub::UnknownInteractionsAjarProtocol_clazz* impl_;
};

class UnknownInteractionsAjarProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Sync {
 public:
  explicit UnknownInteractionsAjarProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsAjarProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.FlexibleOneWay
  zx_status_t FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayFields
  zx_status_t StrictTwoWayFields(int32_t* out_some_field) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayUnion
  zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayTable
  zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* out_UnknownInteractionsAjarProtocolStrictTwoWayTableResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayFieldsErr
  zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayUnionErr
  zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayTableErr
  zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsAjarProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsClosedProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Sync;
  virtual ~UnknownInteractionsClosedProtocol();
      
  virtual void StrictOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;
      
  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayFieldsCallback =
      fit::function<void(int32_t)>;
      
  virtual void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) = 0;
  using StrictTwoWayUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse)>;
      
  virtual void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) = 0;
  using StrictTwoWayTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse)>;
      
  virtual void StrictTwoWayTable(StrictTwoWayTableCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result)>;
      
  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using StrictTwoWayFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result)>;
      
  virtual void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) = 0;
  using StrictTwoWayUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result)>;
      
  virtual void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) = 0;
  using StrictTwoWayTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result)>;
      
  virtual void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventFieldsCallback =
      fit::function<void(int32_t)>;
  using StrictEventUnionCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest)>;
  using StrictEventTableCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest)>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result)>;
  using StrictEventFieldsErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result)>;
  using StrictEventUnionErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result)>;
  using StrictEventTableErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result)>;
};

class UnknownInteractionsClosedProtocol_RequestDecoder {
 public:
  UnknownInteractionsClosedProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsClosedProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields() = 0;
  virtual void StrictTwoWayUnion() = 0;
  virtual void StrictTwoWayTable() = 0;
  virtual void StrictTwoWayErr() = 0;
  virtual void StrictTwoWayFieldsErr() = 0;
  virtual void StrictTwoWayUnionErr() = 0;
  virtual void StrictTwoWayTableErr() = 0;
};

class UnknownInteractionsClosedProtocol_ResponseDecoder {
 public:
  UnknownInteractionsClosedProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsClosedProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayFields(int32_t some_field) = 0;
  virtual void StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) = 0;
  virtual void StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse UnknownInteractionsClosedProtocolStrictTwoWayTableResponse) = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result result) = 0;
  virtual void StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result result) = 0;
  virtual void StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest UnknownInteractionsClosedProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest UnknownInteractionsClosedProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result result) = 0;
};

class UnknownInteractionsClosedProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsClosedProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventFields(int32_t some_field) = 0;
  virtual void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest UnknownInteractionsClosedProtocolStrictEventUnionRequest) = 0;
  virtual void StrictEventTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest UnknownInteractionsClosedProtocolStrictEventTableRequest) = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) = 0;
  virtual void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result result) = 0;
  virtual void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result result) = 0;
  virtual void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result result) = 0;
};

class UnknownInteractionsClosedProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_SyncProxy;
  virtual ~UnknownInteractionsClosedProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayFields(int32_t* out_some_field) = 0;
  virtual zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) = 0;
  virtual zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* out_UnknownInteractionsClosedProtocolStrictTwoWayTableResponse) = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* out_result) = 0;
  virtual zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* out_result) = 0;
};

class UnknownInteractionsClosedProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsClosedProtocol {
 public:
  explicit UnknownInteractionsClosedProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsClosedProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayFields
  void StrictTwoWayFields(StrictTwoWayFieldsCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayUnion
  void StrictTwoWayUnion(StrictTwoWayUnionCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayTable
  void StrictTwoWayTable(StrictTwoWayTableCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayFieldsErr
  void StrictTwoWayFieldsErr(StrictTwoWayFieldsErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayUnionErr
  void StrictTwoWayUnionErr(StrictTwoWayUnionErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayTableErr
  void StrictTwoWayTableErr(StrictTwoWayTableErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventFieldsCallback StrictEventFields;
  StrictEventUnionCallback StrictEventUnion;
  StrictEventTableCallback StrictEventTable;
  StrictEventErrCallback StrictEventErr;
  StrictEventFieldsErrCallback StrictEventFieldsErr;
  StrictEventUnionErrCallback StrictEventUnionErr;
  StrictEventTableErrCallback StrictEventTableErr;

 private:
  UnknownInteractionsClosedProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy&) = delete;
  UnknownInteractionsClosedProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsClosedProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsClosedProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsClosedProtocol UnknownInteractionsClosedProtocol_clazz;
  explicit UnknownInteractionsClosedProtocol_Stub(::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub::UnknownInteractionsClosedProtocol_clazz* impl);
  ~UnknownInteractionsClosedProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventFields(int32_t some_field) override;
  void StrictEventUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest UnknownInteractionsClosedProtocolStrictEventUnionRequest) override;
  void StrictEventTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest UnknownInteractionsClosedProtocolStrictEventTableRequest) override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) override;
  void StrictEventFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result result) override;
  void StrictEventUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result result) override;
  void StrictEventTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub::UnknownInteractionsClosedProtocol_clazz* impl_;
};

class UnknownInteractionsClosedProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Sync {
 public:
  explicit UnknownInteractionsClosedProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsClosedProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayFields
  zx_status_t StrictTwoWayFields(int32_t* out_some_field) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayUnion
  zx_status_t StrictTwoWayUnion(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* out_UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayTable
  zx_status_t StrictTwoWayTable(::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* out_UnknownInteractionsClosedProtocolStrictTwoWayTableResponse) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayFieldsErr
  zx_status_t StrictTwoWayFieldsErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayUnionErr
  zx_status_t StrictTwoWayUnionErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayTableErr
  zx_status_t StrictTwoWayTableErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result* out_result) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsClosedProtocol>;
};
#endif  // __Fuchsia__

}  // namespace unknowninteractions
}  // namespace test


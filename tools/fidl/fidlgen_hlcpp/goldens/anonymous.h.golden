// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace test {
namespace anonymous {
class UnionMember;

class TableData;

class TableMember;

class SomeProtocol_SomeMethod_Error final {
 public:
  constexpr SomeProtocol_SomeMethod_Error() : value_(0) {}
  constexpr explicit SomeProtocol_SomeMethod_Error(uint32_t value)
      : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static SomeProtocol_SomeMethod_Error Unknown() {
    return SomeProtocol_SomeMethod_Error(0xffffffff);
  }

  static const SomeProtocol_SomeMethod_Error ERROR_ONE;

  static const SomeProtocol_SomeMethod_Error ERROR_TWO;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::SomeProtocol_SomeMethod_Error
    SomeProtocol_SomeMethod_Error::ERROR_ONE =
        ::test::anonymous::SomeProtocol_SomeMethod_Error(1u);
constexpr const ::test::anonymous::SomeProtocol_SomeMethod_Error
    SomeProtocol_SomeMethod_Error::ERROR_TWO =
        ::test::anonymous::SomeProtocol_SomeMethod_Error(2u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(
    ::test::anonymous::SomeProtocol_SomeMethod_Error value,
    ::test::anonymous::SomeProtocol_SomeMethod_Error* result) {
  *result = value;
  return ZX_OK;
}

class Op final {
 public:
  constexpr Op() : value_(0) {}
  constexpr explicit Op(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

      case 3u:

        return false;
    }
    return true;
  }

  constexpr static Op Unknown() { return Op(0xffffffff); }

  static const Op ADD;

  static const Op MUL;

  static const Op DIV;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::Op Op::ADD = ::test::anonymous::Op(1u);
constexpr const ::test::anonymous::Op Op::MUL = ::test::anonymous::Op(2u);
constexpr const ::test::anonymous::Op Op::DIV = ::test::anonymous::Op(3u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::anonymous::Op value,
                         ::test::anonymous::Op* result) {
  *result = value;
  return ZX_OK;
}

class OverrideTest;

// |Flags| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class Flags final {
 public:
  constexpr Flags() = default;

  // Constructs an instance of |Flags| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<Flags> TryFrom(uint16_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Flags TruncatingUnknown(uint16_t value) {
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  constexpr explicit Flags(uint16_t value) : value_(value) {}
  const static Flags INLINE;
  const static Flags kMask;

  explicit constexpr inline operator uint16_t() const { return value_; }
  explicit constexpr inline operator bool() const {
    return static_cast<bool>(value_);
  }
  constexpr inline bool operator==(const Flags& other) const {
    return value_ == other.value_;
  }
  constexpr inline bool operator!=(const Flags& other) const {
    return value_ != other.value_;
  }
  constexpr inline Flags operator~() const;
  constexpr inline Flags operator|(const Flags& other) const;
  constexpr inline Flags operator&(const Flags& other) const;
  constexpr inline Flags operator^(const Flags& other) const;
  constexpr inline void operator|=(const Flags& other);
  constexpr inline void operator&=(const Flags& other);
  constexpr inline void operator^=(const Flags& other);
  constexpr inline Flags unknown_bits() const {
    return *this & Flags(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const {
    return static_cast<bool>(unknown_bits());
  }

 private:
  uint16_t value_ = 0;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::Flags Flags::INLINE =
    ::test::anonymous::Flags(1u);
constexpr const ::test::anonymous::Flags Flags::kMask =
    ::test::anonymous::Flags(1u);

#endif  // !(__cplusplus < 201703)

constexpr inline ::test::anonymous::Flags Flags::operator~() const {
  return ::test::anonymous::Flags(
      static_cast<uint16_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator|(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(
      static_cast<uint16_t>(this->value_ | other.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator&(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(
      static_cast<uint16_t>(this->value_ & other.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator^(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(
      static_cast<uint16_t>(this->value_ ^ other.value_));
}

constexpr inline void Flags::operator|=(const ::test::anonymous::Flags& other) {
  this->value_ |= other.value_;
}

constexpr inline void Flags::operator&=(const ::test::anonymous::Flags& other) {
  this->value_ &= other.value_;
}

constexpr inline void Flags::operator^=(const ::test::anonymous::Flags& other) {
  this->value_ ^= other.value_;
}

inline zx_status_t Clone(::test::anonymous::Flags value,
                         ::test::anonymous::Flags* result) {
  *result = value;
  return ZX_OK;
}

class FunctionApplication;

class Expression;

// |BitsMember| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class BitsMember final {
 public:
  constexpr BitsMember() = default;

  // Constructs an instance of |BitsMember| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<BitsMember> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static BitsMember TruncatingUnknown(uint32_t value) {
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  constexpr explicit BitsMember(uint32_t value) : value_(value) {}
  const static BitsMember BIT_ONE;
  const static BitsMember BIT_TWO;
  const static BitsMember kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const {
    return static_cast<bool>(value_);
  }
  constexpr inline bool operator==(const BitsMember& other) const {
    return value_ == other.value_;
  }
  constexpr inline bool operator!=(const BitsMember& other) const {
    return value_ != other.value_;
  }
  constexpr inline BitsMember operator~() const;
  constexpr inline BitsMember operator|(const BitsMember& other) const;
  constexpr inline BitsMember operator&(const BitsMember& other) const;
  constexpr inline BitsMember operator^(const BitsMember& other) const;
  constexpr inline void operator|=(const BitsMember& other);
  constexpr inline void operator&=(const BitsMember& other);
  constexpr inline void operator^=(const BitsMember& other);
  constexpr inline BitsMember unknown_bits() const {
    return *this & BitsMember(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const {
    return static_cast<bool>(unknown_bits());
  }

 private:
  uint32_t value_ = 0;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::BitsMember BitsMember::BIT_ONE =
    ::test::anonymous::BitsMember(1u);
constexpr const ::test::anonymous::BitsMember BitsMember::BIT_TWO =
    ::test::anonymous::BitsMember(2u);
constexpr const ::test::anonymous::BitsMember BitsMember::kMask =
    ::test::anonymous::BitsMember(3u);

#endif  // !(__cplusplus < 201703)

constexpr inline ::test::anonymous::BitsMember BitsMember::operator~() const {
  return ::test::anonymous::BitsMember(
      static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator|(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator&(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator^(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(
      static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void BitsMember::operator|=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ |= other.value_;
}

constexpr inline void BitsMember::operator&=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ &= other.value_;
}

constexpr inline void BitsMember::operator^=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ ^= other.value_;
}

inline zx_status_t Clone(::test::anonymous::BitsMember value,
                         ::test::anonymous::BitsMember* result) {
  *result = value;
  return ZX_OK;
}

class SomeProtocol_SomeMethod_Response;

class SomeProtocol_SomeMethod_Result;

#ifdef __Fuchsia__

class SomeProtocol;
using SomeProtocolHandle = ::fidl::InterfaceHandle<SomeProtocol>;
#endif  // __Fuchsia__

class UnionMember final {
 public:
  static const fidl_type_t* FidlType;

  UnionMember();
  ~UnionMember();

  UnionMember(UnionMember&&);
  UnionMember& operator=(UnionMember&&);

  static UnionMember WithUnionData(uint8_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,

    kUnionData = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnionMember> New() {
    return ::std::make_unique<UnionMember>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnionMember* value,
                     size_t offset);
  zx_status_t Clone(UnionMember* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_union_data() const {
    return tag_ == ::test::anonymous::UnionMember::Tag::kUnionData;
  }

  uint8_t& union_data() {
    EnsureStorageInitialized(::test::anonymous::UnionMember::Tag::kUnionData);
    return union_data_;
  }

  const uint8_t& union_data() const {
    ZX_ASSERT(is_union_data());
    return union_data_;
  }
  UnionMember& set_union_data(uint8_t value);
  UnionMember& SetUnknownData(fidl_xunion_tag_t ordinal,
                              std::vector<uint8_t> bytes);

  ::test::anonymous::UnionMember::Tag Which() const {
    switch (tag_) {
      case ::test::anonymous::UnionMember::Tag::Invalid:
      case ::test::anonymous::UnionMember::Tag::kUnionData:
        return ::test::anonymous::UnionMember::Tag(tag_);
      default:
        return ::test::anonymous::UnionMember::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::anonymous::UnionMember::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::anonymous::UnionMember>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::anonymous::UnionMember::Tag::Invalid);
  union {
    uint8_t union_data_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::anonymous::UnionMember& value,
                         ::test::anonymous::UnionMember* result) {
  return value.Clone(result);
}

using UnionMemberPtr = ::std::unique_ptr<UnionMember>;

class TableData final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t data{};

  static inline ::std::unique_ptr<TableData> New() {
    return ::std::make_unique<TableData>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TableData* value,
                     size_t _offset);
  zx_status_t Clone(TableData* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::TableData& _value,
                         ::test::anonymous::TableData* _result) {
  return _value.Clone(_result);
}

using TableDataPtr = ::std::unique_ptr<TableData>;

class TableMember final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  const ::std::vector<::test::anonymous::TableData>& table_data() const {
    ZX_ASSERT(field_presence_.IsSet<1>());
    return table_data_value_.value;
  }
  bool has_table_data() const { return field_presence_.IsSet<1>(); }

  ::std::vector<::test::anonymous::TableData>* mutable_table_data() {
    if (!field_presence_.IsSet<1>()) {
      field_presence_.Set<1>();
      Construct(&table_data_value_.value);
    }
    return &table_data_value_.value;
  }
  TableMember& set_table_data(
      ::std::vector<::test::anonymous::TableData> _value) {
    if (!field_presence_.IsSet<1>()) {
      field_presence_.Set<1>();
      Construct(&table_data_value_.value, std::move(_value));
    } else {
      table_data_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_table_data() {
    if (!field_presence_.IsSet<1>()) {
      return;
    }
    field_presence_.Clear<1>();
    Destruct(&table_data_value_.value);
  }

  const std::map<uint64_t, std::vector<uint8_t>>& UnknownData() const {
    return _unknown_data;
  }

  void SetUnknownDataEntry(uint32_t ordinal, std::vector<uint8_t>&& data) {
    auto ord = static_cast<uint64_t>(ordinal);
    ZX_ASSERT(!IsOrdinalKnown(ord));
    _unknown_data.insert({ord, std::move(data)});
  }

  TableMember();
  TableMember(TableMember&& other);
  ~TableMember();
  TableMember& operator=(TableMember&& other);

  static inline ::std::unique_ptr<TableMember> New() {
    return ::std::make_unique<TableMember>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TableMember* _value,
                     size_t _offset);
  zx_status_t Clone(TableMember* _result) const;

 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    size_t max_ordinal =
        static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
    for (const auto& data : _unknown_data) {
      if (data.first > max_ordinal) {
        max_ordinal = data.first;
      }
    }
    return max_ordinal;
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      case 2:
        return true;
      default:
        return false;
    }
  }

  ::fidl::internal::BitSet<2> field_presence_;
  union ValueUnion_table_data {
    ValueUnion_table_data() {}
    ~ValueUnion_table_data() {}

    ::std::vector<::test::anonymous::TableData> value;
  };
  ValueUnion_table_data table_data_value_;
  std::map<uint64_t, std::vector<uint8_t>> _unknown_data;
};

using TableMemberPtr = ::std::unique_ptr<TableMember>;

class OverrideTest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::anonymous::Op op{};

  ::std::unique_ptr<::test::anonymous::Expression> left{};

  ::std::unique_ptr<::test::anonymous::Expression> right{};

  static inline ::std::unique_ptr<OverrideTest> New() {
    return ::std::make_unique<OverrideTest>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, OverrideTest* value,
                     size_t _offset);
  zx_status_t Clone(OverrideTest* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::OverrideTest& _value,
                         ::test::anonymous::OverrideTest* _result) {
  return _value.Clone(_result);
}

using OverrideTestPtr = ::std::unique_ptr<OverrideTest>;

class FunctionApplication final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  const ::std::string& func() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return func_value_.value;
  }
  bool has_func() const { return field_presence_.IsSet<0>(); }

  ::std::string* mutable_func() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&func_value_.value);
    }
    return &func_value_.value;
  }
  FunctionApplication& set_func(::std::string _value) {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&func_value_.value, std::move(_value));
    } else {
      func_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_func() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&func_value_.value);
  }

  const ::std::vector<::std::unique_ptr<::test::anonymous::Expression>>& args()
      const {
    ZX_ASSERT(field_presence_.IsSet<2>());
    return args_value_.value;
  }
  bool has_args() const { return field_presence_.IsSet<2>(); }

  ::std::vector<::std::unique_ptr<::test::anonymous::Expression>>*
  mutable_args() {
    if (!field_presence_.IsSet<2>()) {
      field_presence_.Set<2>();
      Construct(&args_value_.value);
    }
    return &args_value_.value;
  }
  FunctionApplication& set_args(
      ::std::vector<::std::unique_ptr<::test::anonymous::Expression>> _value) {
    if (!field_presence_.IsSet<2>()) {
      field_presence_.Set<2>();
      Construct(&args_value_.value, std::move(_value));
    } else {
      args_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_args() {
    if (!field_presence_.IsSet<2>()) {
      return;
    }
    field_presence_.Clear<2>();
    Destruct(&args_value_.value);
  }

  const ::test::anonymous::Flags& flags() const {
    ZX_ASSERT(field_presence_.IsSet<3>());
    return flags_value_.value;
  }
  bool has_flags() const { return field_presence_.IsSet<3>(); }

  ::test::anonymous::Flags* mutable_flags() {
    if (!field_presence_.IsSet<3>()) {
      field_presence_.Set<3>();
      Construct(&flags_value_.value);
    }
    return &flags_value_.value;
  }
  FunctionApplication& set_flags(::test::anonymous::Flags _value) {
    if (!field_presence_.IsSet<3>()) {
      field_presence_.Set<3>();
      Construct(&flags_value_.value, std::move(_value));
    } else {
      flags_value_.value = std::move(_value);
    }
    return *this;
  }
  void clear_flags() {
    if (!field_presence_.IsSet<3>()) {
      return;
    }
    field_presence_.Clear<3>();
    Destruct(&flags_value_.value);
  }

  const std::map<uint64_t, std::vector<uint8_t>>& UnknownData() const {
    return _unknown_data;
  }

  void SetUnknownDataEntry(uint32_t ordinal, std::vector<uint8_t>&& data) {
    auto ord = static_cast<uint64_t>(ordinal);
    ZX_ASSERT(!IsOrdinalKnown(ord));
    _unknown_data.insert({ord, std::move(data)});
  }

  FunctionApplication();
  FunctionApplication(FunctionApplication&& other);
  ~FunctionApplication();
  FunctionApplication& operator=(FunctionApplication&& other);

  static inline ::std::unique_ptr<FunctionApplication> New() {
    return ::std::make_unique<FunctionApplication>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, FunctionApplication* _value,
                     size_t _offset);
  zx_status_t Clone(FunctionApplication* _result) const;

 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    size_t max_ordinal =
        static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
    for (const auto& data : _unknown_data) {
      if (data.first > max_ordinal) {
        max_ordinal = data.first;
      }
    }
    return max_ordinal;
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      case 1:
      case 3:
      case 4:
        return true;
      default:
        return false;
    }
  }

  ::fidl::internal::BitSet<4> field_presence_;
  union ValueUnion_func {
    ValueUnion_func() {}
    ~ValueUnion_func() {}

    ::std::string value;
  };
  ValueUnion_func func_value_;
  union ValueUnion_args {
    ValueUnion_args() {}
    ~ValueUnion_args() {}

    ::std::vector<::std::unique_ptr<::test::anonymous::Expression>> value;
  };
  ValueUnion_args args_value_;
  union ValueUnion_flags {
    ValueUnion_flags() {}
    ~ValueUnion_flags() {}

    ::test::anonymous::Flags value;
  };
  ValueUnion_flags flags_value_;
  std::map<uint64_t, std::vector<uint8_t>> _unknown_data;
};

using FunctionApplicationPtr = ::std::unique_ptr<FunctionApplication>;

class Expression final {
 public:
  static const fidl_type_t* FidlType;

  Expression();
  ~Expression();

  Expression(Expression&&);
  Expression& operator=(Expression&&);

  static Expression WithValue(uint64_t&&);
  static Expression WithBinOp(::test::anonymous::OverrideTest&&);
  static Expression WithFunctionApplication(
      ::test::anonymous::FunctionApplication&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,

    kValue = 1,                // 0x1
    kBinOp = 2,                // 0x2
    kFunctionApplication = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<Expression> New() {
    return ::std::make_unique<Expression>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Expression* value,
                     size_t offset);
  zx_status_t Clone(Expression* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_value() const {
    return tag_ == ::test::anonymous::Expression::Tag::kValue;
  }

  uint64_t& value() {
    EnsureStorageInitialized(::test::anonymous::Expression::Tag::kValue);
    return value_;
  }

  const uint64_t& value() const {
    ZX_ASSERT(is_value());
    return value_;
  }
  Expression& set_value(uint64_t value);

  bool is_bin_op() const {
    return tag_ == ::test::anonymous::Expression::Tag::kBinOp;
  }

  ::test::anonymous::OverrideTest& bin_op() {
    EnsureStorageInitialized(::test::anonymous::Expression::Tag::kBinOp);
    return bin_op_;
  }

  const ::test::anonymous::OverrideTest& bin_op() const {
    ZX_ASSERT(is_bin_op());
    return bin_op_;
  }
  Expression& set_bin_op(::test::anonymous::OverrideTest value);

  bool is_function_application() const {
    return tag_ == ::test::anonymous::Expression::Tag::kFunctionApplication;
  }

  ::test::anonymous::FunctionApplication& function_application() {
    EnsureStorageInitialized(
        ::test::anonymous::Expression::Tag::kFunctionApplication);
    return function_application_;
  }

  const ::test::anonymous::FunctionApplication& function_application() const {
    ZX_ASSERT(is_function_application());
    return function_application_;
  }
  Expression& set_function_application(
      ::test::anonymous::FunctionApplication value);
  Expression& SetUnknownData(fidl_xunion_tag_t ordinal,
                             std::vector<uint8_t> bytes);

  ::test::anonymous::Expression::Tag Which() const {
    switch (tag_) {
      case ::test::anonymous::Expression::Tag::Invalid:
      case ::test::anonymous::Expression::Tag::kValue:
      case ::test::anonymous::Expression::Tag::kBinOp:
      case ::test::anonymous::Expression::Tag::kFunctionApplication:
        return ::test::anonymous::Expression::Tag(tag_);
      default:
        return ::test::anonymous::Expression::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::anonymous::Expression::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::anonymous::Expression>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::anonymous::Expression::Tag::Invalid);
  union {
    uint64_t value_;
    ::test::anonymous::OverrideTest bin_op_;
    ::test::anonymous::FunctionApplication function_application_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::anonymous::Expression& value,
                         ::test::anonymous::Expression* result) {
  return value.Clone(result);
}

using ExpressionPtr = ::std::unique_ptr<Expression>;

class SomeProtocol_SomeMethod_Response final {
 public:
  static const fidl_type_t* FidlType;
  SomeProtocol_SomeMethod_Response() = default;
  explicit SomeProtocol_SomeMethod_Response(::test::anonymous::BitsMember v)
      : bits_member(std::move(v)) {}
  ::test::anonymous::BitsMember ResultValue_() {
    return std::move(bits_member);
  }
  explicit SomeProtocol_SomeMethod_Response(
      ::std::tuple<::test::anonymous::BitsMember> _value_tuple) {
    std::tie(bits_member) = std::move(_value_tuple);
  }
  operator ::std::tuple<::test::anonymous::BitsMember>() && {
    return std::make_tuple(std::move(bits_member));
  }

  ::test::anonymous::BitsMember bits_member{};

  static inline ::std::unique_ptr<SomeProtocol_SomeMethod_Response> New() {
    return ::std::make_unique<SomeProtocol_SomeMethod_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     SomeProtocol_SomeMethod_Response* value, size_t _offset);
  zx_status_t Clone(SomeProtocol_SomeMethod_Response* result) const;
};

inline zx_status_t Clone(
    const ::test::anonymous::SomeProtocol_SomeMethod_Response& _value,
    ::test::anonymous::SomeProtocol_SomeMethod_Response* _result) {
  return _value.Clone(_result);
}

using SomeProtocol_SomeMethod_ResponsePtr =
    ::std::unique_ptr<SomeProtocol_SomeMethod_Response>;

class SomeProtocol_SomeMethod_Result final {
 public:
  static const fidl_type_t* FidlType;

  SomeProtocol_SomeMethod_Result();
  ~SomeProtocol_SomeMethod_Result();

  SomeProtocol_SomeMethod_Result(SomeProtocol_SomeMethod_Result&&);
  SomeProtocol_SomeMethod_Result& operator=(SomeProtocol_SomeMethod_Result&&);

  static SomeProtocol_SomeMethod_Result WithResponse(
      ::test::anonymous::SomeProtocol_SomeMethod_Response&&);
  static SomeProtocol_SomeMethod_Result WithErr(
      ::test::anonymous::SomeProtocol_SomeMethod_Error&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<SomeProtocol_SomeMethod_Result> New() {
    return ::std::make_unique<SomeProtocol_SomeMethod_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     SomeProtocol_SomeMethod_Result* value, size_t offset);
  zx_status_t Clone(SomeProtocol_SomeMethod_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ ==
           ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse;
  }

  ::test::anonymous::SomeProtocol_SomeMethod_Response& response() {
    EnsureStorageInitialized(
        ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse);
    return response_;
  }

  const ::test::anonymous::SomeProtocol_SomeMethod_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  SomeProtocol_SomeMethod_Result& set_response(
      ::test::anonymous::SomeProtocol_SomeMethod_Response value);

  bool is_err() const {
    return tag_ == ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr;
  }

  ::test::anonymous::SomeProtocol_SomeMethod_Error& err() {
    EnsureStorageInitialized(
        ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr);
    return err_;
  }

  const ::test::anonymous::SomeProtocol_SomeMethod_Error& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  SomeProtocol_SomeMethod_Result& set_err(
      ::test::anonymous::SomeProtocol_SomeMethod_Error value);

  ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag Which() const {
    return ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<::test::anonymous::SomeProtocol_SomeMethod_Result>;
  SomeProtocol_SomeMethod_Result(
      fpromise::result<::test::anonymous::BitsMember,
                       ::test::anonymous::SomeProtocol_SomeMethod_Error>&&
          result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::anonymous::SomeProtocol_SomeMethod_Response{
          result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  SomeProtocol_SomeMethod_Result(
      fpromise::ok_result<::test::anonymous::BitsMember>&& result)
      : SomeProtocol_SomeMethod_Result(
            fpromise::result<::test::anonymous::BitsMember,
                             ::test::anonymous::SomeProtocol_SomeMethod_Error>(
                std::move(result))) {}
  SomeProtocol_SomeMethod_Result(
      fpromise::error_result<::test::anonymous::SomeProtocol_SomeMethod_Error>&&
          result)
      : SomeProtocol_SomeMethod_Result(
            fpromise::result<::test::anonymous::BitsMember,
                             ::test::anonymous::SomeProtocol_SomeMethod_Error>(
                std::move(result))) {}
  operator fpromise::result<
      ::test::anonymous::BitsMember,
      ::test::anonymous::SomeProtocol_SomeMethod_Error>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::anonymous::BitsMember> value_tuple =
        std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::Invalid);
  union {
    ::test::anonymous::SomeProtocol_SomeMethod_Response response_;
    ::test::anonymous::SomeProtocol_SomeMethod_Error err_;
  };
};

inline zx_status_t Clone(
    const ::test::anonymous::SomeProtocol_SomeMethod_Result& value,
    ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
  return value.Clone(result);
}

using SomeProtocol_SomeMethod_ResultPtr =
    ::std::unique_ptr<SomeProtocol_SomeMethod_Result>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_anonymous_SomeProtocolSomeMethodRequestTable;

}  // namespace _internal
class SomeProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage SomeMethod(
      ::fidl::MessageEncoder* _encoder,
      ::test::anonymous::UnionMember* union_member,
      ::test::anonymous::TableMember* table_member) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(40);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(32);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, union_member, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, table_member,
                     24 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, union_member, 0 + sizeof(fidl_message_header_t));

      ::fidl::Encode(_encoder, table_member,
                     16 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::anonymous::_internal::
                   test_anonymous_SomeProtocolSomeMethodRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    test_anonymous_SomeProtocolSomeMethodTopResponseTable;

}  // namespace _internal
class SomeProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage SomeMethod(
      ::fidl::MessageEncoder* _encoder,
      ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::internal::WireFormatVersion::kV1:
        _encoder->Alloc(24);
        break;
      case ::fidl::internal::WireFormatVersion::kV2:
        _encoder->Alloc(16);
        break;
    }

    if (_encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1) {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    } else {
      ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));
    }

    fidl_trace(DidHLCPPEncode,
               &::test::anonymous::_internal::
                   test_anonymous_SomeProtocolSomeMethodTopResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

}  // namespace anonymous
}  // namespace test
namespace fidl {
template <>
struct IsFidlXUnion<::test::anonymous::UnionMember> : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::UnionMember>
    : public EncodableCodingTraits<::test::anonymous::UnionMember, 24, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::anonymous::UnionMember>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder, std::unique_ptr<::test::anonymous::UnionMember>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder,
                     std::unique_ptr<::test::anonymous::UnionMember>* value,
                     size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::UnionMember);

    ::test::anonymous::UnionMember::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::anonymous::UnionMember& value,
                         ::test::anonymous::UnionMember* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::UnionMember> {
  bool operator()(const ::test::anonymous::UnionMember& _lhs,
                  const ::test::anonymous::UnionMember& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::anonymous::UnionMember::Tag::Invalid):
        return true;
      case ::test::anonymous::UnionMember::Tag::kUnionData:
        return ::fidl::Equals(_lhs.union_data_, _rhs.union_data_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
template <>
struct CodingTraits<::test::anonymous::TableData>
    : public EncodableCodingTraits<::test::anonymous::TableData, 1, 1> {};

template <>
struct IsMemcpyCompatible<::test::anonymous::TableData>
    : public internal::BoolConstant<
          !HasPadding<::test::anonymous::TableData>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::anonymous::TableData& value,
                         ::test::anonymous::TableData* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::TableData> {
  bool operator()(const ::test::anonymous::TableData& _lhs,
                  const ::test::anonymous::TableData& _rhs) const {
    if (!::fidl::Equals(_lhs.data, _rhs.data)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::TableMember>
    : public EncodableCodingTraits<::test::anonymous::TableMember, 16, 16> {};

inline zx_status_t Clone(const ::test::anonymous::TableMember& _value,
                         ::test::anonymous::TableMember* result) {
  return _value.Clone(result);
}
template <>
struct Equality<::test::anonymous::TableMember> {
  bool operator()(const ::test::anonymous::TableMember& _lhs,
                  const ::test::anonymous::TableMember& _rhs) const {
    if (_lhs.has_table_data()) {
      if (!_rhs.has_table_data()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.table_data(), _rhs.table_data())) {
        return false;
      }
    } else if (_rhs.has_table_data()) {
      return false;
    }
    return ::fidl::Equals(_lhs.UnknownData(), _rhs.UnknownData());
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Error> {
  static constexpr size_t inline_size_old =
      sizeof(::test::anonymous::SomeProtocol_SomeMethod_Error);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::anonymous::SomeProtocol_SomeMethod_Error);
  static constexpr size_t inline_size_v2 =
      sizeof(::test::anonymous::SomeProtocol_SomeMethod_Error);
  static void Encode(
      Encoder* encoder, ::test::anonymous::SomeProtocol_SomeMethod_Error* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder,
                     ::test::anonymous::SomeProtocol_SomeMethod_Error* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::SomeProtocol_SomeMethod_Error>(
        underlying);
  }
};

inline zx_status_t Clone(
    ::test::anonymous::SomeProtocol_SomeMethod_Error value,
    ::test::anonymous::SomeProtocol_SomeMethod_Error* result) {
  return ::test::anonymous::Clone(value, result);
}
template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Error> {
  bool operator()(
      const ::test::anonymous::SomeProtocol_SomeMethod_Error& _lhs,
      const ::test::anonymous::SomeProtocol_SomeMethod_Error& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::anonymous::Op> {
  static constexpr size_t inline_size_old = sizeof(::test::anonymous::Op);
  static constexpr size_t inline_size_v1_no_ee = sizeof(::test::anonymous::Op);
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::Op);
  static void Encode(
      Encoder* encoder, ::test::anonymous::Op* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::Op* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::Op>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::Op value,
                         ::test::anonymous::Op* result) {
  return ::test::anonymous::Clone(value, result);
}
template <>
struct Equality<::test::anonymous::Op> {
  bool operator()(const ::test::anonymous::Op& _lhs,
                  const ::test::anonymous::Op& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::anonymous::OverrideTest>
    : public EncodableCodingTraits<::test::anonymous::OverrideTest, 56, 40> {};

template <>
struct HasPadding<::test::anonymous::OverrideTest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::anonymous::OverrideTest>
    : public internal::BoolConstant<
          !HasPadding<::test::anonymous::OverrideTest>::value &&
          IsMemcpyCompatible<::test::anonymous::Op>::value &&
          IsMemcpyCompatible<
              ::std::unique_ptr<::test::anonymous::Expression>>::value> {};

inline zx_status_t Clone(const ::test::anonymous::OverrideTest& value,
                         ::test::anonymous::OverrideTest* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::OverrideTest> {
  bool operator()(const ::test::anonymous::OverrideTest& _lhs,
                  const ::test::anonymous::OverrideTest& _rhs) const {
    if (!::fidl::Equals(_lhs.op, _rhs.op)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.left, _rhs.left)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.right, _rhs.right)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::Flags> {
  static constexpr size_t inline_size_old = sizeof(::test::anonymous::Flags);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::anonymous::Flags);
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::Flags);
  static void Encode(
      Encoder* encoder, ::test::anonymous::Flags* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint16_t underlying = static_cast<uint16_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::Flags* value,
                     size_t offset) {
    uint16_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::Flags>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::Flags value,
                         ::test::anonymous::Flags* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::Flags> {
  bool operator()(const ::test::anonymous::Flags& _lhs,
                  const ::test::anonymous::Flags& _rhs) const {
    uint16_t _lhs_underlying = static_cast<uint16_t>(_lhs);
    uint16_t _rhs_underlying = static_cast<uint16_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::anonymous::FunctionApplication>
    : public EncodableCodingTraits<::test::anonymous::FunctionApplication, 16,
                                   16> {};

inline zx_status_t Clone(const ::test::anonymous::FunctionApplication& _value,
                         ::test::anonymous::FunctionApplication* result) {
  return _value.Clone(result);
}
template <>
struct Equality<::test::anonymous::FunctionApplication> {
  bool operator()(const ::test::anonymous::FunctionApplication& _lhs,
                  const ::test::anonymous::FunctionApplication& _rhs) const {
    if (_lhs.has_func()) {
      if (!_rhs.has_func()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.func(), _rhs.func())) {
        return false;
      }
    } else if (_rhs.has_func()) {
      return false;
    }
    if (_lhs.has_args()) {
      if (!_rhs.has_args()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.args(), _rhs.args())) {
        return false;
      }
    } else if (_rhs.has_args()) {
      return false;
    }
    if (_lhs.has_flags()) {
      if (!_rhs.has_flags()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.flags(), _rhs.flags())) {
        return false;
      }
    } else if (_rhs.has_flags()) {
      return false;
    }
    return ::fidl::Equals(_lhs.UnknownData(), _rhs.UnknownData());
  }
};
template <>
struct IsFidlXUnion<::test::anonymous::Expression> : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::Expression>
    : public EncodableCodingTraits<::test::anonymous::Expression, 24, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::anonymous::Expression>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder, std::unique_ptr<::test::anonymous::Expression>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder,
                     std::unique_ptr<::test::anonymous::Expression>* value,
                     size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::Expression);

    ::test::anonymous::Expression::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::anonymous::Expression& value,
                         ::test::anonymous::Expression* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::Expression> {
  bool operator()(const ::test::anonymous::Expression& _lhs,
                  const ::test::anonymous::Expression& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::anonymous::Expression::Tag::Invalid):
        return true;
      case ::test::anonymous::Expression::Tag::kValue:
        return ::fidl::Equals(_lhs.value_, _rhs.value_);
      case ::test::anonymous::Expression::Tag::kBinOp:
        return ::fidl::Equals(_lhs.bin_op_, _rhs.bin_op_);
      case ::test::anonymous::Expression::Tag::kFunctionApplication:
        return ::fidl::Equals(_lhs.function_application_,
                              _rhs.function_application_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
template <>
struct CodingTraits<::test::anonymous::BitsMember> {
  static constexpr size_t inline_size_old =
      sizeof(::test::anonymous::BitsMember);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::test::anonymous::BitsMember);
  static constexpr size_t inline_size_v2 =
      sizeof(::test::anonymous::BitsMember);
  static void Encode(
      Encoder* encoder, ::test::anonymous::BitsMember* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::BitsMember* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::BitsMember>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::BitsMember value,
                         ::test::anonymous::BitsMember* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::BitsMember> {
  bool operator()(const ::test::anonymous::BitsMember& _lhs,
                  const ::test::anonymous::BitsMember& _rhs) const {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Response>
    : public EncodableCodingTraits<
          ::test::anonymous::SomeProtocol_SomeMethod_Response, 4, 4> {};

template <>
struct IsMemcpyCompatible<::test::anonymous::SomeProtocol_SomeMethod_Response>
    : public internal::BoolConstant<
          !HasPadding<
              ::test::anonymous::SomeProtocol_SomeMethod_Response>::value &&
          IsMemcpyCompatible<::test::anonymous::BitsMember>::value> {};

inline zx_status_t Clone(
    const ::test::anonymous::SomeProtocol_SomeMethod_Response& value,
    ::test::anonymous::SomeProtocol_SomeMethod_Response* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Response> {
  bool operator()(
      const ::test::anonymous::SomeProtocol_SomeMethod_Response& _lhs,
      const ::test::anonymous::SomeProtocol_SomeMethod_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.bits_member, _rhs.bits_member)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::anonymous::SomeProtocol_SomeMethod_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Result>
    : public EncodableCodingTraits<
          ::test::anonymous::SomeProtocol_SomeMethod_Result, 24, 16> {};

template <>
struct CodingTraits<
    std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>* value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::SomeProtocol_SomeMethod_Result);

    ::test::anonymous::SomeProtocol_SomeMethod_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::test::anonymous::SomeProtocol_SomeMethod_Result& value,
    ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Result> {
  bool operator()(
      const ::test::anonymous::SomeProtocol_SomeMethod_Result& _lhs,
      const ::test::anonymous::SomeProtocol_SomeMethod_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::Invalid):
        return true;
      case ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace anonymous {
#ifdef __Fuchsia__

using SomeProtocolPtr = ::fidl::InterfacePtr<SomeProtocol>;
class SomeProtocol_Proxy;
class SomeProtocol_Stub;
class SomeProtocol_EventSender;
class SomeProtocol_Sync;
using SomeProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<SomeProtocol>;
class SomeProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kSomeProtocol_SomeMethod_Ordinal = 0x22ea52ec7a5146d8lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class SomeProtocol {
 public:
  using Proxy_ = ::test::anonymous::SomeProtocol_Proxy;
  using Stub_ = ::test::anonymous::SomeProtocol_Stub;
  using EventSender_ = ::test::anonymous::SomeProtocol_EventSender;
  using Sync_ = ::test::anonymous::SomeProtocol_Sync;
  virtual ~SomeProtocol();
  using SomeMethodCallback =
      fit::function<void(::test::anonymous::SomeProtocol_SomeMethod_Result)>;

  virtual void SomeMethod(::test::anonymous::UnionMember union_member,
                          ::test::anonymous::TableMember table_member,
                          SomeMethodCallback callback) = 0;
};

class SomeProtocol_RequestDecoder {
 public:
  SomeProtocol_RequestDecoder() = default;
  virtual ~SomeProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void SomeMethod(::test::anonymous::UnionMember union_member,
                          ::test::anonymous::TableMember table_member) = 0;
};

class SomeProtocol_ResponseDecoder {
 public:
  SomeProtocol_ResponseDecoder() = default;
  virtual ~SomeProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void SomeMethod(
      ::test::anonymous::SomeProtocol_SomeMethod_Result result) = 0;
};

class SomeProtocol_EventSender {
 public:
  virtual ~SomeProtocol_EventSender();
};

class SomeProtocol_Sync {
 public:
  using Proxy_ = ::test::anonymous::SomeProtocol_SyncProxy;
  virtual ~SomeProtocol_Sync();
  virtual zx_status_t SomeMethod(
      ::test::anonymous::UnionMember union_member,
      ::test::anonymous::TableMember table_member,
      ::test::anonymous::SomeProtocol_SomeMethod_Result* out_result) = 0;
};

class SomeProtocol_Proxy final : public ::fidl::internal::Proxy,
                                 public SomeProtocol {
 public:
  explicit SomeProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~SomeProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.anonymous/SomeProtocol.SomeMethod
  void SomeMethod(::test::anonymous::UnionMember union_member,
                  ::test::anonymous::TableMember table_member,
                  SomeMethodCallback callback) override;

 private:
  SomeProtocol_Proxy(const ::test::anonymous::SomeProtocol_Proxy&) = delete;
  SomeProtocol_Proxy& operator=(const ::test::anonymous::SomeProtocol_Proxy&) =
      delete;

  ::fidl::internal::ProxyController* controller_;
};

class SomeProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::test::anonymous::SomeProtocol_EventSender {
 public:
  typedef class ::test::anonymous::SomeProtocol SomeProtocol_clazz;
  explicit SomeProtocol_Stub(
      ::test::anonymous::SomeProtocol_Stub::SomeProtocol_clazz* impl);
  ~SomeProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::anonymous::SomeProtocol_Stub::SomeProtocol_clazz* impl_;
};

class SomeProtocol_SyncProxy : public ::test::anonymous::SomeProtocol_Sync {
 public:
  explicit SomeProtocol_SyncProxy(::zx::channel channel);
  ~SomeProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.anonymous/SomeProtocol.SomeMethod
  zx_status_t SomeMethod(
      ::test::anonymous::UnionMember union_member,
      ::test::anonymous::TableMember table_member,
      ::test::anonymous::SomeProtocol_SomeMethod_Result* out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<SomeProtocol>;
};
#endif  // __Fuchsia__

}  // namespace anonymous
}  // namespace test

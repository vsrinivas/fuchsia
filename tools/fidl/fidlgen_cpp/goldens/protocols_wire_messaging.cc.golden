// WARNING: This file is machine generated by fidlgen.

#include <fidl/test.protocols/cpp/wire_messaging.h>

#include <memory>


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal = 5413654872775949227lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal = 1631193469798418024lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal = 9037369643591427517lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal = 7326057319832554103lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal = 2877322062572412767lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal = 6417226585456833969lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal = 5397663296507358806lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


[[maybe_unused]]
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal = 5811598563493228968lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request_object{  };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request_object{ arg };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> empty_event;
            auto* primary = &empty_event;
          event_handler()->OnEmptyResponse(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnWithResponse(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestNoResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestEmptyResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestWithResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestNoResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestEmptyResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestWithResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::Dispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _response{ ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _response{ ret };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _response{ ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _response{ ret };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags);
    }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags);
    }
    
    
  


#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ResponseAsStruct_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ErrorAsEnum_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_HandleInResult_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__


  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::entries_[] = {
    { ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ResponseAsStruct(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ErrorAsPrimitive(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ErrorAsEnum(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::HandleInResult>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->HandleInResult(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::entries_end_ =
    &entries_[4];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplySuccess(int64_t a, int64_t b, int64_t c) {
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse {
  .a = std::move(a),
  .b = std::move(b),
  .c = std::move(c),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplySuccess(int64_t a, int64_t b, int64_t c) {
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse {
  .a = std::move(a),
  .b = std::move(b),
  .c = std::move(c),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Reply(::fit::result<uint32_t> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Reply(::fit::result<uint32_t> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(::fit::result<::test_protocols::wire::ErrorEnum> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplyError(::test_protocols::wire::ErrorEnum error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(::fit::result<::test_protocols::wire::ErrorEnum> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplyError(::test_protocols::wire::ErrorEnum error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> _response{ std::move(result) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplySuccess(::zx::handle&& h) {
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response = ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse {
  .h = std::move(h),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> _response{ std::move(result) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplySuccess(::zx::handle&& h) {
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response = ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse {
  .h = std::move(h),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal, ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
  }
    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal, ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    
  


#ifdef __Fuchsia__


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 3155008840945527714lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MethodA_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;


[[maybe_unused]]
constexpr uint64_t kChannelProtocol_EventA_Ordinal = 2220452875311597006lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kChannelProtocol_EventA_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;


[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 8903004957800778182lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MethodB_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;


extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;


[[maybe_unused]]
constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal = 591935489944717925lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kChannelProtocol_TakeHandle_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;


[[maybe_unused]]
constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MutateSocket_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;


extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MethodB>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MethodB>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request_object{ a, b };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kChannelProtocol_EventA_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::ChannelProtocol::EventA>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventA(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::entries_[] = {
    { ::test_protocols::kChannelProtocol_MethodA_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::ChannelProtocolMethodARequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MethodA(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_MethodB_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::ChannelProtocolMethodBRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MethodB(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::ChannelProtocolTakeHandleRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::TakeHandle>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->TakeHandle(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::ChannelProtocolMutateSocketRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MutateSocket>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MutateSocket(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::entries_end_ =
    &entries_[4];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  return MakeReply(result);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::MakeReply(int64_t result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  return MakeReply(result);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::MakeReply(int64_t result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  return MakeReply(std::move(b));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::MakeReply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> _response{ std::move(b) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  return MakeReply(std::move(b));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::MakeReply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> _response{ std::move(b) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodA_Ordinal, ::test_protocols::kChannelProtocol_MethodA_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_EventA_Ordinal, ::test_protocols::kChannelProtocol_EventA_DynamicFlags);
    }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
  }
    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal, ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal, ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
  }
    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    
  


#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::EventA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::EventA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kTransitional_Request_Ordinal = 5849263021838298888lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kTransitional_Request_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;


extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;


[[maybe_unused]]
constexpr uint64_t kTransitional_OneWay_Ordinal = 4336658926562441191lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kTransitional_OneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;


[[maybe_unused]]
constexpr uint64_t kTransitional_Event_Ordinal = 8507647465196374081lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kTransitional_Event_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::Transitional::Request>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::Transitional::Request>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::Transitional::Request>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::Transitional::Request>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::Transitional::Request>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::Transitional::OneWay>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::Transitional::OneWay>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional>::OneWay(int64_t x) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request_object{ x };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::Transitional::Request> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional>::Request(int64_t x) {
    ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
    return ::fidl::internal::WireThenable<::test_protocols::Transitional::Request>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::Transitional>::OneWay(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::Transitional::OneWay>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request{ x };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::Transitional::Request> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::Transitional>::Request(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::Transitional::Request>();
  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
  return ::fidl::internal::WireBufferThenable<::test_protocols::Transitional::Request>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::Transitional::Request>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional>::Request(int64_t x) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
          return ::fidl::WireResult<::test_protocols::Transitional::Request>(::fidl::UnownedClientEnd<::test_protocols::Transitional>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::Transitional>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::Transitional> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::Transitional> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kTransitional_Event_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::Transitional::Event>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->Event(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::entries_[] = {
    { ::test_protocols::kTransitional_Request_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::TransitionalRequestRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::Transitional::Request>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(interface)->Request(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kTransitional_OneWay_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::TransitionalOneWayRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::Transitional::OneWay>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(interface)->OneWay(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::entries_end_ =
    &entries_[2];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::TryDispatch(
    ::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request>::Reply(int64_t y) {
  return MakeReply(y);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request>::MakeReply(int64_t y) {
  ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request> _response{ y };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::Transitional::Request>::Reply(int64_t y) {
  return MakeReply(y);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::Transitional::Request>::MakeReply(int64_t y) {
  ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request> _response{ y };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::Transitional::Request>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kTransitional_Request_Ordinal, ::test_protocols::kTransitional_Request_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kTransitional_Request_Ordinal, ::test_protocols::kTransitional_Request_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kTransitional_OneWay_Ordinal, ::test_protocols::kTransitional_OneWay_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kTransitional_Event_Ordinal, ::test_protocols::kTransitional_Event_DynamicFlags);
    }
    
    
  


#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> _response{x };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::Transitional::Event>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> _response{x };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> _response{x };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::Transitional::Event>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> _response{x };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kDiscoverableProtocol_Method_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::DiscoverableProtocol::Method>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request_object{  };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::DiscoverableProtocol::Method>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::DiscoverableProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::entries_[] = {
    { ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::VerifyBodyIsAbsent(msg);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::DiscoverableProtocol::Method>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::DiscoverableProtocol>*>(interface)->Method(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kDiscoverableProtocol_Method_Ordinal, ::test_protocols::kDiscoverableProtocol_Method_DynamicFlags);
  }
    
    
  


#ifdef __Fuchsia__


#endif  // __Fuchsia__


  


  

#ifdef __Fuchsia__


#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::AnotherDiscoverableProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::AnotherDiscoverableProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::entries_[] = {
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::entries_end_ =
    &entries_[0];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::Dispatch(::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__

  


#ifdef __Fuchsia__


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_NoResponseMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;


[[maybe_unused]]
constexpr uint64_t kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_ResponseMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;


extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;


[[maybe_unused]]
constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_AnEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request_object{ std::move(h) };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
    return ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
          return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->AnEvent(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::entries_[] = {
    { ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(interface)->NoResponseMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(interface)->ResponseMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::entries_end_ =
    &entries_[2];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::Reply(::zx::socket&& h) {
  return MakeReply(std::move(h));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::MakeReply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> _response{ std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::Reply(::zx::socket&& h) {
  return MakeReply(std::move(h));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::MakeReply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> _response{ std::move(h) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    
    
    

#ifdef __Fuchsia__

    void ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal, ::test_protocols::kHandleRightsProtocol_AnEvent_DynamicFlags);
    }

#endif  // __Fuchsia__

    
    
  


#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_ClientEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_ServerEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;


[[maybe_unused]]
constexpr uint64_t kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_StructContainingEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;


extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__


  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::entries_[] = {
    { ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithProtocolEndsClientEndsRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ClientEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->ClientEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithProtocolEndsServerEndsRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ServerEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->ServerEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->StructContainingEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::entries_end_ =
    &entries_[3];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::Reply(::test_protocols::wire::ProtocolEnds&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::MakeReply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::Reply(::test_protocols::wire::ProtocolEnds&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::MakeReply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    

#ifdef __Fuchsia__

  void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
  }

#endif  // __Fuchsia__

    
    
  


#ifdef __Fuchsia__


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kManyParameters_Fifteen_Ordinal = 6423043252952467815lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kManyParameters_Fifteen_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ManyParameters::Fifteen>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request_object{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ManyParameters::Fifteen>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::ManyParameters>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::entries_[] = {
    { ::test_protocols::kManyParameters_Fifteen_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::ManyParametersFifteenRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ManyParameters>*>(interface)->Fifteen(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::TryDispatch(
    ::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kManyParameters_Fifteen_Ordinal, ::test_protocols::kManyParameters_Fifteen_DynamicFlags);
  }
    
    
  


#ifdef __Fuchsia__


#endif  // __Fuchsia__


  

namespace test_protocols {

[[maybe_unused]]
constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMethodWithUnion_UnionMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;


extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocols

::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocols {

#endif  // __Fuchsia__



  }  // namespace test_protocols

#ifdef __Fuchsia__


  ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
    ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
    return ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
  ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
  return ::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
          return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::entries_[] = {
    { ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocols::wire::MethodWithUnionUnionMethodRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::MethodWithUnion::UnionMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::MethodWithUnion>*>(interface)->UnionMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::TryDispatch(
    ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  return MakeReply(u);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> _response{ u };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  return MakeReply(u);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> _response{ u };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
  }
    
    
  


#ifdef __Fuchsia__


#endif  // __Fuchsia__







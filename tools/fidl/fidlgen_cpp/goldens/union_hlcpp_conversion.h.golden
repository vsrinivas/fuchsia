// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.union/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/internal/transport_channel.h>
#include <test/union/cpp/fidl.h>

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<fidl::ClientEnd<::test_union::TestProtocol>> {
  using HLCPPType = fidl::InterfaceHandle<::test::union_::TestProtocol>;
  static inline fidl::InterfaceHandle<::test::union_::TestProtocol> Convert(fidl::ClientEnd<::test_union::TestProtocol>&& c) {
    return fidl::InterfaceHandle<::test::union_::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ServerEnd<::test_union::TestProtocol>> {
  using HLCPPType = fidl::InterfaceRequest<::test::union_::TestProtocol>;
  static inline fidl::InterfaceRequest<::test::union_::TestProtocol> Convert(fidl::ServerEnd<::test_union::TestProtocol>&& c) {
    return fidl::InterfaceRequest<::test::union_::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceHandle<::test::union_::TestProtocol>> {
  using NaturalType = fidl::ClientEnd<::test_union::TestProtocol>;
  static inline fidl::ClientEnd<::test_union::TestProtocol> Convert(fidl::InterfaceHandle<::test::union_::TestProtocol>&& c) {
    return fidl::ClientEnd<::test_union::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequest<::test::union_::TestProtocol>> {
  using NaturalType = fidl::ServerEnd<::test_union::TestProtocol>;
  static inline fidl::ServerEnd<::test_union::TestProtocol> Convert(fidl::InterfaceRequest<::test::union_::TestProtocol>&& c) {
    return fidl::ServerEnd<::test_union::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<::test_union::StructWithNullableXUnion> {
  using HLCPPType = ::test::union_::StructWithNullableXUnion;
  static inline ::test::union_::StructWithNullableXUnion Convert(::test_union::StructWithNullableXUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StructWithNullableXUnion> {
  using NaturalType = ::test_union::StructWithNullableXUnion;
  static inline ::test_union::StructWithNullableXUnion Convert(::test::union_::StructWithNullableXUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse> {
  using HLCPPType = ::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse;
  static inline ::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse Convert(::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse> {
  using NaturalType = ::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse;
  static inline ::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse Convert(::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Pizza> {
  using HLCPPType = ::test::union_::Pizza;
  static inline ::test::union_::Pizza Convert(::test_union::Pizza&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Pizza> {
  using NaturalType = ::test_union::Pizza;
  static inline ::test_union::Pizza Convert(::test::union_::Pizza&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Pasta> {
  using HLCPPType = ::test::union_::Pasta;
  static inline ::test::union_::Pasta Convert(::test_union::Pasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Pasta> {
  using NaturalType = ::test_union::Pasta;
  static inline ::test_union::Pasta Convert(::test::union_::Pasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse> {
  using HLCPPType = ::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse;
  static inline ::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse Convert(::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse> {
  using NaturalType = ::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse;
  static inline ::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse Convert(::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::NullableUnionStruct> {
  using HLCPPType = ::test::union_::NullableUnionStruct;
  static inline ::test::union_::NullableUnionStruct Convert(::test_union::NullableUnionStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::NullableUnionStruct> {
  using NaturalType = ::test_union::NullableUnionStruct;
  static inline ::test_union::NullableUnionStruct Convert(::test::union_::NullableUnionStruct&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::UnionSandwich> {
  using HLCPPType = ::test::union_::UnionSandwich;
  static inline ::test::union_::UnionSandwich Convert(::test_union::UnionSandwich&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::UnionSandwich> {
  using NaturalType = ::test_union::UnionSandwich;
  static inline ::test_union::UnionSandwich Convert(::test::union_::UnionSandwich&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Empty> {
  using HLCPPType = ::test::union_::Empty;
  static inline ::test::union_::Empty Convert(::test_union::Empty&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Empty> {
  using NaturalType = ::test_union::Empty;
  static inline ::test_union::Empty Convert(::test::union_::Empty&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::UnionWithAttributes> {
  using HLCPPType = ::test::union_::UnionWithAttributes;
  static inline ::test::union_::UnionWithAttributes Convert(::test_union::UnionWithAttributes&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::UnionWithAttributes> {
  using NaturalType = ::test_union::UnionWithAttributes;
  static inline ::test_union::UnionWithAttributes Convert(::test::union_::UnionWithAttributes&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Union> {
  using HLCPPType = ::test::union_::Union;
  static inline ::test::union_::Union Convert(::test_union::Union&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Union> {
  using NaturalType = ::test_union::Union;
  static inline ::test_union::Union Convert(::test::union_::Union&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictUnion> {
  using HLCPPType = ::test::union_::StrictUnion;
  static inline ::test::union_::StrictUnion Convert(::test_union::StrictUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictUnion> {
  using NaturalType = ::test_union::StrictUnion;
  static inline ::test_union::StrictUnion Convert(::test::union_::StrictUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictSimpleXUnion> {
  using HLCPPType = ::test::union_::StrictSimpleXUnion;
  static inline ::test::union_::StrictSimpleXUnion Convert(::test_union::StrictSimpleXUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictSimpleXUnion> {
  using NaturalType = ::test_union::StrictSimpleXUnion;
  static inline ::test_union::StrictSimpleXUnion Convert(::test::union_::StrictSimpleXUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictFoo> {
  using HLCPPType = ::test::union_::StrictFoo;
  static inline ::test::union_::StrictFoo Convert(::test_union::StrictFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictFoo> {
  using NaturalType = ::test_union::StrictFoo;
  static inline ::test_union::StrictFoo Convert(::test::union_::StrictFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictBoundedXUnion> {
  using HLCPPType = ::test::union_::StrictBoundedXUnion;
  static inline ::test::union_::StrictBoundedXUnion Convert(::test_union::StrictBoundedXUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictBoundedXUnion> {
  using NaturalType = ::test_union::StrictBoundedXUnion;
  static inline ::test_union::StrictBoundedXUnion Convert(::test::union_::StrictBoundedXUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ReverseOrdinalUnion> {
  using HLCPPType = ::test::union_::ReverseOrdinalUnion;
  static inline ::test::union_::ReverseOrdinalUnion Convert(::test_union::ReverseOrdinalUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ReverseOrdinalUnion> {
  using NaturalType = ::test_union::ReverseOrdinalUnion;
  static inline ::test_union::ReverseOrdinalUnion Convert(::test::union_::ReverseOrdinalUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictPizzaOrPasta> {
  using HLCPPType = ::test::union_::StrictPizzaOrPasta;
  static inline ::test::union_::StrictPizzaOrPasta Convert(::test_union::StrictPizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictPizzaOrPasta> {
  using NaturalType = ::test_union::StrictPizzaOrPasta;
  static inline ::test_union::StrictPizzaOrPasta Convert(::test::union_::StrictPizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::PizzaOrPasta> {
  using HLCPPType = ::test::union_::PizzaOrPasta;
  static inline ::test::union_::PizzaOrPasta Convert(::test_union::PizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::PizzaOrPasta> {
  using NaturalType = ::test_union::PizzaOrPasta;
  static inline ::test_union::PizzaOrPasta Convert(::test::union_::PizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexiblePizzaOrPasta> {
  using HLCPPType = ::test::union_::FlexiblePizzaOrPasta;
  static inline ::test::union_::FlexiblePizzaOrPasta Convert(::test_union::FlexiblePizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexiblePizzaOrPasta> {
  using NaturalType = ::test_union::FlexiblePizzaOrPasta;
  static inline ::test_union::FlexiblePizzaOrPasta Convert(::test::union_::FlexiblePizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitPizzaOrPasta> {
  using HLCPPType = ::test::union_::ExplicitPizzaOrPasta;
  static inline ::test::union_::ExplicitPizzaOrPasta Convert(::test_union::ExplicitPizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitPizzaOrPasta> {
  using NaturalType = ::test_union::ExplicitPizzaOrPasta;
  static inline ::test_union::ExplicitPizzaOrPasta Convert(::test::union_::ExplicitPizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::OlderSimpleUnion> {
  using HLCPPType = ::test::union_::OlderSimpleUnion;
  static inline ::test::union_::OlderSimpleUnion Convert(::test_union::OlderSimpleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::OlderSimpleUnion> {
  using NaturalType = ::test_union::OlderSimpleUnion;
  static inline ::test_union::OlderSimpleUnion Convert(::test::union_::OlderSimpleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::NewerSimpleUnion> {
  using HLCPPType = ::test::union_::NewerSimpleUnion;
  static inline ::test::union_::NewerSimpleUnion Convert(::test_union::NewerSimpleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::NewerSimpleUnion> {
  using NaturalType = ::test_union::NewerSimpleUnion;
  static inline ::test_union::NewerSimpleUnion Convert(::test::union_::NewerSimpleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexibleUnion> {
  using HLCPPType = ::test::union_::FlexibleUnion;
  static inline ::test::union_::FlexibleUnion Convert(::test_union::FlexibleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexibleUnion> {
  using NaturalType = ::test_union::FlexibleUnion;
  static inline ::test_union::FlexibleUnion Convert(::test::union_::FlexibleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexibleFoo> {
  using HLCPPType = ::test::union_::FlexibleFoo;
  static inline ::test::union_::FlexibleFoo Convert(::test_union::FlexibleFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexibleFoo> {
  using NaturalType = ::test_union::FlexibleFoo;
  static inline ::test_union::FlexibleFoo Convert(::test::union_::FlexibleFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FieldCollision> {
  using HLCPPType = ::test::union_::FieldCollision;
  static inline ::test::union_::FieldCollision Convert(::test_union::FieldCollision&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FieldCollision> {
  using NaturalType = ::test_union::FieldCollision;
  static inline ::test_union::FieldCollision Convert(::test::union_::FieldCollision&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitXUnion> {
  using HLCPPType = ::test::union_::ExplicitXUnion;
  static inline ::test::union_::ExplicitXUnion Convert(::test_union::ExplicitXUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitXUnion> {
  using NaturalType = ::test_union::ExplicitXUnion;
  static inline ::test_union::ExplicitXUnion Convert(::test::union_::ExplicitXUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitUnion> {
  using HLCPPType = ::test::union_::ExplicitUnion;
  static inline ::test::union_::ExplicitUnion Convert(::test_union::ExplicitUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitUnion> {
  using NaturalType = ::test_union::ExplicitUnion;
  static inline ::test_union::ExplicitUnion Convert(::test::union_::ExplicitUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitStrictFoo> {
  using HLCPPType = ::test::union_::ExplicitStrictFoo;
  static inline ::test::union_::ExplicitStrictFoo Convert(::test_union::ExplicitStrictFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitStrictFoo> {
  using NaturalType = ::test_union::ExplicitStrictFoo;
  static inline ::test_union::ExplicitStrictFoo Convert(::test::union_::ExplicitStrictFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitFoo> {
  using HLCPPType = ::test::union_::ExplicitFoo;
  static inline ::test::union_::ExplicitFoo Convert(::test_union::ExplicitFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitFoo> {
  using NaturalType = ::test_union::ExplicitFoo;
  static inline ::test_union::ExplicitFoo Convert(::test::union_::ExplicitFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::XUnionContainingEmptyStruct> {
  using HLCPPType = ::test::union_::XUnionContainingEmptyStruct;
  static inline ::test::union_::XUnionContainingEmptyStruct Convert(::test_union::XUnionContainingEmptyStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::XUnionContainingEmptyStruct> {
  using NaturalType = ::test_union::XUnionContainingEmptyStruct;
  static inline ::test_union::XUnionContainingEmptyStruct Convert(::test::union_::XUnionContainingEmptyStruct&&);
};

::test::union_::StructWithNullableXUnion NaturalToHLCPPTraits<::test_union::StructWithNullableXUnion>::Convert(::test_union::StructWithNullableXUnion&& value) {
  ::test::union_::StructWithNullableXUnion hlcpp;
  hlcpp.x1 = ::fidl::NaturalToHLCPP(std::move(value.x1()));
  return hlcpp;
}

::test_union::StructWithNullableXUnion HLCPPToNaturalTraits<::test::union_::StructWithNullableXUnion>::Convert(::test::union_::StructWithNullableXUnion&& value) {
  return ::test_union::StructWithNullableXUnion{{
      .x1 = ::fidl::HLCPPToNatural(std::move(value.x1)),
  }};
}
::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse NaturalToHLCPPTraits<::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>::Convert(::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&& value) {
  ::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse hlcpp;
  hlcpp.xu = ::fidl::NaturalToHLCPP(std::move(value.xu()));
  return hlcpp;
}

::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse HLCPPToNaturalTraits<::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse>::Convert(::test::union_::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse&& value) {
  return ::test_union::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedTopResponse{{
      .xu = ::fidl::HLCPPToNatural(std::move(value.xu)),
  }};
}
::test::union_::Pizza NaturalToHLCPPTraits<::test_union::Pizza>::Convert(::test_union::Pizza&& value) {
  ::test::union_::Pizza hlcpp;
  hlcpp.toppings = ::fidl::NaturalToHLCPP(std::move(value.toppings()));
  return hlcpp;
}

::test_union::Pizza HLCPPToNaturalTraits<::test::union_::Pizza>::Convert(::test::union_::Pizza&& value) {
  return ::test_union::Pizza{{
      .toppings = ::fidl::HLCPPToNatural(std::move(value.toppings)),
  }};
}
::test::union_::Pasta NaturalToHLCPPTraits<::test_union::Pasta>::Convert(::test_union::Pasta&& value) {
  ::test::union_::Pasta hlcpp;
  hlcpp.sauce = ::fidl::NaturalToHLCPP(std::move(value.sauce()));
  return hlcpp;
}

::test_union::Pasta HLCPPToNaturalTraits<::test::union_::Pasta>::Convert(::test::union_::Pasta&& value) {
  return ::test_union::Pasta{{
      .sauce = ::fidl::HLCPPToNatural(std::move(value.sauce)),
  }};
}
::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse NaturalToHLCPPTraits<::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>::Convert(::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&& value) {
  ::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse hlcpp;
  hlcpp.xu = ::fidl::NaturalToHLCPP(std::move(value.xu()));
  return hlcpp;
}

::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse HLCPPToNaturalTraits<::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse>::Convert(::test::union_::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse&& value) {
  return ::test_union::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedTopResponse{{
      .xu = ::fidl::HLCPPToNatural(std::move(value.xu)),
  }};
}
::test::union_::NullableUnionStruct NaturalToHLCPPTraits<::test_union::NullableUnionStruct>::Convert(::test_union::NullableUnionStruct&& value) {
  ::test::union_::NullableUnionStruct hlcpp;
  hlcpp.the_union = ::fidl::NaturalToHLCPP(std::move(value.the_union()));
  return hlcpp;
}

::test_union::NullableUnionStruct HLCPPToNaturalTraits<::test::union_::NullableUnionStruct>::Convert(::test::union_::NullableUnionStruct&& value) {
  return ::test_union::NullableUnionStruct{{
      .the_union = ::fidl::HLCPPToNatural(std::move(value.the_union)),
  }};
}
::test::union_::UnionSandwich NaturalToHLCPPTraits<::test_union::UnionSandwich>::Convert(::test_union::UnionSandwich&& value) {
  ::test::union_::UnionSandwich hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  hlcpp.u = ::fidl::NaturalToHLCPP(std::move(value.u()));
  hlcpp.b = ::fidl::NaturalToHLCPP(std::move(value.b()));
  return hlcpp;
}

::test_union::UnionSandwich HLCPPToNaturalTraits<::test::union_::UnionSandwich>::Convert(::test::union_::UnionSandwich&& value) {
  return ::test_union::UnionSandwich{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
      .u = ::fidl::HLCPPToNatural(std::move(value.u)),
      .b = ::fidl::HLCPPToNatural(std::move(value.b)),
  }};
}
::test::union_::Empty NaturalToHLCPPTraits<::test_union::Empty>::Convert(::test_union::Empty&& value) {
  ::test::union_::Empty hlcpp;
  hlcpp.__reserved = ::fidl::NaturalToHLCPP(std::move(value.__reserved()));
  return hlcpp;
}

::test_union::Empty HLCPPToNaturalTraits<::test::union_::Empty>::Convert(::test::union_::Empty&& value) {
  return ::test_union::Empty{{
      .__reserved = ::fidl::HLCPPToNatural(std::move(value.__reserved)),
  }};
}

::test::union_::UnionWithAttributes NaturalToHLCPPTraits<::test_union::UnionWithAttributes>::Convert(::test_union::UnionWithAttributes&& value) {
  ::test::union_::UnionWithAttributes hlcpp;
  switch (value.Which()) {
    case ::test_union::UnionWithAttributes::Tag::kX:
      hlcpp.set_x(::fidl::NaturalToHLCPP(std::move(value.x().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::UnionWithAttributes HLCPPToNaturalTraits<::test::union_::UnionWithAttributes>::Convert(::test::union_::UnionWithAttributes&& value) {
  using _NaturalUnion = ::test_union::UnionWithAttributes;
  switch (value.Which()) {
    case ::test::union_::UnionWithAttributes::Tag::kX:
      return _NaturalUnion::WithX(
          ::fidl::HLCPPToNatural(std::move(value.x())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::Union NaturalToHLCPPTraits<::test_union::Union>::Convert(::test_union::Union&& value) {
  ::test::union_::Union hlcpp;
  switch (value.Which()) {
    case ::test_union::Union::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::Union::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::Union HLCPPToNaturalTraits<::test::union_::Union>::Convert(::test::union_::Union&& value) {
  using _NaturalUnion = ::test_union::Union;
  switch (value.Which()) {
    case ::test::union_::Union::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::Union::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::Union::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::Union");
  }
}
::test::union_::StrictUnion NaturalToHLCPPTraits<::test_union::StrictUnion>::Convert(::test_union::StrictUnion&& value) {
  ::test::union_::StrictUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::StrictUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictUnion HLCPPToNaturalTraits<::test::union_::StrictUnion>::Convert(::test::union_::StrictUnion&& value) {
  using _NaturalUnion = ::test_union::StrictUnion;
  switch (value.Which()) {
    case ::test::union_::StrictUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::StrictUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictUnion");
  }
}
::test::union_::StrictSimpleXUnion NaturalToHLCPPTraits<::test_union::StrictSimpleXUnion>::Convert(::test_union::StrictSimpleXUnion&& value) {
  ::test::union_::StrictSimpleXUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictSimpleXUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::StrictSimpleXUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    case ::test_union::StrictSimpleXUnion::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictSimpleXUnion HLCPPToNaturalTraits<::test::union_::StrictSimpleXUnion>::Convert(::test::union_::StrictSimpleXUnion&& value) {
  using _NaturalUnion = ::test_union::StrictSimpleXUnion;
  switch (value.Which()) {
    case ::test::union_::StrictSimpleXUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::StrictSimpleXUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    case ::test::union_::StrictSimpleXUnion::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictSimpleXUnion");
  }
}
::test::union_::StrictFoo NaturalToHLCPPTraits<::test_union::StrictFoo>::Convert(::test_union::StrictFoo&& value) {
  ::test::union_::StrictFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::StrictFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictFoo HLCPPToNaturalTraits<::test::union_::StrictFoo>::Convert(::test::union_::StrictFoo&& value) {
  using _NaturalUnion = ::test_union::StrictFoo;
  switch (value.Which()) {
    case ::test::union_::StrictFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::StrictFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictFoo");
  }
}
::test::union_::StrictBoundedXUnion NaturalToHLCPPTraits<::test_union::StrictBoundedXUnion>::Convert(::test_union::StrictBoundedXUnion&& value) {
  ::test::union_::StrictBoundedXUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictBoundedXUnion::Tag::kV:
      hlcpp.set_v(::fidl::NaturalToHLCPP(std::move(value.v().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictBoundedXUnion HLCPPToNaturalTraits<::test::union_::StrictBoundedXUnion>::Convert(::test::union_::StrictBoundedXUnion&& value) {
  using _NaturalUnion = ::test_union::StrictBoundedXUnion;
  switch (value.Which()) {
    case ::test::union_::StrictBoundedXUnion::Tag::kV:
      return _NaturalUnion::WithV(
          ::fidl::HLCPPToNatural(std::move(value.v())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictBoundedXUnion");
  }
}
::test::union_::ReverseOrdinalUnion NaturalToHLCPPTraits<::test_union::ReverseOrdinalUnion>::Convert(::test_union::ReverseOrdinalUnion&& value) {
  ::test::union_::ReverseOrdinalUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ReverseOrdinalUnion::Tag::kSecond:
      hlcpp.set_second(::fidl::NaturalToHLCPP(std::move(value.second().value())));
      break;
    case ::test_union::ReverseOrdinalUnion::Tag::kFirst:
      hlcpp.set_first(::fidl::NaturalToHLCPP(std::move(value.first().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ReverseOrdinalUnion HLCPPToNaturalTraits<::test::union_::ReverseOrdinalUnion>::Convert(::test::union_::ReverseOrdinalUnion&& value) {
  using _NaturalUnion = ::test_union::ReverseOrdinalUnion;
  switch (value.Which()) {
    case ::test::union_::ReverseOrdinalUnion::Tag::kSecond:
      return _NaturalUnion::WithSecond(
          ::fidl::HLCPPToNatural(std::move(value.second())));
    case ::test::union_::ReverseOrdinalUnion::Tag::kFirst:
      return _NaturalUnion::WithFirst(
          ::fidl::HLCPPToNatural(std::move(value.first())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ReverseOrdinalUnion");
  }
}
::test::union_::StrictPizzaOrPasta NaturalToHLCPPTraits<::test_union::StrictPizzaOrPasta>::Convert(::test_union::StrictPizzaOrPasta&& value) {
  ::test::union_::StrictPizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictPizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::StrictPizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictPizzaOrPasta HLCPPToNaturalTraits<::test::union_::StrictPizzaOrPasta>::Convert(::test::union_::StrictPizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::StrictPizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::StrictPizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::StrictPizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictPizzaOrPasta");
  }
}
::test::union_::PizzaOrPasta NaturalToHLCPPTraits<::test_union::PizzaOrPasta>::Convert(::test_union::PizzaOrPasta&& value) {
  ::test::union_::PizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::PizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::PizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::PizzaOrPasta HLCPPToNaturalTraits<::test::union_::PizzaOrPasta>::Convert(::test::union_::PizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::PizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::PizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::PizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::PizzaOrPasta");
  }
}
::test::union_::FlexiblePizzaOrPasta NaturalToHLCPPTraits<::test_union::FlexiblePizzaOrPasta>::Convert(::test_union::FlexiblePizzaOrPasta&& value) {
  ::test::union_::FlexiblePizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexiblePizzaOrPasta HLCPPToNaturalTraits<::test::union_::FlexiblePizzaOrPasta>::Convert(::test::union_::FlexiblePizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::FlexiblePizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::FlexiblePizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::FlexiblePizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::ExplicitPizzaOrPasta NaturalToHLCPPTraits<::test_union::ExplicitPizzaOrPasta>::Convert(::test_union::ExplicitPizzaOrPasta&& value) {
  ::test::union_::ExplicitPizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitPizzaOrPasta HLCPPToNaturalTraits<::test::union_::ExplicitPizzaOrPasta>::Convert(::test::union_::ExplicitPizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::ExplicitPizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::ExplicitPizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::ExplicitPizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitPizzaOrPasta");
  }
}
::test::union_::OlderSimpleUnion NaturalToHLCPPTraits<::test_union::OlderSimpleUnion>::Convert(::test_union::OlderSimpleUnion&& value) {
  ::test::union_::OlderSimpleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::OlderSimpleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::OlderSimpleUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::OlderSimpleUnion HLCPPToNaturalTraits<::test::union_::OlderSimpleUnion>::Convert(::test::union_::OlderSimpleUnion&& value) {
  using _NaturalUnion = ::test_union::OlderSimpleUnion;
  switch (value.Which()) {
    case ::test::union_::OlderSimpleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::OlderSimpleUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::NewerSimpleUnion NaturalToHLCPPTraits<::test_union::NewerSimpleUnion>::Convert(::test_union::NewerSimpleUnion&& value) {
  ::test::union_::NewerSimpleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::NewerSimpleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::NewerSimpleUnion::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::NewerSimpleUnion::Tag::kV:
      hlcpp.set_v(::fidl::NaturalToHLCPP(std::move(value.v().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::NewerSimpleUnion HLCPPToNaturalTraits<::test::union_::NewerSimpleUnion>::Convert(::test::union_::NewerSimpleUnion&& value) {
  using _NaturalUnion = ::test_union::NewerSimpleUnion;
  switch (value.Which()) {
    case ::test::union_::NewerSimpleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::NewerSimpleUnion::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::NewerSimpleUnion::Tag::kV:
      return _NaturalUnion::WithV(
          ::fidl::HLCPPToNatural(std::move(value.v())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::FlexibleUnion NaturalToHLCPPTraits<::test_union::FlexibleUnion>::Convert(::test_union::FlexibleUnion&& value) {
  ::test::union_::FlexibleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexibleUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexibleUnion HLCPPToNaturalTraits<::test::union_::FlexibleUnion>::Convert(::test::union_::FlexibleUnion&& value) {
  using _NaturalUnion = ::test_union::FlexibleUnion;
  switch (value.Which()) {
    case ::test::union_::FlexibleUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::FlexibleUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::FlexibleFoo NaturalToHLCPPTraits<::test_union::FlexibleFoo>::Convert(::test_union::FlexibleFoo&& value) {
  ::test::union_::FlexibleFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexibleFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::FlexibleFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexibleFoo HLCPPToNaturalTraits<::test::union_::FlexibleFoo>::Convert(::test::union_::FlexibleFoo&& value) {
  using _NaturalUnion = ::test_union::FlexibleFoo;
  switch (value.Which()) {
    case ::test::union_::FlexibleFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::FlexibleFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::FieldCollision NaturalToHLCPPTraits<::test_union::FieldCollision>::Convert(::test_union::FieldCollision&& value) {
  ::test::union_::FieldCollision hlcpp;
  switch (value.Which()) {
    case ::test_union::FieldCollision::Tag::kFieldCollisionTag:
      hlcpp.set_field_collision_tag(::fidl::NaturalToHLCPP(std::move(value.field_collision_tag().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FieldCollision HLCPPToNaturalTraits<::test::union_::FieldCollision>::Convert(::test::union_::FieldCollision&& value) {
  using _NaturalUnion = ::test_union::FieldCollision;
  switch (value.Which()) {
    case ::test::union_::FieldCollision::Tag::kFieldCollisionTag:
      return _NaturalUnion::WithFieldCollisionTag(
          ::fidl::HLCPPToNatural(std::move(value.field_collision_tag())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::FieldCollision");
  }
}
::test::union_::ExplicitXUnion NaturalToHLCPPTraits<::test_union::ExplicitXUnion>::Convert(::test_union::ExplicitXUnion&& value) {
  ::test::union_::ExplicitXUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitXUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::ExplicitXUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitXUnion HLCPPToNaturalTraits<::test::union_::ExplicitXUnion>::Convert(::test::union_::ExplicitXUnion&& value) {
  using _NaturalUnion = ::test_union::ExplicitXUnion;
  switch (value.Which()) {
    case ::test::union_::ExplicitXUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::ExplicitXUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::ExplicitUnion NaturalToHLCPPTraits<::test_union::ExplicitUnion>::Convert(::test_union::ExplicitUnion&& value) {
  ::test::union_::ExplicitUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitUnion HLCPPToNaturalTraits<::test::union_::ExplicitUnion>::Convert(::test::union_::ExplicitUnion&& value) {
  using _NaturalUnion = ::test_union::ExplicitUnion;
  switch (value.Which()) {
    case ::test::union_::ExplicitUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::ExplicitUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitUnion");
  }
}
::test::union_::ExplicitStrictFoo NaturalToHLCPPTraits<::test_union::ExplicitStrictFoo>::Convert(::test_union::ExplicitStrictFoo&& value) {
  ::test::union_::ExplicitStrictFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitStrictFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::ExplicitStrictFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitStrictFoo HLCPPToNaturalTraits<::test::union_::ExplicitStrictFoo>::Convert(::test::union_::ExplicitStrictFoo&& value) {
  using _NaturalUnion = ::test_union::ExplicitStrictFoo;
  switch (value.Which()) {
    case ::test::union_::ExplicitStrictFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::ExplicitStrictFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitStrictFoo");
  }
}
::test::union_::ExplicitFoo NaturalToHLCPPTraits<::test_union::ExplicitFoo>::Convert(::test_union::ExplicitFoo&& value) {
  ::test::union_::ExplicitFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::ExplicitFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitFoo HLCPPToNaturalTraits<::test::union_::ExplicitFoo>::Convert(::test::union_::ExplicitFoo&& value) {
  using _NaturalUnion = ::test_union::ExplicitFoo;
  switch (value.Which()) {
    case ::test::union_::ExplicitFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::ExplicitFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::XUnionContainingEmptyStruct NaturalToHLCPPTraits<::test_union::XUnionContainingEmptyStruct>::Convert(::test_union::XUnionContainingEmptyStruct&& value) {
  ::test::union_::XUnionContainingEmptyStruct hlcpp;
  switch (value.Which()) {
    case ::test_union::XUnionContainingEmptyStruct::Tag::kEmpty:
      hlcpp.set_empty(::fidl::NaturalToHLCPP(std::move(value.empty().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::XUnionContainingEmptyStruct HLCPPToNaturalTraits<::test::union_::XUnionContainingEmptyStruct>::Convert(::test::union_::XUnionContainingEmptyStruct&& value) {
  using _NaturalUnion = ::test_union::XUnionContainingEmptyStruct;
  switch (value.Which()) {
    case ::test::union_::XUnionContainingEmptyStruct::Tag::kEmpty:
      return _NaturalUnion::WithEmpty(
          ::fidl::HLCPPToNatural(std::move(value.empty())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}

}  // namespace internal
}  // namespace fidl

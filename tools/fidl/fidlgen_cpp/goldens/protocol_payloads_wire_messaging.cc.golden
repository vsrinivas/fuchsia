// WARNING: This file is machine generated by fidlgen.

#include <fidl/test.protocolpayloads/cpp/wire_messaging.h>

#include <memory>


  

namespace test_protocolpayloads {

[[maybe_unused]]
constexpr uint64_t kMainProtocol_OneWayComposed_Ordinal = 2602591870026304272lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OneWayComposed_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayComposed_Ordinal = 2542459230546612144lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayComposed_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayComposedWithError_Ordinal = 7681984876526769495lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayComposedWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_imported_ComposedProtocolTwoWayComposedWithErrorTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnComposed_Ordinal = 1872339328378152762lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnComposed_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnComposedWithError_Ordinal = 7167282778061495960lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnComposedWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ComposedProtocolOnComposedWithErrorRequestTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OneWayLocal_Ordinal = 7755175439334311701lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OneWayLocal_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayLocal_Ordinal = 8374292137648566031lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayLocal_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayLocalWithError_Ordinal = 2898559119954589948lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayLocalWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnLocal_Ordinal = 5135782819583756313lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnLocal_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnLocalWithError_Ordinal = 5678277415565140399lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnLocalWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OneWayImport_Ordinal = 3344777159365288972lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OneWayImport_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayImport_Ordinal = 2374708679656510579lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayImport_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayImportWithError_Ordinal = 4286143084949642173lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayImportWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnImport_Ordinal = 1996489653379631369lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnImport_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_imported_ImportStructPayloadTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnImportWithError_Ordinal = 7102941407914553861lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnImportWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OneWayAnon_Ordinal = 811587311021806764lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OneWayAnon_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolOneWayAnonRequestTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayAnon_Ordinal = 629880979996923737lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayAnon_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayAnonRequestTable;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayAnonResponseTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_TwoWayAnonWithError_Ordinal = 6368863385719175734lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_TwoWayAnonWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnAnon_Ordinal = 4815229650203439104lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnAnon_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolOnAnonRequestTable;


[[maybe_unused]]
constexpr uint64_t kMainProtocol_OnAnonWithError_Ordinal = 5024931894357412354lu;


[[maybe_unused]]
constexpr ::fidl::MessageDynamicFlags kMainProtocol_OnAnonWithError_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;


extern "C" const fidl_type_t test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::OneWayComposed>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::OneWayComposed>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposed>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayComposed>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::OneWayLocal>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::OneWayLocal>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocal>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayLocal>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::OneWayImport>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::OneWayImport>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImport>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayImport>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::OneWayAnon>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::OneWayAnon>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
    uint32_t request_byte_capacity = buffer_size;
    uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client_end.handle());
    SetStatus(outgoing);
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnon>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayAnon>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__


#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

::fidl::WireUnownedResult<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    SetStatus(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
        ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>, ::fidl::MessageDirection::kSending>();
    uint8_t* request_bytes = buffer;
    static_assert(buffer_size > request_byte_capacity);
    uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
    uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> request_message(
      request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>(
        outgoing.Call(
            client_end.handle(),
            handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
        )
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}namespace test_protocolpayloads {

#endif  // __Fuchsia__



  }  // namespace test_protocolpayloads

#ifdef __Fuchsia__

  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocolpayloads::MainProtocol>::OneWayComposed(int32_t a) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed> _request_object{ a };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocolpayloads::MainProtocol>::OneWayLocal(uint32_t a, uint32_t b) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal> _request_object{ a, b };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocolpayloads::MainProtocol>::OneWayImport(int32_t a) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport> _request_object{ a };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::Status fidl::internal::WireWeakOnewayClientImpl<::test_protocolpayloads::MainProtocol>::OneWayAnon(uint32_t a, uint32_t b) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon> _request_object{ a, b };
    ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayComposed> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposed(int32_t a) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed> _request{ a };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayComposed>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposedWithError(int32_t a) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> _request{ a };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayLocal> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocal(uint32_t a, uint32_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayLocal>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocalWithError(uint32_t a, uint32_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayImport> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImport(int32_t a) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport> _request{ a };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayImport>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImportWithError(int32_t a) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> _request{ a };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayAnon> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnon(uint32_t a, uint32_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayAnon>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> fidl::internal::WireWeakAsyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnonWithError(uint32_t a, uint32_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocolpayloads::MainProtocol>::OneWayComposed(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed> _request{ a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocolpayloads::MainProtocol>::OneWayLocal(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal> _request{ a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocolpayloads::MainProtocol>::OneWayImport(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport> _request{ a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocolpayloads::MainProtocol>::OneWayAnon(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OneWayAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon> _request{ a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayComposed> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposed(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposed>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed> _request{ a };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayComposed>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposedWithError(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> _request{ a };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayLocal> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocal(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocal>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayLocal>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocalWithError(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayImport> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImport(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImport>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport> _request{ a };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayImport>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImportWithError(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> _request{ a };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayAnon> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnon(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnon>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayAnon>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnonWithError(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>();
  ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposed>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposed(int32_t a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed> _request{ a };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposed>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayComposedWithError(int32_t a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> _request{ a };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocal>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocal(uint32_t a, uint32_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal> _request{ a, b };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocal>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayLocalWithError(uint32_t a, uint32_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> _request{ a, b };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImport>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImport(int32_t a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport> _request{ a };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImport>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayImportWithError(int32_t a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> _request{ a };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnon>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnon(uint32_t a, uint32_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon> _request{ a, b };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnon>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }
  


  ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
  fidl::internal::WireWeakSyncClientImpl<::test_protocolpayloads::MainProtocol>::TwoWayAnonWithError(uint32_t a, uint32_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> _request{ a, b };
          return ::fidl::WireResult<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>(::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

#endif  // __Fuchsia__





#ifdef __Fuchsia__



  ::fidl::Status fidl::WireSyncEventHandler<::test_protocolpayloads::MainProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocolpayloads::MainProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocolpayloads::MainProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocolpayloads::MainProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocolpayloads::MainProtocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocolpayloads::kMainProtocol_OnComposed_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnComposed(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnComposedWithError_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnComposedWithError(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnLocal_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnLocal(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnLocalWithError_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnLocalWithError(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnImport_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnImport(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnImportWithError_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnImportWithError(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnAnon_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnAnon(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocolpayloads::kMainProtocol_OnAnonWithError_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnAnonWithError(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        
        return ::fidl::Status::UnknownOrdinal();
    }
  }

#endif  // __Fuchsia__


#ifdef __Fuchsia__



constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocolpayloads::MainProtocol>::entries_[] = {
    { ::test_protocolpayloads::kMainProtocol_OneWayComposed_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::OneWayComposed>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->OneWayComposed(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayComposed>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayComposed(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayComposedWithError(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_OneWayLocal_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::LocalStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::OneWayLocal>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->OneWayLocal(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::LocalStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayLocal>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayLocal(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::LocalStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayLocalWithError(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_OneWayImport_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::OneWayImport>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->OneWayImport(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayImport>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayImport(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads_imported::wire::ImportStructPayload>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayImportWithError(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_OneWayAnon_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::OneWayAnon>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->OneWayAnon(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayAnon>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayAnon(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::InplaceDecode<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>(std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocolpayloads::MainProtocol>*>(interface)->TwoWayAnonWithError(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocolpayloads::MainProtocol>::entries_end_ =
    &entries_[12];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocolpayloads::MainProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocolpayloads::MainProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}



void fidl::internal::WireServerDispatcher<::test_protocolpayloads::MainProtocol>::Dispatch(::fidl::WireServer<::test_protocolpayloads::MainProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocolpayloads::MainProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocolpayloads::MainProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposed>::Reply(int32_t a) {
  return MakeReply(a);
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposed>::MakeReply(int32_t a) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed> _response{ a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposed>::Reply(int32_t a) {
  return MakeReply(a);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposed>::MakeReply(int32_t a) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed> _response{ a };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads_imported::wire::ImportStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::ReplySuccess(int32_t a) {
    ::test_protocolpayloads_imported::wire::ImportStructPayload _response = ::test_protocolpayloads_imported::wire::ImportStructPayload {
  .a = std::move(a),
};
return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads_imported::wire::ImportStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::ReplySuccess(int32_t a) {
    ::test_protocolpayloads_imported::wire::ImportStructPayload _response = ::test_protocolpayloads_imported::wire::ImportStructPayload {
  .a = std::move(a),
};
return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads_imported::wire::ComposedProtocolTwoWayComposedWithErrorResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocal>::Reply(uint32_t a, uint32_t b) {
  return MakeReply(a, b);
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocal>::MakeReply(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal> _response{ a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocal>::Reply(uint32_t a, uint32_t b) {
  return MakeReply(a, b);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocal>::MakeReply(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal> _response{ a, b };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads::wire::LocalStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::ReplySuccess(uint32_t a, uint32_t b) {
    ::test_protocolpayloads::wire::LocalStructPayload _response = ::test_protocolpayloads::wire::LocalStructPayload {
  .a = std::move(a),
  .b = std::move(b),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads::wire::LocalStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::ReplySuccess(uint32_t a, uint32_t b) {
    ::test_protocolpayloads::wire::LocalStructPayload _response = ::test_protocolpayloads::wire::LocalStructPayload {
  .a = std::move(a),
  .b = std::move(b),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImport>::Reply(int32_t a) {
  return MakeReply(a);
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImport>::MakeReply(int32_t a) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport> _response{ a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImport>::Reply(int32_t a) {
  return MakeReply(a);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImport>::MakeReply(int32_t a) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport> _response{ a };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads_imported::wire::ImportStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::ReplySuccess(int32_t a) {
    ::test_protocolpayloads_imported::wire::ImportStructPayload _response = ::test_protocolpayloads_imported::wire::ImportStructPayload {
  .a = std::move(a),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads_imported::wire::ImportStructPayload*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::ReplySuccess(int32_t a) {
    ::test_protocolpayloads_imported::wire::ImportStructPayload _response = ::test_protocolpayloads_imported::wire::ImportStructPayload {
  .a = std::move(a),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnon>::Reply(uint32_t a, uint32_t b) {
  return MakeReply(a, b);
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnon>::MakeReply(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon> _response{ a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnon>::Reply(uint32_t a, uint32_t b) {
  return MakeReply(a, b);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnon>::MakeReply(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon> _response{ a, b };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__
void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::ReplySuccess(uint32_t a, uint32_t b) {
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse _response = ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse {
  .a = std::move(a),
  .b = std::move(b),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithErr(std::move(error)));
  }


void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::Reply(::fit::result<uint32_t, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult result) {
  ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::ReplySuccess(uint32_t a, uint32_t b) {
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse _response = ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse {
  .a = std::move(a),
  .b = std::move(b),
};
return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithErr(std::move(error)));
  }

#endif  // __Fuchsia__


  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayComposed>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OneWayComposed_Ordinal, ::test_protocolpayloads::kMainProtocol_OneWayComposed_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposed>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayComposed_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposed>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayComposed_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayComposed_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayComposedWithError_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnComposed_Ordinal, ::test_protocolpayloads::kMainProtocol_OnComposed_DynamicFlags);
    }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnComposedWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_OnComposedWithError_DynamicFlags);
    }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayLocal>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OneWayLocal_Ordinal, ::test_protocolpayloads::kMainProtocol_OneWayLocal_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocal>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayLocal_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocal>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayLocal_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayLocal_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayLocalWithError_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnLocal_Ordinal, ::test_protocolpayloads::kMainProtocol_OnLocal_DynamicFlags);
    }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnLocalWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_OnLocalWithError_DynamicFlags);
    }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayImport>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OneWayImport_Ordinal, ::test_protocolpayloads::kMainProtocol_OneWayImport_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImport>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayImport_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImport>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayImport_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayImport_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayImportWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayImportWithError_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnImport_Ordinal, ::test_protocolpayloads::kMainProtocol_OnImport_DynamicFlags);
    }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnImportWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_OnImportWithError_DynamicFlags);
    }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::OneWayAnon>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OneWayAnon_Ordinal, ::test_protocolpayloads::kMainProtocol_OneWayAnon_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnon>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayAnon_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnon>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayAnon_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayAnon_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalRequest<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_DynamicFlags);
  }
    
    

  void ::fidl::internal::TransactionalResponse<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>::_InitHeader() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_TwoWayAnonWithError_DynamicFlags);
  }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnAnon_Ordinal, ::test_protocolpayloads::kMainProtocol_OnAnon_DynamicFlags);
    }
    
    
    
    

    void ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>::_InitHeader() {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocolpayloads::kMainProtocol_OnAnonWithError_Ordinal, ::test_protocolpayloads::kMainProtocol_OnAnonWithError_DynamicFlags);
    }
    
    
  


#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(int32_t a) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed> _response{a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed> _response{a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(int32_t a) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed> _response{a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnComposed(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnComposed>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed> _response{a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposed>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnComposedWithError(::test_protocolpayloads_imported::wire::ComposedProtocolOnComposedWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnComposedWithError(::test_protocolpayloads_imported::wire::ComposedProtocolOnComposedWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnComposedWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnComposedWithError(::test_protocolpayloads_imported::wire::ComposedProtocolOnComposedWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnComposedWithError(::test_protocolpayloads_imported::wire::ComposedProtocolOnComposedWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnComposedWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnComposedWithError>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnLocal(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnLocal>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocal>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnLocalWithError(::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnLocalWithError(::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnLocalWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnLocalWithError(::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnLocalWithError(::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnLocalWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnLocalWithError>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnImport(int32_t a) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport> _response{a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnImport(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport> _response{a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnImport(int32_t a) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport> _response{a };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnImport(int32_t a) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnImport>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport> _response{a };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImport>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnImportWithError(::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnImportWithError(::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnImportWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnImportWithError(::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnImportWithError(::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnImportWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnImportWithError>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(uint32_t a, uint32_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnAnon(uint32_t a, uint32_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnAnon>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon> _response{a, b };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnon>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<::test_protocolpayloads::MainProtocol>::OnAnonWithError(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<::test_protocolpayloads::MainProtocol>::OnAnonWithError(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnAnonWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<::test_protocolpayloads::MainProtocol>::OnAnonWithError(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult result) {
  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError> _response{result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<::test_protocolpayloads::MainProtocol>::OnAnonWithError(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult result) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocolpayloads::MainProtocol::OnAnonWithError>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError> _response{result };
  ::fidl::unstable::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocolpayloads::MainProtocol::OnAnonWithError>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}


#endif  // __Fuchsia__







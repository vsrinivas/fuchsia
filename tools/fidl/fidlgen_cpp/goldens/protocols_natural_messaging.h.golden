// WARNING: This file is machine generated by fidlgen_cpp.

#pragma once

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/natural_types.h>
#include <fidl/test.protocols/cpp/wire_messaging.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/thenable.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>
#include <lib/fidl/cpp/wire/unknown_interaction_handler.h>

namespace fidl {

}  // namespace fidl

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::WithAndWithoutRequestResponseOnWithResponseRequest;
  Event(::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest v) : WithAndWithoutRequestResponseOnWithResponseRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse::WithAndWithoutRequestResponseNoRequestWithResponseResponse;
  Response(::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse v) : WithAndWithoutRequestResponseNoRequestWithResponseResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse;
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
  Response(::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse v) : WithAndWithoutRequestResponseWithRequestWithResponseResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>& request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& request) const;

  ::fit::result<::fidl::Error> NoRequestNoResponse() const;

  ::fit::result<::fidl::Error> WithRequestNoResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>& request);

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& request);

  ::fit::result<::fidl::Error> NoRequestNoResponse();

  ::fit::result<::fidl::Error> WithRequestNoResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnEmptyResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>&) = 0;
  virtual void OnWithResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void OnEmptyResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>&) override {}
  void OnWithResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::Error> OnEmptyResponse();

  ::fit::result<::fidl::Error> OnWithResponse(const ::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::Error> OnEmptyResponse();

  ::fit::result<::fidl::Error> OnWithResponse(const ::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>& payload);
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest::WithAndWithoutRequestResponseWithRequestNoResponseRequest;
  Request(::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest v) : ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
  Request(::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest v) : ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest::WithAndWithoutRequestResponseWithRequestWithResponseRequest;
  Request(::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest v) : ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;
  using NoRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  virtual void NoRequestNoResponse(NoRequestNoResponseRequest& request, NoRequestNoResponseCompleter::Sync& completer) = 0;

  using NoRequestEmptyResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;
  using NoRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(NoRequestEmptyResponseRequest& request, NoRequestEmptyResponseCompleter::Sync& completer) = 0;

  using NoRequestWithResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
  using NoRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  virtual void NoRequestWithResponse(NoRequestWithResponseRequest& request, NoRequestWithResponseCompleter::Sync& completer) = 0;

  using WithRequestNoResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
  using WithRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  virtual void WithRequestNoResponse(WithRequestNoResponseRequest& request, WithRequestNoResponseCompleter::Sync& completer) = 0;

  using WithRequestEmptyResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;
  using WithRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(WithRequestEmptyResponseRequest& request, WithRequestEmptyResponseCompleter::Sync& completer) = 0;

  using WithRequestWithResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
  using WithRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  virtual void WithRequestWithResponse(WithRequestWithResponseRequest& request, WithRequestWithResponseCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithAndWithoutRequestResponse> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct>&)>;

  static constexpr bool kHasDomainError = true;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&)>;

  static constexpr bool kHasDomainError = true;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsEmptyStructPayload = true;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum>&)>;

  static constexpr bool kHasDomainError = true;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsEmptyStructPayload = true;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult>&)>;

  static constexpr bool kHasDomainError = true;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> {
 public:
  using ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse>::result;
  Response(::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> v) : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  using DomainObject = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct> FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fit::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fit::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxResponseAsStructResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxResponseAsStructResult::WithResponse(std::move(m.value()))}};
    }
  }
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::test_protocols::WithErrorSyntaxResponseAsStructResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fit::result<uint32_t> {
 public:
  using ::fit::result<uint32_t>::result;
  Response(::fit::result<uint32_t> v) : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  using DomainObject = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fit::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fit::ok();
    }
  }

  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({})}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fit::result<::test_protocols::ErrorEnum> {
 public:
  using ::fit::result<::test_protocols::ErrorEnum>::result;
  Response(::fit::result<::test_protocols::ErrorEnum> v) : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  using DomainObject = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fit::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fit::ok();
    }
  }

  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsEnumResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsEnumResult::WithResponse({})}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse> {
 public:
  using ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse>::result;
  Response(::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse> v) : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>> {
  using DomainObject = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fit::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fit::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxHandleInResultResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::HandleInResult>, ::test_protocols::WithErrorSyntaxHandleInResultResponse> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::HandleInResult>, ::test_protocols::WithErrorSyntaxHandleInResultResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithErrorSyntax> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();

  ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();

  ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();

  ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithErrorSyntax> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using ResponseAsStructRequest = ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(ResponseAsStructRequest& request, ResponseAsStructCompleter::Sync& completer) = 0;

  using ErrorAsPrimitiveRequest = ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(ErrorAsPrimitiveRequest& request, ErrorAsPrimitiveCompleter::Sync& completer) = 0;

  using ErrorAsEnumRequest = ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequest& request, ErrorAsEnumCompleter::Sync& completer) = 0;

  using HandleInResultRequest = ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequest& request, HandleInResultCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithErrorSyntax> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::MethodB>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::ChannelProtocol::EventA> final : public ::test_protocols::ChannelProtocolEventARequest {
 public:
  using ::test_protocols::ChannelProtocolEventARequest::ChannelProtocolEventARequest;
  Event(::test_protocols::ChannelProtocolEventARequest v) : ChannelProtocolEventARequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<::test_protocols::ChannelProtocol::EventA>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolEventARequest;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::ChannelProtocolMethodBResponse {
 public:
  using ::test_protocols::ChannelProtocolMethodBResponse::ChannelProtocolMethodBResponse;
  Response(::test_protocols::ChannelProtocolMethodBResponse v) : ChannelProtocolMethodBResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::ChannelProtocol::MethodB>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBResponse;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MethodB> final : public ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMethodBResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMethodBResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>> final {
 public:
  static constexpr bool kHasPayload = false;
};

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::ChannelProtocolMutateSocketResponse {
 public:
  using ::test_protocols::ChannelProtocolMutateSocketResponse::ChannelProtocolMutateSocketResponse;
  Response(::test_protocols::ChannelProtocolMutateSocketResponse v) : ChannelProtocolMutateSocketResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketResponse;
};

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMutateSocketResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMutateSocketResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>& request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> request) const;

  ::fit::result<::fidl::Error> MethodA(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::ChannelProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  ::fidl::Result<::test_protocols::ChannelProtocol::MethodB> MethodB(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>& request);

  ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request);

  ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> request);

  ::fit::result<::fidl::Error> MethodA(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventA(::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void EventA(::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ChannelProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::Error> EventA(const ::fidl::Event<::test_protocols::ChannelProtocol::EventA>& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::Error> EventA(const ::fidl::Event<::test_protocols::ChannelProtocol::EventA>& payload);
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> final : public ::test_protocols::ChannelProtocolMethodARequest {
 public:
  using ::test_protocols::ChannelProtocolMethodARequest::ChannelProtocolMethodARequest;
  Request(::test_protocols::ChannelProtocolMethodARequest v) : ::test_protocols::ChannelProtocolMethodARequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::ChannelProtocol::MethodA>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodARequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::ChannelProtocolMethodBRequest {
 public:
  using ::test_protocols::ChannelProtocolMethodBRequest::ChannelProtocolMethodBRequest;
  Request(::test_protocols::ChannelProtocolMethodBRequest v) : ::test_protocols::ChannelProtocolMethodBRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::ChannelProtocol::MethodB>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> final : public ::test_protocols::ChannelProtocolTakeHandleRequest {
 public:
  using ::test_protocols::ChannelProtocolTakeHandleRequest::ChannelProtocolTakeHandleRequest;
  Request(::test_protocols::ChannelProtocolTakeHandleRequest v) : ::test_protocols::ChannelProtocolTakeHandleRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolTakeHandleRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::ChannelProtocolMutateSocketRequest {
 public:
  using ::test_protocols::ChannelProtocolMutateSocketRequest::ChannelProtocolMutateSocketRequest;
  Request(::test_protocols::ChannelProtocolMutateSocketRequest v) : ::test_protocols::ChannelProtocolMutateSocketRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::ChannelProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using MethodARequest = ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>;
  using MethodACompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequest& request, MethodACompleter::Sync& completer) = 0;

  using MethodBRequest = ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>;
  using MethodBCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequest& request, MethodBCompleter::Sync& completer) = 0;

  using TakeHandleRequest = ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequest& request, TakeHandleCompleter::Sync& completer) = 0;

  using MutateSocketRequest = ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequest& request, MutateSocketCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::ChannelProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::Transitional::Request>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::Transitional::Request>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::Transitional::Event> final : public ::test_protocols::TransitionalEventRequest {
 public:
  using ::test_protocols::TransitionalEventRequest::TransitionalEventRequest;
  Event(::test_protocols::TransitionalEventRequest v) : TransitionalEventRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<::test_protocols::Transitional::Event>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalEventRequest;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::Transitional::Request> final : public ::test_protocols::TransitionalRequestResponse {
 public:
  using ::test_protocols::TransitionalRequestResponse::TransitionalRequestResponse;
  Response(::test_protocols::TransitionalRequestResponse v) : TransitionalRequestResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::Transitional::Request>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestResponse;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::Transitional::Request> final : public ::fit::result<::fidl::Error, ::test_protocols::TransitionalRequestResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::TransitionalRequestResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::Transitional::Request> Request(const ::fidl::Request<::test_protocols::Transitional::Request>& request) const;

  ::fit::result<::fidl::Error> OneWay(const ::fidl::Request<::test_protocols::Transitional::OneWay>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::Transitional>> {
 public:
  ::fidl::Result<::test_protocols::Transitional::Request> Request(const ::fidl::Request<::test_protocols::Transitional::Request>& request);

  ::fit::result<::fidl::Error> OneWay(const ::fidl::Request<::test_protocols::Transitional::OneWay>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void Event(::fidl::Event<::test_protocols::Transitional::Event>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void Event(::fidl::Event<::test_protocols::Transitional::Event>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;
  void Event(::fidl::Event<::test_protocols::Transitional::Event>&) override { OnTransitionalEvent_(); }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::Transitional> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::Error> Event(const ::fidl::Event<::test_protocols::Transitional::Event>& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::Error> Event(const ::fidl::Event<::test_protocols::Transitional::Event>& payload);
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::Request> final : public ::test_protocols::TransitionalRequestRequest {
 public:
  using ::test_protocols::TransitionalRequestRequest::TransitionalRequestRequest;
  Request(::test_protocols::TransitionalRequestRequest v) : ::test_protocols::TransitionalRequestRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::Transitional::Request>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::OneWay> final : public ::test_protocols::TransitionalOneWayRequest {
 public:
  using ::test_protocols::TransitionalOneWayRequest::TransitionalOneWayRequest;
  Request(::test_protocols::TransitionalOneWayRequest v) : ::test_protocols::TransitionalOneWayRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::Transitional::OneWay>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalOneWayRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::Transitional::Request> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::Transitional::Request>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::Transitional> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using RequestRequest = ::fidl::Request<::test_protocols::Transitional::Request>;
  using RequestCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::Transitional::Request>;

  virtual void Request(RequestRequest& request, RequestCompleter::Sync& completer) { completer.Close(ZX_ERR_NOT_SUPPORTED); }

  using OneWayRequest = ::fidl::Request<::test_protocols::Transitional::OneWay>;
  using OneWayCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequest& request, OneWayCompleter::Sync& completer) { completer.Close(ZX_ERR_NOT_SUPPORTED); }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fit::result<::fidl::Error> Method() const;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::DiscoverableProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  ::fit::result<::fidl::Error> Method();

 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::DiscoverableProtocol::Method> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::DiscoverableProtocol::Method>> final {
 public:
  static constexpr bool kHasPayload = false;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using MethodRequest = ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>;
  using MethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequest& request, MethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::DiscoverableProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
 private:
  ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::AnotherDiscoverableProtocol;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::AnotherDiscoverableProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> final : public ::test_protocols::HandleRightsProtocolAnEventRequest {
 public:
  using ::test_protocols::HandleRightsProtocolAnEventRequest::HandleRightsProtocolAnEventRequest;
  Event(::test_protocols::HandleRightsProtocolAnEventRequest v) : HandleRightsProtocolAnEventRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolAnEventRequest;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::HandleRightsProtocolResponseMethodResponse {
 public:
  using ::test_protocols::HandleRightsProtocolResponseMethodResponse::HandleRightsProtocolResponseMethodResponse;
  Response(::test_protocols::HandleRightsProtocolResponseMethodResponse v) : HandleRightsProtocolResponseMethodResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolResponseMethodResponse;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fit::result<::fidl::Error, ::test_protocols::HandleRightsProtocolResponseMethodResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::HandleRightsProtocolResponseMethodResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod> request) const;

  ::fit::result<::fidl::Error> NoResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod> request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::HandleRightsProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod> request);

  ::fit::result<::fidl::Error> NoResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod> request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::Error> AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::Error> AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> payload);
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::test_protocols::HandleRightsProtocolNoResponseMethodRequest {
 public:
  using ::test_protocols::HandleRightsProtocolNoResponseMethodRequest::HandleRightsProtocolNoResponseMethodRequest;
  Request(::test_protocols::HandleRightsProtocolNoResponseMethodRequest v) : ::test_protocols::HandleRightsProtocolNoResponseMethodRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolNoResponseMethodRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::HandleRightsProtocolResponseMethodRequest {
 public:
  using ::test_protocols::HandleRightsProtocolResponseMethodRequest::HandleRightsProtocolResponseMethodRequest;
  Request(::test_protocols::HandleRightsProtocolResponseMethodRequest v) : ::test_protocols::HandleRightsProtocolResponseMethodRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolResponseMethodRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using NoResponseMethodRequest = ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(NoResponseMethodRequest& request, NoResponseMethodCompleter::Sync& completer) = 0;

  using ResponseMethodRequest = ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequest& request, ResponseMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::HandleRightsProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::WithProtocolEndsClientEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsClientEndsResponse::WithProtocolEndsClientEndsResponse;
  Response(::test_protocols::WithProtocolEndsClientEndsResponse v) : WithProtocolEndsClientEndsResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsResponse;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsClientEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsClientEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::WithProtocolEndsServerEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsServerEndsResponse::WithProtocolEndsServerEndsResponse;
  Response(::test_protocols::WithProtocolEndsServerEndsResponse v) : WithProtocolEndsServerEndsResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsResponse;
};

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsServerEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsServerEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::WithProtocolEndsStructContainingEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsStructContainingEndsResponse::WithProtocolEndsStructContainingEndsResponse;
  Response(::test_protocols::WithProtocolEndsStructContainingEndsResponse v) : WithProtocolEndsStructContainingEndsResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsStructContainingEndsResponse;
};

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsStructContainingEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsStructContainingEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds> request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithProtocolEnds> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request);

  ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request);

  ::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds> request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::WithProtocolEndsClientEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsClientEndsRequest::WithProtocolEndsClientEndsRequest;
  Request(::test_protocols::WithProtocolEndsClientEndsRequest v) : ::test_protocols::WithProtocolEndsClientEndsRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::WithProtocolEndsServerEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsServerEndsRequest::WithProtocolEndsServerEndsRequest;
  Request(::test_protocols::WithProtocolEndsServerEndsRequest v) : ::test_protocols::WithProtocolEndsServerEndsRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsRequest;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::WithProtocolEndsStructContainingEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsStructContainingEndsRequest::WithProtocolEndsStructContainingEndsRequest;
  Request(::test_protocols::WithProtocolEndsStructContainingEndsRequest v) : ::test_protocols::WithProtocolEndsStructContainingEndsRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsStructContainingEndsRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithProtocolEnds> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using ClientEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequest& request, ClientEndsCompleter::Sync& completer) = 0;

  using ServerEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequest& request, ServerEndsCompleter::Sync& completer) = 0;

  using StructContainingEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(StructContainingEndsRequest& request, StructContainingEndsCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithProtocolEnds> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fit::result<::fidl::Error> Fifteen(const ::fidl::Request<::test_protocols::ManyParameters::Fifteen>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::ManyParameters> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::ManyParameters>> {
 public:
  ::fit::result<::fidl::Error> Fifteen(const ::fidl::Request<::test_protocols::ManyParameters::Fifteen>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ManyParameters> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ManyParameters::Fifteen> final : public ::test_protocols::ManyParametersFifteenRequest {
 public:
  using ::test_protocols::ManyParametersFifteenRequest::ManyParametersFifteenRequest;
  Request(::test_protocols::ManyParametersFifteenRequest v) : ::test_protocols::ManyParametersFifteenRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::ManyParameters::Fifteen>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ManyParametersFifteenRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::ManyParameters> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using FifteenRequest = ::fidl::Request<::test_protocols::ManyParameters::Fifteen>;
  using FifteenCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequest& request, FifteenCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::ManyParameters> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::MethodWithUnion::UnionMethod> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>>;

  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod>&)>;

  static constexpr bool kHasDomainError = false;
  static constexpr bool kHasFrameworkError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::MethodWithUnionUnionMethodResponse {
 public:
  using ::test_protocols::MethodWithUnionUnionMethodResponse::MethodWithUnionUnionMethodResponse;
  Response(::test_protocols::MethodWithUnionUnionMethodResponse v) : MethodWithUnionUnionMethodResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<::test_protocols::MethodWithUnion::UnionMethod>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::MethodWithUnionUnionMethodResponse;
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fit::result<::fidl::Error, ::test_protocols::MethodWithUnionUnionMethodResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::MethodWithUnionUnionMethodResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(const ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::MethodWithUnion> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  ::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(const ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::MethodWithUnion> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::MethodWithUnionUnionMethodRequest {
 public:
  using ::test_protocols::MethodWithUnionUnionMethodRequest::MethodWithUnionUnionMethodRequest;
  Request(::test_protocols::MethodWithUnionUnionMethodRequest v) : ::test_protocols::MethodWithUnionUnionMethodRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>> final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::MethodWithUnionUnionMethodRequest;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::MethodWithUnion::UnionMethod>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::MethodWithUnion> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using UnionMethodRequest = ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequest& request, UnionMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::MethodWithUnion> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/cpp/wire/internal/display_error.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

namespace test_anonymous {

// |Flags| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class Flags final {
 public:
  constexpr Flags() = default;

  // Constructs an instance of |Flags| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr Flags(uint16_t value) : value_(value) {}
  const static Flags kInline;
  const static Flags kMask;

  explicit constexpr inline operator uint16_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const Flags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const Flags& other) const { return value_ != other.value_; }
  constexpr inline Flags operator~() const;
  constexpr inline Flags operator|(const Flags& other) const;
  constexpr inline Flags operator&(const Flags& other) const;
  constexpr inline Flags operator^(const Flags& other) const;
  constexpr inline void operator|=(const Flags& other);
  constexpr inline void operator&=(const Flags& other);
  constexpr inline void operator^=(const Flags& other);

  // Constructs an instance of |Flags| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |std::nullopt|.
  constexpr inline static std::optional<Flags> TryFrom(uint16_t value) {
    if (value & ~kMask.value_) {
      return std::nullopt;
    }
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Flags TruncatingUnknown(uint16_t value) {
    return Flags(value & Flags::kMask.value_);
  }
  constexpr inline Flags unknown_bits() const {
    return *this & Flags(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

 private:
  uint16_t value_ = 0;
};
constexpr const ::test_anonymous::Flags Flags::kInline =
    ::test_anonymous::Flags(1u);
constexpr const ::test_anonymous::Flags Flags::kMask = ::test_anonymous::Flags(1u);

constexpr inline ::test_anonymous::Flags Flags::operator~() const {
  return ::test_anonymous::Flags(static_cast<uint16_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator|(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(static_cast<uint16_t>(this->value_ | other.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator&(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(static_cast<uint16_t>(this->value_ & other.value_));
}

constexpr inline ::test_anonymous::Flags Flags::operator^(
    const ::test_anonymous::Flags& other) const {
  return ::test_anonymous::Flags(static_cast<uint16_t>(this->value_ ^ other.value_));
}

constexpr inline void Flags::operator|=(
    const ::test_anonymous::Flags& other) {
  this->value_ |= other.value_;
}

constexpr inline void Flags::operator&=(
    const ::test_anonymous::Flags& other) {
  this->value_ &= other.value_;
}

constexpr inline void Flags::operator^=(
    const ::test_anonymous::Flags& other) {
  this->value_ ^= other.value_;
}

// |BitsMember| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class BitsMember final {
 public:
  constexpr BitsMember() = default;

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr BitsMember(uint32_t value) : value_(value) {}
  const static BitsMember kBitOne;
  const static BitsMember kBitTwo;
  const static BitsMember kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const BitsMember& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const BitsMember& other) const { return value_ != other.value_; }
  constexpr inline BitsMember operator~() const;
  constexpr inline BitsMember operator|(const BitsMember& other) const;
  constexpr inline BitsMember operator&(const BitsMember& other) const;
  constexpr inline BitsMember operator^(const BitsMember& other) const;
  constexpr inline void operator|=(const BitsMember& other);
  constexpr inline void operator&=(const BitsMember& other);
  constexpr inline void operator^=(const BitsMember& other);

  // Constructs an instance of |BitsMember| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |std::nullopt|.
  constexpr inline static std::optional<BitsMember> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return std::nullopt;
    }
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static BitsMember TruncatingUnknown(uint32_t value) {
    return BitsMember(value & BitsMember::kMask.value_);
  }
  constexpr inline BitsMember unknown_bits() const {
    return *this & BitsMember(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

 private:
  uint32_t value_ = 0;
};
constexpr const ::test_anonymous::BitsMember BitsMember::kBitOne =
    ::test_anonymous::BitsMember(1u);
constexpr const ::test_anonymous::BitsMember BitsMember::kBitTwo =
    ::test_anonymous::BitsMember(2u);
constexpr const ::test_anonymous::BitsMember BitsMember::kMask = ::test_anonymous::BitsMember(3u);

constexpr inline ::test_anonymous::BitsMember BitsMember::operator~() const {
  return ::test_anonymous::BitsMember(static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator|(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator&(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test_anonymous::BitsMember BitsMember::operator^(
    const ::test_anonymous::BitsMember& other) const {
  return ::test_anonymous::BitsMember(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void BitsMember::operator|=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ |= other.value_;
}

constexpr inline void BitsMember::operator&=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ &= other.value_;
}

constexpr inline void BitsMember::operator^=(
    const ::test_anonymous::BitsMember& other) {
  this->value_ ^= other.value_;
}

class Op final {
 private:
  enum class EnumForSwitching_ : uint32_t {

    kAdd = 1u,

    kMul = 2u,

    kDiv = 3u,

    _do_not_handle_this__write_a_default_case_instead = 0xffffffff,
  };

  constexpr explicit Op(EnumForSwitching_ value) : value_(static_cast<uint32_t>(value)) {}

 public:
  constexpr Op() : value_(static_cast<uint32_t>(Unknown())) {}
  constexpr explicit Op(uint32_t value) : value_(value) {}
  constexpr operator EnumForSwitching_() const { return static_cast<EnumForSwitching_>(value_); }
  constexpr explicit operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

      case 3u:

        return false;
    }
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static Op Unknown() {
    return Op(0xffffffff);
  }

  static const Op kAdd;

  static const Op kMul;

  static const Op kDiv;

 private:
  uint32_t value_;
};
constexpr const ::test_anonymous::Op Op::kAdd =
    ::test_anonymous::Op(1u);
constexpr const ::test_anonymous::Op Op::kMul =
    ::test_anonymous::Op(2u);
constexpr const ::test_anonymous::Op Op::kDiv =
    ::test_anonymous::Op(3u);

}  // namespace test_anonymous

template <>
struct fidl::internal::DisplayError<::test_anonymous::Op> {
  static size_t Format(const ::test_anonymous::Op& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_anonymous::Op value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

}  // namespace fidl
namespace test_anonymous {

class SomeProtocolSomeMethodError final {
 private:
  enum class EnumForSwitching_ : uint32_t {

    kErrorOne = 1u,

    kErrorTwo = 2u,

    _do_not_handle_this__write_a_default_case_instead = 0xffffffff,
  };

  constexpr explicit SomeProtocolSomeMethodError(EnumForSwitching_ value) : value_(static_cast<uint32_t>(value)) {}

 public:
  constexpr SomeProtocolSomeMethodError() : value_(static_cast<uint32_t>(Unknown())) {}
  constexpr explicit SomeProtocolSomeMethodError(uint32_t value) : value_(value) {}
  constexpr operator EnumForSwitching_() const { return static_cast<EnumForSwitching_>(value_); }
  constexpr explicit operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static SomeProtocolSomeMethodError Unknown() {
    return SomeProtocolSomeMethodError(0xffffffff);
  }

  static const SomeProtocolSomeMethodError kErrorOne;

  static const SomeProtocolSomeMethodError kErrorTwo;

 private:
  uint32_t value_;
};
constexpr const ::test_anonymous::SomeProtocolSomeMethodError SomeProtocolSomeMethodError::kErrorOne =
    ::test_anonymous::SomeProtocolSomeMethodError(1u);
constexpr const ::test_anonymous::SomeProtocolSomeMethodError SomeProtocolSomeMethodError::kErrorTwo =
    ::test_anonymous::SomeProtocolSomeMethodError(2u);

}  // namespace test_anonymous

template <>
struct fidl::internal::DisplayError<::test_anonymous::SomeProtocolSomeMethodError> {
  static size_t Format(const ::test_anonymous::SomeProtocolSomeMethodError& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_anonymous::SomeProtocolSomeMethodError value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

template <>
struct IsFidlType<::test_anonymous::Flags> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::Flags> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_anonymous::Flags>);
static_assert(sizeof(::test_anonymous::Flags) == sizeof(uint16_t));

template <>
struct IsFidlType<::test_anonymous::BitsMember> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::BitsMember> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_anonymous::BitsMember>);
static_assert(sizeof(::test_anonymous::BitsMember) == sizeof(uint32_t));

template <>
struct IsFidlType<::test_anonymous::Op> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::Op> : public std::false_type {};

template <>
struct IsFidlType<::test_anonymous::SomeProtocolSomeMethodError> : public std::true_type {};
template <>
struct ContainsHandle<::test_anonymous::SomeProtocolSomeMethodError> : public std::false_type {};

}  // namespace fidl

// WARNING: This file is machine generated by fidlgen.

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    

#endif  // __Fuchsia__


  #include <fidl/test.union/cpp/markers.h>
  #include <fidl/test.union/cpp/common_types.h>
  

  namespace test_union {


  
  
  
namespace wire {

struct Pizza;


struct Pasta;


struct NullableUnionStruct;


struct Empty;


struct TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse;


struct TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse;


struct StructWithNullableXUnion;


struct UnionSandwich;
  
  


class PizzaOrPasta;


class ExplicitPizzaOrPasta;


class FlexiblePizzaOrPasta;


class StrictPizzaOrPasta;


class Union;


class FlexibleUnion;


class StrictUnion;


class FieldCollision;


class ExplicitUnion;


class ReverseOrdinalUnion;


class FlexibleFoo;


class StrictFoo;


class ExplicitFoo;


class ExplicitStrictFoo;


class OlderSimpleUnion;


class NewerSimpleUnion;


class StrictSimpleXUnion;


class XUnionContainingEmptyStruct;


class StrictBoundedXUnion;


class ExplicitXUnion;


class UnionWithAttributes;


class EmptyFlexibleUnion;


class OnlyReservedFlexibleUnion;
    
    
    
    



extern "C" const fidl_type_t test_union_EmptyTable;

struct Empty {

    uint8_t __reserved = {};
};
    
    
    
    
  
  



extern "C" const fidl_type_t test_union_PizzaOrPastaTable;

class PizzaOrPasta {
  public:

  PizzaOrPasta() : ordinal_(::test_union::wire::PizzaOrPasta::Ordinal::Invalid), envelope_{} {}

  PizzaOrPasta(const PizzaOrPasta&) = default;
  PizzaOrPasta& operator=(const PizzaOrPasta&) = default;
  PizzaOrPasta(PizzaOrPasta&&) = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza; }
  
  static PizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
    PizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::PizzaOrPasta::Ordinal::kPizza;
    result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static PizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pizza& pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta; }
  
  static PizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
    PizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::PizzaOrPasta::Ordinal::kPasta;
    result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static PizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pasta& pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  ::test_union::wire::PizzaOrPasta::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::PizzaOrPasta::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::PizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ExplicitPizzaOrPastaTable;

class ExplicitPizzaOrPasta {
  public:

  ExplicitPizzaOrPasta() : ordinal_(::test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid), envelope_{} {}

  ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta& operator=(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza; }
  
  static ExplicitPizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
    ExplicitPizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza;
    result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitPizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pizza& pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta; }
  
  static ExplicitPizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
    ExplicitPizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta;
    result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitPizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pasta& pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  ::test_union::wire::ExplicitPizzaOrPasta::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::ExplicitPizzaOrPasta::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_FlexiblePizzaOrPastaTable;

class FlexiblePizzaOrPasta {
  public:

  FlexiblePizzaOrPasta() : ordinal_(::test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid), envelope_{} {}

  FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta& operator=(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexiblePizzaOrPasta::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza; }
  
  static FlexiblePizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
    FlexiblePizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza;
    result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static FlexiblePizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pizza& pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta; }
  
  static FlexiblePizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
    FlexiblePizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta;
    result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static FlexiblePizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pasta& pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  ::test_union::wire::FlexiblePizzaOrPasta::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexiblePizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_StrictPizzaOrPastaTable;

class StrictPizzaOrPasta {
  public:

  StrictPizzaOrPasta() : ordinal_(::test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid), envelope_{} {}

  StrictPizzaOrPasta(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta& operator=(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta(StrictPizzaOrPasta&&) = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid; }

  bool is_pizza() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza; }
  
  static StrictPizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
    StrictPizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza;
    result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictPizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pizza& pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta; }
  
  static StrictPizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
    StrictPizzaOrPasta result;
    result.ordinal_ = ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta;
    result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictPizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_union::wire::Pasta& pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  ::test_union::wire::StrictPizzaOrPasta::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::StrictPizzaOrPasta::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_UnionTable;

class Union {
  public:

  Union() : ordinal_(::test_union::wire::Union::Ordinal::Invalid), envelope_{} {}

  Union(const Union&) = default;
  Union& operator=(const Union&) = default;
  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::Union::Ordinal::Invalid; }

  bool is_primitive() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive; }
  
  static Union WithPrimitive(int32_t val) {
    Union result;
    result.ordinal_ = ::test_union::wire::Union::Ordinal::kPrimitive;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor; }
  
  static Union WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
    Union result;
    result.ordinal_ = ::test_union::wire::Union::Ordinal::kStringNeedsConstructor;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static Union WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor; }
  
  static Union WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    Union result;
    result.ordinal_ = ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor;
    result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static Union WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::test_union::wire::Union::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::Union::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::Union::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_FlexibleUnionTable;

class FlexibleUnion {
  public:

  FlexibleUnion() : ordinal_(::test_union::wire::FlexibleUnion::Ordinal::Invalid), envelope_{} {}

  FlexibleUnion(const FlexibleUnion&) = default;
  FlexibleUnion& operator=(const FlexibleUnion&) = default;
  FlexibleUnion(FlexibleUnion&&) = default;
  FlexibleUnion& operator=(FlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::Invalid; }

  bool is_primitive() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive; }
  
  static FlexibleUnion WithPrimitive(int32_t val) {
    FlexibleUnion result;
    result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor; }
  
  static FlexibleUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
    FlexibleUnion result;
    result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static FlexibleUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor; }
  
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    FlexibleUnion result;
    result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor;
    result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::test_union::wire::FlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_StrictUnionTable;

class StrictUnion {
  public:

  StrictUnion() : ordinal_(::test_union::wire::StrictUnion::Ordinal::Invalid), envelope_{} {}

  StrictUnion(const StrictUnion&) = default;
  StrictUnion& operator=(const StrictUnion&) = default;
  StrictUnion(StrictUnion&&) = default;
  StrictUnion& operator=(StrictUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::Invalid; }

  bool is_primitive() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive; }
  
  static StrictUnion WithPrimitive(int32_t val) {
    StrictUnion result;
    result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kPrimitive;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor; }
  
  static StrictUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
    StrictUnion result;
    result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor; }
  
  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    StrictUnion result;
    result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor;
    result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::test_union::wire::StrictUnion::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::StrictUnion::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 2,  // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_FieldCollisionTable;

class FieldCollision {
  public:

  FieldCollision() : ordinal_(::test_union::wire::FieldCollision::Ordinal::Invalid), envelope_{} {}

  FieldCollision(const FieldCollision&) = default;
  FieldCollision& operator=(const FieldCollision&) = default;
  FieldCollision(FieldCollision&&) = default;
  FieldCollision& operator=(FieldCollision&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::FieldCollision::Ordinal::Invalid; }

  bool is_field_collision_tag() const { return ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag; }
  
  static FieldCollision WithFieldCollisionTag(int32_t val) {
    FieldCollision result;
    result.ordinal_ = ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& field_collision_tag() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_union::wire::FieldCollision::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::FieldCollision::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FieldCollision::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ExplicitUnionTable;

class ExplicitUnion {
  public:

  ExplicitUnion() : ordinal_(::test_union::wire::ExplicitUnion::Ordinal::Invalid), envelope_{} {}

  ExplicitUnion(const ExplicitUnion&) = default;
  ExplicitUnion& operator=(const ExplicitUnion&) = default;
  ExplicitUnion(ExplicitUnion&&) = default;
  ExplicitUnion& operator=(ExplicitUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::Invalid; }

  bool is_primitive() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive; }
  
  static ExplicitUnion WithPrimitive(int32_t val) {
    ExplicitUnion result;
    result.ordinal_ = ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor; }
  
  static ExplicitUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitUnion result;
    result.ordinal_ = ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  ::test_union::wire::ExplicitUnion::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::ExplicitUnion::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,  // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ReverseOrdinalUnionTable;

class ReverseOrdinalUnion {
  public:

  ReverseOrdinalUnion() : ordinal_(::test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid), envelope_{} {}

  ReverseOrdinalUnion(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion& operator=(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion(ReverseOrdinalUnion&&) = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSecond = 2,  // 0x2
    kFirst = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid; }

  bool is_second() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond; }
  
  static ReverseOrdinalUnion WithSecond(uint32_t val) {
    ReverseOrdinalUnion result;
    result.ordinal_ = ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& second() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }

  bool is_first() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst; }
  
  static ReverseOrdinalUnion WithFirst(uint32_t val) {
    ReverseOrdinalUnion result;
    result.ordinal_ = ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& first() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_union::wire::ReverseOrdinalUnion::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::ReverseOrdinalUnion::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSecond = 2,  // 0x2
    kFirst = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ReverseOrdinalUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_FlexibleFooTable;

class FlexibleFoo {
  public:

  FlexibleFoo() : ordinal_(::test_union::wire::FlexibleFoo::Ordinal::Invalid), envelope_{} {}

  FlexibleFoo(const FlexibleFoo&) = default;
  FlexibleFoo& operator=(const FlexibleFoo&) = default;
  FlexibleFoo(FlexibleFoo&&) = default;
  FlexibleFoo& operator=(FlexibleFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexibleFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS; }
  
  static FlexibleFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    FlexibleFoo result;
    result.ordinal_ = ::test_union::wire::FlexibleFoo::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static FlexibleFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI; }
  
  static FlexibleFoo WithI(int32_t val) {
    FlexibleFoo result;
    result.ordinal_ = ::test_union::wire::FlexibleFoo::Ordinal::kI;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_union::wire::FlexibleFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexibleFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_StrictFooTable;

class StrictFoo {
  public:

  StrictFoo() : ordinal_(::test_union::wire::StrictFoo::Ordinal::Invalid), envelope_{} {}

  StrictFoo(const StrictFoo&) = default;
  StrictFoo& operator=(const StrictFoo&) = default;
  StrictFoo(StrictFoo&&) = default;
  StrictFoo& operator=(StrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS; }
  
  static StrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    StrictFoo result;
    result.ordinal_ = ::test_union::wire::StrictFoo::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI; }
  
  static StrictFoo WithI(int32_t val) {
    StrictFoo result;
    result.ordinal_ = ::test_union::wire::StrictFoo::Ordinal::kI;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_union::wire::StrictFoo::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::StrictFoo::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ExplicitFooTable;

class ExplicitFoo {
  public:

  ExplicitFoo() : ordinal_(::test_union::wire::ExplicitFoo::Ordinal::Invalid), envelope_{} {}

  ExplicitFoo(const ExplicitFoo&) = default;
  ExplicitFoo& operator=(const ExplicitFoo&) = default;
  ExplicitFoo(ExplicitFoo&&) = default;
  ExplicitFoo& operator=(ExplicitFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 2,  // 0x2
    kI = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::ExplicitFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS; }
  
  static ExplicitFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitFoo result;
    result.ordinal_ = ::test_union::wire::ExplicitFoo::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI; }
  
  static ExplicitFoo WithI(int32_t val) {
    ExplicitFoo result;
    result.ordinal_ = ::test_union::wire::ExplicitFoo::Ordinal::kI;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_union::wire::ExplicitFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 2,  // 0x2
    kI = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ExplicitStrictFooTable;

class ExplicitStrictFoo {
  public:

  ExplicitStrictFoo() : ordinal_(::test_union::wire::ExplicitStrictFoo::Ordinal::Invalid), envelope_{} {}

  ExplicitStrictFoo(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo& operator=(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo(ExplicitStrictFoo&&) = default;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::Invalid; }

  bool is_s() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS; }
  
  static ExplicitStrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitStrictFoo result;
    result.ordinal_ = ::test_union::wire::ExplicitStrictFoo::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitStrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI; }
  
  static ExplicitStrictFoo WithI(int32_t val) {
    ExplicitStrictFoo result;
    result.ordinal_ = ::test_union::wire::ExplicitStrictFoo::Ordinal::kI;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_union::wire::ExplicitStrictFoo::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::ExplicitStrictFoo::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitStrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_OlderSimpleUnionTable;

class OlderSimpleUnion {
  public:

  OlderSimpleUnion() : ordinal_(::test_union::wire::OlderSimpleUnion::Ordinal::Invalid), envelope_{} {}

  OlderSimpleUnion(const OlderSimpleUnion&) = default;
  OlderSimpleUnion& operator=(const OlderSimpleUnion&) = default;
  OlderSimpleUnion(OlderSimpleUnion&&) = default;
  OlderSimpleUnion& operator=(OlderSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::OlderSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI; }
  
  static OlderSimpleUnion WithI(::fidl::ObjectView<int64_t> val) {
    OlderSimpleUnion result;
    result.ordinal_ = ::test_union::wire::OlderSimpleUnion::Ordinal::kI;
    result.envelope_.As<int64_t>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static OlderSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                         std::forward<Args>(args)...));
  }


  int64_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_f() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF; }
  
  static OlderSimpleUnion WithF(float val) {
    OlderSimpleUnion result;
    result.ordinal_ = ::test_union::wire::OlderSimpleUnion::Ordinal::kF;
    result.envelope_.As<float>().set_data(std::move(val));
    return result;
  }


  float& f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  ::test_union::wire::OlderSimpleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::OlderSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_NewerSimpleUnionTable;

class NewerSimpleUnion {
  public:

  NewerSimpleUnion() : ordinal_(::test_union::wire::NewerSimpleUnion::Ordinal::Invalid), envelope_{} {}

  NewerSimpleUnion(const NewerSimpleUnion&) = default;
  NewerSimpleUnion& operator=(const NewerSimpleUnion&) = default;
  NewerSimpleUnion(NewerSimpleUnion&&) = default;
  NewerSimpleUnion& operator=(NewerSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::NewerSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI; }
  
  static NewerSimpleUnion WithI(::fidl::ObjectView<int64_t> val) {
    NewerSimpleUnion result;
    result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kI;
    result.envelope_.As<int64_t>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static NewerSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                         std::forward<Args>(args)...));
  }


  int64_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_s() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS; }
  
  static NewerSimpleUnion WithS(::fidl::ObjectView<::fidl::StringView> val) {
    NewerSimpleUnion result;
    result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static NewerSimpleUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_v() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV; }
  
  static NewerSimpleUnion WithV(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    NewerSimpleUnion result;
    result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kV;
    result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static NewerSimpleUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    return WithV(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::VectorView<::fidl::StringView>& v() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& v() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::test_union::wire::NewerSimpleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::NewerSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_StrictSimpleXUnionTable;

class StrictSimpleXUnion {
  public:

  StrictSimpleXUnion() : ordinal_(::test_union::wire::StrictSimpleXUnion::Ordinal::Invalid), envelope_{} {}

  StrictSimpleXUnion(const StrictSimpleXUnion&) = default;
  StrictSimpleXUnion& operator=(const StrictSimpleXUnion&) = default;
  StrictSimpleXUnion(StrictSimpleXUnion&&) = default;
  StrictSimpleXUnion& operator=(StrictSimpleXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kI; }
  
  static StrictSimpleXUnion WithI(int32_t val) {
    StrictSimpleXUnion result;
    result.ordinal_ = ::test_union::wire::StrictSimpleXUnion::Ordinal::kI;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_f() const { return ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kF; }
  
  static StrictSimpleXUnion WithF(float val) {
    StrictSimpleXUnion result;
    result.ordinal_ = ::test_union::wire::StrictSimpleXUnion::Ordinal::kF;
    result.envelope_.As<float>().set_data(std::move(val));
    return result;
  }


  float& f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }

  bool is_s() const { return ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kS; }
  
  static StrictSimpleXUnion WithS(::fidl::ObjectView<::fidl::StringView> val) {
    StrictSimpleXUnion result;
    result.ordinal_ = ::test_union::wire::StrictSimpleXUnion::Ordinal::kS;
    result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictSimpleXUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::StringView& s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleXUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  ::test_union::wire::StrictSimpleXUnion::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::StrictSimpleXUnion::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictSimpleXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_XUnionContainingEmptyStructTable;

class XUnionContainingEmptyStruct {
  public:

  XUnionContainingEmptyStruct() : ordinal_(::test_union::wire::XUnionContainingEmptyStruct::Ordinal::Invalid), envelope_{} {}

  XUnionContainingEmptyStruct(const XUnionContainingEmptyStruct&) = default;
  XUnionContainingEmptyStruct& operator=(const XUnionContainingEmptyStruct&) = default;
  XUnionContainingEmptyStruct(XUnionContainingEmptyStruct&&) = default;
  XUnionContainingEmptyStruct& operator=(XUnionContainingEmptyStruct&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kEmpty = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::XUnionContainingEmptyStruct::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::XUnionContainingEmptyStruct::Ordinal::Invalid; }

  bool is_empty() const { return ordinal_ == ::test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty; }
  
  static XUnionContainingEmptyStruct WithEmpty(::test_union::wire::Empty val) {
    XUnionContainingEmptyStruct result;
    result.ordinal_ = ::test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty;
    result.envelope_.As<::test_union::wire::Empty>().set_data(std::move(val));
    return result;
  }


  ::test_union::wire::Empty& empty() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::test_union::wire::Empty>().get_data();
  }
  const ::test_union::wire::Empty& empty() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::test_union::wire::Empty>().get_data();
  }
  ::test_union::wire::XUnionContainingEmptyStruct::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kEmpty = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::XUnionContainingEmptyStruct::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_StrictBoundedXUnionTable;

class StrictBoundedXUnion {
  public:

  StrictBoundedXUnion() : ordinal_(::test_union::wire::StrictBoundedXUnion::Ordinal::Invalid), envelope_{} {}

  StrictBoundedXUnion(const StrictBoundedXUnion&) = default;
  StrictBoundedXUnion& operator=(const StrictBoundedXUnion&) = default;
  StrictBoundedXUnion(StrictBoundedXUnion&&) = default;
  StrictBoundedXUnion& operator=(StrictBoundedXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictBoundedXUnion::Ordinal::Invalid; }

  bool is_v() const { return ordinal_ == ::test_union::wire::StrictBoundedXUnion::Ordinal::kV; }
  
  static StrictBoundedXUnion WithV(::fidl::ObjectView<::fidl::VectorView<uint8_t>> val) {
    StrictBoundedXUnion result;
    result.ordinal_ = ::test_union::wire::StrictBoundedXUnion::Ordinal::kV;
    result.envelope_.As<::fidl::VectorView<uint8_t>>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static StrictBoundedXUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    return WithV(::fidl::ObjectView<::fidl::VectorView<uint8_t>>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::fidl::VectorView<uint8_t>& v() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictBoundedXUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }
  const ::fidl::VectorView<uint8_t>& v() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictBoundedXUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }
  ::test_union::wire::StrictBoundedXUnion::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_union::wire::StrictBoundedXUnion::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictBoundedXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_ExplicitXUnionTable;

class ExplicitXUnion {
  public:

  ExplicitXUnion() : ordinal_(::test_union::wire::ExplicitXUnion::Ordinal::Invalid), envelope_{} {}

  ExplicitXUnion(const ExplicitXUnion&) = default;
  ExplicitXUnion& operator=(const ExplicitXUnion&) = default;
  ExplicitXUnion(ExplicitXUnion&&) = default;
  ExplicitXUnion& operator=(ExplicitXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::ExplicitXUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::Invalid; }

  bool is_i() const { return ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kI; }
  
  static ExplicitXUnion WithI(::fidl::ObjectView<int64_t> val) {
    ExplicitXUnion result;
    result.ordinal_ = ::test_union::wire::ExplicitXUnion::Ordinal::kI;
    result.envelope_.As<int64_t>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ExplicitXUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                         std::forward<Args>(args)...));
  }


  int64_t& i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_f() const { return ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kF; }
  
  static ExplicitXUnion WithF(float val) {
    ExplicitXUnion result;
    result.ordinal_ = ::test_union::wire::ExplicitXUnion::Ordinal::kF;
    result.envelope_.As<float>().set_data(std::move(val));
    return result;
  }


  float& f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  ::test_union::wire::ExplicitXUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_UnionWithAttributesTable;

class UnionWithAttributes {
  public:

  UnionWithAttributes() : ordinal_(::test_union::wire::UnionWithAttributes::Ordinal::Invalid), envelope_{} {}

  UnionWithAttributes(const UnionWithAttributes&) = default;
  UnionWithAttributes& operator=(const UnionWithAttributes&) = default;
  UnionWithAttributes(UnionWithAttributes&&) = default;
  UnionWithAttributes& operator=(UnionWithAttributes&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::UnionWithAttributes::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::Invalid; }

  bool is_x() const { return ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX; }
  
  static UnionWithAttributes WithX(::fidl::ObjectView<int64_t> val) {
    UnionWithAttributes result;
    result.ordinal_ = ::test_union::wire::UnionWithAttributes::Ordinal::kX;
    result.envelope_.As<int64_t>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnionWithAttributes WithX(::fidl::AnyArena& allocator, Args&&... args) {
    return WithX(::fidl::ObjectView<int64_t>(allocator,
                                         std::forward<Args>(args)...));
  }


  int64_t& x() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& x() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }
  ::test_union::wire::UnionWithAttributes::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kX = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::UnionWithAttributes::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_EmptyFlexibleUnionTable;

class EmptyFlexibleUnion {
  public:

  EmptyFlexibleUnion() : ordinal_(::test_union::wire::EmptyFlexibleUnion::Ordinal::Invalid), envelope_{} {}

  EmptyFlexibleUnion(const EmptyFlexibleUnion&) = default;
  EmptyFlexibleUnion& operator=(const EmptyFlexibleUnion&) = default;
  EmptyFlexibleUnion(EmptyFlexibleUnion&&) = default;
  EmptyFlexibleUnion& operator=(EmptyFlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::EmptyFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::EmptyFlexibleUnion::Ordinal::Invalid; }
  ::test_union::wire::EmptyFlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::EmptyFlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_union_OnlyReservedFlexibleUnionTable;

class OnlyReservedFlexibleUnion {
  public:

  OnlyReservedFlexibleUnion() : ordinal_(::test_union::wire::OnlyReservedFlexibleUnion::Ordinal::Invalid), envelope_{} {}

  OnlyReservedFlexibleUnion(const OnlyReservedFlexibleUnion&) = default;
  OnlyReservedFlexibleUnion& operator=(const OnlyReservedFlexibleUnion&) = default;
  OnlyReservedFlexibleUnion(OnlyReservedFlexibleUnion&&) = default;
  OnlyReservedFlexibleUnion& operator=(OnlyReservedFlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_union::wire::OnlyReservedFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_union::wire::OnlyReservedFlexibleUnion::Ordinal::Invalid; }
  ::test_union::wire::OnlyReservedFlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::OnlyReservedFlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};
  
  
    



extern "C" const fidl_type_t test_union_PizzaTable;

struct Pizza {

    ::fidl::VectorView<::fidl::StringView> toppings = {};
};
    



extern "C" const fidl_type_t test_union_PastaTable;

struct Pasta {

    ::fidl::StringView sauce = {};
};
    



extern "C" const fidl_type_t test_union_NullableUnionStructTable;

struct NullableUnionStruct {

    ::fidl::WireOptional<::test_union::wire::Union> the_union = {};
};
    
    



extern "C" const fidl_type_t test_union_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponseTable;

struct TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse {

    ::test_union::wire::StrictBoundedXUnion xu = {};
};
    



extern "C" const fidl_type_t test_union_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponseTable;

struct TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse {

    ::test_union::wire::OlderSimpleUnion xu = {};
};
    



extern "C" const fidl_type_t test_union_StructWithNullableXUnionTable;

struct StructWithNullableXUnion {

    ::fidl::WireOptional<::test_union::wire::OlderSimpleUnion> x1 = {};
};
    



extern "C" const fidl_type_t test_union_UnionSandwichTable;

struct UnionSandwich {

    uint32_t a = {};

    ::test_union::wire::ExplicitXUnion u = {};

    uint32_t b = {};
};

  }  // namespace wire
}  // namespace test_union
namespace fidl {


  
  
  


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::Pizza>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_PizzaTable;
};

template<>
struct TypeTraits<::test_union::wire::Pizza> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Pizza> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Pizza> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::Pizza>);
static_assert(offsetof(::test_union::wire::Pizza, toppings) == 0);
static_assert(sizeof(::test_union::wire::Pizza) == TypeTraits<::test_union::wire::Pizza>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::Pizza* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::Pizza));
    } else {
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>::Encode(encoder, &value->toppings, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::Pasta>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_PastaTable;
};

template<>
struct TypeTraits<::test_union::wire::Pasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Pasta> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Pasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::Pasta>);
static_assert(offsetof(::test_union::wire::Pasta, sauce) == 0);
static_assert(sizeof(::test_union::wire::Pasta) == TypeTraits<::test_union::wire::Pasta>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::Pasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::Pasta));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>::Encode(encoder, &value->sauce, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::NullableUnionStruct>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_NullableUnionStructTable;
};

template<>
struct TypeTraits<::test_union::wire::NullableUnionStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::NullableUnionStruct> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::NullableUnionStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::NullableUnionStruct>);
static_assert(offsetof(::test_union::wire::NullableUnionStruct, the_union) == 0);
static_assert(sizeof(::test_union::wire::NullableUnionStruct) == TypeTraits<::test_union::wire::NullableUnionStruct>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::NullableUnionStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::NullableUnionStruct));
    } else {
      internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->the_union, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::Empty>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_EmptyTable;
};

template<>
struct TypeTraits<::test_union::wire::Empty> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_union::wire::Empty> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Empty> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::Empty>);
static_assert(offsetof(::test_union::wire::Empty, __reserved) == 0);
static_assert(sizeof(::test_union::wire::Empty) == TypeTraits<::test_union::wire::Empty>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::Empty* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::Empty));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponseTable;
};

template<>
struct TypeTraits<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse>);
static_assert(offsetof(::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse, xu) == 0);
static_assert(sizeof(::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse) == TypeTraits<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::StrictBoundedXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::TestProtocolStrictXUnionHenceResponseMayBeStackAllocatedResponse));
    } else {
      internal::WireCodingTraits<::test_union::wire::StrictBoundedXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->xu, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_union::wire::StrictBoundedXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponseTable;
};

template<>
struct TypeTraits<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>);
static_assert(offsetof(::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse, xu) == 0);
static_assert(sizeof(::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse) == TypeTraits<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::TestProtocolFlexibleXUnionHenceResponseMustBeHeapAllocatedResponse));
    } else {
      internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->xu, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::StructWithNullableXUnion>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_StructWithNullableXUnionTable;
};

template<>
struct TypeTraits<::test_union::wire::StructWithNullableXUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StructWithNullableXUnion> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::StructWithNullableXUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StructWithNullableXUnion>);
static_assert(offsetof(::test_union::wire::StructWithNullableXUnion, x1) == 0);
static_assert(sizeof(::test_union::wire::StructWithNullableXUnion) == TypeTraits<::test_union::wire::StructWithNullableXUnion>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableXUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::StructWithNullableXUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::StructWithNullableXUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::StructWithNullableXUnion));
    } else {
      internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->x1, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_union::wire::UnionSandwich>{
  static constexpr const fidl_type_t* kType = &::test_union::wire::test_union_UnionSandwichTable;
};

template<>
struct TypeTraits<::test_union::wire::UnionSandwich> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kPrimarySizeV1 = 40;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::UnionSandwich> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::UnionSandwich> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::UnionSandwich>);
static_assert(offsetof(::test_union::wire::UnionSandwich, a) == 0);
static_assert(offsetof(::test_union::wire::UnionSandwich, u) == 8);
static_assert(offsetof(::test_union::wire::UnionSandwich, b) == 24);
static_assert(sizeof(::test_union::wire::UnionSandwich) == TypeTraits<::test_union::wire::UnionSandwich>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 32;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::ExplicitXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_union::wire::UnionSandwich* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_union::wire::UnionSandwich));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireZeroPadding<uint64_t>(encoder, position + 24);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<::test_union::wire::ExplicitXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->u, position + 8, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 24, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::test_union::wire::ExplicitXUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000ull);
  }
};
  
  


template <>
struct TypeTraits<::test_union::wire::PizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::PizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::PizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::PizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::PizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::PizzaOrPasta::Tag::kPizza
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::PizzaOrPasta::Tag::kPasta
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::PizzaOrPasta::Tag::kPizza
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::PizzaOrPasta::Tag::kPasta
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::PizzaOrPasta::Tag tag = *position.As<::test_union::wire::PizzaOrPasta::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::PizzaOrPasta::Tag::kPizza:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::PizzaOrPasta::Tag::kPasta:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::PizzaOrPasta::Tag::kPizza:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::PizzaOrPasta::Tag::kPasta:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ExplicitPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitPizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitPizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitPizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 4: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 4: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ExplicitPizzaOrPasta::Tag tag = *position.As<::test_union::wire::ExplicitPizzaOrPasta::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::FlexiblePizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexiblePizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexiblePizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::FlexiblePizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexiblePizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::FlexiblePizzaOrPasta::Tag tag = *position.As<::test_union::wire::FlexiblePizzaOrPasta::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::StrictPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictPizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictPizzaOrPasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StrictPizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictPizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::StrictPizzaOrPasta::Tag tag = *position.As<::test_union::wire::StrictPizzaOrPasta::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Union> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::Union>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::Union* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::Union::Tag::kPrimitive
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::Union::Tag::kStringNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::Union::Tag::kPrimitive
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::Union::Tag::kStringNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 3: // ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::Union::Tag tag = *position.As<::test_union::wire::Union::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::Union::Tag::kPrimitive:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::Union::Tag::kStringNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::Union::Tag::kPrimitive:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::Union::Tag::kStringNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::FlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexibleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::FlexibleUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexibleUnion::Tag::kPrimitive
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexibleUnion::Tag::kPrimitive
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 3: // ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::FlexibleUnion::Tag tag = *position.As<::test_union::wire::FlexibleUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::FlexibleUnion::Tag::kPrimitive:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::FlexibleUnion::Tag::kPrimitive:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::StrictUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StrictUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictUnion::Tag::kPrimitive
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictUnion::Tag::kPrimitive
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 3: // ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::StrictUnion::Tag tag = *position.As<::test_union::wire::StrictUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::StrictUnion::Tag::kPrimitive:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::StrictUnion::Tag::kPrimitive:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::FieldCollision> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FieldCollision> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FieldCollision> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::FieldCollision>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FieldCollision* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::FieldCollision::Tag tag = *position.As<::test_union::wire::FieldCollision::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ExplicitUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitUnion::Tag::kPrimitive
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitUnion::Tag::kPrimitive
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ExplicitUnion::Tag tag = *position.As<::test_union::wire::ExplicitUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ExplicitUnion::Tag::kPrimitive:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ExplicitUnion::Tag::kPrimitive:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ReverseOrdinalUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ReverseOrdinalUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ReverseOrdinalUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ReverseOrdinalUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ReverseOrdinalUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 2: // ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond
        inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 1: // ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst
        inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 2: // ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 1: // ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ReverseOrdinalUnion::Tag tag = *position.As<::test_union::wire::ReverseOrdinalUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond:
        inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst:
        inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::FlexibleFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexibleFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexibleFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::FlexibleFoo>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexibleFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexibleFoo::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::FlexibleFoo::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::FlexibleFoo::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 2: // ::test_union::wire::FlexibleFoo::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::FlexibleFoo::Tag tag = *position.As<::test_union::wire::FlexibleFoo::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::FlexibleFoo::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::FlexibleFoo::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::FlexibleFoo::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::FlexibleFoo::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::StrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StrictFoo>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictFoo::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::StrictFoo::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictFoo::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 2: // ::test_union::wire::StrictFoo::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::StrictFoo::Tag tag = *position.As<::test_union::wire::StrictFoo::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::StrictFoo::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictFoo::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::StrictFoo::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::StrictFoo::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ExplicitFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitFoo>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 2: // ::test_union::wire::ExplicitFoo::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 1: // ::test_union::wire::ExplicitFoo::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 2: // ::test_union::wire::ExplicitFoo::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 1: // ::test_union::wire::ExplicitFoo::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ExplicitFoo::Tag tag = *position.As<::test_union::wire::ExplicitFoo::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ExplicitFoo::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ExplicitFoo::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ExplicitFoo::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::ExplicitFoo::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ExplicitStrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitStrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitStrictFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitStrictFoo>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitStrictFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 3: // ::test_union::wire::ExplicitStrictFoo::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::ExplicitStrictFoo::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 3: // ::test_union::wire::ExplicitStrictFoo::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 2: // ::test_union::wire::ExplicitStrictFoo::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ExplicitStrictFoo::Tag tag = *position.As<::test_union::wire::ExplicitStrictFoo::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ExplicitStrictFoo::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ExplicitStrictFoo::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ExplicitStrictFoo::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::ExplicitStrictFoo::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::OlderSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::OlderSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::OlderSimpleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::OlderSimpleUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::OlderSimpleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::OlderSimpleUnion::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::OlderSimpleUnion::Tag::kF
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::OlderSimpleUnion::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::OlderSimpleUnion::Tag::kF
        encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::OlderSimpleUnion::Tag tag = *position.As<::test_union::wire::OlderSimpleUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::OlderSimpleUnion::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::OlderSimpleUnion::Tag::kF:
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::OlderSimpleUnion::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::OlderSimpleUnion::Tag::kF:
        decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::NewerSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::NewerSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::NewerSimpleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::NewerSimpleUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::NewerSimpleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::NewerSimpleUnion::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::NewerSimpleUnion::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::NewerSimpleUnion::Tag::kV
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::NewerSimpleUnion::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::NewerSimpleUnion::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case 3: // ::test_union::wire::NewerSimpleUnion::Tag::kV
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::NewerSimpleUnion::Tag tag = *position.As<::test_union::wire::NewerSimpleUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::NewerSimpleUnion::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::NewerSimpleUnion::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::NewerSimpleUnion::Tag::kV:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::NewerSimpleUnion::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::NewerSimpleUnion::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      case ::test_union::wire::NewerSimpleUnion::Tag::kV:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::StrictSimpleXUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictSimpleXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictSimpleXUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StrictSimpleXUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleXUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictSimpleXUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictSimpleXUnion::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_union::wire::StrictSimpleXUnion::Tag::kF
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_union::wire::StrictSimpleXUnion::Tag::kS
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictSimpleXUnion::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_union::wire::StrictSimpleXUnion::Tag::kF
        encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_union::wire::StrictSimpleXUnion::Tag::kS
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::StrictSimpleXUnion::Tag tag = *position.As<::test_union::wire::StrictSimpleXUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::StrictSimpleXUnion::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictSimpleXUnion::Tag::kF:
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::StrictSimpleXUnion::Tag::kS:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::StrictSimpleXUnion::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::StrictSimpleXUnion::Tag::kF:
        decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::StrictSimpleXUnion::Tag::kS:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleXUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleXUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::XUnionContainingEmptyStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::XUnionContainingEmptyStruct> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::XUnionContainingEmptyStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::XUnionContainingEmptyStruct>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::XUnionContainingEmptyStruct, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::XUnionContainingEmptyStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::XUnionContainingEmptyStruct::Tag::kEmpty
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::XUnionContainingEmptyStruct::Tag::kEmpty
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::XUnionContainingEmptyStruct::Tag tag = *position.As<::test_union::wire::XUnionContainingEmptyStruct::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::XUnionContainingEmptyStruct::Tag::kEmpty:
        inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::XUnionContainingEmptyStruct::Tag::kEmpty:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::XUnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::XUnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::StrictBoundedXUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictBoundedXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictBoundedXUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::StrictBoundedXUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedXUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictBoundedXUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictBoundedXUnion::Tag::kV
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::StrictBoundedXUnion::Tag::kV
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::StrictBoundedXUnion::Tag tag = *position.As<::test_union::wire::StrictBoundedXUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::StrictBoundedXUnion::Tag::kV:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::StrictBoundedXUnion::Tag::kV:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedXUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedXUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::ExplicitXUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitXUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitXUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitXUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitXUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitXUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitXUnion::Tag::kI
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 4: // ::test_union::wire::ExplicitXUnion::Tag::kF
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::ExplicitXUnion::Tag::kI
        encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 4: // ::test_union::wire::ExplicitXUnion::Tag::kF
        encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::ExplicitXUnion::Tag tag = *position.As<::test_union::wire::ExplicitXUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::ExplicitXUnion::Tag::kI:
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_union::wire::ExplicitXUnion::Tag::kF:
        inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::ExplicitXUnion::Tag::kI:
        decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_union::wire::ExplicitXUnion::Tag::kF:
        decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitXUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitXUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::UnionWithAttributes> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::UnionWithAttributes> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::UnionWithAttributes> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::UnionWithAttributes>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::UnionWithAttributes* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_union::wire::UnionWithAttributes::Tag::kX
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_union::wire::UnionWithAttributes::Tag::kX
        encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::UnionWithAttributes::Tag tag = *position.As<::test_union::wire::UnionWithAttributes::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_union::wire::UnionWithAttributes::Tag::kX:
        inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_union::wire::UnionWithAttributes::Tag::kX:
        decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::EmptyFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::EmptyFlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::EmptyFlexibleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::EmptyFlexibleUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::EmptyFlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::EmptyFlexibleUnion::Tag tag = *position.As<::test_union::wire::EmptyFlexibleUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_union::wire::OnlyReservedFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::OnlyReservedFlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::OnlyReservedFlexibleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_union::wire::OnlyReservedFlexibleUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OnlyReservedFlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::OnlyReservedFlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_union::wire::OnlyReservedFlexibleUnion::Tag tag = *position.As<::test_union::wire::OnlyReservedFlexibleUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OnlyReservedFlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_union::wire::OnlyReservedFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

  }  // namespace fidl


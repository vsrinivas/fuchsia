// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/cpp/wire/internal/display_error.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

namespace test_doccomments {

/// strict bits comment #1
///
/// strict bits comment #2
// |MyStrictBits| is strict, hence is guaranteed to only contain
// members defined in the FIDL schema when receiving it in a message.
// Sending unknown members will fail at runtime.
class MyStrictBits final {
 public:
  constexpr MyStrictBits() = default;

  // Constructs an instance of |MyStrictBits| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr MyStrictBits(uint32_t value) : value_(value) {}
  const static MyStrictBits kMyFirstBit;
  const static MyStrictBits kMyOtherBit;
  const static MyStrictBits kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const MyStrictBits& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const MyStrictBits& other) const { return value_ != other.value_; }
  constexpr inline MyStrictBits operator~() const;
  constexpr inline MyStrictBits operator|(const MyStrictBits& other) const;
  constexpr inline MyStrictBits operator&(const MyStrictBits& other) const;
  constexpr inline MyStrictBits operator^(const MyStrictBits& other) const;
  constexpr inline void operator|=(const MyStrictBits& other);
  constexpr inline void operator&=(const MyStrictBits& other);
  constexpr inline void operator^=(const MyStrictBits& other);

  // Constructs an instance of |MyStrictBits| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |std::nullopt|.
  constexpr inline static std::optional<MyStrictBits> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return std::nullopt;
    }
    return MyStrictBits(value & MyStrictBits::kMask.value_);
  }

  // Constructs an instance of |MyStrictBits| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static MyStrictBits TruncatingUnknown(uint32_t value) {
    return MyStrictBits(value & MyStrictBits::kMask.value_);
  }

 private:
  uint32_t value_ = 0;
};
constexpr const ::test_doccomments::MyStrictBits MyStrictBits::kMyFirstBit =
    ::test_doccomments::MyStrictBits(1u);
constexpr const ::test_doccomments::MyStrictBits MyStrictBits::kMyOtherBit =
    ::test_doccomments::MyStrictBits(2u);
constexpr const ::test_doccomments::MyStrictBits MyStrictBits::kMask = ::test_doccomments::MyStrictBits(3u);

constexpr inline ::test_doccomments::MyStrictBits MyStrictBits::operator~() const {
  return ::test_doccomments::MyStrictBits(static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_doccomments::MyStrictBits MyStrictBits::operator|(
    const ::test_doccomments::MyStrictBits& other) const {
  return ::test_doccomments::MyStrictBits(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test_doccomments::MyStrictBits MyStrictBits::operator&(
    const ::test_doccomments::MyStrictBits& other) const {
  return ::test_doccomments::MyStrictBits(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test_doccomments::MyStrictBits MyStrictBits::operator^(
    const ::test_doccomments::MyStrictBits& other) const {
  return ::test_doccomments::MyStrictBits(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void MyStrictBits::operator|=(
    const ::test_doccomments::MyStrictBits& other) {
  this->value_ |= other.value_;
}

constexpr inline void MyStrictBits::operator&=(
    const ::test_doccomments::MyStrictBits& other) {
  this->value_ &= other.value_;
}

constexpr inline void MyStrictBits::operator^=(
    const ::test_doccomments::MyStrictBits& other) {
  this->value_ ^= other.value_;
}

/// flexible bits comment #1
///
/// flexible bits comment #2
// |MyFlexibleBits| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class MyFlexibleBits final {
 public:
  constexpr MyFlexibleBits() = default;

  // Constructs an instance of |MyFlexibleBits| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr MyFlexibleBits(uint32_t value) : value_(value) {}
  const static MyFlexibleBits kMyFirstBit;
  const static MyFlexibleBits kMyOtherBit;
  const static MyFlexibleBits kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const MyFlexibleBits& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const MyFlexibleBits& other) const { return value_ != other.value_; }
  constexpr inline MyFlexibleBits operator~() const;
  constexpr inline MyFlexibleBits operator|(const MyFlexibleBits& other) const;
  constexpr inline MyFlexibleBits operator&(const MyFlexibleBits& other) const;
  constexpr inline MyFlexibleBits operator^(const MyFlexibleBits& other) const;
  constexpr inline void operator|=(const MyFlexibleBits& other);
  constexpr inline void operator&=(const MyFlexibleBits& other);
  constexpr inline void operator^=(const MyFlexibleBits& other);

  // Constructs an instance of |MyFlexibleBits| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |std::nullopt|.
  constexpr inline static std::optional<MyFlexibleBits> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return std::nullopt;
    }
    return MyFlexibleBits(value & MyFlexibleBits::kMask.value_);
  }

  // Constructs an instance of |MyFlexibleBits| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static MyFlexibleBits TruncatingUnknown(uint32_t value) {
    return MyFlexibleBits(value & MyFlexibleBits::kMask.value_);
  }
  constexpr inline MyFlexibleBits unknown_bits() const {
    return *this & MyFlexibleBits(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

 private:
  uint32_t value_ = 0;
};
constexpr const ::test_doccomments::MyFlexibleBits MyFlexibleBits::kMyFirstBit =
    ::test_doccomments::MyFlexibleBits(1u);
constexpr const ::test_doccomments::MyFlexibleBits MyFlexibleBits::kMyOtherBit =
    ::test_doccomments::MyFlexibleBits(2u);
constexpr const ::test_doccomments::MyFlexibleBits MyFlexibleBits::kMask = ::test_doccomments::MyFlexibleBits(3u);

constexpr inline ::test_doccomments::MyFlexibleBits MyFlexibleBits::operator~() const {
  return ::test_doccomments::MyFlexibleBits(static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test_doccomments::MyFlexibleBits MyFlexibleBits::operator|(
    const ::test_doccomments::MyFlexibleBits& other) const {
  return ::test_doccomments::MyFlexibleBits(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test_doccomments::MyFlexibleBits MyFlexibleBits::operator&(
    const ::test_doccomments::MyFlexibleBits& other) const {
  return ::test_doccomments::MyFlexibleBits(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test_doccomments::MyFlexibleBits MyFlexibleBits::operator^(
    const ::test_doccomments::MyFlexibleBits& other) const {
  return ::test_doccomments::MyFlexibleBits(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void MyFlexibleBits::operator|=(
    const ::test_doccomments::MyFlexibleBits& other) {
  this->value_ |= other.value_;
}

constexpr inline void MyFlexibleBits::operator&=(
    const ::test_doccomments::MyFlexibleBits& other) {
  this->value_ &= other.value_;
}

constexpr inline void MyFlexibleBits::operator^=(
    const ::test_doccomments::MyFlexibleBits& other) {
  this->value_ ^= other.value_;
}

/// strict enum comment #1.
///
/// strict enum comment #2.
enum class MyStrictEnum : uint32_t {

  /// FOO member comment #1
  ///
  /// FOO member comment #3
  kFoo = 1u,

  /// BAR member comment #1
  ///
  /// BAR member comment #3
  kBar = 2u,
};

}  // namespace test_doccomments

template <>
struct fidl::internal::DisplayError<::test_doccomments::MyStrictEnum> {
  static size_t Format(const ::test_doccomments::MyStrictEnum& value, char* destination, size_t capacity);
};

namespace test_doccomments {

/// flexible enum comment #1.
///
/// flexible enum comment #2.
class MyFlexibleEnum final {
 public:
  constexpr MyFlexibleEnum() : value_(Unknown()) {}
  constexpr explicit MyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static MyFlexibleEnum Unknown() {
    return MyFlexibleEnum(0xffffffff);
  }

  /// FOO member comment #1
  ///
  /// FOO member comment #3
  static const MyFlexibleEnum kFoo;

  /// BAR member comment #1
  ///
  /// BAR member comment #3
  static const MyFlexibleEnum kBar;

 private:
  uint32_t value_;
};
constexpr const ::test_doccomments::MyFlexibleEnum MyFlexibleEnum::kFoo =
    ::test_doccomments::MyFlexibleEnum(1u);
constexpr const ::test_doccomments::MyFlexibleEnum MyFlexibleEnum::kBar =
    ::test_doccomments::MyFlexibleEnum(2u);

}  // namespace test_doccomments

template <>
struct fidl::internal::DisplayError<::test_doccomments::MyFlexibleEnum> {
  static size_t Format(const ::test_doccomments::MyFlexibleEnum& value, char* destination, size_t capacity);
};

namespace fidl {

template <>
struct IsFidlType<::test_doccomments::MyStrictBits> : public std::true_type {};
template <>
struct ContainsHandle<::test_doccomments::MyStrictBits> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_doccomments::MyStrictBits>);
static_assert(sizeof(::test_doccomments::MyStrictBits) == sizeof(uint32_t));

template <>
struct IsFidlType<::test_doccomments::MyFlexibleBits> : public std::true_type {};
template <>
struct ContainsHandle<::test_doccomments::MyFlexibleBits> : public std::false_type {};
static_assert(std::is_standard_layout_v<::test_doccomments::MyFlexibleBits>);
static_assert(sizeof(::test_doccomments::MyFlexibleBits) == sizeof(uint32_t));

template <>
struct IsFidlType<::test_doccomments::MyStrictEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_doccomments::MyStrictEnum> : public std::false_type {};

template <>
struct IsFidlType<::test_doccomments::MyFlexibleEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_doccomments::MyFlexibleEnum> : public std::false_type {};

}  // namespace fidl

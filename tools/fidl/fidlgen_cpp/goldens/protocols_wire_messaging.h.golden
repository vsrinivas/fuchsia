// WARNING: This file is machine generated by fidlgen.

  #pragma once

  #include <fidl/test.protocols/cpp/markers.h>
  #include <fidl/test.protocols/cpp/wire_types.h>

  #include <lib/fidl/cpp/wire/wire_messaging.h>

  
#ifdef __Fuchsia__

    #include <lib/fidl/cpp/wire/client.h>
    #include <lib/fidl/cpp/wire/connect_service.h>
    #include <lib/fidl/cpp/wire/server.h>
    #include <lib/fidl/cpp/wire/service_handler.h>
    #include <lib/fidl/cpp/wire/sync_call.h>
    #include <lib/fidl/cpp/wire/unknown_interaction_handler.h>
  

#endif  // __Fuchsia__


  
    
  namespace test_protocols {

  class WithAndWithoutRequestResponse;
    
  

  class WithErrorSyntax;
    
  

  class ChannelProtocol;
    
  

  class Transitional;
    
  

  class DiscoverableProtocol;
    
  

  class AnotherDiscoverableProtocol;
    
  

  class HandleRightsProtocol;
    
  

  class WithProtocolEnds;
    
  

  class ManyParameters;
    
  

  class MethodWithUnion;
    

    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final { static constexpr uint64_t value = 5413654872775949227lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final { static constexpr uint64_t value = 1631193469798418024lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final { static constexpr uint64_t value = 9037369643591427517lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final { static constexpr uint64_t value = 7326057319832554103lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final { static constexpr uint64_t value = 2877322062572412767lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final { static constexpr uint64_t value = 6417226585456833969lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final { static constexpr uint64_t value = 5397663296507358806lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final { static constexpr uint64_t value = 5811598563493228968lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithAndWithoutRequestResponse> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};




template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse {

  
  explicit WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse(std::move(base)) {}
  explicit WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse{ .ret = std::move(ret)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> body;
  explicit TransactionalResponse(::fidl::StringView ret)
  : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest { arg } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest { arg } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};




template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest { arg } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse {

  
  explicit WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse(std::move(base)) {}
  explicit WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse{ .ret = std::move(ret)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> body;
  explicit TransactionalResponse(::fidl::StringView ret)
  : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


  template<>
  struct ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final {

    
    WireEvent() = default;
  };



  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


  template<>
  struct ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest {

    
    explicit WireEvent(::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest base) : ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest(std::move(base)) {}
    explicit WireEvent(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest{ .ret = std::move(ret)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> body;
    explicit TransactionalEvent(::fidl::StringView ret)
    : body(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>(ret)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest)
    == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest)
    == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest)
    == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ret) == 0);
#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>> {
      static constexpr uint32_t kNumHandles =
            0;

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>> {
      static constexpr uint32_t kNumHandles =
            0;

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse>> {
   public:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Type = ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Type = ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void OnEmptyResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* event) = 0;
    virtual void OnWithResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void OnEmptyResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* event) override {}
    void OnWithResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::WithAndWithoutRequestResponse>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> NoRequestNoResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(_client_end(), &_request);
    }

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> WithRequestNoResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> NoRequestNoResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> WithRequestNoResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::StringView ret);

 private:
  void MakeReply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::StringView ret);

 private:
  void MakeReply(::fidl::StringView ret);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::StringView ret);

 private:
  void MakeReply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::StringView ret);

 private:
  void MakeReply(::fidl::StringView ret);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::WithAndWithoutRequestResponse>|
// and |::fidl::ServerEnd<::test_protocols::WithAndWithoutRequestResponse>|).
template<>
class ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::WithAndWithoutRequestResponse>)>;


    using NoRequestNoResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  
  virtual void NoRequestNoResponse(
    NoRequestNoResponseCompleter::Sync& completer)= 0;

    using NoRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  
  virtual void NoRequestEmptyResponse(
    NoRequestEmptyResponseCompleter::Sync& completer)= 0;

    using NoRequestWithResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  
  virtual void NoRequestWithResponse(
    NoRequestWithResponseCompleter::Sync& completer)= 0;

    using WithRequestNoResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
      using WithRequestNoResponseRequestView = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest*;

  
  virtual void WithRequestNoResponse(
      ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest* request,
    WithRequestNoResponseCompleter::Sync& completer)= 0;

    using WithRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;
      using WithRequestEmptyResponseRequestView = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest*;

  
  virtual void WithRequestEmptyResponse(
      ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest* request,
    WithRequestEmptyResponseCompleter::Sync& completer)= 0;

    using WithRequestWithResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
      using WithRequestWithResponseRequestView = ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest*;

  
  virtual void WithRequestWithResponse(
      ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest* request,
    WithRequestWithResponseCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithAndWithoutRequestResponse> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    
    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ResponseAsStruct> final { static constexpr uint64_t value = 268248568430741139lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final { static constexpr uint64_t value = 6930994461233198567lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ErrorAsEnum> final { static constexpr uint64_t value = 5491891352371277635lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::HandleInResult> final { static constexpr uint64_t value = 1371676333068455103lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithErrorSyntax> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse base) : ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) : ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse base) : ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) : ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse base) : ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) : ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse base) : ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) : ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>(std::move(result))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  
  
  using DomainError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  
  
  using DomainError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  
  
  using DomainError = ::test_protocols::wire::ErrorEnum;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::HandleInResult> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  
  
  using DomainError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::HandleInResult,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::HandleInResult,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, result) == 0);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>> {
      ::fidl::internal::InlineMessageBuffer<64> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax> handles_storage_;
  };



template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Type = ::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<64> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> decoded_;
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Type = ::fit::result<uint32_t>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> decoded_;
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Type = ::fit::result<::test_protocols::wire::ErrorEnum>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> decoded_;
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithErrorSyntax::HandleInResult> {
  using Type = ::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::WithErrorSyntax>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result);
  void ReplySuccess(int64_t a, int64_t b, int64_t c);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result);
  void ReplySuccess(int64_t a, int64_t b, int64_t c);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t> result);
  void ReplySuccess();
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t> result);
  void ReplySuccess();
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<::test_protocols::wire::ErrorEnum> result);
  void ReplySuccess();
  void ReplyError(::test_protocols::wire::ErrorEnum error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<::test_protocols::wire::ErrorEnum> result);
  void ReplySuccess();
  void ReplyError(::test_protocols::wire::ErrorEnum error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result);
  void ReplySuccess(::zx::handle&& h);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result);
  void ReplySuccess(::zx::handle&& h);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::WithErrorSyntax>|
// and |::fidl::ServerEnd<::test_protocols::WithErrorSyntax>|).
template<>
class ::fidl::WireServer<::test_protocols::WithErrorSyntax> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::WithErrorSyntax>)>;


    using ResponseAsStructCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  
  virtual void ResponseAsStruct(
    ResponseAsStructCompleter::Sync& completer)= 0;

    using ErrorAsPrimitiveCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  
  virtual void ErrorAsPrimitive(
    ErrorAsPrimitiveCompleter::Sync& completer)= 0;

    using ErrorAsEnumCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  
  virtual void ErrorAsEnum(
    ErrorAsEnumCompleter::Sync& completer)= 0;

    using HandleInResultCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::HandleInResult>;

  
  virtual void HandleInResult(
    HandleInResultCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithErrorSyntax> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;
    
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodA> final { static constexpr uint64_t value = 3155008840945527714lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::EventA> final { static constexpr uint64_t value = 2220452875311597006lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodB> final { static constexpr uint64_t value = 8903004957800778182lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::TakeHandle> final { static constexpr uint64_t value = 591935489944717925lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MutateSocket> final { static constexpr uint64_t value = 7411742788430590287lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ChannelProtocol> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::ChannelProtocolMethodARequest body;
  explicit TransactionalRequest(int64_t a, int64_t b)
  : body(::test_protocols::wire::ChannelProtocolMethodARequest { a, b } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


  template<>
  struct ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> final : public ::test_protocols::wire::ChannelProtocolEventARequest {

    
    explicit WireEvent(::test_protocols::wire::ChannelProtocolEventARequest base) : ::test_protocols::wire::ChannelProtocolEventARequest(std::move(base)) {}
    explicit WireEvent(int64_t a, int64_t b) : ::test_protocols::wire::ChannelProtocolEventARequest{ .a = std::move(a), .b = std::move(b)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> body;
    explicit TransactionalEvent(int64_t a, int64_t b)
    : body(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>(a, b)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::ChannelProtocolMethodBRequest body;
  explicit TransactionalRequest(int64_t a, int64_t b)
  : body(::test_protocols::wire::ChannelProtocolMethodBRequest { a, b } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::wire::ChannelProtocolMethodBResponse {

  
  explicit WireResponse(::test_protocols::wire::ChannelProtocolMethodBResponse base) : ::test_protocols::wire::ChannelProtocolMethodBResponse(std::move(base)) {}
  explicit WireResponse(int64_t result) : ::test_protocols::wire::ChannelProtocolMethodBResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> body;
  explicit TransactionalResponse(int64_t result)
  : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::ChannelProtocolTakeHandleRequest body;
  explicit TransactionalRequest(::zx::handle&& h)
  : body(::test_protocols::wire::ChannelProtocolTakeHandleRequest { std::move(h) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__





template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::ChannelProtocolMutateSocketRequest body;
  explicit TransactionalRequest(::zx::socket&& a)
  : body(::test_protocols::wire::ChannelProtocolMutateSocketRequest { std::move(a) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::wire::ChannelProtocolMutateSocketResponse {

  
  explicit WireResponse(::test_protocols::wire::ChannelProtocolMutateSocketResponse base) : ::test_protocols::wire::ChannelProtocolMutateSocketResponse(std::move(base)) {}
  explicit WireResponse(::zx::socket&& b) : ::test_protocols::wire::ChannelProtocolMutateSocketResponse{ .b = std::move(b)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket> body;
  explicit TransactionalResponse(::zx::socket&& b)
  : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>(std::move(b))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::MethodA> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::ChannelProtocolMethodARequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodA,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodA,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::MethodB> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::ChannelProtocolMethodBRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodB,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodB,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::TakeHandle> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::ChannelProtocolTakeHandleRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::TakeHandle,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::TakeHandle,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::MutateSocket> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::ChannelProtocolMutateSocketRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MutateSocket,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MutateSocket,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodARequest)
    == TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, a) == 0);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodBRequest)
    == TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::ChannelProtocolTakeHandleRequest)
    == TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolTakeHandleRequest, h) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, header) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMutateSocketRequest)
    == TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMutateSocketRequest, a) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, b) == 0);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>> {
      static constexpr uint32_t kNumHandles =
            0;

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<32> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::ChannelProtocol::MethodB> {
  using Type = ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* response)
        : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::ChannelProtocol::MutateSocket> {
  using Type = ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* response)
        : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void EventA(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void EventA(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::ChannelProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> MethodA(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>(_client_end(), &_request);
    }

    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(_client_end(), &_request);
    }

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA> MethodA(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::MethodB> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(int64_t result);

 private:
  void MakeReply(int64_t result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(int64_t result);

 private:
  void MakeReply(int64_t result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();

 private:
  void MakeReply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::zx::socket&& b);

 private:
  void MakeReply(::zx::socket&& b);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::zx::socket&& b);

 private:
  void MakeReply(::zx::socket&& b);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::ChannelProtocol>|
// and |::fidl::ServerEnd<::test_protocols::ChannelProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::ChannelProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::ChannelProtocol>)>;


    using MethodACompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodA>;
      using MethodARequestView = ::test_protocols::wire::ChannelProtocolMethodARequest*;

  
  virtual void MethodA(
      ::test_protocols::wire::ChannelProtocolMethodARequest* request,
    MethodACompleter::Sync& completer)= 0;

    using MethodBCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodB>;
      using MethodBRequestView = ::test_protocols::wire::ChannelProtocolMethodBRequest*;

  
  virtual void MethodB(
      ::test_protocols::wire::ChannelProtocolMethodBRequest* request,
    MethodBCompleter::Sync& completer)= 0;

    using TakeHandleCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::TakeHandle>;
      using TakeHandleRequestView = ::test_protocols::wire::ChannelProtocolTakeHandleRequest*;

  
  virtual void TakeHandle(
      ::test_protocols::wire::ChannelProtocolTakeHandleRequest* request,
    TakeHandleCompleter::Sync& completer)= 0;

    using MutateSocketCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MutateSocket>;
      using MutateSocketRequestView = ::test_protocols::wire::ChannelProtocolMutateSocketRequest*;

  
  virtual void MutateSocket(
      ::test_protocols::wire::ChannelProtocolMutateSocketRequest* request,
    MutateSocketCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::ChannelProtocol> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;
    
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Request> final { static constexpr uint64_t value = 5849263021838298888lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::OneWay> final { static constexpr uint64_t value = 4336658926562441191lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Event> final { static constexpr uint64_t value = 8507647465196374081lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::Transitional> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::Transitional> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::TransitionalRequestRequest body;
  explicit TransactionalRequest(int64_t x)
  : body(::test_protocols::wire::TransitionalRequestRequest { x } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::TransitionalRequestRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::TransitionalRequestRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::Transitional::Request> final : public ::test_protocols::wire::TransitionalRequestResponse {

  
  explicit WireResponse(::test_protocols::wire::TransitionalRequestResponse base) : ::test_protocols::wire::TransitionalRequestResponse(std::move(base)) {}
  explicit WireResponse(int64_t y) : ::test_protocols::wire::TransitionalRequestResponse{ .y = std::move(y)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::Transitional::Request> body;
  explicit TransactionalResponse(int64_t y)
  : body(::fidl::WireResponse<::test_protocols::Transitional::Request>(y)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::TransitionalOneWayRequest body;
  explicit TransactionalRequest(int64_t x)
  : body(::test_protocols::wire::TransitionalOneWayRequest { x } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::TransitionalOneWayRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::TransitionalOneWayRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};


  template<>
  struct ::fidl::WireEvent<::test_protocols::Transitional::Event> final : public ::test_protocols::wire::TransitionalEventRequest {

    
    explicit WireEvent(::test_protocols::wire::TransitionalEventRequest base) : ::test_protocols::wire::TransitionalEventRequest(std::move(base)) {}
    explicit WireEvent(int64_t x) : ::test_protocols::wire::TransitionalEventRequest{ .x = std::move(x)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::Transitional::Event>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::Transitional::Event> body;
    explicit TransactionalEvent(int64_t x)
    : body(::fidl::WireEvent<::test_protocols::Transitional::Event>(x)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::Transitional::OneWay> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::TransitionalOneWayRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::OneWay,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::OneWay,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::Transitional::Request> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::Transitional::Request>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::TransitionalRequestRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::Request,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::Request,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::TransitionalRequestRequest)
    == TypeTraits<::test_protocols::wire::TransitionalRequestRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::TransitionalRequestRequest, x) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::Transitional::Request>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::Transitional::Request>, y) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::TransitionalOneWayRequest)
    == TypeTraits<::test_protocols::wire::TransitionalOneWayRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::TransitionalOneWayRequest, x) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::Transitional::Event>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::Transitional::Event>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::Transitional::Event>, x) == 0);
#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::Transitional::Request>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::Transitional> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::Transitional>> {
   public:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional> handles_storage_;
  };



template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::Transitional::Request> {
  using Type = ::fidl::WireResponse<::test_protocols::Transitional::Request>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::Transitional::Request> final : public ::fidl::BaseWireResult<::test_protocols::Transitional::Request> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::Transitional::Request>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::Transitional::Request>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> final : public ::fidl::BaseWireResult<::test_protocols::Transitional::Request> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::Transitional::Request>* response)
        : ::fidl::BaseWireResult<::test_protocols::Transitional::Request>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::Transitional::Request>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::Transitional::Request>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::Transitional::Request>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::Transitional::Request>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::Transitional::OneWay> final : public ::fidl::BaseWireResult<::test_protocols::Transitional::OneWay> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::Transitional::OneWay>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> final : public ::fidl::BaseWireResult<::test_protocols::Transitional::OneWay> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::Transitional::OneWay>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::Transitional::OneWay>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::Transitional>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;
        void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) override { OnTransitionalEvent_(); }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::Transitional> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::Transitional>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::Transitional> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::Transitional>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::Transitional::Request> Request(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
      return ::fidl::WireResult<::test_protocols::Transitional::Request>(_client_end(), &_request);
    }

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::Transitional::OneWay> OneWay(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request{ x };
      return ::fidl::WireResult<::test_protocols::Transitional::OneWay>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::Transitional> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::Transitional>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> Request(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
      return ::fidl::WireUnownedResult<::test_protocols::Transitional::Request>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> OneWay(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request{ x };
      return ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request> : public ::fidl::internal::CompleterImplBase<::test_protocols::Transitional::Request> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(int64_t y);

 private:
  void MakeReply(int64_t y);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::Transitional::Request> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(int64_t y);

 private:
  void MakeReply(int64_t y);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::Transitional::Request> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::Transitional>|
// and |::fidl::ServerEnd<::test_protocols::Transitional>|).
template<>
class ::fidl::WireServer<::test_protocols::Transitional> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::Transitional>)>;


    using RequestCompleter = ::fidl::internal::WireCompleter<::test_protocols::Transitional::Request>;
      using RequestRequestView = ::test_protocols::wire::TransitionalRequestRequest*;

  
  virtual void Request(
      ::test_protocols::wire::TransitionalRequestRequest* request,
    RequestCompleter::Sync& completer){ completer.Close(ZX_ERR_NOT_SUPPORTED); }

    using OneWayCompleter = ::fidl::internal::WireCompleter<::test_protocols::Transitional::OneWay>;
      using OneWayRequestView = ::test_protocols::wire::TransitionalOneWayRequest*;

  
  virtual void OneWay(
      ::test_protocols::wire::TransitionalOneWayRequest* request,
    OneWayCompleter::Sync& completer){ completer.Close(ZX_ERR_NOT_SUPPORTED); }


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::Transitional> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    
    
}  // namespace fidl

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::DiscoverableProtocol::Method> final { static constexpr uint64_t value = 3455873048082739435lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::DiscoverableProtocol> {
    static constexpr char DiscoverableName[] = "test.protocols.DiscoverableProtocol";
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::DiscoverableProtocol::Method> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = false;
  
    using Request = void;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::DiscoverableProtocol::Method,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::DiscoverableProtocol::Method,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, header) == 0);
#ifdef __Fuchsia__
}  // namespace fidl

  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> final : public ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method> final : public ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> Method() {
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
      return ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method> Method() {
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>|
// and |::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>)>;


    using MethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::DiscoverableProtocol::Method>;

  
  virtual void Method(
    MethodCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    



}  // namespace fidl
namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::AnotherDiscoverableProtocol> {
    static constexpr char DiscoverableName[] = "fake.library.FakeProtocol";
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__


namespace fidl {


#ifdef __Fuchsia__
}  // namespace fidl

  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::AnotherDiscoverableProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::AnotherDiscoverableProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::AnotherDiscoverableProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::AnotherDiscoverableProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::AnotherDiscoverableProtocol> handles_storage_;
  };


template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::AnotherDiscoverableProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::AnotherDiscoverableProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  

 private:
  ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::AnotherDiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  

 private:
  ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::AnotherDiscoverableProtocol>|
// and |::fidl::ServerEnd<::test_protocols::AnotherDiscoverableProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::AnotherDiscoverableProtocol;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::AnotherDiscoverableProtocol>)>;



  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::AnotherDiscoverableProtocol> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;
    
    
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::NoResponseMethod> final { static constexpr uint64_t value = 1155044649514904573lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::ResponseMethod> final { static constexpr uint64_t value = 5956276128041940295lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::AnEvent> final { static constexpr uint64_t value = 476727631355490611lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::HandleRightsProtocol> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest body;
  explicit TransactionalRequest(::zx::socket&& h)
  : body(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest { std::move(h) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest body;
  explicit TransactionalRequest(::zx::socket&& h)
  : body(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest { std::move(h) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse {

  
  explicit WireResponse(::test_protocols::wire::HandleRightsProtocolResponseMethodResponse base) : ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse(std::move(base)) {}
  explicit WireResponse(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse{ .h = std::move(h)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> body;
  explicit TransactionalResponse(::zx::socket&& h)
  : body(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(std::move(h))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


  template<>
  struct ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent> final : public ::test_protocols::wire::HandleRightsProtocolAnEventRequest {

    
    explicit WireEvent(::test_protocols::wire::HandleRightsProtocolAnEventRequest base) : ::test_protocols::wire::HandleRightsProtocolAnEventRequest(std::move(base)) {}
    explicit WireEvent(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolAnEventRequest{ .h = std::move(h)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent> body;
    explicit TransactionalEvent(::zx::socket&& h)
    : body(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>(std::move(h))) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }
    void _CloseHandles() {
      body._CloseHandles();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::HandleRightsProtocol::NoResponseMethod> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::HandleRightsProtocol::ResponseMethod> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::ResponseMethod,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::ResponseMethod,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest)
    == TypeTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, h) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest)
    == TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, h) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, h) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, h) == 0);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 1;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Type = ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* response)
        : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void AnEvent(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void AnEvent(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::HandleRightsProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> NoResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> NoResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::internal::CompleterImplBase<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::zx::socket&& h);

 private:
  void MakeReply(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::zx::socket&& h);

 private:
  void MakeReply(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::HandleRightsProtocol>|
// and |::fidl::ServerEnd<::test_protocols::HandleRightsProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::HandleRightsProtocol>)>;


    using NoResponseMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
      using NoResponseMethodRequestView = ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest*;

  
  virtual void NoResponseMethod(
      ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest* request,
    NoResponseMethodCompleter::Sync& completer)= 0;

    using ResponseMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>;
      using ResponseMethodRequestView = ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest*;

  
  virtual void ResponseMethod(
      ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest* request,
    ResponseMethodCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::HandleRightsProtocol> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::ClientEnds> final { static constexpr uint64_t value = 5870448041025163330lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::ServerEnds> final { static constexpr uint64_t value = 8115535094437022259lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::StructContainingEnds> final { static constexpr uint64_t value = 4076866772260025813lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithProtocolEnds> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithProtocolEndsClientEndsRequest body;
  explicit TransactionalRequest(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in)
  : body(::test_protocols::wire::WithProtocolEndsClientEndsRequest { std::move(in) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::wire::WithProtocolEndsClientEndsResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsClientEndsResponse base) : ::test_protocols::wire::WithProtocolEndsClientEndsResponse(std::move(base)) {}
  explicit WireResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsClientEndsResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds> body;
  explicit TransactionalResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithProtocolEndsServerEndsRequest body;
  explicit TransactionalRequest(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in)
  : body(::test_protocols::wire::WithProtocolEndsServerEndsRequest { std::move(in) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::wire::WithProtocolEndsServerEndsResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsServerEndsResponse base) : ::test_protocols::wire::WithProtocolEndsServerEndsResponse(std::move(base)) {}
  explicit WireResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsServerEndsResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds> body;
  explicit TransactionalResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__


template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest body;
  explicit TransactionalRequest(::test_protocols::wire::ProtocolEnds&& in)
  : body(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest { std::move(in) } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__

template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse base) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::ProtocolEnds&& out) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> body;
  explicit TransactionalResponse(::test_protocols::wire::ProtocolEnds&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::ClientEnds> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithProtocolEndsClientEndsRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ClientEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ClientEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::ServerEnds> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithProtocolEndsServerEndsRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ServerEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ServerEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::StructContainingEnds> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::StructContainingEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::StructContainingEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsClientEndsRequest)
    == TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsClientEndsRequest, in) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, out) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsServerEndsRequest)
    == TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsServerEndsRequest, in) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, out) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest)
    == TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, in) == 0);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, out) == 0);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>> {
      ::fidl::internal::InlineMessageBuffer<32> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds> handles_storage_;
  };



template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithProtocolEnds::ClientEnds> {
  using Type = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> decoded_;
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithProtocolEnds::ServerEnds> {
  using Type = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> decoded_;
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Type = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<32> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::WithProtocolEnds>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(_client_end(), &_request);
    }

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);

 private:
  void MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);

 private:
  void MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);

 private:
  void MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);

 private:
  void MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::ProtocolEnds&& out);

 private:
  void MakeReply(::test_protocols::wire::ProtocolEnds&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::ProtocolEnds&& out);

 private:
  void MakeReply(::test_protocols::wire::ProtocolEnds&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::WithProtocolEnds>|
// and |::fidl::ServerEnd<::test_protocols::WithProtocolEnds>|).
template<>
class ::fidl::WireServer<::test_protocols::WithProtocolEnds> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::WithProtocolEnds>)>;


    using ClientEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ClientEnds>;
      using ClientEndsRequestView = ::test_protocols::wire::WithProtocolEndsClientEndsRequest*;

  
  virtual void ClientEnds(
      ::test_protocols::wire::WithProtocolEndsClientEndsRequest* request,
    ClientEndsCompleter::Sync& completer)= 0;

    using ServerEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ServerEnds>;
      using ServerEndsRequestView = ::test_protocols::wire::WithProtocolEndsServerEndsRequest*;

  
  virtual void ServerEnds(
      ::test_protocols::wire::WithProtocolEndsServerEndsRequest* request,
    ServerEndsCompleter::Sync& completer)= 0;

    using StructContainingEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>;
      using StructContainingEndsRequestView = ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest*;

  
  virtual void StructContainingEnds(
      ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest* request,
    StructContainingEndsCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithProtocolEnds> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;
    
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ManyParameters::Fifteen> final { static constexpr uint64_t value = 6423043252952467815lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ManyParameters> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::ManyParametersFifteenRequest body;
  explicit TransactionalRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15)
  : body(::test_protocols::wire::ManyParametersFifteenRequest { p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 15 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ManyParameters::Fifteen> {
  
    using Completer = fidl::Completer<>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::ManyParametersFifteenRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ManyParameters::Fifteen,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ManyParameters::Fifteen,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::ManyParametersFifteenRequest)
    == TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p1) == 0);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p2) == 1);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p3) == 2);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p4) == 3);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p5) == 4);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p6) == 5);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p7) == 6);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p8) == 7);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p9) == 8);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p10) == 9);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p11) == 10);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p12) == 11);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p13) == 12);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p14) == 13);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p15) == 14);
#ifdef __Fuchsia__
}  // namespace fidl

  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> final : public ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> final : public ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::ManyParameters>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::ManyParameters>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
      return ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ManyParameters> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ManyParameters>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
      return ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::ManyParameters>|
// and |::fidl::ServerEnd<::test_protocols::ManyParameters>|).
template<>
class ::fidl::WireServer<::test_protocols::ManyParameters> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::ManyParameters>)>;


    using FifteenCompleter = ::fidl::internal::WireCompleter<::test_protocols::ManyParameters::Fifteen>;
      using FifteenRequestView = ::test_protocols::wire::ManyParametersFifteenRequest*;

  
  virtual void Fifteen(
      ::test_protocols::wire::ManyParametersFifteenRequest* request,
    FifteenCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::ManyParameters> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;
    
__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;
}  // namespace test_protocols

template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::MethodWithUnion::UnionMethod> final { static constexpr uint64_t value = 4124874338266649112lu; };

namespace test_protocols {

}  // namespace test_protocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::MethodWithUnion> {
  static constexpr bool kIsProtocol = true;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_protocols::wire::MethodWithUnionUnionMethodRequest body;
  explicit TransactionalRequest(::test_protocols::wire::TheUnion u)
  : body(::test_protocols::wire::MethodWithUnionUnionMethodRequest { u } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::wire::MethodWithUnionUnionMethodResponse {

  
  explicit WireResponse(::test_protocols::wire::MethodWithUnionUnionMethodResponse base) : ::test_protocols::wire::MethodWithUnionUnionMethodResponse(std::move(base)) {}
  explicit WireResponse(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) : ::test_protocols::wire::MethodWithUnionUnionMethodResponse{ .u = std::move(u)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod> body;
  explicit TransactionalResponse(::fidl::WireOptional<::test_protocols::wire::TheUnion> u)
  : body(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>(u)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::MethodWithUnion::UnionMethod> {
  
    using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>>;
  

  static constexpr bool HasRequestPayload = true;
  
    using Request = ::test_protocols::wire::MethodWithUnionUnionMethodRequest;
  

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::MethodWithUnion::UnionMethod,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::MethodWithUnion::UnionMethod,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


namespace fidl {



template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_protocols::wire::MethodWithUnionUnionMethodRequest)
    == TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest>::kPrimarySize);
static_assert(offsetof(::test_protocols::wire::MethodWithUnionUnionMethodRequest, u) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, u) == 0);
#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion> handles_storage_;
  };



template<>
struct ::fidl::internal::WireResultUnwrap<::test_protocols::MethodWithUnion::UnionMethod> {
  using Type = ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* response)
        : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_protocols::MethodWithUnion>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u) {
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
      return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u) {
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
      return ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::internal::CompleterImplBase<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u);

 private:
  void MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u);

 private:
  void MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_protocols::MethodWithUnion>|
// and |::fidl::ServerEnd<::test_protocols::MethodWithUnion>|).
template<>
class ::fidl::WireServer<::test_protocols::MethodWithUnion> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using Handler = fit::function<void(::fidl::ServerEnd<::test_protocols::MethodWithUnion>)>;


    using UnionMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::MethodWithUnion::UnionMethod>;
      using UnionMethodRequestView = ::test_protocols::wire::MethodWithUnionUnionMethodRequest*;

  
  virtual void UnionMethod(
      ::test_protocols::wire::MethodWithUnionUnionMethodRequest* request,
    UnionMethodCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::MethodWithUnion> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__


  

    
#ifdef __Fuchsia__
}  // namespace fidl

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status NoRequestNoResponse();
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::Status WithRequestNoResponse(::fidl::StringView arg);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status NoRequestNoResponse();


// Caller provides the backing storage for FIDL message.
::fidl::Status WithRequestNoResponse(::fidl::StringView arg);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();
  
  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);
};namespace fidl {

#endif  // __Fuchsia__


    
}  // namespace fidl

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status MethodA(int64_t a, int64_t b);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status MethodA(int64_t a, int64_t b);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status EventA(int64_t a, int64_t b);


};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status OneWay(int64_t x);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::Transitional::Request> Request(int64_t x);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::Transitional> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status OneWay(int64_t x);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::Transitional::Request> Request(int64_t x);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::Transitional::Request> Request(int64_t x);
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status Event(int64_t x);


};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status Method();
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status Method();

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::AnotherDiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::AnotherDiscoverableProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::AnotherDiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status NoResponseMethod(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status NoResponseMethod(::zx::socket&& h);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status AnEvent(::zx::socket&& h);


};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);
  
  // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__

    
#ifdef __Fuchsia__


template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::MethodWithUnion> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);
};

#endif  // __Fuchsia__


    


#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};

#endif  // __Fuchsia__


  


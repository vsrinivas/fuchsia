{{/*
// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Service:ForwardDeclaration:WireMessagingHeader" }}
{{ EnsureNamespace . }}
class {{ .Name }};
{{- end }}

{{- define "Service:WireMessagingHeader" }}
{{ EnsureNamespace . }}
{{ "" }}
{{- .Docs }}
class {{ .Name }} final {
  {{ .Name }}() = default;
 public:
  static constexpr bool kIsService = true;
  static constexpr char Name[] = "{{ .ServiceName }}";
  using Transport = {{ .Transport.Type }};
  
  {{- IfdefFuchsia -}}
  using ServiceInstanceHandler = fidl::ServiceInstanceHandler<{{ .Transport.Type }}>;
  {{ EndifFuchsia }}
  
  {{- range .Members }}
  {{ "" }}
  class {{ .ClassName }} final {
   public:
    static constexpr bool kIsServiceMember = true;
    static constexpr char Name[] = "{{ .Name }}";
    static constexpr char ServiceName[] = "{{ .Service.ServiceName }}";
    using ProtocolType = {{ .ProtocolType }};
  };
  {{- end }}

  // Client protocol for connecting to member protocols of a service instance.
  class ServiceClient final {
    ServiceClient() = delete;
  {{- IfdefFuchsia -}}
   public:
    ServiceClient(::zx::channel dir, ::fidl::internal::ConnectMemberFunc connect_func)
    {{- with .Members }}
        : dir_(std::move(dir)), connect_func_(connect_func) {}
    {{- else }}
        { (void)dir; (void)connect_func; }
    {{- end }}
    {{- range .Members }}
  {{ "" }}
    // Connects |client_end| to the member protocol "{{ .Name }}".
    //
    // # Errors
    //
    // On failure, returns a |zx::error| with status != ZX_OK.
    // Failures can occur if there was an issue making a |fuchsia.io.Directory/Open| call.
    //
    // Since the call to |Open| is asynchronous, an error sent by the remote end will not
    // result in a failure of this method. Any errors sent by the remote will appear on
    // the reciprocal |ClientEnd| for the |ServerEnd| passed into this method.
    ::zx::result<> connect_{{ .Name }}({{ .ClientEnd }} client_end) {
      return connect_func_(
          ::zx::unowned_channel(dir_),
          ::fidl::StringView("{{ .Name }}"),
          ::fidl::internal::MakeAnyTransport(client_end.TakeChannel()));
    }

    // Connects to the member protocol "{{ .Name }}".
    //
    // # Errors
    //
    // On failure, returns a |zx::error| with status != ZX_OK.
    // Failures can occur if channel creation failed, or if there was an issue making
    // a |fuchsia.io.Directory/Open| call.
    //
    // Since the call to |Open| is asynchronous, an error sent by the remote end will not
    // result in a failure of this method. Any errors sent by the remote will appear on
    // the |ClientEnd| returned from this method.
    ::zx::result<{{ .ClientEnd }}> connect_{{ .Name }}() {
      auto endpoints = {{ .CreateEndpoints }}();
      if (endpoints.is_error()) {
        return endpoints.take_error();
      }
      auto connection = connect_func_(
          ::zx::unowned_channel(dir_),
          ::fidl::StringView("{{ .Name }}"),
          ::fidl::internal::MakeAnyTransport(endpoints->server.TakeChannel()));
      if (connection.is_error()) {
        return connection.take_error();
      }
      return ::zx::ok(std::move(endpoints->client));
    }
    {{- end }}

   private:
    {{- with .Members }}
    ::zx::channel dir_;
    ::fidl::internal::ConnectMemberFunc connect_func_;
    {{- end }}
  {{ EndifFuchsia }}
  };

  // Facilitates member protocol registration for servers.
  class Handler final {
  {{- IfdefFuchsia -}}
   public:
    // Constructs a FIDL Service-typed handler. Does not take ownership of |service_handler|.
    explicit Handler(ServiceInstanceHandler* service_handler)
    {{- with .Members }}
        : service_handler_(service_handler) {}
    {{- else }}
        { (void)service_handler; }
    {{- end }}

    {{- range .Members }}
    {{ "" }}
    // Adds member "{{ .Name }}" to the service instance. |handler| will be invoked on connection
    // attempts.
    //
    // # Errors
    //
    // Returns ZX_ERR_ALREADY_EXISTS if the member was already added.
    ::zx::result<> add_{{ .Name }}(
        ServiceInstanceHandler::MemberHandler<{{ .ProtocolType }}> handler) {
      return service_handler_->AddMember<{{ .ProtocolType }}>(std::move(handler), "{{ .Name }}");
    }
    {{- end }}

   private:
    {{- with .Members }}
    ServiceInstanceHandler* service_handler_;  // not owned.
    {{- end }}
  {{ EndifFuchsia }}
  };

  {{- IfdefFuchsia -}}
  // Facilitates member protocol registration for servers.
  class InstanceHandler final : public fidl::ServiceInstanceHandler<{{ .Transport.Type }}> {
   public:
    struct Members {
      {{- range .Members }}
        MemberHandler<{{ .ProtocolType }}> {{ .Name }};
      {{- end }}
    };

    InstanceHandler() = default;

    // Construct an instance handler for a FIDL service. It is expected that every member
    // contained in |members| is initialized with a handler.
    InstanceHandler(Members members) {
      {{- range .Members }}
        // TODO(https://fxbug.dev/102973): Handle member registration failure.
        (void) this->AddMember<{{ .ProtocolType }}>(std::move(members.{{ .Name }}), "{{ .Name }}");
      {{- end }}
    }

  };
  {{ EndifFuchsia }}
};
{{- end }}

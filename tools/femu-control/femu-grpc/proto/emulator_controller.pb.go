// Copyright (C) 2018 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Note that if you add/remove methods in this file you must update
// the metrics sql as well ./android/scripts/gen-grpc-sql.py
//
// Please group deleted methods in a block including the date (MM/DD/YY)
// it was removed. This enables us to easily keep metrics around after removal
//
// List of deleted methods
// rpc iWasDeleted (03/12/12)
// ...

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.12.3
// source: emulator_controller.proto

package android_emulator_control_proto

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type VmRunState_RunState int32

const (
	// The emulator is in an unknown state. You cannot transition to this state.
	VmRunState_UNKNOWN VmRunState_RunState = 0
	// Guest is actively running. You can transition to this state from the
	// paused state.
	VmRunState_RUNNING VmRunState_RunState = 1
	// Guest is paused to load a snapshot. You cannot transition to this state.
	VmRunState_RESTORE_VM VmRunState_RunState = 2
	// Guest has been paused. Transitioning to this state will pause the
	// emulator the guest will not be consuming any cpu cycles.
	VmRunState_PAUSED VmRunState_RunState = 3
	// Guest is paused to take or export a snapshot. You cannot
	// transition to this state.
	VmRunState_SAVE_VM VmRunState_RunState = 4
	// System shutdown, note that it is similar to power off. It tries to set
	// the system status and notify guest. The system is likely going to
	// disappear soon and do proper cleanup of resources, possibly taking
	// a snapshot. This is the same behavior as closing the emulator by clicking
	// the X (close) in the user interface.
	VmRunState_SHUTDOWN VmRunState_RunState = 5
	// Immediately terminate the emulator. No resource cleanup will take place.
	// There is a good change to corrupt the system.
	VmRunState_TERMINATE VmRunState_RunState = 7
	// Will cause the emulator to reset. This is not a state you can observe.
	VmRunState_RESET VmRunState_RunState = 9
	// Guest experienced some error state, you cannot transition to this state.
	VmRunState_INTERNAL_ERROR VmRunState_RunState = 10
)

// Enum value maps for VmRunState_RunState.
var (
	VmRunState_RunState_name = map[int32]string{
		0:  "UNKNOWN",
		1:  "RUNNING",
		2:  "RESTORE_VM",
		3:  "PAUSED",
		4:  "SAVE_VM",
		5:  "SHUTDOWN",
		7:  "TERMINATE",
		9:  "RESET",
		10: "INTERNAL_ERROR",
	}
	VmRunState_RunState_value = map[string]int32{
		"UNKNOWN":        0,
		"RUNNING":        1,
		"RESTORE_VM":     2,
		"PAUSED":         3,
		"SAVE_VM":        4,
		"SHUTDOWN":       5,
		"TERMINATE":      7,
		"RESET":          9,
		"INTERNAL_ERROR": 10,
	}
)

func (x VmRunState_RunState) Enum() *VmRunState_RunState {
	p := new(VmRunState_RunState)
	*p = x
	return p
}

func (x VmRunState_RunState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VmRunState_RunState) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[0].Descriptor()
}

func (VmRunState_RunState) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[0]
}

func (x VmRunState_RunState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VmRunState_RunState.Descriptor instead.
func (VmRunState_RunState) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{0, 0}
}

type PhysicalModelValue_State int32

const (
	PhysicalModelValue_OK         PhysicalModelValue_State = 0
	PhysicalModelValue_NO_SERVICE PhysicalModelValue_State = -3 // qemud service is not available/initiated.
	PhysicalModelValue_DISABLED   PhysicalModelValue_State = -2 // Sensor is disabled.
	PhysicalModelValue_UNKNOWN    PhysicalModelValue_State = -1 // Unknown sensor (should not happen)
)

// Enum value maps for PhysicalModelValue_State.
var (
	PhysicalModelValue_State_name = map[int32]string{
		0:  "OK",
		-3: "NO_SERVICE",
		-2: "DISABLED",
		-1: "UNKNOWN",
	}
	PhysicalModelValue_State_value = map[string]int32{
		"OK":         0,
		"NO_SERVICE": -3,
		"DISABLED":   -2,
		"UNKNOWN":    -1,
	}
)

func (x PhysicalModelValue_State) Enum() *PhysicalModelValue_State {
	p := new(PhysicalModelValue_State)
	*p = x
	return p
}

func (x PhysicalModelValue_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PhysicalModelValue_State) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[1].Descriptor()
}

func (PhysicalModelValue_State) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[1]
}

func (x PhysicalModelValue_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PhysicalModelValue_State.Descriptor instead.
func (PhysicalModelValue_State) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{2, 0}
}

// Details on the sensors documentation can be found here:
// https://developer.android.com/reference/android/hardware/Sensor.html#TYPE_
type PhysicalModelValue_PhysicalType int32

const (
	PhysicalModelValue_POSITION PhysicalModelValue_PhysicalType = 0
	// All values are angles in degrees.
	// values = [x,y,z]
	PhysicalModelValue_ROTATION       PhysicalModelValue_PhysicalType = 1
	PhysicalModelValue_MAGNETIC_FIELD PhysicalModelValue_PhysicalType = 2
	// Temperature in °C
	PhysicalModelValue_TEMPERATURE PhysicalModelValue_PhysicalType = 3
	// Proximity sensor distance measured in centimeters
	PhysicalModelValue_PROXIMITY PhysicalModelValue_PhysicalType = 4
	// Ambient light level in SI lux units
	PhysicalModelValue_LIGHT PhysicalModelValue_PhysicalType = 5
	// Atmospheric pressure in hPa (millibar)
	PhysicalModelValue_PRESSURE PhysicalModelValue_PhysicalType = 6
	// Relative ambient air humidity in percent
	PhysicalModelValue_HUMIDITY       PhysicalModelValue_PhysicalType = 7
	PhysicalModelValue_VELOCITY       PhysicalModelValue_PhysicalType = 8
	PhysicalModelValue_AMBIENT_MOTION PhysicalModelValue_PhysicalType = 9
)

// Enum value maps for PhysicalModelValue_PhysicalType.
var (
	PhysicalModelValue_PhysicalType_name = map[int32]string{
		0: "POSITION",
		1: "ROTATION",
		2: "MAGNETIC_FIELD",
		3: "TEMPERATURE",
		4: "PROXIMITY",
		5: "LIGHT",
		6: "PRESSURE",
		7: "HUMIDITY",
		8: "VELOCITY",
		9: "AMBIENT_MOTION",
	}
	PhysicalModelValue_PhysicalType_value = map[string]int32{
		"POSITION":       0,
		"ROTATION":       1,
		"MAGNETIC_FIELD": 2,
		"TEMPERATURE":    3,
		"PROXIMITY":      4,
		"LIGHT":          5,
		"PRESSURE":       6,
		"HUMIDITY":       7,
		"VELOCITY":       8,
		"AMBIENT_MOTION": 9,
	}
)

func (x PhysicalModelValue_PhysicalType) Enum() *PhysicalModelValue_PhysicalType {
	p := new(PhysicalModelValue_PhysicalType)
	*p = x
	return p
}

func (x PhysicalModelValue_PhysicalType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PhysicalModelValue_PhysicalType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[2].Descriptor()
}

func (PhysicalModelValue_PhysicalType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[2]
}

func (x PhysicalModelValue_PhysicalType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PhysicalModelValue_PhysicalType.Descriptor instead.
func (PhysicalModelValue_PhysicalType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{2, 1}
}

type SensorValue_State int32

const (
	SensorValue_OK         SensorValue_State = 0
	SensorValue_NO_SERVICE SensorValue_State = -3 // qemud service is not available/initiated.
	SensorValue_DISABLED   SensorValue_State = -2 // Sensor is disabled.
	SensorValue_UNKNOWN    SensorValue_State = -1 // Unknown sensor (should not happen)
)

// Enum value maps for SensorValue_State.
var (
	SensorValue_State_name = map[int32]string{
		0:  "OK",
		-3: "NO_SERVICE",
		-2: "DISABLED",
		-1: "UNKNOWN",
	}
	SensorValue_State_value = map[string]int32{
		"OK":         0,
		"NO_SERVICE": -3,
		"DISABLED":   -2,
		"UNKNOWN":    -1,
	}
)

func (x SensorValue_State) Enum() *SensorValue_State {
	p := new(SensorValue_State)
	*p = x
	return p
}

func (x SensorValue_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SensorValue_State) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[3].Descriptor()
}

func (SensorValue_State) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[3]
}

func (x SensorValue_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SensorValue_State.Descriptor instead.
func (SensorValue_State) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{3, 0}
}

// These are the various sensors that can be available in an emulated
// devices.
type SensorValue_SensorType int32

const (
	// Measures the acceleration force in m/s2 that is applied to a device
	// on all three physical axes (x, y, and z), including the force of
	// gravity.
	SensorValue_ACCELERATION SensorValue_SensorType = 0
	// Measures a device's rate of rotation in rad/s around each of the
	// three physical axes (x, y, and z).
	SensorValue_GYROSCOPE SensorValue_SensorType = 1
	// Measures the ambient geomagnetic field for all three physical axes
	// (x, y, z) in μT.
	SensorValue_MAGNETIC_FIELD SensorValue_SensorType = 2
	// Measures degrees of rotation that a device makes around all three
	// physical axes (x, y, z)
	SensorValue_ORIENTATION SensorValue_SensorType = 3
	// Measures the temperature of the device in degrees Celsius (°C).
	SensorValue_TEMPERATURE SensorValue_SensorType = 4
	// Measures the proximity of an object in cm relative to the view screen
	// of a device. This sensor is typically used to determine whether a
	// handset is being held up to a person's ear.
	SensorValue_PROXIMITY SensorValue_SensorType = 5
	// Measures the ambient light level (illumination) in lx.
	SensorValue_LIGHT SensorValue_SensorType = 6
	// Measures the ambient air pressure in hPa or mbar.
	SensorValue_PRESSURE SensorValue_SensorType = 7
	// Measures the relative ambient humidity in percent (%).
	SensorValue_HUMIDITY                    SensorValue_SensorType = 8
	SensorValue_MAGNETIC_FIELD_UNCALIBRATED SensorValue_SensorType = 9
	SensorValue_GYROSCOPE_UNCALIBRATED      SensorValue_SensorType = 10
)

// Enum value maps for SensorValue_SensorType.
var (
	SensorValue_SensorType_name = map[int32]string{
		0:  "ACCELERATION",
		1:  "GYROSCOPE",
		2:  "MAGNETIC_FIELD",
		3:  "ORIENTATION",
		4:  "TEMPERATURE",
		5:  "PROXIMITY",
		6:  "LIGHT",
		7:  "PRESSURE",
		8:  "HUMIDITY",
		9:  "MAGNETIC_FIELD_UNCALIBRATED",
		10: "GYROSCOPE_UNCALIBRATED",
	}
	SensorValue_SensorType_value = map[string]int32{
		"ACCELERATION":                0,
		"GYROSCOPE":                   1,
		"MAGNETIC_FIELD":              2,
		"ORIENTATION":                 3,
		"TEMPERATURE":                 4,
		"PROXIMITY":                   5,
		"LIGHT":                       6,
		"PRESSURE":                    7,
		"HUMIDITY":                    8,
		"MAGNETIC_FIELD_UNCALIBRATED": 9,
		"GYROSCOPE_UNCALIBRATED":      10,
	}
)

func (x SensorValue_SensorType) Enum() *SensorValue_SensorType {
	p := new(SensorValue_SensorType)
	*p = x
	return p
}

func (x SensorValue_SensorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SensorValue_SensorType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[4].Descriptor()
}

func (SensorValue_SensorType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[4]
}

func (x SensorValue_SensorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SensorValue_SensorType.Descriptor instead.
func (SensorValue_SensorType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{3, 1}
}

type LogMessage_LogType int32

const (
	LogMessage_Text   LogMessage_LogType = 0
	LogMessage_Parsed LogMessage_LogType = 1
)

// Enum value maps for LogMessage_LogType.
var (
	LogMessage_LogType_name = map[int32]string{
		0: "Text",
		1: "Parsed",
	}
	LogMessage_LogType_value = map[string]int32{
		"Text":   0,
		"Parsed": 1,
	}
)

func (x LogMessage_LogType) Enum() *LogMessage_LogType {
	p := new(LogMessage_LogType)
	*p = x
	return p
}

func (x LogMessage_LogType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogMessage_LogType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[5].Descriptor()
}

func (LogMessage_LogType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[5]
}

func (x LogMessage_LogType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogMessage_LogType.Descriptor instead.
func (LogMessage_LogType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{4, 0}
}

// The possible log levels.
type LogcatEntry_LogLevel int32

const (
	LogcatEntry_UNKNOWN LogcatEntry_LogLevel = 0
	LogcatEntry_DEFAULT LogcatEntry_LogLevel = 1
	LogcatEntry_VERBOSE LogcatEntry_LogLevel = 2
	LogcatEntry_DEBUG   LogcatEntry_LogLevel = 3
	LogcatEntry_INFO    LogcatEntry_LogLevel = 4
	LogcatEntry_WARN    LogcatEntry_LogLevel = 5
	LogcatEntry_ERR     LogcatEntry_LogLevel = 6
	LogcatEntry_FATAL   LogcatEntry_LogLevel = 7
	LogcatEntry_SILENT  LogcatEntry_LogLevel = 8
)

// Enum value maps for LogcatEntry_LogLevel.
var (
	LogcatEntry_LogLevel_name = map[int32]string{
		0: "UNKNOWN",
		1: "DEFAULT",
		2: "VERBOSE",
		3: "DEBUG",
		4: "INFO",
		5: "WARN",
		6: "ERR",
		7: "FATAL",
		8: "SILENT",
	}
	LogcatEntry_LogLevel_value = map[string]int32{
		"UNKNOWN": 0,
		"DEFAULT": 1,
		"VERBOSE": 2,
		"DEBUG":   3,
		"INFO":    4,
		"WARN":    5,
		"ERR":     6,
		"FATAL":   7,
		"SILENT":  8,
	}
)

func (x LogcatEntry_LogLevel) Enum() *LogcatEntry_LogLevel {
	p := new(LogcatEntry_LogLevel)
	*p = x
	return p
}

func (x LogcatEntry_LogLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogcatEntry_LogLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[6].Descriptor()
}

func (LogcatEntry_LogLevel) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[6]
}

func (x LogcatEntry_LogLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogcatEntry_LogLevel.Descriptor instead.
func (LogcatEntry_LogLevel) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{5, 0}
}

type VmConfiguration_VmHypervisorType int32

const (
	// An unknown hypervisor
	VmConfiguration_UNKNOWN VmConfiguration_VmHypervisorType = 0
	// No hypervisor is in use. This usually means that the guest is
	// running on a different CPU than the host, or you are using a
	// platform where no hypervisor is available.
	VmConfiguration_NONE VmConfiguration_VmHypervisorType = 1
	// The Kernel based Virtual Machine
	// (https://www.linux-kvm.org/page/Main_Page)
	VmConfiguration_KVM VmConfiguration_VmHypervisorType = 2
	// Intel® Hardware Accelerated Execution Manager (Intel® HAXM)
	// https://github.com/intel/haxm
	VmConfiguration_HAXM VmConfiguration_VmHypervisorType = 3
	// Hypervisor Framework.
	// https://developer.apple.com/documentation/hypervisor
	VmConfiguration_HVF VmConfiguration_VmHypervisorType = 4
	// Window Hypervisor Platform
	// https://docs.microsoft.com/en-us/virtualization/api/
	VmConfiguration_WHPX VmConfiguration_VmHypervisorType = 5
	VmConfiguration_GVM  VmConfiguration_VmHypervisorType = 6
)

// Enum value maps for VmConfiguration_VmHypervisorType.
var (
	VmConfiguration_VmHypervisorType_name = map[int32]string{
		0: "UNKNOWN",
		1: "NONE",
		2: "KVM",
		3: "HAXM",
		4: "HVF",
		5: "WHPX",
		6: "GVM",
	}
	VmConfiguration_VmHypervisorType_value = map[string]int32{
		"UNKNOWN": 0,
		"NONE":    1,
		"KVM":     2,
		"HAXM":    3,
		"HVF":     4,
		"WHPX":    5,
		"GVM":     6,
	}
)

func (x VmConfiguration_VmHypervisorType) Enum() *VmConfiguration_VmHypervisorType {
	p := new(VmConfiguration_VmHypervisorType)
	*p = x
	return p
}

func (x VmConfiguration_VmHypervisorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VmConfiguration_VmHypervisorType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[7].Descriptor()
}

func (VmConfiguration_VmHypervisorType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[7]
}

func (x VmConfiguration_VmHypervisorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VmConfiguration_VmHypervisorType.Descriptor instead.
func (VmConfiguration_VmHypervisorType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{6, 0}
}

// Code types that the emulator can receive. Note that the emulator
// will do its best to translate the code to an evdev value that
// will be send to the emulator. This translation is based on
// the chromium translation tables. See
// (this)[https://android.googlesource.com/platform/external/qemu/+/refs/heads/emu-master-dev/android/android-grpc/android/emulation/control/keyboard/keycode_converter_data.inc]
// for details on the translation.
type KeyboardEvent_KeyCodeType int32

const (
	KeyboardEvent_Usb   KeyboardEvent_KeyCodeType = 0
	KeyboardEvent_Evdev KeyboardEvent_KeyCodeType = 1
	KeyboardEvent_XKB   KeyboardEvent_KeyCodeType = 2
	KeyboardEvent_Win   KeyboardEvent_KeyCodeType = 3
	KeyboardEvent_Mac   KeyboardEvent_KeyCodeType = 4
)

// Enum value maps for KeyboardEvent_KeyCodeType.
var (
	KeyboardEvent_KeyCodeType_name = map[int32]string{
		0: "Usb",
		1: "Evdev",
		2: "XKB",
		3: "Win",
		4: "Mac",
	}
	KeyboardEvent_KeyCodeType_value = map[string]int32{
		"Usb":   0,
		"Evdev": 1,
		"XKB":   2,
		"Win":   3,
		"Mac":   4,
	}
)

func (x KeyboardEvent_KeyCodeType) Enum() *KeyboardEvent_KeyCodeType {
	p := new(KeyboardEvent_KeyCodeType)
	*p = x
	return p
}

func (x KeyboardEvent_KeyCodeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyboardEvent_KeyCodeType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[8].Descriptor()
}

func (KeyboardEvent_KeyCodeType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[8]
}

func (x KeyboardEvent_KeyCodeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyboardEvent_KeyCodeType.Descriptor instead.
func (KeyboardEvent_KeyCodeType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{11, 0}
}

type KeyboardEvent_KeyEventType int32

const (
	// Indicates that this keyevent should be send to the emulator
	// as a key down event. Meaning that the key event will be
	// translated to an EvDev event type and bit 11 (0x400) will be
	// set before it is sent to the emulator.
	KeyboardEvent_keydown KeyboardEvent_KeyEventType = 0
	// Indicates that the keyevent should be send to the emulator
	// as a key up event. Meaning that the key event will be
	// translated to an EvDev event type and
	// sent to the emulator.
	KeyboardEvent_keyup KeyboardEvent_KeyEventType = 1
	// Indicates that the keyevent will be send to the emulator
	// as e key down event and immediately followed by a keyup event.
	KeyboardEvent_keypress KeyboardEvent_KeyEventType = 2
)

// Enum value maps for KeyboardEvent_KeyEventType.
var (
	KeyboardEvent_KeyEventType_name = map[int32]string{
		0: "keydown",
		1: "keyup",
		2: "keypress",
	}
	KeyboardEvent_KeyEventType_value = map[string]int32{
		"keydown":  0,
		"keyup":    1,
		"keypress": 2,
	}
)

func (x KeyboardEvent_KeyEventType) Enum() *KeyboardEvent_KeyEventType {
	p := new(KeyboardEvent_KeyEventType)
	*p = x
	return p
}

func (x KeyboardEvent_KeyEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyboardEvent_KeyEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[9].Descriptor()
}

func (KeyboardEvent_KeyEventType) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[9]
}

func (x KeyboardEvent_KeyEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyboardEvent_KeyEventType.Descriptor instead.
func (KeyboardEvent_KeyEventType) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{11, 1}
}

type BatteryState_BatteryStatus int32

const (
	BatteryState_UNKNOWN      BatteryState_BatteryStatus = 0
	BatteryState_CHARGING     BatteryState_BatteryStatus = 1
	BatteryState_DISCHARGING  BatteryState_BatteryStatus = 2
	BatteryState_NOT_CHARGING BatteryState_BatteryStatus = 3
	BatteryState_FULL         BatteryState_BatteryStatus = 4
)

// Enum value maps for BatteryState_BatteryStatus.
var (
	BatteryState_BatteryStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "CHARGING",
		2: "DISCHARGING",
		3: "NOT_CHARGING",
		4: "FULL",
	}
	BatteryState_BatteryStatus_value = map[string]int32{
		"UNKNOWN":      0,
		"CHARGING":     1,
		"DISCHARGING":  2,
		"NOT_CHARGING": 3,
		"FULL":         4,
	}
)

func (x BatteryState_BatteryStatus) Enum() *BatteryState_BatteryStatus {
	p := new(BatteryState_BatteryStatus)
	*p = x
	return p
}

func (x BatteryState_BatteryStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BatteryState_BatteryStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[10].Descriptor()
}

func (BatteryState_BatteryStatus) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[10]
}

func (x BatteryState_BatteryStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BatteryState_BatteryStatus.Descriptor instead.
func (BatteryState_BatteryStatus) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{14, 0}
}

type BatteryState_BatteryCharger int32

const (
	BatteryState_NONE     BatteryState_BatteryCharger = 0
	BatteryState_AC       BatteryState_BatteryCharger = 1
	BatteryState_USB      BatteryState_BatteryCharger = 2
	BatteryState_WIRELESS BatteryState_BatteryCharger = 3
)

// Enum value maps for BatteryState_BatteryCharger.
var (
	BatteryState_BatteryCharger_name = map[int32]string{
		0: "NONE",
		1: "AC",
		2: "USB",
		3: "WIRELESS",
	}
	BatteryState_BatteryCharger_value = map[string]int32{
		"NONE":     0,
		"AC":       1,
		"USB":      2,
		"WIRELESS": 3,
	}
)

func (x BatteryState_BatteryCharger) Enum() *BatteryState_BatteryCharger {
	p := new(BatteryState_BatteryCharger)
	*p = x
	return p
}

func (x BatteryState_BatteryCharger) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BatteryState_BatteryCharger) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[11].Descriptor()
}

func (BatteryState_BatteryCharger) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[11]
}

func (x BatteryState_BatteryCharger) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BatteryState_BatteryCharger.Descriptor instead.
func (BatteryState_BatteryCharger) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{14, 1}
}

type BatteryState_BatteryHealth int32

const (
	BatteryState_GOOD        BatteryState_BatteryHealth = 0
	BatteryState_FAILED      BatteryState_BatteryHealth = 1
	BatteryState_DEAD        BatteryState_BatteryHealth = 2
	BatteryState_OVERVOLTAGE BatteryState_BatteryHealth = 3
	BatteryState_OVERHEATED  BatteryState_BatteryHealth = 4
)

// Enum value maps for BatteryState_BatteryHealth.
var (
	BatteryState_BatteryHealth_name = map[int32]string{
		0: "GOOD",
		1: "FAILED",
		2: "DEAD",
		3: "OVERVOLTAGE",
		4: "OVERHEATED",
	}
	BatteryState_BatteryHealth_value = map[string]int32{
		"GOOD":        0,
		"FAILED":      1,
		"DEAD":        2,
		"OVERVOLTAGE": 3,
		"OVERHEATED":  4,
	}
)

func (x BatteryState_BatteryHealth) Enum() *BatteryState_BatteryHealth {
	p := new(BatteryState_BatteryHealth)
	*p = x
	return p
}

func (x BatteryState_BatteryHealth) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BatteryState_BatteryHealth) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[12].Descriptor()
}

func (BatteryState_BatteryHealth) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[12]
}

func (x BatteryState_BatteryHealth) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BatteryState_BatteryHealth.Descriptor instead.
func (BatteryState_BatteryHealth) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{14, 2}
}

type ImageTransport_TransportChannel int32

const (
	// Return full frames over the gRPC transport
	ImageTransport_TRANSPORT_CHANNEL_UNSPECIFIED ImageTransport_TransportChannel = 0
	// Write images to the a file/shared memory handle.
	ImageTransport_MMAP ImageTransport_TransportChannel = 1
)

// Enum value maps for ImageTransport_TransportChannel.
var (
	ImageTransport_TransportChannel_name = map[int32]string{
		0: "TRANSPORT_CHANNEL_UNSPECIFIED",
		1: "MMAP",
	}
	ImageTransport_TransportChannel_value = map[string]int32{
		"TRANSPORT_CHANNEL_UNSPECIFIED": 0,
		"MMAP":                          1,
	}
)

func (x ImageTransport_TransportChannel) Enum() *ImageTransport_TransportChannel {
	p := new(ImageTransport_TransportChannel)
	*p = x
	return p
}

func (x ImageTransport_TransportChannel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageTransport_TransportChannel) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[13].Descriptor()
}

func (ImageTransport_TransportChannel) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[13]
}

func (x ImageTransport_TransportChannel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageTransport_TransportChannel.Descriptor instead.
func (ImageTransport_TransportChannel) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{15, 0}
}

type ImageFormat_ImgFormat int32

const (
	// Portable Network Graphics format
	// (https://en.wikipedia.org/wiki/Portable_Network_Graphics)
	ImageFormat_PNG ImageFormat_ImgFormat = 0
	// Three-channel RGB color model supplemented with a fourth alpha
	// channel. https://en.wikipedia.org/wiki/RGBA_color_model
	// Each pixel consists of 4 bytes.
	ImageFormat_RGBA8888 ImageFormat_ImgFormat = 1
	// Three-channel RGB color model, each pixel consists of 3 bytes
	ImageFormat_RGB888 ImageFormat_ImgFormat = 2
)

// Enum value maps for ImageFormat_ImgFormat.
var (
	ImageFormat_ImgFormat_name = map[int32]string{
		0: "PNG",
		1: "RGBA8888",
		2: "RGB888",
	}
	ImageFormat_ImgFormat_value = map[string]int32{
		"PNG":      0,
		"RGBA8888": 1,
		"RGB888":   2,
	}
)

func (x ImageFormat_ImgFormat) Enum() *ImageFormat_ImgFormat {
	p := new(ImageFormat_ImgFormat)
	*p = x
	return p
}

func (x ImageFormat_ImgFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageFormat_ImgFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[14].Descriptor()
}

func (ImageFormat_ImgFormat) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[14]
}

func (x ImageFormat_ImgFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageFormat_ImgFormat.Descriptor instead.
func (ImageFormat_ImgFormat) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{16, 0}
}

type Rotation_SkinRotation int32

const (
	Rotation_PORTRAIT          Rotation_SkinRotation = 0 // 0 degrees
	Rotation_LANDSCAPE         Rotation_SkinRotation = 1 // 90 degrees
	Rotation_REVERSE_PORTRAIT  Rotation_SkinRotation = 2 // -180 degrees
	Rotation_REVERSE_LANDSCAPE Rotation_SkinRotation = 3 // -90 degrees
)

// Enum value maps for Rotation_SkinRotation.
var (
	Rotation_SkinRotation_name = map[int32]string{
		0: "PORTRAIT",
		1: "LANDSCAPE",
		2: "REVERSE_PORTRAIT",
		3: "REVERSE_LANDSCAPE",
	}
	Rotation_SkinRotation_value = map[string]int32{
		"PORTRAIT":          0,
		"LANDSCAPE":         1,
		"REVERSE_PORTRAIT":  2,
		"REVERSE_LANDSCAPE": 3,
	}
)

func (x Rotation_SkinRotation) Enum() *Rotation_SkinRotation {
	p := new(Rotation_SkinRotation)
	*p = x
	return p
}

func (x Rotation_SkinRotation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Rotation_SkinRotation) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[15].Descriptor()
}

func (Rotation_SkinRotation) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[15]
}

func (x Rotation_SkinRotation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Rotation_SkinRotation.Descriptor instead.
func (Rotation_SkinRotation) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{18, 0}
}

type PhoneCall_Operation int32

const (
	PhoneCall_InitCall           PhoneCall_Operation = 0
	PhoneCall_AcceptCall         PhoneCall_Operation = 1
	PhoneCall_RejectCallExplicit PhoneCall_Operation = 2
	PhoneCall_RejectCallBusy     PhoneCall_Operation = 3
	PhoneCall_DisconnectCall     PhoneCall_Operation = 4
	PhoneCall_PlaceCallOnHold    PhoneCall_Operation = 5
	PhoneCall_TakeCallOffHold    PhoneCall_Operation = 6
)

// Enum value maps for PhoneCall_Operation.
var (
	PhoneCall_Operation_name = map[int32]string{
		0: "InitCall",
		1: "AcceptCall",
		2: "RejectCallExplicit",
		3: "RejectCallBusy",
		4: "DisconnectCall",
		5: "PlaceCallOnHold",
		6: "TakeCallOffHold",
	}
	PhoneCall_Operation_value = map[string]int32{
		"InitCall":           0,
		"AcceptCall":         1,
		"RejectCallExplicit": 2,
		"RejectCallBusy":     3,
		"DisconnectCall":     4,
		"PlaceCallOnHold":    5,
		"TakeCallOffHold":    6,
	}
)

func (x PhoneCall_Operation) Enum() *PhoneCall_Operation {
	p := new(PhoneCall_Operation)
	*p = x
	return p
}

func (x PhoneCall_Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PhoneCall_Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[16].Descriptor()
}

func (PhoneCall_Operation) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[16]
}

func (x PhoneCall_Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PhoneCall_Operation.Descriptor instead.
func (PhoneCall_Operation) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{19, 0}
}

type PhoneResponse_Response int32

const (
	PhoneResponse_OK            PhoneResponse_Response = 0
	PhoneResponse_BadOperation  PhoneResponse_Response = 1 // Enum out of range
	PhoneResponse_BadNumber     PhoneResponse_Response = 2 // Mal-formed telephone number
	PhoneResponse_InvalidAction PhoneResponse_Response = 3 // E.g., disconnect when no call is in progress
	PhoneResponse_ActionFailed  PhoneResponse_Response = 4 // Internal error
	PhoneResponse_RadioOff      PhoneResponse_Response = 5 // Radio power off
)

// Enum value maps for PhoneResponse_Response.
var (
	PhoneResponse_Response_name = map[int32]string{
		0: "OK",
		1: "BadOperation",
		2: "BadNumber",
		3: "InvalidAction",
		4: "ActionFailed",
		5: "RadioOff",
	}
	PhoneResponse_Response_value = map[string]int32{
		"OK":            0,
		"BadOperation":  1,
		"BadNumber":     2,
		"InvalidAction": 3,
		"ActionFailed":  4,
		"RadioOff":      5,
	}
)

func (x PhoneResponse_Response) Enum() *PhoneResponse_Response {
	p := new(PhoneResponse_Response)
	*p = x
	return p
}

func (x PhoneResponse_Response) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PhoneResponse_Response) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[17].Descriptor()
}

func (PhoneResponse_Response) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[17]
}

func (x PhoneResponse_Response) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PhoneResponse_Response.Descriptor instead.
func (PhoneResponse_Response) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{20, 0}
}

type AudioFormat_SampleFormat int32

const (
	AudioFormat_AUD_FMT_U8  AudioFormat_SampleFormat = 0 // Unsigned 8 bit
	AudioFormat_AUD_FMT_S16 AudioFormat_SampleFormat = 1 // Signed 16 bit (little endian)
)

// Enum value maps for AudioFormat_SampleFormat.
var (
	AudioFormat_SampleFormat_name = map[int32]string{
		0: "AUD_FMT_U8",
		1: "AUD_FMT_S16",
	}
	AudioFormat_SampleFormat_value = map[string]int32{
		"AUD_FMT_U8":  0,
		"AUD_FMT_S16": 1,
	}
)

func (x AudioFormat_SampleFormat) Enum() *AudioFormat_SampleFormat {
	p := new(AudioFormat_SampleFormat)
	*p = x
	return p
}

func (x AudioFormat_SampleFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AudioFormat_SampleFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[18].Descriptor()
}

func (AudioFormat_SampleFormat) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[18]
}

func (x AudioFormat_SampleFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AudioFormat_SampleFormat.Descriptor instead.
func (AudioFormat_SampleFormat) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{24, 0}
}

type AudioFormat_Channels int32

const (
	AudioFormat_Mono   AudioFormat_Channels = 0
	AudioFormat_Stereo AudioFormat_Channels = 1
)

// Enum value maps for AudioFormat_Channels.
var (
	AudioFormat_Channels_name = map[int32]string{
		0: "Mono",
		1: "Stereo",
	}
	AudioFormat_Channels_value = map[string]int32{
		"Mono":   0,
		"Stereo": 1,
	}
)

func (x AudioFormat_Channels) Enum() *AudioFormat_Channels {
	p := new(AudioFormat_Channels)
	*p = x
	return p
}

func (x AudioFormat_Channels) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AudioFormat_Channels) Descriptor() protoreflect.EnumDescriptor {
	return file_emulator_controller_proto_enumTypes[19].Descriptor()
}

func (AudioFormat_Channels) Type() protoreflect.EnumType {
	return &file_emulator_controller_proto_enumTypes[19]
}

func (x AudioFormat_Channels) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AudioFormat_Channels.Descriptor instead.
func (AudioFormat_Channels) EnumDescriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{24, 1}
}

// A Run State that describes the state of the Virtual Machine.
type VmRunState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	State VmRunState_RunState `protobuf:"varint,1,opt,name=state,proto3,enum=android.emulation.control.VmRunState_RunState" json:"state,omitempty"`
}

func (x *VmRunState) Reset() {
	*x = VmRunState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VmRunState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VmRunState) ProtoMessage() {}

func (x *VmRunState) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VmRunState.ProtoReflect.Descriptor instead.
func (*VmRunState) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{0}
}

func (x *VmRunState) GetState() VmRunState_RunState {
	if x != nil {
		return x.State
	}
	return VmRunState_UNKNOWN
}

type ParameterValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data []float32 `protobuf:"fixed32,1,rep,packed,name=data,proto3" json:"data,omitempty"`
}

func (x *ParameterValue) Reset() {
	*x = ParameterValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ParameterValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParameterValue) ProtoMessage() {}

func (x *ParameterValue) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParameterValue.ProtoReflect.Descriptor instead.
func (*ParameterValue) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{1}
}

func (x *ParameterValue) GetData() []float32 {
	if x != nil {
		return x.Data
	}
	return nil
}

type PhysicalModelValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Target PhysicalModelValue_PhysicalType `protobuf:"varint,1,opt,name=target,proto3,enum=android.emulation.control.PhysicalModelValue_PhysicalType" json:"target,omitempty"`
	// [Output Only]
	Status PhysicalModelValue_State `protobuf:"varint,2,opt,name=status,proto3,enum=android.emulation.control.PhysicalModelValue_State" json:"status,omitempty"`
	// Value interpretation depends on sensor, will contain at most 3 values.
	Value *ParameterValue `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *PhysicalModelValue) Reset() {
	*x = PhysicalModelValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhysicalModelValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhysicalModelValue) ProtoMessage() {}

func (x *PhysicalModelValue) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhysicalModelValue.ProtoReflect.Descriptor instead.
func (*PhysicalModelValue) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{2}
}

func (x *PhysicalModelValue) GetTarget() PhysicalModelValue_PhysicalType {
	if x != nil {
		return x.Target
	}
	return PhysicalModelValue_POSITION
}

func (x *PhysicalModelValue) GetStatus() PhysicalModelValue_State {
	if x != nil {
		return x.Status
	}
	return PhysicalModelValue_OK
}

func (x *PhysicalModelValue) GetValue() *ParameterValue {
	if x != nil {
		return x.Value
	}
	return nil
}

// A single sensor value.
type SensorValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Type of sensor
	Target SensorValue_SensorType `protobuf:"varint,1,opt,name=target,proto3,enum=android.emulation.control.SensorValue_SensorType" json:"target,omitempty"`
	// [Output Only]
	Status SensorValue_State `protobuf:"varint,2,opt,name=status,proto3,enum=android.emulation.control.SensorValue_State" json:"status,omitempty"`
	// Value interpretation depends on sensor enum, will contain at most 3
	// values.
	Value *ParameterValue `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *SensorValue) Reset() {
	*x = SensorValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SensorValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SensorValue) ProtoMessage() {}

func (x *SensorValue) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SensorValue.ProtoReflect.Descriptor instead.
func (*SensorValue) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{3}
}

func (x *SensorValue) GetTarget() SensorValue_SensorType {
	if x != nil {
		return x.Target
	}
	return SensorValue_ACCELERATION
}

func (x *SensorValue) GetStatus() SensorValue_State {
	if x != nil {
		return x.Status
	}
	return SensorValue_OK
}

func (x *SensorValue) GetValue() *ParameterValue {
	if x != nil {
		return x.Value
	}
	return nil
}

type LogMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// [Output Only] The contents of the log output.
	Contents string `protobuf:"bytes,1,opt,name=contents,proto3" json:"contents,omitempty"`
	// The starting byte position of the output that was returned. This
	// should match the start parameter sent with the request. If the serial
	// console output exceeds the size of the buffer, older output will be
	// overwritten by newer content and the start values will be mismatched.
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	//[Output Only] The position of the next byte of content from the serial
	// console output. Use this value in the next request as the start
	// parameter.
	Next int64 `protobuf:"varint,3,opt,name=next,proto3" json:"next,omitempty"`
	// Set the sort of response you are interested it in.
	// It the type is "Parsed" the entries field will contain the parsed
	// results. otherwise the contents field will be set.
	Sort LogMessage_LogType `protobuf:"varint,4,opt,name=sort,proto3,enum=android.emulation.control.LogMessage_LogType" json:"sort,omitempty"`
	// [Output Only] The parsed logcat entries so far. Only set if sort is
	// set to Parsed
	Entries []*LogcatEntry `protobuf:"bytes,5,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (x *LogMessage) Reset() {
	*x = LogMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogMessage) ProtoMessage() {}

func (x *LogMessage) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogMessage.ProtoReflect.Descriptor instead.
func (*LogMessage) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{4}
}

func (x *LogMessage) GetContents() string {
	if x != nil {
		return x.Contents
	}
	return ""
}

func (x *LogMessage) GetStart() int64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *LogMessage) GetNext() int64 {
	if x != nil {
		return x.Next
	}
	return 0
}

func (x *LogMessage) GetSort() LogMessage_LogType {
	if x != nil {
		return x.Sort
	}
	return LogMessage_Text
}

func (x *LogMessage) GetEntries() []*LogcatEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// A parsed logcat entry.
type LogcatEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A Unix timestamps in  milliseconds (The number of milliseconds that
	// have elapsed since January 1, 1970 (midnight UTC/GMT), not counting
	// leap seconds)
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Process id.
	Pid uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// Thread id.
	Tid   uint32               `protobuf:"varint,3,opt,name=tid,proto3" json:"tid,omitempty"`
	Level LogcatEntry_LogLevel `protobuf:"varint,4,opt,name=level,proto3,enum=android.emulation.control.LogcatEntry_LogLevel" json:"level,omitempty"`
	Tag   string               `protobuf:"bytes,5,opt,name=tag,proto3" json:"tag,omitempty"`
	Msg   string               `protobuf:"bytes,6,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (x *LogcatEntry) Reset() {
	*x = LogcatEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogcatEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogcatEntry) ProtoMessage() {}

func (x *LogcatEntry) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogcatEntry.ProtoReflect.Descriptor instead.
func (*LogcatEntry) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{5}
}

func (x *LogcatEntry) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *LogcatEntry) GetPid() uint32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *LogcatEntry) GetTid() uint32 {
	if x != nil {
		return x.Tid
	}
	return 0
}

func (x *LogcatEntry) GetLevel() LogcatEntry_LogLevel {
	if x != nil {
		return x.Level
	}
	return LogcatEntry_UNKNOWN
}

func (x *LogcatEntry) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *LogcatEntry) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// Information about the hypervisor that is currently in use.
type VmConfiguration struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	HypervisorType   VmConfiguration_VmHypervisorType `protobuf:"varint,1,opt,name=hypervisorType,proto3,enum=android.emulation.control.VmConfiguration_VmHypervisorType" json:"hypervisorType,omitempty"`
	NumberOfCpuCores int32                            `protobuf:"varint,2,opt,name=numberOfCpuCores,proto3" json:"numberOfCpuCores,omitempty"`
	RamSizeBytes     int64                            `protobuf:"varint,3,opt,name=ramSizeBytes,proto3" json:"ramSizeBytes,omitempty"`
}

func (x *VmConfiguration) Reset() {
	*x = VmConfiguration{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VmConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VmConfiguration) ProtoMessage() {}

func (x *VmConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VmConfiguration.ProtoReflect.Descriptor instead.
func (*VmConfiguration) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{6}
}

func (x *VmConfiguration) GetHypervisorType() VmConfiguration_VmHypervisorType {
	if x != nil {
		return x.HypervisorType
	}
	return VmConfiguration_UNKNOWN
}

func (x *VmConfiguration) GetNumberOfCpuCores() int32 {
	if x != nil {
		return x.NumberOfCpuCores
	}
	return 0
}

func (x *VmConfiguration) GetRamSizeBytes() int64 {
	if x != nil {
		return x.RamSizeBytes
	}
	return 0
}

// Representation of a clipped data object on the clipboard.
type ClipData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// UTF-8 Encoded text.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *ClipData) Reset() {
	*x = ClipData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ClipData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipData) ProtoMessage() {}

func (x *ClipData) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipData.ProtoReflect.Descriptor instead.
func (*ClipData) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{7}
}

func (x *ClipData) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

// The Touch interface represents a single contact point on a
// touch-sensitive device. The contact point is commonly a finger or stylus
// and the device may be a touchscreen or trackpad.
type Touch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The horizontal coordinate. This is the physical location on the
	// screen For example 0 indicates the leftmost coordinate.
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// The vertical coordinate. This is the physical location on the screen
	// For example 0 indicates the top left coordinate.
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// The identifier is an arbitrary non-negative integer that is used to
	// identify and track each tool independently when multiple tools are
	// active. For example, when multiple fingers are touching the device,
	// each finger should be assigned a distinct tracking id that is used as
	// long as the finger remains in contact. Tracking ids may be reused
	// when their associated tools move out of range.
	//
	// The emulator currently supports up to 10 concurrent touch events. The
	// identifier should be a value from the set [0, 10]
	Identifier int32 `protobuf:"varint,3,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Reports the physical pressure applied to the tip of the tool or the
	// signal strength of the touch contact.
	//
	// The values reported must be non-zero when the tool is touching the
	// device and zero otherwise to indicate that the touch event is
	// completed.
	//
	// Make sure to deliver a pressure of 0 for the given identifier when
	// the touch event is completed, otherwise the touch identifier will not
	// be unregistered!
	Pressure int32 `protobuf:"varint,4,opt,name=pressure,proto3" json:"pressure,omitempty"`
	// Optionally reports the cross-sectional area of the touch contact, or
	// the length of the longer dimension of the touch contact.
	TouchMajor int32 `protobuf:"varint,5,opt,name=touch_major,json=touchMajor,proto3" json:"touch_major,omitempty"`
	// Optionally reports the length of the shorter dimension of the touch
	// contact. This axis will be ignored if touch_major is reporting an
	// area measurement greater than 0.
	TouchMinor int32 `protobuf:"varint,6,opt,name=touch_minor,json=touchMinor,proto3" json:"touch_minor,omitempty"`
}

func (x *Touch) Reset() {
	*x = Touch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Touch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Touch) ProtoMessage() {}

func (x *Touch) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Touch.ProtoReflect.Descriptor instead.
func (*Touch) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{8}
}

func (x *Touch) GetX() int32 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *Touch) GetY() int32 {
	if x != nil {
		return x.Y
	}
	return 0
}

func (x *Touch) GetIdentifier() int32 {
	if x != nil {
		return x.Identifier
	}
	return 0
}

func (x *Touch) GetPressure() int32 {
	if x != nil {
		return x.Pressure
	}
	return 0
}

func (x *Touch) GetTouchMajor() int32 {
	if x != nil {
		return x.TouchMajor
	}
	return 0
}

func (x *Touch) GetTouchMinor() int32 {
	if x != nil {
		return x.TouchMinor
	}
	return 0
}

// A TouchEvent contains a list of Touch objects that are in contact with
// the touch surface.
//
// Touch events are delivered in sequence as specified in the touchList.
//
// TouchEvents are delivered to the emulated devices using ["Protocol
// B"](https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt)
type TouchEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of Touch objects, note that these do not need to be unique
	Touches []*Touch `protobuf:"bytes,1,rep,name=touches,proto3" json:"touches,omitempty"`
	// The display device where the touch event occurred.
	// Omitting or using the value 0 indicates the main display.
	//
	// Touch events cannot be send to devices other than 0, due to
	// https://issuetracker.google.com/issues/150699691
	Device int32 `protobuf:"varint,2,opt,name=device,proto3" json:"device,omitempty"`
}

func (x *TouchEvent) Reset() {
	*x = TouchEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TouchEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TouchEvent) ProtoMessage() {}

func (x *TouchEvent) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TouchEvent.ProtoReflect.Descriptor instead.
func (*TouchEvent) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{9}
}

func (x *TouchEvent) GetTouches() []*Touch {
	if x != nil {
		return x.Touches
	}
	return nil
}

func (x *TouchEvent) GetDevice() int32 {
	if x != nil {
		return x.Device
	}
	return 0
}

// The MouseEvent interface represents events that occur due to the user
// interacting with a pointing device (such as a mouse).
type MouseEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The horizontal coordinate. This is the physical location on the
	// screen For example 0 indicates the leftmost coordinate.
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// The vertical coordinate. This is the physical location on the screen
	// For example 0 indicates the top left coordinate.
	Y int32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// Indicates which buttons are pressed.
	// 0: No button was pressed
	// 1: Primary button (left)
	// 2: Secondary button (right)
	Buttons int32 `protobuf:"varint,3,opt,name=buttons,proto3" json:"buttons,omitempty"`
	// The display device where the mouse event occurred.
	// Omitting or using the value 0 indicates the main display.
	Device int32 `protobuf:"varint,4,opt,name=device,proto3" json:"device,omitempty"`
}

func (x *MouseEvent) Reset() {
	*x = MouseEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MouseEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MouseEvent) ProtoMessage() {}

func (x *MouseEvent) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MouseEvent.ProtoReflect.Descriptor instead.
func (*MouseEvent) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{10}
}

func (x *MouseEvent) GetX() int32 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *MouseEvent) GetY() int32 {
	if x != nil {
		return x.Y
	}
	return 0
}

func (x *MouseEvent) GetButtons() int32 {
	if x != nil {
		return x.Buttons
	}
	return 0
}

func (x *MouseEvent) GetDevice() int32 {
	if x != nil {
		return x.Device
	}
	return 0
}

// KeyboardEvent objects describe a user interaction with the keyboard; each
// event describes a single interaction between the user and a key (or
// combination of a key with modifier keys) on the keyboard.
// This follows the pattern as set by
// (javascript)[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent]
//
// Note: that only keyCode, key, or text can be set and that the semantics
// will slightly vary.
type KeyboardEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Type of keycode contained in the keyCode field.
	CodeType KeyboardEvent_KeyCodeType `protobuf:"varint,1,opt,name=codeType,proto3,enum=android.emulation.control.KeyboardEvent_KeyCodeType" json:"codeType,omitempty"`
	// The type of keyboard event that should be sent to the emulator
	EventType KeyboardEvent_KeyEventType `protobuf:"varint,2,opt,name=eventType,proto3,enum=android.emulation.control.KeyboardEvent_KeyEventType" json:"eventType,omitempty"`
	// This property represents a physical key on the keyboard (as opposed
	// to the character generated by pressing the key). In other words, this
	// property is a value which isn't altered by keyboard layout or the
	// state of the modifier keys. This value will be interpreted by the
	// emulator depending on the KeyCodeType. The incoming key code will be
	// translated to an evdev code type and send to the emulator.
	// The values in key and text will be ignored.
	KeyCode int32 `protobuf:"varint,3,opt,name=keyCode,proto3" json:"keyCode,omitempty"`
	// The value of the key pressed by the user, taking into consideration
	// the state of modifier keys such as Shift as well as the keyboard
	// locale and layout. This follows the w3c standard used in browsers.
	// You can find an accurate description of valid values
	// [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
	//
	// Note that some keys can result in multiple evdev events that are
	// delivered to the emulator. for example the Key "A" will result in a
	// sequence:
	// ["Shift", "a"] -> [0x2a, 0x1e] whereas "a" results in ["a"] -> [0x1e].
	//
	// Not all documented keys are understood by android, and only printable
	// ASCII [32-127) characters are properly translated.
	//
	// Keep in mind that there are a set of key values that result in android
	// specific behavior
	// [see](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#Phone_keys):
	//
	// - "AppSwitch": Behaves as the "Overview" button in android.
	// - "GoBack": The Back button.
	// - "GoHome": The Home button, which takes the user to the phone's main
	//             screen (usually an application launcher).
	// - "Power":  The Power button.
	Key string `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	// Series of utf8 encoded characters to send to the emulator. An attempt
	// will be made to translate every character will an EvDev event type and
	// send to the emulator as a keypress event. The values in keyCode,
	// eventType, codeType and key will be ignored.
	//
	// Note that most printable ASCII characters (range [32-127) can be send
	// individually with the "key" param. Do not expect arbitrary UTF symbols to
	// arrive in the emulator (most will be ignored).
	Text string `protobuf:"bytes,5,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *KeyboardEvent) Reset() {
	*x = KeyboardEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KeyboardEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyboardEvent) ProtoMessage() {}

func (x *KeyboardEvent) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyboardEvent.ProtoReflect.Descriptor instead.
func (*KeyboardEvent) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{11}
}

func (x *KeyboardEvent) GetCodeType() KeyboardEvent_KeyCodeType {
	if x != nil {
		return x.CodeType
	}
	return KeyboardEvent_Usb
}

func (x *KeyboardEvent) GetEventType() KeyboardEvent_KeyEventType {
	if x != nil {
		return x.EventType
	}
	return KeyboardEvent_keydown
}

func (x *KeyboardEvent) GetKeyCode() int32 {
	if x != nil {
		return x.KeyCode
	}
	return 0
}

func (x *KeyboardEvent) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyboardEvent) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

type Fingerprint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// True when the fingprint is touched.
	IsTouching bool `protobuf:"varint,1,opt,name=isTouching,proto3" json:"isTouching,omitempty"`
	// The identifier of the registered fingerprint.
	TouchId int32 `protobuf:"varint,2,opt,name=touchId,proto3" json:"touchId,omitempty"`
}

func (x *Fingerprint) Reset() {
	*x = Fingerprint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Fingerprint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Fingerprint) ProtoMessage() {}

func (x *Fingerprint) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Fingerprint.ProtoReflect.Descriptor instead.
func (*Fingerprint) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{12}
}

func (x *Fingerprint) GetIsTouching() bool {
	if x != nil {
		return x.IsTouching
	}
	return false
}

func (x *Fingerprint) GetTouchId() int32 {
	if x != nil {
		return x.TouchId
	}
	return 0
}

type GpsState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Setting this to false will disable auto updating  from the LocationUI,
	// otherwise the location UI will override the location at a frequency of 1hz.
	//
	// - This is unused if the emulator is launched with -no-window, or when he
	//   location ui is disabled.
	// - This will BREAK the location ui experience if it is set to false. For
	//    example routing will no longer function.
	PassiveUpdate bool `protobuf:"varint,1,opt,name=passiveUpdate,proto3" json:"passiveUpdate,omitempty"`
	// The latitude, in degrees.
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// The longitude, in degrees.
	Longitude float64 `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// The speed if it is available, in meters/second over ground
	Speed float64 `protobuf:"fixed64,4,opt,name=speed,proto3" json:"speed,omitempty"`
	// gets the horizontal direction of travel of this device, and is not
	// related to the device orientation. It is guaranteed to be in the
	// range [0.0, 360.0] if the device has a bearing. 0=North, 90=East,
	// 180=South, etc..
	Bearing float64 `protobuf:"fixed64,5,opt,name=bearing,proto3" json:"bearing,omitempty"`
	// The altitude if available, in meters above the WGS 84 reference
	// ellipsoid.
	Altitude float64 `protobuf:"fixed64,6,opt,name=altitude,proto3" json:"altitude,omitempty"`
	// The number of satellites used to derive the fix
	Satellites int32 `protobuf:"varint,7,opt,name=satellites,proto3" json:"satellites,omitempty"`
}

func (x *GpsState) Reset() {
	*x = GpsState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GpsState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GpsState) ProtoMessage() {}

func (x *GpsState) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GpsState.ProtoReflect.Descriptor instead.
func (*GpsState) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{13}
}

func (x *GpsState) GetPassiveUpdate() bool {
	if x != nil {
		return x.PassiveUpdate
	}
	return false
}

func (x *GpsState) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *GpsState) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *GpsState) GetSpeed() float64 {
	if x != nil {
		return x.Speed
	}
	return 0
}

func (x *GpsState) GetBearing() float64 {
	if x != nil {
		return x.Bearing
	}
	return 0
}

func (x *GpsState) GetAltitude() float64 {
	if x != nil {
		return x.Altitude
	}
	return 0
}

func (x *GpsState) GetSatellites() int32 {
	if x != nil {
		return x.Satellites
	}
	return 0
}

type BatteryState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	HasBattery  bool                        `protobuf:"varint,1,opt,name=hasBattery,proto3" json:"hasBattery,omitempty"`
	IsPresent   bool                        `protobuf:"varint,2,opt,name=isPresent,proto3" json:"isPresent,omitempty"`
	Charger     BatteryState_BatteryCharger `protobuf:"varint,3,opt,name=charger,proto3,enum=android.emulation.control.BatteryState_BatteryCharger" json:"charger,omitempty"`
	ChargeLevel int32                       `protobuf:"varint,4,opt,name=chargeLevel,proto3" json:"chargeLevel,omitempty"`
	Health      BatteryState_BatteryHealth  `protobuf:"varint,5,opt,name=health,proto3,enum=android.emulation.control.BatteryState_BatteryHealth" json:"health,omitempty"`
	Status      BatteryState_BatteryStatus  `protobuf:"varint,6,opt,name=status,proto3,enum=android.emulation.control.BatteryState_BatteryStatus" json:"status,omitempty"`
}

func (x *BatteryState) Reset() {
	*x = BatteryState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatteryState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatteryState) ProtoMessage() {}

func (x *BatteryState) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatteryState.ProtoReflect.Descriptor instead.
func (*BatteryState) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{14}
}

func (x *BatteryState) GetHasBattery() bool {
	if x != nil {
		return x.HasBattery
	}
	return false
}

func (x *BatteryState) GetIsPresent() bool {
	if x != nil {
		return x.IsPresent
	}
	return false
}

func (x *BatteryState) GetCharger() BatteryState_BatteryCharger {
	if x != nil {
		return x.Charger
	}
	return BatteryState_NONE
}

func (x *BatteryState) GetChargeLevel() int32 {
	if x != nil {
		return x.ChargeLevel
	}
	return 0
}

func (x *BatteryState) GetHealth() BatteryState_BatteryHealth {
	if x != nil {
		return x.Health
	}
	return BatteryState_GOOD
}

func (x *BatteryState) GetStatus() BatteryState_BatteryStatus {
	if x != nil {
		return x.Status
	}
	return BatteryState_UNKNOWN
}

// An ImageTransport allows for specifying a side channel for
// delivering image frames versus using the standard bytes array that is
// returned with the gRPC request.
type ImageTransport struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The desired transport channel used for delivering image frames. Only
	// relevant when streaming screenshots.
	Channel ImageTransport_TransportChannel `protobuf:"varint,1,opt,name=channel,proto3,enum=android.emulation.control.ImageTransport_TransportChannel" json:"channel,omitempty"`
	// Handle used for writing image frames if transport is mmap. The client sets
	// and owns this handle. It can be either a shm region, or a mmap. A mmap
	// should be a url that starts with `file:///`
	// Note: the mmap can result in tearing.
	Handle string `protobuf:"bytes,2,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (x *ImageTransport) Reset() {
	*x = ImageTransport{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageTransport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageTransport) ProtoMessage() {}

func (x *ImageTransport) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageTransport.ProtoReflect.Descriptor instead.
func (*ImageTransport) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{15}
}

func (x *ImageTransport) GetChannel() ImageTransport_TransportChannel {
	if x != nil {
		return x.Channel
	}
	return ImageTransport_TRANSPORT_CHANNEL_UNSPECIFIED
}

func (x *ImageTransport) GetHandle() string {
	if x != nil {
		return x.Handle
	}
	return ""
}

type ImageFormat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The (desired) format of the resulting bytes.
	Format ImageFormat_ImgFormat `protobuf:"varint,1,opt,name=format,proto3,enum=android.emulation.control.ImageFormat_ImgFormat" json:"format,omitempty"`
	// [Output Only] The rotation of the image. The image will be rotated
	// based upon the coarse grained orientation of the device.
	Rotation *Rotation `protobuf:"bytes,2,opt,name=rotation,proto3" json:"rotation,omitempty"`
	// The (desired) width of the image. When passed as input
	// the image will be scaled to match the given
	// width, while maintaining the aspect ratio of the device.
	// The returned image will never exceed the given width, but can be less.
	// Omitting this value (or passing in 0) will result in no scaling,
	// and the width of the actual device will be used.
	Width uint32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// The (desired) height of the image.  When passed as input
	// the image will be scaled to match the given
	// height, while maintaining the aspect ratio of the device.
	// The returned image will never exceed the given height, but can be less.
	// Omitting this value (or passing in 0) will result in no scaling,
	// and the height of the actual device will be used.
	Height uint32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	// The (desired) display id of the device. Setting this to 0 (or omitting)
	// indicates the main display.
	Display uint32 `protobuf:"varint,5,opt,name=display,proto3" json:"display,omitempty"`
	// Set this if you wish to use a different transport channel to deliver image
	// frames.
	Transport *ImageTransport `protobuf:"bytes,6,opt,name=transport,proto3" json:"transport,omitempty"`
}

func (x *ImageFormat) Reset() {
	*x = ImageFormat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageFormat) ProtoMessage() {}

func (x *ImageFormat) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageFormat.ProtoReflect.Descriptor instead.
func (*ImageFormat) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{16}
}

func (x *ImageFormat) GetFormat() ImageFormat_ImgFormat {
	if x != nil {
		return x.Format
	}
	return ImageFormat_PNG
}

func (x *ImageFormat) GetRotation() *Rotation {
	if x != nil {
		return x.Rotation
	}
	return nil
}

func (x *ImageFormat) GetWidth() uint32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *ImageFormat) GetHeight() uint32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *ImageFormat) GetDisplay() uint32 {
	if x != nil {
		return x.Display
	}
	return 0
}

func (x *ImageFormat) GetTransport() *ImageTransport {
	if x != nil {
		return x.Transport
	}
	return nil
}

type Image struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Format *ImageFormat `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	// Deprecated: Do not use.
	Width uint32 `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"` // width is contained in format.
	// Deprecated: Do not use.
	Height uint32 `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"` // height is contained in format.
	// The organization of the pixels in the image buffer is from left to
	// right and bottom up. This will be empty if an alternative image transport
	// is requested in the image format. In that case the side channel should
	// be used to obtain the image data.
	Image []byte `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	// [Output Only] Monotonically increasing sequence number in a stream of
	// screenshots. The first screenshot will have a sequence of 0. A single
	// screenshot will always have a sequence number of 0. The sequence is not
	// necessarily contiguous, and can be used to detect how many frames were
	// dropped. An example sequence could be: [0, 3, 5, 7, 9, 11].
	Seq uint32 `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (x *Image) Reset() {
	*x = Image{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Image) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Image) ProtoMessage() {}

func (x *Image) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Image.ProtoReflect.Descriptor instead.
func (*Image) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{17}
}

func (x *Image) GetFormat() *ImageFormat {
	if x != nil {
		return x.Format
	}
	return nil
}

// Deprecated: Do not use.
func (x *Image) GetWidth() uint32 {
	if x != nil {
		return x.Width
	}
	return 0
}

// Deprecated: Do not use.
func (x *Image) GetHeight() uint32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *Image) GetImage() []byte {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *Image) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

type Rotation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Rotation Rotation_SkinRotation `protobuf:"varint,1,opt,name=rotation,proto3,enum=android.emulation.control.Rotation_SkinRotation" json:"rotation,omitempty"` // Can be inferred from z-axis as well.
	// Specifies the angle of rotation, in degrees [-180, 180]
	XAxis float64 `protobuf:"fixed64,2,opt,name=xAxis,proto3" json:"xAxis,omitempty"`
	YAxis float64 `protobuf:"fixed64,3,opt,name=yAxis,proto3" json:"yAxis,omitempty"`
	ZAxis float64 `protobuf:"fixed64,4,opt,name=zAxis,proto3" json:"zAxis,omitempty"`
}

func (x *Rotation) Reset() {
	*x = Rotation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rotation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rotation) ProtoMessage() {}

func (x *Rotation) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rotation.ProtoReflect.Descriptor instead.
func (*Rotation) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{18}
}

func (x *Rotation) GetRotation() Rotation_SkinRotation {
	if x != nil {
		return x.Rotation
	}
	return Rotation_PORTRAIT
}

func (x *Rotation) GetXAxis() float64 {
	if x != nil {
		return x.XAxis
	}
	return 0
}

func (x *Rotation) GetYAxis() float64 {
	if x != nil {
		return x.YAxis
	}
	return 0
}

func (x *Rotation) GetZAxis() float64 {
	if x != nil {
		return x.ZAxis
	}
	return 0
}

type PhoneCall struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Operation PhoneCall_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=android.emulation.control.PhoneCall_Operation" json:"operation,omitempty"`
	Number    string              `protobuf:"bytes,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (x *PhoneCall) Reset() {
	*x = PhoneCall{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhoneCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneCall) ProtoMessage() {}

func (x *PhoneCall) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneCall.ProtoReflect.Descriptor instead.
func (*PhoneCall) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{19}
}

func (x *PhoneCall) GetOperation() PhoneCall_Operation {
	if x != nil {
		return x.Operation
	}
	return PhoneCall_InitCall
}

func (x *PhoneCall) GetNumber() string {
	if x != nil {
		return x.Number
	}
	return ""
}

type PhoneResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Response PhoneResponse_Response `protobuf:"varint,1,opt,name=response,proto3,enum=android.emulation.control.PhoneResponse_Response" json:"response,omitempty"`
}

func (x *PhoneResponse) Reset() {
	*x = PhoneResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PhoneResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneResponse) ProtoMessage() {}

func (x *PhoneResponse) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneResponse.ProtoReflect.Descriptor instead.
func (*PhoneResponse) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{20}
}

func (x *PhoneResponse) GetResponse() PhoneResponse_Response {
	if x != nil {
		return x.Response
	}
	return PhoneResponse_OK
}

type Entry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Entry) Reset() {
	*x = Entry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Entry) ProtoMessage() {}

func (x *Entry) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Entry.ProtoReflect.Descriptor instead.
func (*Entry) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{21}
}

func (x *Entry) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Entry) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type EntryList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Entry []*Entry `protobuf:"bytes,1,rep,name=entry,proto3" json:"entry,omitempty"`
}

func (x *EntryList) Reset() {
	*x = EntryList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EntryList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EntryList) ProtoMessage() {}

func (x *EntryList) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EntryList.ProtoReflect.Descriptor instead.
func (*EntryList) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{22}
}

func (x *EntryList) GetEntry() []*Entry {
	if x != nil {
		return x.Entry
	}
	return nil
}

type EmulatorStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The emulator version string.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The time the emulator has been active in .ms
	Uptime uint64 `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// True if the device has completed booting.
	// For P and later this information will accurate,
	// for older images we rely on adb.
	Booted bool `protobuf:"varint,3,opt,name=booted,proto3" json:"booted,omitempty"`
	// The current vm configuration
	VmConfig *VmConfiguration `protobuf:"bytes,4,opt,name=vmConfig,proto3" json:"vmConfig,omitempty"`
	// The hardware configuration of the running emulator as
	// key valure pairs.
	HardwareConfig *EntryList `protobuf:"bytes,5,opt,name=hardwareConfig,proto3" json:"hardwareConfig,omitempty"`
}

func (x *EmulatorStatus) Reset() {
	*x = EmulatorStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EmulatorStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmulatorStatus) ProtoMessage() {}

func (x *EmulatorStatus) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmulatorStatus.ProtoReflect.Descriptor instead.
func (*EmulatorStatus) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{23}
}

func (x *EmulatorStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *EmulatorStatus) GetUptime() uint64 {
	if x != nil {
		return x.Uptime
	}
	return 0
}

func (x *EmulatorStatus) GetBooted() bool {
	if x != nil {
		return x.Booted
	}
	return false
}

func (x *EmulatorStatus) GetVmConfig() *VmConfiguration {
	if x != nil {
		return x.VmConfig
	}
	return nil
}

func (x *EmulatorStatus) GetHardwareConfig() *EntryList {
	if x != nil {
		return x.HardwareConfig
	}
	return nil
}

type AudioFormat struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Sampling rate to use, defaulting to 44100 if this is not set.
	// Note, that android devices typically will not use a sampling
	// rate higher than 48kHz. See https://developer.android.com/ndk/guides/audio.
	SamplingRate uint64                   `protobuf:"varint,1,opt,name=samplingRate,proto3" json:"samplingRate,omitempty"`
	Channels     AudioFormat_Channels     `protobuf:"varint,2,opt,name=channels,proto3,enum=android.emulation.control.AudioFormat_Channels" json:"channels,omitempty"`
	Format       AudioFormat_SampleFormat `protobuf:"varint,3,opt,name=format,proto3,enum=android.emulation.control.AudioFormat_SampleFormat" json:"format,omitempty"`
}

func (x *AudioFormat) Reset() {
	*x = AudioFormat{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AudioFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioFormat) ProtoMessage() {}

func (x *AudioFormat) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioFormat.ProtoReflect.Descriptor instead.
func (*AudioFormat) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{24}
}

func (x *AudioFormat) GetSamplingRate() uint64 {
	if x != nil {
		return x.SamplingRate
	}
	return 0
}

func (x *AudioFormat) GetChannels() AudioFormat_Channels {
	if x != nil {
		return x.Channels
	}
	return AudioFormat_Mono
}

func (x *AudioFormat) GetFormat() AudioFormat_SampleFormat {
	if x != nil {
		return x.Format
	}
	return AudioFormat_AUD_FMT_U8
}

type AudioPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Format *AudioFormat `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	// Unix epoch in us when this frame was captured.
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Contains a sample in the given audio format.
	Audio []byte `protobuf:"bytes,3,opt,name=audio,proto3" json:"audio,omitempty"`
}

func (x *AudioPacket) Reset() {
	*x = AudioPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AudioPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioPacket) ProtoMessage() {}

func (x *AudioPacket) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioPacket.ProtoReflect.Descriptor instead.
func (*AudioPacket) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{25}
}

func (x *AudioPacket) GetFormat() *AudioFormat {
	if x != nil {
		return x.Format
	}
	return nil
}

func (x *AudioPacket) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AudioPacket) GetAudio() []byte {
	if x != nil {
		return x.Audio
	}
	return nil
}

type SmsMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The source address where this message came from.
	//
	// The address should be a valid GSM-formatted address as specified by
	// 3GPP 23.040 Sec 9.1.2.5.
	//
	// For example: +3106225412 or (650) 555-1221
	SrcAddress string `protobuf:"bytes,1,opt,name=srcAddress,proto3" json:"srcAddress,omitempty"`
	// A utf8 encoded text message that should be delivered.
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *SmsMessage) Reset() {
	*x = SmsMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_emulator_controller_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SmsMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SmsMessage) ProtoMessage() {}

func (x *SmsMessage) ProtoReflect() protoreflect.Message {
	mi := &file_emulator_controller_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SmsMessage.ProtoReflect.Descriptor instead.
func (*SmsMessage) Descriptor() ([]byte, []int) {
	return file_emulator_controller_proto_rawDescGZIP(), []int{26}
}

func (x *SmsMessage) GetSrcAddress() string {
	if x != nil {
		return x.SrcAddress
	}
	return ""
}

func (x *SmsMessage) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

var File_emulator_controller_proto protoreflect.FileDescriptor

var file_emulator_controller_proto_rawDesc = []byte{
	0x0a, 0x19, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x61, 0x6e, 0x64,
	0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xde, 0x01, 0x0a, 0x0a, 0x56, 0x6d, 0x52, 0x75, 0x6e, 0x53, 0x74, 0x61,
	0x74, 0x65, 0x12, 0x44, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x2e, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x56, 0x6d,
	0x52, 0x75, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x52, 0x75, 0x6e, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x22, 0x89, 0x01, 0x0a, 0x08, 0x52, 0x75, 0x6e,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e,
	0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12,
	0x0e, 0x0a, 0x0a, 0x52, 0x45, 0x53, 0x54, 0x4f, 0x52, 0x45, 0x5f, 0x56, 0x4d, 0x10, 0x02, 0x12,
	0x0a, 0x0a, 0x06, 0x50, 0x41, 0x55, 0x53, 0x45, 0x44, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x53,
	0x41, 0x56, 0x45, 0x5f, 0x56, 0x4d, 0x10, 0x04, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x48, 0x55, 0x54,
	0x44, 0x4f, 0x57, 0x4e, 0x10, 0x05, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e,
	0x41, 0x54, 0x45, 0x10, 0x07, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x45, 0x53, 0x45, 0x54, 0x10, 0x09,
	0x12, 0x12, 0x0a, 0x0e, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x45, 0x52, 0x52,
	0x4f, 0x52, 0x10, 0x0a, 0x22, 0x28, 0x0a, 0x0e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
	0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x16, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x02, 0x42, 0x02, 0x10, 0x01, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0xf7,
	0x03, 0x0a, 0x12, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x52, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3a, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
	0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x4b, 0x0a, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x33, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f,
	0x64, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x06,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3f, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
	0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x55, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65,
	0x12, 0x06, 0x0a, 0x02, 0x4f, 0x4b, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x0a, 0x4e, 0x4f, 0x5f, 0x53,
	0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x10, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x12, 0x15, 0x0a, 0x08, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x10, 0xfe, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x14, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e,
	0x4f, 0x57, 0x4e, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x22, 0xa7,
	0x01, 0x0a, 0x0c, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x0c, 0x0a, 0x08, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x00, 0x12, 0x0c, 0x0a,
	0x08, 0x52, 0x4f, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x4d,
	0x41, 0x47, 0x4e, 0x45, 0x54, 0x49, 0x43, 0x5f, 0x46, 0x49, 0x45, 0x4c, 0x44, 0x10, 0x02, 0x12,
	0x0f, 0x0a, 0x0b, 0x54, 0x45, 0x4d, 0x50, 0x45, 0x52, 0x41, 0x54, 0x55, 0x52, 0x45, 0x10, 0x03,
	0x12, 0x0d, 0x0a, 0x09, 0x50, 0x52, 0x4f, 0x58, 0x49, 0x4d, 0x49, 0x54, 0x59, 0x10, 0x04, 0x12,
	0x09, 0x0a, 0x05, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x50, 0x52,
	0x45, 0x53, 0x53, 0x55, 0x52, 0x45, 0x10, 0x06, 0x12, 0x0c, 0x0a, 0x08, 0x48, 0x55, 0x4d, 0x49,
	0x44, 0x49, 0x54, 0x59, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x56, 0x45, 0x4c, 0x4f, 0x43, 0x49,
	0x54, 0x59, 0x10, 0x08, 0x12, 0x12, 0x0a, 0x0e, 0x41, 0x4d, 0x42, 0x49, 0x45, 0x4e, 0x54, 0x5f,
	0x4d, 0x4f, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x09, 0x22, 0x8f, 0x04, 0x0a, 0x0b, 0x53, 0x65, 0x6e,
	0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x49, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67,
	0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x06, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x12, 0x44, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e,
	0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x3f, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x55, 0x0a, 0x05, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x12, 0x06, 0x0a, 0x02, 0x4f, 0x4b, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x0a, 0x4e,
	0x4f, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x10, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x01, 0x12, 0x15, 0x0a, 0x08, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44,
	0x10, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x14, 0x0a, 0x07, 0x55,
	0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x22, 0xd6, 0x01, 0x0a, 0x0a, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x10, 0x0a, 0x0c, 0x41, 0x43, 0x43, 0x45, 0x4c, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e,
	0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09, 0x47, 0x59, 0x52, 0x4f, 0x53, 0x43, 0x4f, 0x50, 0x45, 0x10,
	0x01, 0x12, 0x12, 0x0a, 0x0e, 0x4d, 0x41, 0x47, 0x4e, 0x45, 0x54, 0x49, 0x43, 0x5f, 0x46, 0x49,
	0x45, 0x4c, 0x44, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41,
	0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x45, 0x4d, 0x50, 0x45, 0x52,
	0x41, 0x54, 0x55, 0x52, 0x45, 0x10, 0x04, 0x12, 0x0d, 0x0a, 0x09, 0x50, 0x52, 0x4f, 0x58, 0x49,
	0x4d, 0x49, 0x54, 0x59, 0x10, 0x05, 0x12, 0x09, 0x0a, 0x05, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x10,
	0x06, 0x12, 0x0c, 0x0a, 0x08, 0x50, 0x52, 0x45, 0x53, 0x53, 0x55, 0x52, 0x45, 0x10, 0x07, 0x12,
	0x0c, 0x0a, 0x08, 0x48, 0x55, 0x4d, 0x49, 0x44, 0x49, 0x54, 0x59, 0x10, 0x08, 0x12, 0x1f, 0x0a,
	0x1b, 0x4d, 0x41, 0x47, 0x4e, 0x45, 0x54, 0x49, 0x43, 0x5f, 0x46, 0x49, 0x45, 0x4c, 0x44, 0x5f,
	0x55, 0x4e, 0x43, 0x41, 0x4c, 0x49, 0x42, 0x52, 0x41, 0x54, 0x45, 0x44, 0x10, 0x09, 0x12, 0x1a,
	0x0a, 0x16, 0x47, 0x59, 0x52, 0x4f, 0x53, 0x43, 0x4f, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x43, 0x41,
	0x4c, 0x49, 0x42, 0x52, 0x41, 0x54, 0x45, 0x44, 0x10, 0x0a, 0x22, 0xf8, 0x01, 0x0a, 0x0a, 0x4c,
	0x6f, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e,
	0x74, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e,
	0x74, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x6e, 0x65, 0x78, 0x74, 0x12,
	0x41, 0x0a, 0x04, 0x73, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2d, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x73, 0x6f,
	0x72, 0x74, 0x12, 0x40, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x05, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e,
	0x4c, 0x6f, 0x67, 0x63, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74,
	0x72, 0x69, 0x65, 0x73, 0x22, 0x1f, 0x0a, 0x07, 0x4c, 0x6f, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x08, 0x0a, 0x04, 0x54, 0x65, 0x78, 0x74, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x50, 0x61, 0x72,
	0x73, 0x65, 0x64, 0x10, 0x01, 0x22, 0xac, 0x02, 0x0a, 0x0b, 0x4c, 0x6f, 0x67, 0x63, 0x61, 0x74,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x70, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x70, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x03, 0x74, 0x69, 0x64, 0x12, 0x45, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2f, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x63, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x2e, 0x4c,
	0x6f, 0x67, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x10,
	0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67,
	0x12, 0x10, 0x0a, 0x03, 0x6d, 0x73, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d,
	0x73, 0x67, 0x22, 0x70, 0x0a, 0x08, 0x4c, 0x6f, 0x67, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x0b,
	0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x44,
	0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x56, 0x45, 0x52, 0x42,
	0x4f, 0x53, 0x45, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x45, 0x42, 0x55, 0x47, 0x10, 0x03,
	0x12, 0x08, 0x0a, 0x04, 0x49, 0x4e, 0x46, 0x4f, 0x10, 0x04, 0x12, 0x08, 0x0a, 0x04, 0x57, 0x41,
	0x52, 0x4e, 0x10, 0x05, 0x12, 0x07, 0x0a, 0x03, 0x45, 0x52, 0x52, 0x10, 0x06, 0x12, 0x09, 0x0a,
	0x05, 0x46, 0x41, 0x54, 0x41, 0x4c, 0x10, 0x07, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x49, 0x4c, 0x45,
	0x4e, 0x54, 0x10, 0x08, 0x22, 0xa0, 0x02, 0x0a, 0x0f, 0x56, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x63, 0x0a, 0x0e, 0x68, 0x79, 0x70, 0x65,
	0x72, 0x76, 0x69, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x3b, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x56, 0x6d, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x6d, 0x48,
	0x79, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0e, 0x68,
	0x79, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x2a, 0x0a,
	0x10, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x43, 0x70, 0x75, 0x43, 0x6f, 0x72, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f,
	0x66, 0x43, 0x70, 0x75, 0x43, 0x6f, 0x72, 0x65, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x72, 0x61, 0x6d,
	0x53, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x0c, 0x72, 0x61, 0x6d, 0x53, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0x58, 0x0a,
	0x10, 0x56, 0x6d, 0x48, 0x79, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6f, 0x72, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x08,
	0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x4b, 0x56, 0x4d, 0x10,
	0x02, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x41, 0x58, 0x4d, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x48,
	0x56, 0x46, 0x10, 0x04, 0x12, 0x08, 0x0a, 0x04, 0x57, 0x48, 0x50, 0x58, 0x10, 0x05, 0x12, 0x07,
	0x0a, 0x03, 0x47, 0x56, 0x4d, 0x10, 0x06, 0x22, 0x1e, 0x0a, 0x08, 0x43, 0x6c, 0x69, 0x70, 0x44,
	0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x22, 0xa1, 0x01, 0x0a, 0x05, 0x54, 0x6f, 0x75, 0x63,
	0x68, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x01, 0x78, 0x12,
	0x0c, 0x0a, 0x01, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x01, 0x79, 0x12, 0x1e, 0x0a,
	0x0a, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0a, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12, 0x1a, 0x0a,
	0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x08, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x75,
	0x63, 0x68, 0x5f, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a,
	0x74, 0x6f, 0x75, 0x63, 0x68, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f,
	0x75, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0a, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x4d, 0x69, 0x6e, 0x6f, 0x72, 0x22, 0x60, 0x0a, 0x0a, 0x54,
	0x6f, 0x75, 0x63, 0x68, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x3a, 0x0a, 0x07, 0x74, 0x6f, 0x75,
	0x63, 0x68, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x6e, 0x64,
	0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x52, 0x07, 0x74, 0x6f,
	0x75, 0x63, 0x68, 0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x22, 0x5a, 0x0a,
	0x0a, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x0c, 0x0a, 0x01, 0x78,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x01, 0x78, 0x12, 0x0c, 0x0a, 0x01, 0x79, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x01, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x74, 0x74, 0x6f,
	0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e,
	0x73, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x22, 0xea, 0x02, 0x0a, 0x0d, 0x4b, 0x65,
	0x79, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x50, 0x0a, 0x08, 0x63,
	0x6f, 0x64, 0x65, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4b, 0x65, 0x79, 0x62, 0x6f, 0x61,
	0x72, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x4b, 0x65, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x53, 0x0a,
	0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x35, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4b, 0x65, 0x79,
	0x62, 0x6f, 0x61, 0x72, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x4b, 0x65, 0x79, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6b, 0x65, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x07, 0x6b, 0x65, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x12,
	0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65,
	0x78, 0x74, 0x22, 0x3c, 0x0a, 0x0b, 0x4b, 0x65, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x73, 0x62, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x76,
	0x64, 0x65, 0x76, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x58, 0x4b, 0x42, 0x10, 0x02, 0x12, 0x07,
	0x0a, 0x03, 0x57, 0x69, 0x6e, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x61, 0x63, 0x10, 0x04,
	0x22, 0x34, 0x0a, 0x0c, 0x4b, 0x65, 0x79, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x0b, 0x0a, 0x07, 0x6b, 0x65, 0x79, 0x64, 0x6f, 0x77, 0x6e, 0x10, 0x00, 0x12, 0x09, 0x0a,
	0x05, 0x6b, 0x65, 0x79, 0x75, 0x70, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x6b, 0x65, 0x79, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x10, 0x02, 0x22, 0x47, 0x0a, 0x0b, 0x46, 0x69, 0x6e, 0x67, 0x65, 0x72,
	0x70, 0x72, 0x69, 0x6e, 0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x69, 0x73, 0x54, 0x6f, 0x75, 0x63, 0x68,
	0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x54, 0x6f, 0x75,
	0x63, 0x68, 0x69, 0x6e, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x49, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x49, 0x64, 0x22,
	0xd6, 0x01, 0x0a, 0x08, 0x47, 0x70, 0x73, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x24, 0x0a, 0x0d,
	0x70, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0d, 0x70, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1c,
	0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x01, 0x52, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x73, 0x70, 0x65,
	0x65, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x07, 0x62, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x1a, 0x0a, 0x08,
	0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08,
	0x61, 0x6c, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x61, 0x74, 0x65,
	0x6c, 0x6c, 0x69, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x73, 0x61,
	0x74, 0x65, 0x6c, 0x6c, 0x69, 0x74, 0x65, 0x73, 0x22, 0xc4, 0x04, 0x0a, 0x0c, 0x42, 0x61, 0x74,
	0x74, 0x65, 0x72, 0x79, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x68, 0x61, 0x73,
	0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x68,
	0x61, 0x73, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x50,
	0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73,
	0x50, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x12, 0x50, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x72, 0x67,
	0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x36, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x72,
	0x52, 0x07, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x68, 0x61,
	0x72, 0x67, 0x65, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b,
	0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x4d, 0x0a, 0x06, 0x68,
	0x65, 0x61, 0x6c, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x35, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x48, 0x65, 0x61, 0x6c,
	0x74, 0x68, 0x52, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x12, 0x4d, 0x0a, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x35, 0x2e, 0x61, 0x6e, 0x64,
	0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x57, 0x0a, 0x0d, 0x42, 0x61, 0x74,
	0x74, 0x65, 0x72, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e,
	0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x48, 0x41, 0x52, 0x47,
	0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x44, 0x49, 0x53, 0x43, 0x48, 0x41, 0x52,
	0x47, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x4e, 0x4f, 0x54, 0x5f, 0x43, 0x48,
	0x41, 0x52, 0x47, 0x49, 0x4e, 0x47, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x46, 0x55, 0x4c, 0x4c,
	0x10, 0x04, 0x22, 0x39, 0x0a, 0x0e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x43, 0x68, 0x61,
	0x72, 0x67, 0x65, 0x72, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x06,
	0x0a, 0x02, 0x41, 0x43, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x53, 0x42, 0x10, 0x02, 0x12,
	0x0c, 0x0a, 0x08, 0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x10, 0x03, 0x22, 0x50, 0x0a,
	0x0d, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x12, 0x08,
	0x0a, 0x04, 0x47, 0x4f, 0x4f, 0x44, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x46, 0x41, 0x49, 0x4c,
	0x45, 0x44, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x45, 0x41, 0x44, 0x10, 0x02, 0x12, 0x0f,
	0x0a, 0x0b, 0x4f, 0x56, 0x45, 0x52, 0x56, 0x4f, 0x4c, 0x54, 0x41, 0x47, 0x45, 0x10, 0x03, 0x12,
	0x0e, 0x0a, 0x0a, 0x4f, 0x56, 0x45, 0x52, 0x48, 0x45, 0x41, 0x54, 0x45, 0x44, 0x10, 0x04, 0x22,
	0xbf, 0x01, 0x0a, 0x0e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f,
	0x72, 0x74, 0x12, 0x54, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x3a, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d,
	0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x52,
	0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x61, 0x6e, 0x64,
	0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
	0x22, 0x3f, 0x0a, 0x10, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x43, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x21, 0x0a, 0x1d, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x50, 0x4f, 0x52,
	0x54, 0x5f, 0x43, 0x48, 0x41, 0x4e, 0x4e, 0x45, 0x4c, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x4d, 0x4d, 0x41, 0x50, 0x10,
	0x01, 0x22, 0xd9, 0x02, 0x0a, 0x0b, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x12, 0x48, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x30, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x49, 0x6d, 0x67, 0x46, 0x6f, 0x72,
	0x6d, 0x61, 0x74, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x3f, 0x0a, 0x08, 0x72,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x08, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05,
	0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x77, 0x69, 0x64,
	0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x69,
	0x73, 0x70, 0x6c, 0x61, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x64, 0x69, 0x73,
	0x70, 0x6c, 0x61, 0x79, 0x12, 0x47, 0x0a, 0x09, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72,
	0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
	0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f,
	0x72, 0x74, 0x52, 0x09, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x22, 0x2e, 0x0a,
	0x09, 0x49, 0x6d, 0x67, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x07, 0x0a, 0x03, 0x50, 0x4e,
	0x47, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x47, 0x42, 0x41, 0x38, 0x38, 0x38, 0x38, 0x10,
	0x01, 0x12, 0x0a, 0x0a, 0x06, 0x52, 0x47, 0x42, 0x38, 0x38, 0x38, 0x10, 0x02, 0x22, 0xa5, 0x01,
	0x0a, 0x05, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x3e, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
	0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52,
	0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x02, 0x18, 0x01, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74,
	0x68, 0x12, 0x1a, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0d, 0x42, 0x02, 0x18, 0x01, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x14, 0x0a,
	0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x69, 0x6d,
	0x61, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x65, 0x71, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x73, 0x65, 0x71, 0x22, 0xf4, 0x01, 0x0a, 0x08, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x4c, 0x0a, 0x08, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x30, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65,
	0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x2e, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x53, 0x6b, 0x69, 0x6e, 0x52, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x14, 0x0a, 0x05, 0x78, 0x41, 0x78, 0x69, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x05, 0x78, 0x41, 0x78, 0x69, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x79, 0x41, 0x78, 0x69, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x79, 0x41, 0x78, 0x69, 0x73, 0x12, 0x14, 0x0a, 0x05,
	0x7a, 0x41, 0x78, 0x69, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x7a, 0x41, 0x78,
	0x69, 0x73, 0x22, 0x58, 0x0a, 0x0c, 0x53, 0x6b, 0x69, 0x6e, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x08, 0x50, 0x4f, 0x52, 0x54, 0x52, 0x41, 0x49, 0x54, 0x10, 0x00,
	0x12, 0x0d, 0x0a, 0x09, 0x4c, 0x41, 0x4e, 0x44, 0x53, 0x43, 0x41, 0x50, 0x45, 0x10, 0x01, 0x12,
	0x14, 0x0a, 0x10, 0x52, 0x45, 0x56, 0x45, 0x52, 0x53, 0x45, 0x5f, 0x50, 0x4f, 0x52, 0x54, 0x52,
	0x41, 0x49, 0x54, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x52, 0x45, 0x56, 0x45, 0x52, 0x53, 0x45,
	0x5f, 0x4c, 0x41, 0x4e, 0x44, 0x53, 0x43, 0x41, 0x50, 0x45, 0x10, 0x03, 0x22, 0x87, 0x02, 0x0a,
	0x09, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x43, 0x61, 0x6c, 0x6c, 0x12, 0x4c, 0x0a, 0x09, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x43,
	0x61, 0x6c, 0x6c, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
	0x22, 0x93, 0x01, 0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0c,
	0x0a, 0x08, 0x49, 0x6e, 0x69, 0x74, 0x43, 0x61, 0x6c, 0x6c, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a,
	0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x43, 0x61, 0x6c, 0x6c, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12,
	0x52, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x61, 0x6c, 0x6c, 0x45, 0x78, 0x70, 0x6c, 0x69, 0x63,
	0x69, 0x74, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x52, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x61,
	0x6c, 0x6c, 0x42, 0x75, 0x73, 0x79, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x69, 0x73, 0x63,
	0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x61, 0x6c, 0x6c, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f,
	0x50, 0x6c, 0x61, 0x63, 0x65, 0x43, 0x61, 0x6c, 0x6c, 0x4f, 0x6e, 0x48, 0x6f, 0x6c, 0x64, 0x10,
	0x05, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x61, 0x6b, 0x65, 0x43, 0x61, 0x6c, 0x6c, 0x4f, 0x66, 0x66,
	0x48, 0x6f, 0x6c, 0x64, 0x10, 0x06, 0x22, 0xc6, 0x01, 0x0a, 0x0d, 0x50, 0x68, 0x6f, 0x6e, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4d, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x61, 0x6e, 0x64,
	0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x08, 0x72,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x66, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x06, 0x0a, 0x02, 0x4f, 0x4b, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x42,
	0x61, 0x64, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x10, 0x01, 0x12, 0x0d, 0x0a,
	0x09, 0x42, 0x61, 0x64, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d,
	0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x10, 0x03, 0x12,
	0x10, 0x0a, 0x0c, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x10,
	0x04, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x4f, 0x66, 0x66, 0x10, 0x05, 0x22,
	0x2f, 0x0a, 0x05, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x22, 0x43, 0x0a, 0x09, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x36, 0x0a,
	0x05, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61,
	0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x05,
	0x65, 0x6e, 0x74, 0x72, 0x79, 0x22, 0xf0, 0x01, 0x0a, 0x0e, 0x45, 0x6d, 0x75, 0x6c, 0x61, 0x74,
	0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x75, 0x70, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x06, 0x75, 0x70, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x62, 0x6f,
	0x6f, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x62, 0x6f, 0x6f, 0x74,
	0x65, 0x64, 0x12, 0x46, 0x0a, 0x08, 0x76, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65,
	0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x2e, 0x56, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x08, 0x76, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4c, 0x0a, 0x0e, 0x68, 0x61,
	0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x24, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x0e, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61,
	0x72, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x9e, 0x02, 0x0a, 0x0b, 0x41, 0x75, 0x64,
	0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x61, 0x6d, 0x70,
	0x6c, 0x69, 0x6e, 0x67, 0x52, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c,
	0x73, 0x61, 0x6d, 0x70, 0x6c, 0x69, 0x6e, 0x67, 0x52, 0x61, 0x74, 0x65, 0x12, 0x4b, 0x0a, 0x08,
	0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2f,
	0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f,
	0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x52,
	0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x4b, 0x0a, 0x06, 0x66, 0x6f, 0x72,
	0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x33, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x2e, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x06,
	0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0x2f, 0x0a, 0x0c, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65,
	0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x0e, 0x0a, 0x0a, 0x41, 0x55, 0x44, 0x5f, 0x46, 0x4d,
	0x54, 0x5f, 0x55, 0x38, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x55, 0x44, 0x5f, 0x46, 0x4d,
	0x54, 0x5f, 0x53, 0x31, 0x36, 0x10, 0x01, 0x22, 0x20, 0x0a, 0x08, 0x43, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x73, 0x12, 0x08, 0x0a, 0x04, 0x4d, 0x6f, 0x6e, 0x6f, 0x10, 0x00, 0x12, 0x0a, 0x0a,
	0x06, 0x53, 0x74, 0x65, 0x72, 0x65, 0x6f, 0x10, 0x01, 0x22, 0x81, 0x01, 0x0a, 0x0b, 0x41, 0x75,
	0x64, 0x69, 0x6f, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x3e, 0x0a, 0x06, 0x66, 0x6f, 0x72,
	0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x22, 0x40, 0x0a,
	0x0a, 0x53, 0x6d, 0x73, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x73,
	0x72, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0a, 0x73, 0x72, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x74,
	0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x32,
	0xe4, 0x12, 0x0a, 0x12, 0x45, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x62, 0x0a, 0x0c, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
	0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x26,
	0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f,
	0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x5d, 0x0a, 0x09, 0x67, 0x65,
	0x74, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
	0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a,
	0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73,
	0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x09, 0x73, 0x65, 0x74,
	0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x53, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x16,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5b, 0x0a, 0x10, 0x73, 0x65, 0x74, 0x50,
	0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x2d, 0x2e, 0x61,
	0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61,
	0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x16, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d,
	0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x72, 0x0a, 0x10, 0x67, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73,
	0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x2d, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f,
	0x64, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x2d, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x00, 0x12, 0x77, 0x0a, 0x13, 0x73, 0x74, 0x72,
	0x65, 0x61, 0x6d, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c,
	0x12, 0x2d, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79,
	0x73, 0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a,
	0x2d, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x79, 0x73,
	0x69, 0x63, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x00,
	0x30, 0x01, 0x12, 0x4d, 0x0a, 0x0c, 0x73, 0x65, 0x74, 0x43, 0x6c, 0x69, 0x70, 0x62, 0x6f, 0x61,
	0x72, 0x64, 0x12, 0x23, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x43,
	0x6c, 0x69, 0x70, 0x44, 0x61, 0x74, 0x61, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22,
	0x00, 0x12, 0x4d, 0x0a, 0x0c, 0x67, 0x65, 0x74, 0x43, 0x6c, 0x69, 0x70, 0x62, 0x6f, 0x61, 0x72,
	0x64, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x23, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x43, 0x6c, 0x69, 0x70, 0x44, 0x61, 0x74, 0x61, 0x22, 0x00,
	0x12, 0x52, 0x0a, 0x0f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6c, 0x69, 0x70, 0x62, 0x6f,
	0x61, 0x72, 0x64, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x23, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x43, 0x6c, 0x69, 0x70, 0x44, 0x61, 0x74, 0x61,
	0x22, 0x00, 0x30, 0x01, 0x12, 0x4f, 0x0a, 0x0a, 0x73, 0x65, 0x74, 0x42, 0x61, 0x74, 0x74, 0x65,
	0x72, 0x79, 0x12, 0x27, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x42,
	0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53, 0x74, 0x61, 0x74, 0x65, 0x1a, 0x16, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d,
	0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4f, 0x0a, 0x0a, 0x67, 0x65, 0x74, 0x42, 0x61, 0x74, 0x74,
	0x65, 0x72, 0x79, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x27, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x22, 0x00, 0x12, 0x47, 0x0a, 0x06, 0x73, 0x65, 0x74, 0x47, 0x70, 0x73,
	0x12, 0x23, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x47, 0x70, 0x73,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12,
	0x47, 0x0a, 0x06, 0x67, 0x65, 0x74, 0x47, 0x70, 0x73, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74,
	0x79, 0x1a, 0x23, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x47, 0x70,
	0x73, 0x53, 0x74, 0x61, 0x74, 0x65, 0x22, 0x00, 0x12, 0x53, 0x0a, 0x0f, 0x73, 0x65, 0x6e, 0x64,
	0x46, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x12, 0x26, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x46, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x70, 0x72,
	0x69, 0x6e, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4d, 0x0a,
	0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x12, 0x28, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4b, 0x65, 0x79, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4c, 0x0a, 0x09,
	0x73, 0x65, 0x6e, 0x64, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4c, 0x0a, 0x09, 0x73, 0x65,
	0x6e, 0x64, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
	0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x2e, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x16,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5d, 0x0a, 0x09, 0x73, 0x65, 0x6e, 0x64,
	0x50, 0x68, 0x6f, 0x6e, 0x65, 0x12, 0x24, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
	0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x43, 0x61, 0x6c, 0x6c, 0x1a, 0x28, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5c, 0x0a, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x53,
	0x6d, 0x73, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x53,
	0x6d, 0x73, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x28, 0x2e, 0x61, 0x6e, 0x64, 0x72,
	0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x50, 0x0a, 0x09, 0x67, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x29, 0x2e, 0x61, 0x6e, 0x64,
	0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x45, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x00, 0x12, 0x5b, 0x0a, 0x0d, 0x67, 0x65, 0x74, 0x53, 0x63,
	0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
	0x1a, 0x20, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x22, 0x00, 0x12, 0x60, 0x0a, 0x10, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x63,
	0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f,
	0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
	0x1a, 0x20, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x61, 0x0a, 0x0b, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
	0x41, 0x75, 0x64, 0x69, 0x6f, 0x12, 0x26, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
	0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x1a, 0x26, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x50,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x22, 0x00, 0x30, 0x01, 0x12, 0x5b, 0x0a, 0x09, 0x67, 0x65, 0x74,
	0x4c, 0x6f, 0x67, 0x63, 0x61, 0x74, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x25, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x60, 0x0a, 0x0c, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
	0x4c, 0x6f, 0x67, 0x63, 0x61, 0x74, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x25, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x4c, 0x6f, 0x67, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x4d, 0x0a, 0x0a, 0x73, 0x65, 0x74, 0x56,
	0x6d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x25, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
	0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x2e, 0x56, 0x6d, 0x52, 0x75, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x1a, 0x16, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0a, 0x67, 0x65, 0x74, 0x56, 0x6d,
	0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x25, 0x2e,
	0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e, 0x56, 0x6d, 0x52, 0x75, 0x6e, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x22, 0x00, 0x42, 0x46, 0x0a, 0x1c, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x6e,
	0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x63,
	0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x01, 0x5a, 0x1e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
	0x64, 0x5f, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0xa2, 0x02, 0x03, 0x41, 0x45, 0x43, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_emulator_controller_proto_rawDescOnce sync.Once
	file_emulator_controller_proto_rawDescData = file_emulator_controller_proto_rawDesc
)

func file_emulator_controller_proto_rawDescGZIP() []byte {
	file_emulator_controller_proto_rawDescOnce.Do(func() {
		file_emulator_controller_proto_rawDescData = protoimpl.X.CompressGZIP(file_emulator_controller_proto_rawDescData)
	})
	return file_emulator_controller_proto_rawDescData
}

var file_emulator_controller_proto_enumTypes = make([]protoimpl.EnumInfo, 20)
var file_emulator_controller_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_emulator_controller_proto_goTypes = []interface{}{
	(VmRunState_RunState)(0),              // 0: android.emulation.control.VmRunState.RunState
	(PhysicalModelValue_State)(0),         // 1: android.emulation.control.PhysicalModelValue.State
	(PhysicalModelValue_PhysicalType)(0),  // 2: android.emulation.control.PhysicalModelValue.PhysicalType
	(SensorValue_State)(0),                // 3: android.emulation.control.SensorValue.State
	(SensorValue_SensorType)(0),           // 4: android.emulation.control.SensorValue.SensorType
	(LogMessage_LogType)(0),               // 5: android.emulation.control.LogMessage.LogType
	(LogcatEntry_LogLevel)(0),             // 6: android.emulation.control.LogcatEntry.LogLevel
	(VmConfiguration_VmHypervisorType)(0), // 7: android.emulation.control.VmConfiguration.VmHypervisorType
	(KeyboardEvent_KeyCodeType)(0),        // 8: android.emulation.control.KeyboardEvent.KeyCodeType
	(KeyboardEvent_KeyEventType)(0),       // 9: android.emulation.control.KeyboardEvent.KeyEventType
	(BatteryState_BatteryStatus)(0),       // 10: android.emulation.control.BatteryState.BatteryStatus
	(BatteryState_BatteryCharger)(0),      // 11: android.emulation.control.BatteryState.BatteryCharger
	(BatteryState_BatteryHealth)(0),       // 12: android.emulation.control.BatteryState.BatteryHealth
	(ImageTransport_TransportChannel)(0),  // 13: android.emulation.control.ImageTransport.TransportChannel
	(ImageFormat_ImgFormat)(0),            // 14: android.emulation.control.ImageFormat.ImgFormat
	(Rotation_SkinRotation)(0),            // 15: android.emulation.control.Rotation.SkinRotation
	(PhoneCall_Operation)(0),              // 16: android.emulation.control.PhoneCall.Operation
	(PhoneResponse_Response)(0),           // 17: android.emulation.control.PhoneResponse.Response
	(AudioFormat_SampleFormat)(0),         // 18: android.emulation.control.AudioFormat.SampleFormat
	(AudioFormat_Channels)(0),             // 19: android.emulation.control.AudioFormat.Channels
	(*VmRunState)(nil),                    // 20: android.emulation.control.VmRunState
	(*ParameterValue)(nil),                // 21: android.emulation.control.ParameterValue
	(*PhysicalModelValue)(nil),            // 22: android.emulation.control.PhysicalModelValue
	(*SensorValue)(nil),                   // 23: android.emulation.control.SensorValue
	(*LogMessage)(nil),                    // 24: android.emulation.control.LogMessage
	(*LogcatEntry)(nil),                   // 25: android.emulation.control.LogcatEntry
	(*VmConfiguration)(nil),               // 26: android.emulation.control.VmConfiguration
	(*ClipData)(nil),                      // 27: android.emulation.control.ClipData
	(*Touch)(nil),                         // 28: android.emulation.control.Touch
	(*TouchEvent)(nil),                    // 29: android.emulation.control.TouchEvent
	(*MouseEvent)(nil),                    // 30: android.emulation.control.MouseEvent
	(*KeyboardEvent)(nil),                 // 31: android.emulation.control.KeyboardEvent
	(*Fingerprint)(nil),                   // 32: android.emulation.control.Fingerprint
	(*GpsState)(nil),                      // 33: android.emulation.control.GpsState
	(*BatteryState)(nil),                  // 34: android.emulation.control.BatteryState
	(*ImageTransport)(nil),                // 35: android.emulation.control.ImageTransport
	(*ImageFormat)(nil),                   // 36: android.emulation.control.ImageFormat
	(*Image)(nil),                         // 37: android.emulation.control.Image
	(*Rotation)(nil),                      // 38: android.emulation.control.Rotation
	(*PhoneCall)(nil),                     // 39: android.emulation.control.PhoneCall
	(*PhoneResponse)(nil),                 // 40: android.emulation.control.PhoneResponse
	(*Entry)(nil),                         // 41: android.emulation.control.Entry
	(*EntryList)(nil),                     // 42: android.emulation.control.EntryList
	(*EmulatorStatus)(nil),                // 43: android.emulation.control.EmulatorStatus
	(*AudioFormat)(nil),                   // 44: android.emulation.control.AudioFormat
	(*AudioPacket)(nil),                   // 45: android.emulation.control.AudioPacket
	(*SmsMessage)(nil),                    // 46: android.emulation.control.SmsMessage
	(*empty.Empty)(nil),                   // 47: google.protobuf.Empty
}
var file_emulator_controller_proto_depIdxs = []int32{
	0,  // 0: android.emulation.control.VmRunState.state:type_name -> android.emulation.control.VmRunState.RunState
	2,  // 1: android.emulation.control.PhysicalModelValue.target:type_name -> android.emulation.control.PhysicalModelValue.PhysicalType
	1,  // 2: android.emulation.control.PhysicalModelValue.status:type_name -> android.emulation.control.PhysicalModelValue.State
	21, // 3: android.emulation.control.PhysicalModelValue.value:type_name -> android.emulation.control.ParameterValue
	4,  // 4: android.emulation.control.SensorValue.target:type_name -> android.emulation.control.SensorValue.SensorType
	3,  // 5: android.emulation.control.SensorValue.status:type_name -> android.emulation.control.SensorValue.State
	21, // 6: android.emulation.control.SensorValue.value:type_name -> android.emulation.control.ParameterValue
	5,  // 7: android.emulation.control.LogMessage.sort:type_name -> android.emulation.control.LogMessage.LogType
	25, // 8: android.emulation.control.LogMessage.entries:type_name -> android.emulation.control.LogcatEntry
	6,  // 9: android.emulation.control.LogcatEntry.level:type_name -> android.emulation.control.LogcatEntry.LogLevel
	7,  // 10: android.emulation.control.VmConfiguration.hypervisorType:type_name -> android.emulation.control.VmConfiguration.VmHypervisorType
	28, // 11: android.emulation.control.TouchEvent.touches:type_name -> android.emulation.control.Touch
	8,  // 12: android.emulation.control.KeyboardEvent.codeType:type_name -> android.emulation.control.KeyboardEvent.KeyCodeType
	9,  // 13: android.emulation.control.KeyboardEvent.eventType:type_name -> android.emulation.control.KeyboardEvent.KeyEventType
	11, // 14: android.emulation.control.BatteryState.charger:type_name -> android.emulation.control.BatteryState.BatteryCharger
	12, // 15: android.emulation.control.BatteryState.health:type_name -> android.emulation.control.BatteryState.BatteryHealth
	10, // 16: android.emulation.control.BatteryState.status:type_name -> android.emulation.control.BatteryState.BatteryStatus
	13, // 17: android.emulation.control.ImageTransport.channel:type_name -> android.emulation.control.ImageTransport.TransportChannel
	14, // 18: android.emulation.control.ImageFormat.format:type_name -> android.emulation.control.ImageFormat.ImgFormat
	38, // 19: android.emulation.control.ImageFormat.rotation:type_name -> android.emulation.control.Rotation
	35, // 20: android.emulation.control.ImageFormat.transport:type_name -> android.emulation.control.ImageTransport
	36, // 21: android.emulation.control.Image.format:type_name -> android.emulation.control.ImageFormat
	15, // 22: android.emulation.control.Rotation.rotation:type_name -> android.emulation.control.Rotation.SkinRotation
	16, // 23: android.emulation.control.PhoneCall.operation:type_name -> android.emulation.control.PhoneCall.Operation
	17, // 24: android.emulation.control.PhoneResponse.response:type_name -> android.emulation.control.PhoneResponse.Response
	41, // 25: android.emulation.control.EntryList.entry:type_name -> android.emulation.control.Entry
	26, // 26: android.emulation.control.EmulatorStatus.vmConfig:type_name -> android.emulation.control.VmConfiguration
	42, // 27: android.emulation.control.EmulatorStatus.hardwareConfig:type_name -> android.emulation.control.EntryList
	19, // 28: android.emulation.control.AudioFormat.channels:type_name -> android.emulation.control.AudioFormat.Channels
	18, // 29: android.emulation.control.AudioFormat.format:type_name -> android.emulation.control.AudioFormat.SampleFormat
	44, // 30: android.emulation.control.AudioPacket.format:type_name -> android.emulation.control.AudioFormat
	23, // 31: android.emulation.control.EmulatorController.streamSensor:input_type -> android.emulation.control.SensorValue
	23, // 32: android.emulation.control.EmulatorController.getSensor:input_type -> android.emulation.control.SensorValue
	23, // 33: android.emulation.control.EmulatorController.setSensor:input_type -> android.emulation.control.SensorValue
	22, // 34: android.emulation.control.EmulatorController.setPhysicalModel:input_type -> android.emulation.control.PhysicalModelValue
	22, // 35: android.emulation.control.EmulatorController.getPhysicalModel:input_type -> android.emulation.control.PhysicalModelValue
	22, // 36: android.emulation.control.EmulatorController.streamPhysicalModel:input_type -> android.emulation.control.PhysicalModelValue
	27, // 37: android.emulation.control.EmulatorController.setClipboard:input_type -> android.emulation.control.ClipData
	47, // 38: android.emulation.control.EmulatorController.getClipboard:input_type -> google.protobuf.Empty
	47, // 39: android.emulation.control.EmulatorController.streamClipboard:input_type -> google.protobuf.Empty
	34, // 40: android.emulation.control.EmulatorController.setBattery:input_type -> android.emulation.control.BatteryState
	47, // 41: android.emulation.control.EmulatorController.getBattery:input_type -> google.protobuf.Empty
	33, // 42: android.emulation.control.EmulatorController.setGps:input_type -> android.emulation.control.GpsState
	47, // 43: android.emulation.control.EmulatorController.getGps:input_type -> google.protobuf.Empty
	32, // 44: android.emulation.control.EmulatorController.sendFingerprint:input_type -> android.emulation.control.Fingerprint
	31, // 45: android.emulation.control.EmulatorController.sendKey:input_type -> android.emulation.control.KeyboardEvent
	29, // 46: android.emulation.control.EmulatorController.sendTouch:input_type -> android.emulation.control.TouchEvent
	30, // 47: android.emulation.control.EmulatorController.sendMouse:input_type -> android.emulation.control.MouseEvent
	39, // 48: android.emulation.control.EmulatorController.sendPhone:input_type -> android.emulation.control.PhoneCall
	46, // 49: android.emulation.control.EmulatorController.sendSms:input_type -> android.emulation.control.SmsMessage
	47, // 50: android.emulation.control.EmulatorController.getStatus:input_type -> google.protobuf.Empty
	36, // 51: android.emulation.control.EmulatorController.getScreenshot:input_type -> android.emulation.control.ImageFormat
	36, // 52: android.emulation.control.EmulatorController.streamScreenshot:input_type -> android.emulation.control.ImageFormat
	44, // 53: android.emulation.control.EmulatorController.streamAudio:input_type -> android.emulation.control.AudioFormat
	24, // 54: android.emulation.control.EmulatorController.getLogcat:input_type -> android.emulation.control.LogMessage
	24, // 55: android.emulation.control.EmulatorController.streamLogcat:input_type -> android.emulation.control.LogMessage
	20, // 56: android.emulation.control.EmulatorController.setVmState:input_type -> android.emulation.control.VmRunState
	47, // 57: android.emulation.control.EmulatorController.getVmState:input_type -> google.protobuf.Empty
	23, // 58: android.emulation.control.EmulatorController.streamSensor:output_type -> android.emulation.control.SensorValue
	23, // 59: android.emulation.control.EmulatorController.getSensor:output_type -> android.emulation.control.SensorValue
	47, // 60: android.emulation.control.EmulatorController.setSensor:output_type -> google.protobuf.Empty
	47, // 61: android.emulation.control.EmulatorController.setPhysicalModel:output_type -> google.protobuf.Empty
	22, // 62: android.emulation.control.EmulatorController.getPhysicalModel:output_type -> android.emulation.control.PhysicalModelValue
	22, // 63: android.emulation.control.EmulatorController.streamPhysicalModel:output_type -> android.emulation.control.PhysicalModelValue
	47, // 64: android.emulation.control.EmulatorController.setClipboard:output_type -> google.protobuf.Empty
	27, // 65: android.emulation.control.EmulatorController.getClipboard:output_type -> android.emulation.control.ClipData
	27, // 66: android.emulation.control.EmulatorController.streamClipboard:output_type -> android.emulation.control.ClipData
	47, // 67: android.emulation.control.EmulatorController.setBattery:output_type -> google.protobuf.Empty
	34, // 68: android.emulation.control.EmulatorController.getBattery:output_type -> android.emulation.control.BatteryState
	47, // 69: android.emulation.control.EmulatorController.setGps:output_type -> google.protobuf.Empty
	33, // 70: android.emulation.control.EmulatorController.getGps:output_type -> android.emulation.control.GpsState
	47, // 71: android.emulation.control.EmulatorController.sendFingerprint:output_type -> google.protobuf.Empty
	47, // 72: android.emulation.control.EmulatorController.sendKey:output_type -> google.protobuf.Empty
	47, // 73: android.emulation.control.EmulatorController.sendTouch:output_type -> google.protobuf.Empty
	47, // 74: android.emulation.control.EmulatorController.sendMouse:output_type -> google.protobuf.Empty
	40, // 75: android.emulation.control.EmulatorController.sendPhone:output_type -> android.emulation.control.PhoneResponse
	40, // 76: android.emulation.control.EmulatorController.sendSms:output_type -> android.emulation.control.PhoneResponse
	43, // 77: android.emulation.control.EmulatorController.getStatus:output_type -> android.emulation.control.EmulatorStatus
	37, // 78: android.emulation.control.EmulatorController.getScreenshot:output_type -> android.emulation.control.Image
	37, // 79: android.emulation.control.EmulatorController.streamScreenshot:output_type -> android.emulation.control.Image
	45, // 80: android.emulation.control.EmulatorController.streamAudio:output_type -> android.emulation.control.AudioPacket
	24, // 81: android.emulation.control.EmulatorController.getLogcat:output_type -> android.emulation.control.LogMessage
	24, // 82: android.emulation.control.EmulatorController.streamLogcat:output_type -> android.emulation.control.LogMessage
	47, // 83: android.emulation.control.EmulatorController.setVmState:output_type -> google.protobuf.Empty
	20, // 84: android.emulation.control.EmulatorController.getVmState:output_type -> android.emulation.control.VmRunState
	58, // [58:85] is the sub-list for method output_type
	31, // [31:58] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_emulator_controller_proto_init() }
func file_emulator_controller_proto_init() {
	if File_emulator_controller_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_emulator_controller_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VmRunState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ParameterValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhysicalModelValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SensorValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogcatEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VmConfiguration); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ClipData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Touch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TouchEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MouseEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*KeyboardEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Fingerprint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GpsState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatteryState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageTransport); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageFormat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Image); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rotation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhoneCall); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PhoneResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Entry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EntryList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EmulatorStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AudioFormat); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AudioPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_emulator_controller_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SmsMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_emulator_controller_proto_rawDesc,
			NumEnums:      20,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_emulator_controller_proto_goTypes,
		DependencyIndexes: file_emulator_controller_proto_depIdxs,
		EnumInfos:         file_emulator_controller_proto_enumTypes,
		MessageInfos:      file_emulator_controller_proto_msgTypes,
	}.Build()
	File_emulator_controller_proto = out.File
	file_emulator_controller_proto_rawDesc = nil
	file_emulator_controller_proto_goTypes = nil
	file_emulator_controller_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EmulatorControllerClient is the client API for EmulatorController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EmulatorControllerClient interface {
	// set/get/stream the sensor data
	StreamSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (EmulatorController_StreamSensorClient, error)
	GetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*SensorValue, error)
	SetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*empty.Empty, error)
	// set/get/stream the physical model, this is likely the one you are
	// looking for when you wish to modify the device state.
	SetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*empty.Empty, error)
	GetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*PhysicalModelValue, error)
	StreamPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (EmulatorController_StreamPhysicalModelClient, error)
	// Atomically set/get the current primary clipboard data.
	SetClipboard(ctx context.Context, in *ClipData, opts ...grpc.CallOption) (*empty.Empty, error)
	GetClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ClipData, error)
	// Streams the current data on the clipboard. This will immediately produce
	// a result with the current state of the clipboard after which the stream
	// will block and wait until a new clip event is available from the guest.
	// Calling the setClipboard method above will not result in generating a clip
	// event. It is possible to lose clipboard events if the clipboard updates
	// very rapidly.
	StreamClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamClipboardClient, error)
	// Set/get the battery to the given state.
	SetBattery(ctx context.Context, in *BatteryState, opts ...grpc.CallOption) (*empty.Empty, error)
	GetBattery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BatteryState, error)
	// Set the state of the gps, gps support will only work
	// properly if:
	//
	// - no location ui is active. That is the emulator
	//   is launched in headless mode (-no-window) or the location
	//   ui is disabled (-no-location-ui).
	// - the passiveUpdate is set to false. Setting this to false
	//   will disable/break the LocationUI.
	//
	// Keep in mind that android usually only samples the gps at 1 hz.
	SetGps(ctx context.Context, in *GpsState, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gets the latest gps state as delivered by the setGps call, or location ui
	// if active.
	//
	// Note: this is not necessarily the actual gps coordinate visible at the
	// time, due to gps sample frequency (usually 1hz).
	GetGps(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GpsState, error)
	// Simulate a touch event on the finger print sensor.
	SendFingerprint(ctx context.Context, in *Fingerprint, opts ...grpc.CallOption) (*empty.Empty, error)
	// Send a keyboard event. Translating the event.
	SendKey(ctx context.Context, in *KeyboardEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	// Send touch/mouse events. Note that mouse events can be simulated
	// by touch events.
	SendTouch(ctx context.Context, in *TouchEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	SendMouse(ctx context.Context, in *MouseEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	// Make a phone call.
	SendPhone(ctx context.Context, in *PhoneCall, opts ...grpc.CallOption) (*PhoneResponse, error)
	// Sends an sms message to the emulator.
	SendSms(ctx context.Context, in *SmsMessage, opts ...grpc.CallOption) (*PhoneResponse, error)
	// Retrieve the status of the emulator. This will contain general
	// hardware information, and whether the device has booted or not.
	GetStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EmulatorStatus, error)
	// Gets an individual screenshot in the desired format.
	//
	// The image will be scaled to the desired ImageFormat, while maintaining
	// the aspect ratio. The returned image will never exceed the provided width
	// and height. Not setting the width or height (i.e. they are 0) will result
	// in using the device width and height.
	//
	// The resulting image will be properly oriented and can be displayed
	// directly without post processing. For example, if the device has a
	// 1080x1920 screen and is in landscape mode and called with no width or
	// height parameter, it will return an 1920x1080 image.
	//
	// This method will return an empty image if the display is not visible.
	GetScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (*Image, error)
	// Streams a series of screenshots in the desired format.
	// A new frame will be delivered whenever the device produces a new frame.
	// (Beware that this can produce a significant amount of data, and that
	// certain translations are (png transform) can be costly).
	//
	// If the requested display is not visible it will send a single empty image
	// and wait start producing images once the display becomes active, again
	// producing a single empty image when the display becomes inactive.
	StreamScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (EmulatorController_StreamScreenshotClient, error)
	// Streams a series of audio packets in the desired format.
	// A new frame will be delivered whenever the emulated device
	// produces a new audio frame.
	StreamAudio(ctx context.Context, in *AudioFormat, opts ...grpc.CallOption) (EmulatorController_StreamAudioClient, error)
	// Returns the last 128Kb of logcat output from the emulator
	// Note that parsed logcat messages are only available after L (Api >23).
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	GetLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (*LogMessage, error)
	// Streams the logcat output from the emulator. The first call
	// can retrieve up to 128Kb. This call will not return.
	// Note that parsed logcat messages are only available after L (Api >23)
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	StreamLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (EmulatorController_StreamLogcatClient, error)
	// Transition the virtual machine to the desired state. Note that
	// some states are only observable. For example you cannot transition
	// to the error state.
	SetVmState(ctx context.Context, in *VmRunState, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gets the state of the virtual machine.
	GetVmState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VmRunState, error)
}

type emulatorControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEmulatorControllerClient(cc grpc.ClientConnInterface) EmulatorControllerClient {
	return &emulatorControllerClient{cc}
}

func (c *emulatorControllerClient) StreamSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (EmulatorController_StreamSensorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[0], "/android.emulation.control.EmulatorController/streamSensor", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamSensorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamSensorClient interface {
	Recv() (*SensorValue, error)
	grpc.ClientStream
}

type emulatorControllerStreamSensorClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamSensorClient) Recv() (*SensorValue, error) {
	m := new(SensorValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) GetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*SensorValue, error) {
	out := new(SensorValue)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getSensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setSensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setPhysicalModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*PhysicalModelValue, error) {
	out := new(PhysicalModelValue)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getPhysicalModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (EmulatorController_StreamPhysicalModelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[1], "/android.emulation.control.EmulatorController/streamPhysicalModel", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamPhysicalModelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamPhysicalModelClient interface {
	Recv() (*PhysicalModelValue, error)
	grpc.ClientStream
}

type emulatorControllerStreamPhysicalModelClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamPhysicalModelClient) Recv() (*PhysicalModelValue, error) {
	m := new(PhysicalModelValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetClipboard(ctx context.Context, in *ClipData, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setClipboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ClipData, error) {
	out := new(ClipData)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getClipboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamClipboardClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[2], "/android.emulation.control.EmulatorController/streamClipboard", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamClipboardClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamClipboardClient interface {
	Recv() (*ClipData, error)
	grpc.ClientStream
}

type emulatorControllerStreamClipboardClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamClipboardClient) Recv() (*ClipData, error) {
	m := new(ClipData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetBattery(ctx context.Context, in *BatteryState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setBattery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetBattery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BatteryState, error) {
	out := new(BatteryState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getBattery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetGps(ctx context.Context, in *GpsState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setGps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetGps(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GpsState, error) {
	out := new(GpsState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getGps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendFingerprint(ctx context.Context, in *Fingerprint, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendFingerprint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendKey(ctx context.Context, in *KeyboardEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendTouch(ctx context.Context, in *TouchEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendTouch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendMouse(ctx context.Context, in *MouseEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendMouse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendPhone(ctx context.Context, in *PhoneCall, opts ...grpc.CallOption) (*PhoneResponse, error) {
	out := new(PhoneResponse)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendPhone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendSms(ctx context.Context, in *SmsMessage, opts ...grpc.CallOption) (*PhoneResponse, error) {
	out := new(PhoneResponse)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendSms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EmulatorStatus, error) {
	out := new(EmulatorStatus)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getScreenshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (EmulatorController_StreamScreenshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[3], "/android.emulation.control.EmulatorController/streamScreenshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamScreenshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamScreenshotClient interface {
	Recv() (*Image, error)
	grpc.ClientStream
}

type emulatorControllerStreamScreenshotClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamScreenshotClient) Recv() (*Image, error) {
	m := new(Image)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) StreamAudio(ctx context.Context, in *AudioFormat, opts ...grpc.CallOption) (EmulatorController_StreamAudioClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[4], "/android.emulation.control.EmulatorController/streamAudio", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamAudioClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamAudioClient interface {
	Recv() (*AudioPacket, error)
	grpc.ClientStream
}

type emulatorControllerStreamAudioClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamAudioClient) Recv() (*AudioPacket, error) {
	m := new(AudioPacket)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) GetLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (*LogMessage, error) {
	out := new(LogMessage)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getLogcat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (EmulatorController_StreamLogcatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmulatorController_serviceDesc.Streams[5], "/android.emulation.control.EmulatorController/streamLogcat", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamLogcatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamLogcatClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type emulatorControllerStreamLogcatClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamLogcatClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetVmState(ctx context.Context, in *VmRunState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setVmState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetVmState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VmRunState, error) {
	out := new(VmRunState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getVmState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmulatorControllerServer is the server API for EmulatorController service.
type EmulatorControllerServer interface {
	// set/get/stream the sensor data
	StreamSensor(*SensorValue, EmulatorController_StreamSensorServer) error
	GetSensor(context.Context, *SensorValue) (*SensorValue, error)
	SetSensor(context.Context, *SensorValue) (*empty.Empty, error)
	// set/get/stream the physical model, this is likely the one you are
	// looking for when you wish to modify the device state.
	SetPhysicalModel(context.Context, *PhysicalModelValue) (*empty.Empty, error)
	GetPhysicalModel(context.Context, *PhysicalModelValue) (*PhysicalModelValue, error)
	StreamPhysicalModel(*PhysicalModelValue, EmulatorController_StreamPhysicalModelServer) error
	// Atomically set/get the current primary clipboard data.
	SetClipboard(context.Context, *ClipData) (*empty.Empty, error)
	GetClipboard(context.Context, *empty.Empty) (*ClipData, error)
	// Streams the current data on the clipboard. This will immediately produce
	// a result with the current state of the clipboard after which the stream
	// will block and wait until a new clip event is available from the guest.
	// Calling the setClipboard method above will not result in generating a clip
	// event. It is possible to lose clipboard events if the clipboard updates
	// very rapidly.
	StreamClipboard(*empty.Empty, EmulatorController_StreamClipboardServer) error
	// Set/get the battery to the given state.
	SetBattery(context.Context, *BatteryState) (*empty.Empty, error)
	GetBattery(context.Context, *empty.Empty) (*BatteryState, error)
	// Set the state of the gps, gps support will only work
	// properly if:
	//
	// - no location ui is active. That is the emulator
	//   is launched in headless mode (-no-window) or the location
	//   ui is disabled (-no-location-ui).
	// - the passiveUpdate is set to false. Setting this to false
	//   will disable/break the LocationUI.
	//
	// Keep in mind that android usually only samples the gps at 1 hz.
	SetGps(context.Context, *GpsState) (*empty.Empty, error)
	// Gets the latest gps state as delivered by the setGps call, or location ui
	// if active.
	//
	// Note: this is not necessarily the actual gps coordinate visible at the
	// time, due to gps sample frequency (usually 1hz).
	GetGps(context.Context, *empty.Empty) (*GpsState, error)
	// Simulate a touch event on the finger print sensor.
	SendFingerprint(context.Context, *Fingerprint) (*empty.Empty, error)
	// Send a keyboard event. Translating the event.
	SendKey(context.Context, *KeyboardEvent) (*empty.Empty, error)
	// Send touch/mouse events. Note that mouse events can be simulated
	// by touch events.
	SendTouch(context.Context, *TouchEvent) (*empty.Empty, error)
	SendMouse(context.Context, *MouseEvent) (*empty.Empty, error)
	// Make a phone call.
	SendPhone(context.Context, *PhoneCall) (*PhoneResponse, error)
	// Sends an sms message to the emulator.
	SendSms(context.Context, *SmsMessage) (*PhoneResponse, error)
	// Retrieve the status of the emulator. This will contain general
	// hardware information, and whether the device has booted or not.
	GetStatus(context.Context, *empty.Empty) (*EmulatorStatus, error)
	// Gets an individual screenshot in the desired format.
	//
	// The image will be scaled to the desired ImageFormat, while maintaining
	// the aspect ratio. The returned image will never exceed the provided width
	// and height. Not setting the width or height (i.e. they are 0) will result
	// in using the device width and height.
	//
	// The resulting image will be properly oriented and can be displayed
	// directly without post processing. For example, if the device has a
	// 1080x1920 screen and is in landscape mode and called with no width or
	// height parameter, it will return an 1920x1080 image.
	//
	// This method will return an empty image if the display is not visible.
	GetScreenshot(context.Context, *ImageFormat) (*Image, error)
	// Streams a series of screenshots in the desired format.
	// A new frame will be delivered whenever the device produces a new frame.
	// (Beware that this can produce a significant amount of data, and that
	// certain translations are (png transform) can be costly).
	//
	// If the requested display is not visible it will send a single empty image
	// and wait start producing images once the display becomes active, again
	// producing a single empty image when the display becomes inactive.
	StreamScreenshot(*ImageFormat, EmulatorController_StreamScreenshotServer) error
	// Streams a series of audio packets in the desired format.
	// A new frame will be delivered whenever the emulated device
	// produces a new audio frame.
	StreamAudio(*AudioFormat, EmulatorController_StreamAudioServer) error
	// Returns the last 128Kb of logcat output from the emulator
	// Note that parsed logcat messages are only available after L (Api >23).
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	GetLogcat(context.Context, *LogMessage) (*LogMessage, error)
	// Streams the logcat output from the emulator. The first call
	// can retrieve up to 128Kb. This call will not return.
	// Note that parsed logcat messages are only available after L (Api >23)
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	StreamLogcat(*LogMessage, EmulatorController_StreamLogcatServer) error
	// Transition the virtual machine to the desired state. Note that
	// some states are only observable. For example you cannot transition
	// to the error state.
	SetVmState(context.Context, *VmRunState) (*empty.Empty, error)
	// Gets the state of the virtual machine.
	GetVmState(context.Context, *empty.Empty) (*VmRunState, error)
}

// UnimplementedEmulatorControllerServer can be embedded to have forward compatible implementations.
type UnimplementedEmulatorControllerServer struct {
}

func (*UnimplementedEmulatorControllerServer) StreamSensor(*SensorValue, EmulatorController_StreamSensorServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSensor not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetSensor(context.Context, *SensorValue) (*SensorValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensor not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetSensor(context.Context, *SensorValue) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSensor not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetPhysicalModel(context.Context, *PhysicalModelValue) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPhysicalModel not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetPhysicalModel(context.Context, *PhysicalModelValue) (*PhysicalModelValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPhysicalModel not implemented")
}
func (*UnimplementedEmulatorControllerServer) StreamPhysicalModel(*PhysicalModelValue, EmulatorController_StreamPhysicalModelServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPhysicalModel not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetClipboard(context.Context, *ClipData) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClipboard not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetClipboard(context.Context, *empty.Empty) (*ClipData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClipboard not implemented")
}
func (*UnimplementedEmulatorControllerServer) StreamClipboard(*empty.Empty, EmulatorController_StreamClipboardServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamClipboard not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetBattery(context.Context, *BatteryState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBattery not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetBattery(context.Context, *empty.Empty) (*BatteryState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBattery not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetGps(context.Context, *GpsState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGps not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetGps(context.Context, *empty.Empty) (*GpsState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGps not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendFingerprint(context.Context, *Fingerprint) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFingerprint not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendKey(context.Context, *KeyboardEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendKey not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendTouch(context.Context, *TouchEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTouch not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendMouse(context.Context, *MouseEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMouse not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendPhone(context.Context, *PhoneCall) (*PhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPhone not implemented")
}
func (*UnimplementedEmulatorControllerServer) SendSms(context.Context, *SmsMessage) (*PhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSms not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetStatus(context.Context, *empty.Empty) (*EmulatorStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetScreenshot(context.Context, *ImageFormat) (*Image, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScreenshot not implemented")
}
func (*UnimplementedEmulatorControllerServer) StreamScreenshot(*ImageFormat, EmulatorController_StreamScreenshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamScreenshot not implemented")
}
func (*UnimplementedEmulatorControllerServer) StreamAudio(*AudioFormat, EmulatorController_StreamAudioServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAudio not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetLogcat(context.Context, *LogMessage) (*LogMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogcat not implemented")
}
func (*UnimplementedEmulatorControllerServer) StreamLogcat(*LogMessage, EmulatorController_StreamLogcatServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamLogcat not implemented")
}
func (*UnimplementedEmulatorControllerServer) SetVmState(context.Context, *VmRunState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVmState not implemented")
}
func (*UnimplementedEmulatorControllerServer) GetVmState(context.Context, *empty.Empty) (*VmRunState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVmState not implemented")
}

func RegisterEmulatorControllerServer(s *grpc.Server, srv EmulatorControllerServer) {
	s.RegisterService(&_EmulatorController_serviceDesc, srv)
}

func _EmulatorController_StreamSensor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SensorValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamSensor(m, &emulatorControllerStreamSensorServer{stream})
}

type EmulatorController_StreamSensorServer interface {
	Send(*SensorValue) error
	grpc.ServerStream
}

type emulatorControllerStreamSensorServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamSensorServer) Send(m *SensorValue) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_GetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetSensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetSensor(ctx, req.(*SensorValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetSensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetSensor(ctx, req.(*SensorValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetPhysicalModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhysicalModelValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetPhysicalModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetPhysicalModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetPhysicalModel(ctx, req.(*PhysicalModelValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetPhysicalModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhysicalModelValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetPhysicalModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetPhysicalModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetPhysicalModel(ctx, req.(*PhysicalModelValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamPhysicalModel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PhysicalModelValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamPhysicalModel(m, &emulatorControllerStreamPhysicalModelServer{stream})
}

type EmulatorController_StreamPhysicalModelServer interface {
	Send(*PhysicalModelValue) error
	grpc.ServerStream
}

type emulatorControllerStreamPhysicalModelServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamPhysicalModelServer) Send(m *PhysicalModelValue) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetClipboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClipData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetClipboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetClipboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetClipboard(ctx, req.(*ClipData))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetClipboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetClipboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetClipboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetClipboard(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamClipboard_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamClipboard(m, &emulatorControllerStreamClipboardServer{stream})
}

type EmulatorController_StreamClipboardServer interface {
	Send(*ClipData) error
	grpc.ServerStream
}

type emulatorControllerStreamClipboardServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamClipboardServer) Send(m *ClipData) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetBattery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatteryState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetBattery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetBattery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetBattery(ctx, req.(*BatteryState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetBattery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetBattery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetBattery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetBattery(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetGps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpsState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetGps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetGps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetGps(ctx, req.(*GpsState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetGps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetGps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetGps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetGps(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Fingerprint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendFingerprint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendFingerprint(ctx, req.(*Fingerprint))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyboardEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendKey(ctx, req.(*KeyboardEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendTouch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TouchEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendTouch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendTouch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendTouch(ctx, req.(*TouchEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendMouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MouseEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendMouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendMouse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendMouse(ctx, req.(*MouseEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhoneCall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendPhone(ctx, req.(*PhoneCall))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SendSms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendSms(ctx, req.(*SmsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetScreenshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageFormat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetScreenshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetScreenshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetScreenshot(ctx, req.(*ImageFormat))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamScreenshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImageFormat)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamScreenshot(m, &emulatorControllerStreamScreenshotServer{stream})
}

type EmulatorController_StreamScreenshotServer interface {
	Send(*Image) error
	grpc.ServerStream
}

type emulatorControllerStreamScreenshotServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamScreenshotServer) Send(m *Image) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_StreamAudio_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AudioFormat)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamAudio(m, &emulatorControllerStreamAudioServer{stream})
}

type EmulatorController_StreamAudioServer interface {
	Send(*AudioPacket) error
	grpc.ServerStream
}

type emulatorControllerStreamAudioServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamAudioServer) Send(m *AudioPacket) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_GetLogcat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetLogcat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetLogcat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetLogcat(ctx, req.(*LogMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamLogcat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamLogcat(m, &emulatorControllerStreamLogcatServer{stream})
}

type EmulatorController_StreamLogcatServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type emulatorControllerStreamLogcatServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamLogcatServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetVmState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VmRunState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetVmState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/SetVmState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetVmState(ctx, req.(*VmRunState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetVmState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetVmState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/GetVmState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetVmState(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _EmulatorController_serviceDesc = grpc.ServiceDesc{
	ServiceName: "android.emulation.control.EmulatorController",
	HandlerType: (*EmulatorControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getSensor",
			Handler:    _EmulatorController_GetSensor_Handler,
		},
		{
			MethodName: "setSensor",
			Handler:    _EmulatorController_SetSensor_Handler,
		},
		{
			MethodName: "setPhysicalModel",
			Handler:    _EmulatorController_SetPhysicalModel_Handler,
		},
		{
			MethodName: "getPhysicalModel",
			Handler:    _EmulatorController_GetPhysicalModel_Handler,
		},
		{
			MethodName: "setClipboard",
			Handler:    _EmulatorController_SetClipboard_Handler,
		},
		{
			MethodName: "getClipboard",
			Handler:    _EmulatorController_GetClipboard_Handler,
		},
		{
			MethodName: "setBattery",
			Handler:    _EmulatorController_SetBattery_Handler,
		},
		{
			MethodName: "getBattery",
			Handler:    _EmulatorController_GetBattery_Handler,
		},
		{
			MethodName: "setGps",
			Handler:    _EmulatorController_SetGps_Handler,
		},
		{
			MethodName: "getGps",
			Handler:    _EmulatorController_GetGps_Handler,
		},
		{
			MethodName: "sendFingerprint",
			Handler:    _EmulatorController_SendFingerprint_Handler,
		},
		{
			MethodName: "sendKey",
			Handler:    _EmulatorController_SendKey_Handler,
		},
		{
			MethodName: "sendTouch",
			Handler:    _EmulatorController_SendTouch_Handler,
		},
		{
			MethodName: "sendMouse",
			Handler:    _EmulatorController_SendMouse_Handler,
		},
		{
			MethodName: "sendPhone",
			Handler:    _EmulatorController_SendPhone_Handler,
		},
		{
			MethodName: "sendSms",
			Handler:    _EmulatorController_SendSms_Handler,
		},
		{
			MethodName: "getStatus",
			Handler:    _EmulatorController_GetStatus_Handler,
		},
		{
			MethodName: "getScreenshot",
			Handler:    _EmulatorController_GetScreenshot_Handler,
		},
		{
			MethodName: "getLogcat",
			Handler:    _EmulatorController_GetLogcat_Handler,
		},
		{
			MethodName: "setVmState",
			Handler:    _EmulatorController_SetVmState_Handler,
		},
		{
			MethodName: "getVmState",
			Handler:    _EmulatorController_GetVmState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "streamSensor",
			Handler:       _EmulatorController_StreamSensor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamPhysicalModel",
			Handler:       _EmulatorController_StreamPhysicalModel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamClipboard",
			Handler:       _EmulatorController_StreamClipboard_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamScreenshot",
			Handler:       _EmulatorController_StreamScreenshot_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamAudio",
			Handler:       _EmulatorController_StreamAudio_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamLogcat",
			Handler:       _EmulatorController_StreamLogcat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "emulator_controller.proto",
}

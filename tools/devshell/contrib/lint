#!/bin/bash
# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

### runs source linters on modified files

## Usage: fx lint
##           [--dry-run] [--verbose] [--fix]
##           [--all]
##           [--files=FILES,[FILES ...]]
##           [--target=GN_TARGET]
##           [--git] [-- PATTERN]
##
##   --fix     If supported by the linter tool for the target language,
##             attempt to apply recommended fixes
##   --dry-run Stops the program short of running the linters
##   --all     Lints all code in the git repo under the current working
##             directory.
##   --files   Allows the user to specify files.  Files are comma separated.
##             Globs are dealt with by bash; fx lint "--files=foo/*" will
##             work as expected.
##   --target  Allows the user to specify a gn target.
##   --git     The default; it uses `git diff` against the newest parent
##             commit in the upstream branch (or against HEAD if no such commit
##             is found).  Files that are locally modified, staged or touched by
##             any commits introduced on the local branch are linted.
##    -- [PATTERN...] -additional -args -for -linter
##             For --all or --git, passes along PATTERNs to `git ls-files`
##             to filter what files are affected. The first argument starting
##             with a dash, and all arguments thereafter, are passed to the
##             linter command (positioned before the filename). Used in
##             combination, the pattern can constrain which linter is selected,
##             so linter options are only applied to the expected linter
##             program.
##
## Examples:
##     fx lint -- "*.fidl" --include-check no-trailing-comment
##     fx lint --files=sdk/fidl/fuchsia.sys/service_provider.fidl -- --exclude-check string-bounds-not-specified

set -e

source "$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"/../lib/vars.sh || exit $?

function usage() {
  fx-command-help
}

function zap-commas() {
  echo $1 | tr ',' '\n'
}

function get-diff-base() {
  local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null)
  if [[ -z "${upstream}" ]]; then
    upstream="origin/master"
  fi
  local local_commit=$(git rev-list HEAD ^${upstream} --  2>/dev/null | tail -1)
  if [[ -z "${local_commit}" ]]; then
    printf "HEAD"
  else
    git rev-parse "${local_commit}"^
  fi
}

function lint-cmd() {
  if [ -f "$1" ]; then
    case "$1" in
      *.c) printf "${CLANG_TIDY_CMD}" ;;
      *.cc) printf "${CLANG_TIDY_CMD}" ;;
      *.cmx) printf "${JSON_LINT_CMD}" ;;
      *.cpp) printf "${CLANG_TIDY_CMD}" ;;
      *.dart) printf "${DART_LINT_CMD}" ;;
      *.fidl) printf "${FIDL_LINT_CMD}" ;;
      *.go) printf "${GO_LINT_CMD}" ;;
      *.h) printf "${CLANG_TIDY_CMD}" ;;
      *.hh) printf "${CLANG_TIDY_CMD}" ;;
      *.hpp) printf "${CLANG_TIDY_CMD}" ;;
      *.ts) printf "${CLANG_TIDY_CMD}" ;;
      *.rs) printf "${RUST_LINT_CMD}" ;;
    esac

    # Note: clang-tidy can produce errors on header files (*.h, *.hh, *.hpp)
    # clang-tidy uses a compilation database that only contains implementation
    # files, and so it makes a best-effort guess at what the relevant
    # implementation file is based on the name. However, if you have a header
    # with no implementation file or with a different name than the
    # implementation file (e.g. "functions.h" and "function_a.cpp" that
    # implements it), clang-tidy will return an error.
  fi
}

# Removes leading //, resolves to absolute path, and resolves globs.  The first
# argument is a path prefix, and the remaining arguments are relative to that
# path prefix.
function canonicalize() {
  local root_dir="$1"
  shift
  for fileglob in "${@}"; do
    # // means it comes from gn, [^/]* means it is relative
    if [[ "${fileglob}" = //* || "${fileglob}" = [^/]* ]]; then
      local dir="${root_dir}"/
    else
      local dir=""
    fi
    for file in "${dir}"${fileglob#"//"}; do
      echo "${file}"
    done
  done
}

DRY_RUN=
VERBOSE=
FIX_OPTION=

fx-config-read

GET_FILES=get_git_files
while [ $# -gt 0 ]; do
  ARG="$1"
  case "$1" in
    --verbose) VERBOSE="1" ;;
    --dry-run) DRY_RUN="1" ;;
    --fix) FIX_OPTION="-fix" ;;
    --all) GET_FILES=get_all_files ;;
    --git) GET_FILES=get_git_files ;;
    --files=*)
      GET_FILES=:
      FILES=$(canonicalize "${PWD}" $(zap-commas "${ARG#--files=}"))
      ;;
    --target=*)
      GET_FILES=:
      FILES=$(canonicalize "${FUCHSIA_DIR}" \
        $(fx-buildtool-run gn desc \
            "${FUCHSIA_OUT_DIR}/${FUCHSIA_ARCH}" "${ARG#--target=}" sources)) &&
        RUST_ENTRY_POINT=$(canonicalize "${FUCHSIA_DIR}" \
            $(fx rustfmt --print-sources ${ARG#--target=})) ;;
    --)
      shift
      break
      ;;
    *) usage && printf "Unknown flag %s\n" "${ARG}" && exit 1 ;;
  esac
  shift
done

GIT_FILTER=()
while [ $# -gt 0 ]; do
  if [[ $1 == -* ]]; then
    break
  fi
  if [[ ${#GIT_FILTER[@]} == 0 ]]; then
    GIT_FILTER=(--)
  fi
  GIT_FILTER+=($1)
  shift
done

COMMAND_ARGS=("$@")

get_git_files() {
  FILES=$(canonicalize $(git rev-parse --show-toplevel) \
    $(git diff --name-only $(get-diff-base) "${GIT_FILTER[@]}"))
}

get_all_files() {
  FILES=$(canonicalize "${PWD}" $(git ls-files "${GIT_FILTER[@]}"))
}

$GET_FILES

if [[ -n "${VERBOSE}" ]]; then
  printf "Files to be linted:\n%s\n" "${FILES}"
fi

declare BUILDTOOLS_ROOT="${FUCHSIA_DIR}"/buildtools
declare HOST_OS=$(uname | tr '[:upper:]' '[:lower:]')

[[ "${HOST_OS}" == "darwin" ]] && HOST_OS="mac"
case $(uname -m) in
  x86_64) HOST_ARCH="x64" ;;
  aarch64) HOST_ARCH="arm64" ;;
  *) echo "Unknown arch $(uname -m)" && exit 1 ;;
esac

declare HOST_PLATFORM="${HOST_OS}-${HOST_ARCH}"

# Specify both the clang-tidy and the clang-apply-replacements binaries to be
# the ones in //buildtools, so that they'll work properly on the tree.
declare CLANG_TIDY="${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/clang/bin/clang-tidy"
declare CLANG_APPLY_REPLACEMENTS="${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/clang/bin/clang-apply-replacements"
declare RUN_CLANG_TIDY="${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/clang/share/clang/run-clang-tidy.py"

# Suppress the "name-repeats-*" checks for now. These produce a high number of
# linter warnings, many of which are questionable. The algorithm will be refined.
declare FIDL_LINT="${ZIRCON_TOOLS_DIR}"/fidl-lint

declare CLANG_TIDY_CMD="${RUN_CLANG_TIDY} -clang-tidy-binary ${CLANG_TIDY} -clang-apply-replacements-binary ${CLANG_APPLY_REPLACEMENTS} ${FIX_OPTION}"
declare FIDL_LINT_CMD="${FIDL_LINT}"
declare DART_LINT_CMD= # "${FUCHSIA_DIR}/topaz/tools/prebuilt-dart-sdk/${HOST_PLATFORM}/bin/dart<cmd?> <options?>"
# TODO(fxb/TC-542): add command and args for Go linter
declare GO_LINT_CMD= # "${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/go/bin/go<cmd?> <options?>"
# TODO(fxb/TC-543): add command and args for JSON linter
declare JSON_LINT_CMD= # "${FUCHSIA_DIR}"/scripts/style/json-<cmd?> <options?>"
# TODO(fxb/TC-544): add command and args for Rust linter
declare RUST_LINT_CMD= # "${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/rust/bin/rust<cmd?> <options?>"
declare RUST_ENTRY_POINT_LINT_CMD= # "${BUILDTOOLS_ROOT}/${HOST_PLATFORM}/rust/bin/rust<cmd?> <options?>"

# If there is a FIDL file to fix, and we don't have a copy of fidl-lint,
# generate one.
for file in ${FILES}; do
  if [[ ${file} =~ .*\.fidl ]]; then
    if [[ ! -x "${FIDL_LINT}" ]]; then
       printf "fidl-lint not found: attempting to build it\n"
       fx-command-run build system/fidl:tools
       break
     fi
  fi
done

[[ -n "${RUST_ENTRY_POINT}" ]] && ${RUST_ENTRY_POINT_LINT_CMD} "${RUST_ENTRY_POINT}"

for file in ${FILES}; do
  # Git reports deleted files, which we don't want to try to lint
  [[ ! -f "${file}" ]] && continue

  # Lint the file
  declare lcmd=$(lint-cmd ${file})
  if [[ -n "${lcmd}" ]]; then
    if [[ -n "${DRY_RUN}" ]]; then
      echo "Dry run: ${lcmd} ${file}" "${COMMAND_ARGS[@]}"
    else
      ${lcmd} "${COMMAND_ARGS[@]}" "${file}"
    fi
  fi
done

# "for" loop returns error status after done
# "set -e" causes the script to return an error status when any command
# returns a non-zero status.
exit 0
